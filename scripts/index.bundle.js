/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@firebolt-js/sdk/dist/firebolt.js":
/*!********************************************************!*\
  !*** ./node_modules/@firebolt-js/sdk/dist/firebolt.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Accessibility": () => (/* binding */ __webpack_exports__Accessibility),
/* harmony export */   "Account": () => (/* binding */ __webpack_exports__Account),
/* harmony export */   "Advertising": () => (/* binding */ __webpack_exports__Advertising),
/* harmony export */   "Authentication": () => (/* binding */ __webpack_exports__Authentication),
/* harmony export */   "Device": () => (/* binding */ __webpack_exports__Device),
/* harmony export */   "Discovery": () => (/* binding */ __webpack_exports__Discovery),
/* harmony export */   "Events": () => (/* binding */ __webpack_exports__Events),
/* harmony export */   "Keyboard": () => (/* binding */ __webpack_exports__Keyboard),
/* harmony export */   "Lifecycle": () => (/* binding */ __webpack_exports__Lifecycle),
/* harmony export */   "Localization": () => (/* binding */ __webpack_exports__Localization),
/* harmony export */   "Log": () => (/* binding */ __webpack_exports__Log),
/* harmony export */   "Metrics": () => (/* binding */ __webpack_exports__Metrics),
/* harmony export */   "Parameters": () => (/* binding */ __webpack_exports__Parameters),
/* harmony export */   "Platform": () => (/* binding */ __webpack_exports__Platform),
/* harmony export */   "Profile": () => (/* binding */ __webpack_exports__Profile),
/* harmony export */   "SecondScreen": () => (/* binding */ __webpack_exports__SecondScreen),
/* harmony export */   "Settings": () => (/* binding */ __webpack_exports__Settings)
/* harmony export */ });
/******/ // The require scope
/******/ var __nested_webpack_require_43__ = {};
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_43__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nested_webpack_require_43__.o(definition, key) && !__nested_webpack_require_43__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_43__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__nested_webpack_require_43__.d(__webpack_exports__, {
  "yq": () => (/* reexport */ Accessibility),
  "mR": () => (/* reexport */ Account),
  "ZL": () => (/* reexport */ Advertising),
  "Vy": () => (/* reexport */ Authentication),
  "AS": () => (/* reexport */ Device),
  "PG": () => (/* reexport */ Discovery),
  "zW": () => (/* reexport */ Events),
  "N1": () => (/* reexport */ Keyboard),
  "Fw": () => (/* reexport */ Lifecycle),
  "WH": () => (/* reexport */ Localization),
  "Zb": () => (/* reexport */ Log),
  "C3": () => (/* reexport */ Metrics),
  "aE": () => (/* reexport */ Parameters),
  "t4": () => (/* reexport */ Platform),
  "NZ": () => (/* reexport */ Profile),
  "_F": () => (/* reexport */ SecondScreen),
  "Zr": () => (/* reexport */ Settings)
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Prop/MockProps.js


const mocks = {}

function mock(module, method, args, def) {
  const fullMethod = `${module}.${method}`
  if ((args == null) || (args.length === 0)) {
    // get
    const rv = mocks[fullMethod] && mocks[fullMethod].value ? mocks[fullMethod].value : def
    return rv
  } else {
    // set
    let mockMethod = mocks[fullMethod]
    if (mockMethod == null) {
      mockMethod = {
        subscribers: []
      }
    }
    mocks[fullMethod] = mockMethod
    mockMethod.value = args[0].value
    Transport_mock.event(module, method + 'Changed', {
      value: args[0].value
    })
    return {}
  }
}

/* harmony default export */ const MockProps = ({
  mock: mock
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Accessibility/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const defaults = ({

    closedCaptions: {
  "enabled": true,
  "styles": {
    "fontFamily": "Monospace sans-serif",
    "fontSize": 1,
    "fontColor": "#ffffff",
    "fontEdge": "none",
    "fontEdgeColor": "#7F7F7F",
    "fontOpacity": 100,
    "backgroundColor": "#000000",
    "backgroundOpacity": 100,
    "textAlign": "center",
    "textAlignVertical": "middle"
  }
},

    closedCaptionsSettings: function () { return MockProps.mock('accessibility', 'closedCaptionsSettings', arguments, {
  "enabled": true,
  "styles": {
    "fontFamily": "Monospace sans-serif",
    "fontSize": 1,
    "fontColor": "#ffffff",
    "fontEdge": "none",
    "fontEdgeColor": "#7F7F7F",
    "fontOpacity": 100,
    "backgroundColor": "#000000",
    "backgroundOpacity": 100,
    "textAlign": "center",
    "textAlignVertical": "middle"
  }
}) },

    voiceGuidance: {
  "enabled": true,
  "speed": 5
},

    voiceGuidanceSettings: function () { return MockProps.mock('accessibility', 'voiceGuidanceSettings', arguments, {
  "enabled": true,
  "speed": 5
}) }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Account/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Account_defaults = ({

    id: function () { return MockProps.mock('account', 'id', arguments, "123") },

    uid: function () { return MockProps.mock('account', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Advertising/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Advertising_defaults = ({

    config: {
  "adServerUrl": "http://demo.v.fwmrm.net/ad/p/1",
  "adServerUrlTemplate": "http://demo.v.fwmrm.net/ad/p/1?flag=+sltp+exvt+slcb+emcr+amcb+aeti&prof=12345:caf_allinone_profile &nw=12345&mode=live&vdur=123&caid=a110523018&asnw=372464&csid=gmott_ios_tablet_watch_live_ESPNU&ssnw=372464&vip=198.205.92.1&resp=vmap1&metr=1031&pvrn=12345&vprn=12345&vcid=1X0Ce7L3xRWlTeNhc7br8Q%3D%3D",
  "adNetworkId": "519178",
  "adProfileId": "12345:caf_allinone_profile",
  "adSiteSectionId": "caf_allinone_profile_section",
  "adOptOut": true,
  "privacyData": "ew0KICAicGR0IjogImdkcDp2MSIsDQogICJ1c19wcml2YWN5IjogIjEtTi0iLA0KICAibG10IjogIjEiIA0KfQ0K",
  "ifaValue": "01234567-89AB-CDEF-GH01-23456789ABCD",
  "ifa": "ewogICJ2YWx1ZSI6ICIwMTIzNDU2Ny04OUFCLUNERUYtR0gwMS0yMzQ1Njc4OUFCQ0QiLAogICJpZmFfdHlwZSI6ICJzc3BpZCIsCiAgImxtdCI6ICIwIgp9Cg==",
  "appName": "FutureToday",
  "appBundleId": "FutureToday.comcast",
  "distributorAppId": "1001",
  "deviceAdAttributes": "ewogICJib0F0dHJpYnV0ZXNGb3JSZXZTaGFyZUlkIjogIjEyMzQiCn0=",
  "coppa": 0,
  "authenticationEntity": "60f72475281cfba3852413bd53e957f6"
},

    policy: function () { return MockProps.mock('advertising', 'policy', arguments, {
  "skipRestriction": "adsUnwatched",
  "limitAdTracking": false
}) },

    advertisingId: {
  "ifa": "01234567-89AB-CDEF-GH01-23456789ABCD",
  "ifa_type": "idfa",
  "lmt": "0"
},

    deviceAttributes: {},

    appBundleId: "operator.app"
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Authentication/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Authentication_defaults = ({

    token: {
  "value": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c",
  "expires": "2022-04-23T18:25:43.511Z",
  "type": "platform"
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Device/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Device_defaults = ({

    id: function () { return MockProps.mock('device', 'id', arguments, "123") },

    distributor: function () { return MockProps.mock('device', 'distributor', arguments, "Company") },

    platform: function () { return MockProps.mock('device', 'platform', arguments, "WPE") },

    uid: function () { return MockProps.mock('device', 'uid', arguments, "ee6723b8-7ab3-462c-8d93-dbf61227998e") },

    type: function () { return MockProps.mock('device', 'type', arguments, "STB") },

    model: function () { return MockProps.mock('device', 'model', arguments, "xi6") },

    sku: function () { return MockProps.mock('device', 'sku', arguments, "AX061AEI") },

    make: function () { return MockProps.mock('device', 'make', arguments, "Arris") },

    version: function () { return MockProps.mock('device', 'version', arguments, {
  "sdk": {
    "major": 0,
    "minor": 5,
    "patch": 0,
    "readable": "Firebolt JS SDK v0.5.0"
  },
  "os": {
    "major": 0,
    "minor": 1,
    "patch": 0,
    "readable": "Firebolt OS v0.1.0"
  },
  "debug": ""
}) },

    hdcp: function () { return MockProps.mock('device', 'hdcp', arguments, {
  "hdcp1.4": true,
  "hdcp2.2": true
}) },

    hdr: function () { return MockProps.mock('device', 'hdr', arguments, {
  "hdr10": true,
  "hdr10Plus": true,
  "dolbyVision": true,
  "hlg": true
}) },

    audio: function () { return MockProps.mock('device', 'audio', arguments, {
  "stereo": true,
  "dolbyDigital5.1": true,
  "dolbyDigital5.1+": true,
  "dolbyAtmos": true
}) },

    screenResolution: function () { return MockProps.mock('device', 'screenResolution', arguments, [
  1920,
  1080
]) },

    videoResolution: function () { return MockProps.mock('device', 'videoResolution', arguments, [
  1920,
  1080
]) },

    name: function () { return MockProps.mock('device', 'name', arguments, "Living Room") },

    network: function () { return MockProps.mock('device', 'network', arguments, {
  "state": "connected",
  "type": "wifi"
}) }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Discovery/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Discovery_defaults = ({

    policy: function () { return MockProps.mock('discovery', 'policy', arguments, {
  "enableRecommendations": true,
  "shareWatchHistory": true,
  "rememberWatchedPrograms": true
}) },

    entityInfo: true,

    purchasedContent: true,

    watched: true,

    watchNext: true,

    entitlements: true,

    launch: true,

    signIn: true,

    signOut: true
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Keyboard/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Keyboard_defaults = ({

    email: "user@domain.com",

    password: "abc123",

    standard: "Living Room"
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/global.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

let g

if (typeof self !== 'undefined') {
	g = self;
} else if (typeof window !== 'undefined') {
	g = window;
} else {
	g = Function('return this')();
} 

const global = g

/* harmony default export */ const Transport_global = (global);
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Lifecycle/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */





let inactive = {"state":"inactive","previous":"initializing"}
let foreground = {"state":"foreground","previous":"inactive"}
let background = {"state":"background","previous":"foreground"}
let suspended = {"state":"suspended","previous":"inactive"}
let unloading = {"state":"unloading","previous":"inactive"}

const emit = (value) => {
  value.previous = Lifecycle.state()
  Transport_mock.event('Lifecycle', value.state, value)
}

const automation = Transport_global && Transport_global.__firebolt ? !!Transport_global.__firebolt.automation : false

/* harmony default export */ const Lifecycle_defaults = ({
  ready: function() {
    inactive.previous = 'initializing'
    setTimeout(() => emit(inactive), automation ? 1 : 500)
    foreground.previous = 'inactive'
    setTimeout(() => emit(foreground), automation ? 2 : 1000)
  },

  close: function(params) {
    let reason = params.reason
    if (reason === Lifecycle.CloseReason.REMOTE_BUTTON) {
      setTimeout(() => emit(inactive), automation ? 1 : 500)
    }
    else if (Object.values(Lifecycle.CloseReason).includes(reason)) {
      setTimeout(() => emit(inactive), automation ? 1 : 500)
      setTimeout(() => emit(unloading), automation ? 2 : 1000)
      setTimeout(() => Lifecycle.finished(), automation ? 3: 3000)
    }
    else {
      throw "Invalid close reason"
    }
  },

  finished: function() {
    if (Transport_global.location)
      Transport_global.location.href = "about:blank"
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Localization/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Localization_defaults = ({

    locality: "Philadelphia",

    postalCode: "19103",

    countryCode: "US",

    language: function () { return MockProps.mock('localization', 'language', arguments, "en") },

    locale: "en-US",

    latlon: [
  39.9549,
  75.1699
],

    additionalInfo: {}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Metrics/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Metrics_defaults = ({

    ready: true,

    signIn: true,

    signOut: true,

    startContent: true,

    stopContent: true,

    page: true,

    action: true,

    error: true,

    mediaLoadStart: true,

    mediaPlay: true,

    mediaPlaying: true,

    mediaPause: true,

    mediaWaiting: true,

    mediaProgress: true,

    mediaSeeking: true,

    mediaSeeked: true,

    mediaRateChange: true,

    mediaRenditionChange: true,

    mediaEnded: true
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Parameters/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Parameters_defaults = ({

    initialization: {
  "lmt": 0,
  "us_privacy": "1-Y-",
  "discovery": {
    "navigateTo": {
      "action": "entity",
      "data": {
        "entityId": "abc",
        "entityType": "program",
        "programType": "movie"
      },
      "context": {
        "source": "voice"
      }
    }
  }
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Profile/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const Profile_defaults = ({

    approveContentRating: false,

    approvePurchase: false,

    flags: {
  "userExperience": "1000"
}
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/SecondScreen/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */


/* harmony default export */ const SecondScreen_defaults = ({

    protocols: {
  "dial1.7": true
},

    device: "device-id",

    friendlyName: function () { return MockProps.mock('secondscreen', 'friendlyName', arguments, "Living Room") }
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Platform/defaults.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */





/* harmony default export */ const Platform_defaults = ({
  localization: Localization_defaults,
  device: Device_defaults,
  accessibility: defaults,
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/mock.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



















let listener
const setMockListener = func => { listener = func }

let mock_mock = {
  accessibility: defaults,
  account: Account_defaults,
  advertising: Advertising_defaults,
  authentication: Authentication_defaults,
  device: Device_defaults,
  discovery: Discovery_defaults,
  keyboard: Keyboard_defaults,
  lifecycle: Lifecycle_defaults,
  localization: Localization_defaults,
  metrics: Metrics_defaults,
  parameters: Parameters_defaults,
  profile: Profile_defaults,
  secondscreen: SecondScreen_defaults,
  platform: Platform_defaults,
}

let callback
let testHarness

if (Transport_global.__firebolt && Transport_global.__firebolt.testHarness) {
  testHarness = Transport_global.__firebolt.testHarness
}

function send(message) {
  let json = JSON.parse(message)
  let [module, method] = json.method.split('.')

  if (testHarness && testHarness.onSend) {
    testHarness.onSend(module, method, json.params, json.id)
  }

  // store the ID of the first listen for each event
  // TODO: what about wild cards?
  let result
  try {
    result = getResult(json.method, json.params)
  }
  catch (error) {
    setTimeout(() => callback(JSON.stringify({ 
      jsonrpc: '2.0',
      error: {
        code: -32602,
        message: "Invalid params (this is a mock error from the mock transport layer)"
      },
      id: json.id
    })))
  }

  setTimeout(() => callback(JSON.stringify({ 
    jsonrpc: '2.0',
    result: result,
    id: json.id
  })))
}

function receive(_callback) {
  callback = _callback

  if (testHarness && (typeof testHarness.initialize === 'function')) {
    testHarness.initialize({
      emit: mock_event,
      listen: function(...args) { listener(...args) },
    })
  }
}

function mock_event(module, event, value) {
  const listener = Object.entries(Transport.getEventMap()).find(([k, v]) => v.toLowerCase() === module.toLowerCase() + '.' + event.toLowerCase())
  if (listener) {
    let message = JSON.stringify({
      jsonrpc: '2.0',
      id: listener[0],
      result: value
    })
    callback(message)
  }
}

function dotGrab(obj = {}, key) {
  const keys = key.split('.')
  let ref = obj
  for (let i = 0; i < keys.length; i++) {
    ref = ref[keys[i]] || {}
  }
  return ref
}

function getResult(method, params) {
  let api = dotGrab(mock_mock, method)

  if (method.match(/^[a-zA-Z]+\.on[A-Za-z]+$/)) {
    api = {
      event: method,
      listening: true
    }
  }

  if (typeof api === 'function') {
    return params == null ? api() : api(params)
  } else return api
}

/* harmony default export */ const Transport_mock = ({
  send: send,
  receive: receive,
  event: mock_event
});


;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/queue.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

class Queue {
  constructor () {
    this._callback = null
    this._queue = []
  }

  send (json) {
    this._queue.push(json)
  }

  receive (_callback) {
    this._callback = _callback
  }

  flush (transport) {
    transport.receive(this._callback)
    this._queue.forEach(item => transport.send(item))
  }
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Settings/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

const settings = {}
const subscribers = {}

const initSettings = (appSettings, platformSettings) => {
  settings['app'] = appSettings
  settings['platform'] = {
    logLevel: 'WARN',
    ...platformSettings
  }
  settings['user'] = {}
}

const publish = (key, value) => {
  subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value))
}

const Settings_dotGrab = (obj = {}, key) => {
  const keys = key.split('.')
  for (let i = 0; i < keys.length; i++) {
    obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {}
  }
  return typeof obj === 'object' ? (Object.keys(obj).length ? obj : undefined) : obj
}

/* harmony default export */ const Settings = ({
  get(type, key, fallback = undefined) {
    const val = Settings_dotGrab(settings[type], key)
    return val !== undefined ? val : fallback
  },
  has(type, key) {
    return !!this.get(type, key)
  },
  set(key, value) {
    settings['user'][key] = value
    publish(key, value)
  },
  subscribe(key, callback) {
    subscribers[key] = subscribers[key] || []
    subscribers[key].push(callback)
  },
  unsubscribe(key, callback) {
    if (callback) {
      const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback)
      index > -1 && subscribers[key].splice(index, 1)
    } else {
      if (key in subscribers) {
        subscribers[key] = []
      }
    }
  },
  clearSubscribers() {
    for (const key of Object.getOwnPropertyNames(subscribers)) {
      delete subscribers[key]
    }
  },
  setLogLevel (logLevel) {
    settings.platform.logLevel = logLevel
  },
  getLogLevel () {
    return settings.platform.logLevel
  }
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/LegacyTransport.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

class LegacyTransport {
  constructor (bridge) {
    this.bridge = bridge
  }

  send (msg) {
    this.bridge.JSMessageChanged(msg, () => {})
  }

  receive (callback) {
    window.$badger = window.$badger || {}
    /** Hold on to real $badger callback and event methods so they can be called for non-jsonrpc messages */
    const badgerCallback = window.$badger.callback ? window.$badger.callback.bind(window.$badger) : null
    const badgerEvent = window.$badger.event ? window.$badger.event.bind(window.$badger) : null
    window.$badger.callback = (pid, success, json) => {
      if (json.jsonrpc) {
        callback(JSON.stringify(json))
      } else if (badgerCallback) {
        badgerCallback(pid, success, json)
      }
    }
    window.$badger.event = (handlerId, json) => {
      if (json.jsonrpc) {
        callback(JSON.stringify(json))
      } else if (badgerEvent) {
        badgerEvent(handlerId, json)
      }
    }
  }

  static isLegacy (transport) {
    return LegacyTransport.isXREProxy(transport) || ((transport.send === undefined) && (transport.JSMessageChanged))
  }

  static isXREProxy (transport) {
    /** Set top boxes running XRE has a "Proxy" transport
     * native object that intercepts ALL method calls, so we
     * cannot test for transport.send existence because it will return true
     * even though it actually is not supported. Check if some obscure method
     * name like "proxyObjectTest" is defined. If it is then we know we are using a
     * Proxy object and thus is legacy transport.
     */
    return transport.proxyObjectTest !== undefined
  }
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/WebsocketTransport.js
const MAX_QUEUED_MESSAGES = 100

class WebsocketTransport {
  constructor (endpoint) {
    this._endpoint = endpoint
    this._ws = null
    this._connected = false
    this._queue = []
    this._callbacks = []
  }

  send (msg) {
    this._connect()

    if (this._connected) {
      this._ws.send(msg)
    } else {
      if (this._queue.length < MAX_QUEUED_MESSAGES) {
        this._queue.push(msg)
      }
    }
  }

  receive (callback) {
    if (!callback) return
    this._connect()
    this._callbacks.push(callback)
  }

  _notifyCallbacks (message) {
    for (let i = 0; i < this._callbacks.length; i++) {
      setTimeout(() => this._callbacks[i](message), 1)
    }
  }

  _connect () {
    if (this._ws) return
    this._ws = new WebSocket(this._endpoint)
    this._ws.addEventListener('message', message => {
      this._notifyCallbacks(message.data)
    })
    this._ws.addEventListener('error', message => {
    })
    this._ws.addEventListener('close', message => {
      this._ws = null
      this._connected = false
    })
    this._ws.addEventListener('open', message => {
      this._connected = true
      for (let i = 0; i < this._queue.length; i++) {
        this._ws.send(this._queue[i])
      }
      this._queue = []
    })
  }
}
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Transport/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */








const LEGACY_TRANSPORT_SERVICE_NAME = 'com.comcast.BridgeObject_1'
let moduleInstance = null

const isEventSuccess = x => x && (typeof x.event === 'string') && (typeof x.listening === 'boolean')

class Transport {
  constructor () {
    this._promises = []
    this._transport = null
    this._id = 1
    this._eventEmitters = []
    this._eventMap = {}
    this._queue = new Queue()
    this._deprecated = {}
    this.isMock = false
  }

  static addEventEmitter (emitter) {
    Transport.get()._eventEmitters.push(emitter)
  }

  static registerDeprecatedMethod (module, method, alternative) {
    Transport.get()._deprecated[module.toLowerCase() + '.' + method.toLowerCase()] = {
      alternative: alternative || ''
    }
  }

  _endpoint () {
    if (Transport_global.__firebolt && Transport_global.__firebolt.endpoint) {
      return Transport_global.__firebolt.endpoint
    }
    return null
  }

  constructTransportLayer () {
    let transport
    const endpoint = this._endpoint()
    if (endpoint && (endpoint.startsWith('ws://') || endpoint.startsWith('wss://'))) {
      transport = new WebsocketTransport(endpoint)
      transport.receive(this.receiveHandler.bind(this))
    } else if (
      typeof Transport_global.ServiceManager !== 'undefined' &&
      Transport_global.ServiceManager &&
      Transport_global.ServiceManager.version
    ) {
      // Wire up the queue
      transport = this._queue
      // get the default bridge service, and flush the queue
      Transport_global.ServiceManager.getServiceForJavaScript(LEGACY_TRANSPORT_SERVICE_NAME, service => {
        if (LegacyTransport.isLegacy(service)) {
          transport = new LegacyTransport(service)
        } else {
          transport = service
        }
        this.setTransportLayer(transport)
      })
    } else {
      this.isMock = true
      transport = Transport_mock
      transport.receive(this.receiveHandler.bind(this))
    }
    return transport
  }

  setTransportLayer (tl) {
    this._transport = tl
    this._queue.flush(tl)
  }

  static send (module, method, params) {
    /** Transport singleton across all SDKs to keep single id map */
    return Transport.get()._send(module, method, params)
  }

  _send (module, method, params) {
    const p = new Promise((resolve, reject) => {
      this._promises[this._id] = {}
      this._promises[this._id].promise = this
      this._promises[this._id].resolve = resolve
      this._promises[this._id].reject = reject

      const deprecated = this._deprecated[module.toLowerCase() + '.' + method.toLowerCase()]
      if (deprecated) {
        console.warn(`WARNING: ${module}.${method}() is deprecated. ` + deprecated.alternative)
      }

      // store the ID of the first listen for each event
      // TODO: what about wild cards?
      if (method.match(/^on[A-Z]/)) {
        if (params.listen) {
          this._eventMap[this._id] = module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)
        } else {
          Object.keys(this._eventMap).forEach(key => {
            if (this._eventMap[key] === module.toLowerCase() + '.' + method[2].toLowerCase() + method.substr(3)) {
              delete this._eventMap[key]
            }
          })
        }
      }
    })

    const json = { jsonrpc: '2.0', method: module + '.' + method, params: params, id: this._id }
    this._id++

    const msg = JSON.stringify(json)
    if (Settings.getLogLevel() === 'DEBUG') {
      console.debug('Sending message to transport: ' + msg)
    }
    this._transport.send(msg)

    return p
  }

  static getEventMap () {
    return Transport.get()._eventMap
  }

  /**
   * If we have a global transport, use that. Otherwise, use the module-scoped transport instance.
   * @returns {Transport}
   */
  static get () {
    return Transport_global.__firebolt.transport ? Transport_global.__firebolt.transport : moduleInstance
  }

  receiveHandler (message) {
    if (Settings.getLogLevel() === 'DEBUG') {
      console.debug('Received message from transport: ' + message)
    }
    const json = JSON.parse(message)
    const p = this._promises[json.id]

    if (p) {
      if (json.error) p.reject(json.error)
      else {
        p.resolve(json.result)
      }
      delete this._promises[json.id]
    }

    // event responses need to be emitted, even after the listen call is resolved
    if (this._eventMap[json.id] && !isEventSuccess(json.result)) {
      const moduleevent = this._eventMap[json.id]
      if (moduleevent) {
        this._eventEmitters.forEach(emit => {
          emit(moduleevent.split('.')[0], moduleevent.split('.')[1], json.result)
        })
      }
    }
  }

  init () {
    initSettings({}, { log: true })
    this._queue.receive(this.receiveHandler.bind(this))
    if (Transport_global.__firebolt) {
      if (Transport_global.__firebolt.mockTransportLayer === true) {
        this.isMock = true
        this.setTransportLayer(Transport_mock)
      } else if (Transport_global.__firebolt.getTransportLayer) {
        this.setTransportLayer(Transport_global.__firebolt.getTransportLayer())
      }
    }
    if (this._transport == null) {
      this._transport = this.constructTransportLayer()
    }
  }
}

/** Set up singleton and initialize it */
Transport_global.__firebolt = Transport_global.__firebolt || {}
if ((Transport_global.__firebolt.transport == null) && (moduleInstance == null)) {
  const transport = new Transport()
  transport.init()
  if (transport.isMock) {
    /** We should use the mock transport built with the SDK, not a global */
    moduleInstance = transport
  } else {
    Transport_global.__firebolt = Transport_global.__firebolt || {}
    Transport_global.__firebolt.transport = transport
  }
  Transport_global.__firebolt.setTransportLayer = transport.setTransportLayer.bind(transport)
}

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Events/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */




let listenerId = 0

// holds a map of ${module}.${event} => listenerId, e.g. callback method id
// note that one callback can listen to multiple events, e.g. 'discovery.*'
const listeners = {}

// holds a map of ${module}.${event} => Transport.send calls (only called once per event)
// note that the keys here MUST NOT contain wild cards
const enabledEvents = {}

const oncers = []
const validEvents = {}
let transportInitialized = false

const Events_emit = (module, event, value) => {
  callCallbacks(listeners[module + '.*'], [event, value])
  callCallbacks(listeners[module + '.' + event], [value])
}

const registerEvents = (module, events) => {
  validEvents[module.toLowerCase()] = events.concat()
}

const callCallbacks = (cbs, args) => {
  cbs &&
    Object.keys(cbs).forEach(listenerId => {
      let callback = cbs[listenerId]
      if (oncers.indexOf(parseInt(listenerId)) >= 0) {
        oncers.splice(oncers.indexOf(parseInt(listenerId)), 1)
        delete cbs[listenerId]
      }
      callback.apply(null, args)
    })
}

const doListen = function(module, event, callback, once) {
  if (typeof callback !== 'function') {
    return Promise.reject('No valid callback function provided.')
  } else {
    if (module === '*') {
      return Promise.reject('No valid module name provided')
    }

    let events = (event === '*' ? validEvents[module] : [event]) // explodes wildcards into an array
    let promises = []
    const key = module + '.' + event // this might be a wildcard, e.g. 'lifecycle.*'
    listenerId++
    listeners[key] = listeners[key] || {}
    listeners[key][''+listenerId] = callback

    if (once) {
      oncers.push(listenerId)
    }

    events.forEach(event => {
      // Check each event, and only turn on events (not wildcards) that are off
      if (!enabledEvents[module + '.' + event]) {
        promises.push(
          Transport.send(module, 'on' + event[0].toUpperCase() + event.substr(1), { listen: true })
        )
        enabledEvents[module + '.' + event] = true
      }
    })

    let resolve, reject
    let p = new Promise((res, rej) => {
      resolve = res
      reject = rej
    })

    if (promises.length) {
      Promise.all(promises).then(responses => {
        resolve(listenerId)
      }).catch(error => {
        // Promise.all rejects if at least one promise rejects... we don't want that behavior here
        // TODO: Do something better than fail silently
        if (event === '*') {
          resolve(listenerId)
        }
        else {
          reject(error)
        }
      })
    }
    else {
      resolve(listenerId)
    }

    return p
  }
}

const getListenArgs = function(...args) {
  const callback = args.pop()
  const module = args[0].toLowerCase() || '*'
  const event = args[1] || '*'
  return [module, event, callback]
}

const once = function(...args) {
  const [module, event, callback] = getListenArgs(...args)
  return doListen(module, event, callback, true)
}

const listen = function(...args) {
  init()
  const [module, event, callback] = getListenArgs(...args)
  return doListen(module, event, callback, false)
}

const init = () => {
  if (!transportInitialized) {
    Transport.addEventEmitter(Events_emit)
    setMockListener(listen)
    transportInitialized = true
  }
}

/* harmony default export */ const Events = ({
  listen: listen,
  once: once,
  // TODO: clear needs to go through Transport Layer
  clear(moduleOrId = false, event = false) {
    if (typeof moduleOrId === 'number') {
      const searchId = moduleOrId.toString()
      Object.keys(listeners).every(key => {
        if (listeners[key][searchId]) {
          // delete callback
          delete listeners[key][searchId]
          // delete the whole namespace if it was the only callback
          if (Object.keys(listeners[key]).length === 0) {
            delete listeners[key]
          }
          return false
        }
        return true
      })
    } else {
      if (!moduleOrId && !event) {
        Object.keys(listeners).forEach(key => {
          delete listeners[key]
        })
      } else if (!event) {
        Object.keys(listeners).forEach(key => {
          if (key.indexOf(moduleOrId.toLowerCase()) === 0) {
            delete listeners[key]
          }
        })
      } else {
        delete listeners[moduleOrId + '.' + event]
      }
    }
  },
  broadcast(event, value) {
    Events_emit('app', event, value)
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Prop/index.js



function prop(moduleName, key, args, immutable, readonly) {
  if (args.length === 0) {
    // getter
    return Transport.send(moduleName, key)
  } else if (args.length === 1 && typeof args[0] === 'function') {
    // subscribe
    if (immutable) {
      throw new Error('Cannot subscribe to an immutable property')
    }
    return Events.listen(moduleName, key + 'Changed', args[0])
  } else {
    // setter
    if (immutable) {
      throw new Error('Cannot set a value to an immutable property')
    }
    if (readonly) {
      throw new Error('Cannot set a value to a readonly property')
    }
    return Transport.send(moduleName, key, {
      value: args[0]
    })
  }
}

/* harmony default export */ const Prop = ({
  prop: prop
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Accessibility/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Accessibility', Object.values(["closedCaptionsSettingsChanged","voiceGuidanceSettingsChanged"]))

Transport.registerDeprecatedMethod('Accessibility', 'closedCaptions', 'Use Accessibility.closedCaptionsSettings() instead.')
Transport.registerDeprecatedMethod('Accessibility', 'voiceGuidance', 'Use Accessibility.voiceGuidanceSettings() instead.')


function closedCaptions() {
  return Transport.send('accessibility', 'closedCaptions', {  })
}
function closedCaptionsSettings() {
  return Prop.prop('accessibility',  'closedCaptionsSettings', arguments, false, true)
}

function voiceGuidance() {
  return Transport.send('accessibility', 'voiceGuidance', {  })
}
function voiceGuidanceSettings() {
  return Prop.prop('accessibility',  'voiceGuidanceSettings', arguments, false, true)
}

function Accessibility_listen(...args) {
  return Events.listen('accessibility', ...args)
} 

function Accessibility_once(...args) {
  return Events.once('accessibility', ...args)
}

function clear(...args) {
  return Events.clear('accessibility', ...args)
}

/* harmony default export */ const Accessibility = ({

  events: {
    closedCaptionsSettingsChanged:'closedCaptionsSettingsChanged',
    voiceGuidanceSettingsChanged:'voiceGuidanceSettingsChanged'
  },
closedCaptions,
  closedCaptionsSettings,
  voiceGuidance,
  voiceGuidanceSettings,
  listen: Accessibility_listen,
  once: Accessibility_once,
  clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Account/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function id() {
  return Prop.prop('account',  'id', arguments, true, true)
}
function uid() {
  return Prop.prop('account',  'uid', arguments, true, true)
}

/* harmony default export */ const Account = ({

id,
  uid
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Advertising/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Advertising', Object.values(["policyChanged"]))



function config(options) {
  return Transport.send('advertising', 'config', { options })
}
function policy() {
  return Prop.prop('advertising',  'policy', arguments, false, true)
}

function advertisingId() {
  return Transport.send('advertising', 'advertisingId', {  })
}

function deviceAttributes() {
  return Transport.send('advertising', 'deviceAttributes', {  })
}

function appBundleId() {
  return Transport.send('advertising', 'appBundleId', {  })
}

function Advertising_listen(...args) {
  return Events.listen('advertising', ...args)
} 

function Advertising_once(...args) {
  return Events.once('advertising', ...args)
}

function Advertising_clear(...args) {
  return Events.clear('advertising', ...args)
}

/* harmony default export */ const Advertising = ({

  events: {
    policyChanged:'policyChanged'
  },

  SkipRestriction: {
    NONE: 'none',
    ADS_UNWATCHED: 'adsUnwatched',
    ADS_ALL: 'adsAll',
    ALL: 'all'
  },

config,
  policy,
  advertisingId,
  deviceAttributes,
  appBundleId,
  listen: Advertising_listen,
  once: Advertising_once,
  clear: Advertising_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Authentication/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function token(type, options) {
  return Transport.send('authentication', 'token', { type, options })
}

/* harmony default export */ const Authentication = ({


  TokenType: {
    PLATFORM: 'platform',
    DEVICE: 'device',
    DISTRIBUTOR: 'distributor'
  },

token
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Device/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Device', Object.values(["deviceNameChanged","hdcpChanged","hdrChanged","audioChanged","screenResolutionChanged","videoResolutionChanged","nameChanged","networkChanged"]))

Transport.registerDeprecatedMethod('Device', 'onDeviceNameChanged', 'Use Device.name() instead.')

function version() {
  return new Promise( (resolve, reject) => {
      Transport.send('device', 'version').then( v => {
          v = v || {}
          v.sdk = v.sdk || {}
          v.sdk.major = parseInt('0')
          v.sdk.minor = parseInt('6')
          v.sdk.patch = parseInt('0')
          v.sdk.readable = 'The Firebolt JS SDK'
          resolve(v)    
      }).catch(error => {
          reject(error)
      })
  })
}

function Device_id() {
  return Prop.prop('device',  'id', arguments, true, true)
}
function distributor() {
  return Prop.prop('device',  'distributor', arguments, true, true)
}
function platform() {
  return Prop.prop('device',  'platform', arguments, true, true)
}
function Device_uid() {
  return Prop.prop('device',  'uid', arguments, true, true)
}
function type() {
  return Prop.prop('device',  'type', arguments, true, true)
}
function model() {
  return Prop.prop('device',  'model', arguments, true, true)
}
function sku() {
  return Prop.prop('device',  'sku', arguments, true, true)
}
function make() {
  return Prop.prop('device',  'make', arguments, true, true)
}
function hdcp() {
  return Prop.prop('device',  'hdcp', arguments, false, true)
}
function hdr() {
  return Prop.prop('device',  'hdr', arguments, false, true)
}
function audio() {
  return Prop.prop('device',  'audio', arguments, false, true)
}
function screenResolution() {
  return Prop.prop('device',  'screenResolution', arguments, false, true)
}
function videoResolution() {
  return Prop.prop('device',  'videoResolution', arguments, false, true)
}
function Device_name() {
  return Prop.prop('device',  'name', arguments, false, true)
}
function network() {
  return Prop.prop('device',  'network', arguments, false, true)
}

function Device_listen(...args) {
  return Events.listen('device', ...args)
} 

function Device_once(...args) {
  return Events.once('device', ...args)
}

function Device_clear(...args) {
  return Events.clear('device', ...args)
}

/* harmony default export */ const Device = ({

  events: {
    deviceNameChanged:'deviceNameChanged',
    hdcpChanged:'hdcpChanged',
    hdrChanged:'hdrChanged',
    audioChanged:'audioChanged',
    screenResolutionChanged:'screenResolutionChanged',
    videoResolutionChanged:'videoResolutionChanged',
    nameChanged:'nameChanged',
    networkChanged:'networkChanged'
  },

  NetworkType: {
    WIFI: 'wifi',
    ETHERNET: 'ethernet',
    HYBRID: 'hybrid'
  },


  NetworkState: {
    CONNECTED: 'connected',
    DISCONNECTED: 'disconnected'
  },


  AudioProfile: {
    STEREO: 'stereo',
    DOLBY_DIGITAL_5_1: 'dolbyDigital5.1',
    DOLBY_DIGITAL_7_1: 'dolbyDigital7.1',
    DOLBY_DIGITAL_5_1_PLUS: 'dolbyDigital5.1+',
    DOLBY_DIGITAL_7_1_PLUS: 'dolbyDigital7.1+',
    DOLBY_ATMOS: 'dolbyAtmos'
  },


  version,
id: Device_id,
  distributor,
  platform,
  uid: Device_uid,
  type,
  model,
  sku,
  make,
  hdcp,
  hdr,
  audio,
  screenResolution,
  videoResolution,
  name: Device_name,
  network,
  listen: Device_listen,
  once: Device_once,
  clear: Device_clear
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Metrics/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function ready() {
  return Transport.send('metrics', 'ready', {})
}

function signIn() {
  return Transport.send('metrics', 'signIn', {})
}

function signOut() {
  return Transport.send('metrics', 'signOut', {})
}



function startContent(entityId) {
  return Transport.send('metrics', 'startContent', { entityId })
}

function stopContent(entityId) {
  return Transport.send('metrics', 'stopContent', { entityId })
}

function page(pageId) {
  return Transport.send('metrics', 'page', { pageId })
}

function action(category, type, parameters) {
  return Transport.send('metrics', 'action', { category, type, parameters })
}

function error(type, code, description, visible, parameters) {
  return Transport.send('metrics', 'error', { type, code, description, visible, parameters })
}

function mediaLoadStart(entityId) {
  return Transport.send('metrics', 'mediaLoadStart', { entityId })
}

function mediaPlay(entityId) {
  return Transport.send('metrics', 'mediaPlay', { entityId })
}

function mediaPlaying(entityId) {
  return Transport.send('metrics', 'mediaPlaying', { entityId })
}

function mediaPause(entityId) {
  return Transport.send('metrics', 'mediaPause', { entityId })
}

function mediaWaiting(entityId) {
  return Transport.send('metrics', 'mediaWaiting', { entityId })
}

function mediaProgress(entityId, progress) {
  return Transport.send('metrics', 'mediaProgress', { entityId, progress })
}

function mediaSeeking(entityId, target) {
  return Transport.send('metrics', 'mediaSeeking', { entityId, target })
}

function mediaSeeked(entityId, position) {
  return Transport.send('metrics', 'mediaSeeked', { entityId, position })
}

function mediaRateChange(entityId, rate) {
  return Transport.send('metrics', 'mediaRateChange', { entityId, rate })
}

function mediaRenditionChange(entityId, bitrate, width, height, profile) {
  return Transport.send('metrics', 'mediaRenditionChange', { entityId, bitrate, width, height, profile })
}

function mediaEnded(entityId) {
  return Transport.send('metrics', 'mediaEnded', { entityId })
}

/* harmony default export */ const Metrics = ({


  ErrorType: {
    NETWORK: 'network',
    MEDIA: 'media',
    RESTRICTION: 'restriction',
    ENTITLEMENT: 'entitlement',
    OTHER: 'other'
  },

startContent,
  stopContent,
  page,
  action,
  error,
  mediaLoadStart,
  mediaPlay,
  mediaPlaying,
  mediaPause,
  mediaWaiting,
  mediaProgress,
  mediaSeeking,
  mediaSeeked,
  mediaRateChange,
  mediaRenditionChange,
  mediaEnded
});


;// CONCATENATED MODULE: ./build/sdk/javascript/src/Discovery/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Discovery', Object.values(["navigateTo","policyChanged"]))


function Discovery_policy() {
  return Prop.prop('discovery',  'policy', arguments, false, true)
}

let entityInfoHasCallback = false

function entityInfo (data) {
  if (arguments.length === 1 && typeof arguments[0] === 'function') {
    if (entityInfoHasCallback) {
      return Promise.reject('Cannot register more than one entityInfo handler.')
    }

    const callback = arguments[0]
    entityInfoHasCallback = true
    return Events.listen('discovery', 'pullEntityInfo', (request) => {
      if (typeof request === 'boolean') return

      try {
        const result = callback(request.parameters).then(result => {
          const params = {
            correlationId: request.correlationId,
            result: result
          }
          Transport.send('discovery', 'entityInfo', params).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
            InternalMetrics.sdk.error(`Failed to send entityInfo pull response through Transport Layer: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
          })
        }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
          InternalMetrics.sdk.error(`App 'entityInfo' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
        })
      }
      catch (error) {
        const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
        InternalMetrics.sdk.error(`App 'entityInfo' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
    }
    })
  }
  else {
    return Transport.send('discovery', 'entityInfo', { data })
  }
}

let purchasedContentHasCallback = false

function purchasedContent (data) {
  if (arguments.length === 1 && typeof arguments[0] === 'function') {
    if (purchasedContentHasCallback) {
      return Promise.reject('Cannot register more than one purchasedContent handler.')
    }

    const callback = arguments[0]
    purchasedContentHasCallback = true
    return Events.listen('discovery', 'pullPurchasedContent', (request) => {
      if (typeof request === 'boolean') return

      try {
        const result = callback(request.parameters).then(result => {
          const params = {
            correlationId: request.correlationId,
            result: result
          }
          Transport.send('discovery', 'purchasedContent', params).catch(error => {
            const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
            InternalMetrics.sdk.error(`Failed to send purchasedContent pull response through Transport Layer: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
          })
        }).catch(error => {
          const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
          InternalMetrics.sdk.error(`App 'purchasedContent' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
        })
      }
      catch (error) {
        const msg = typeof error === 'string' ? error : error.message || 'Unknown Error'
        InternalMetrics.sdk.error(`App 'purchasedContent' callback failed: ${msg}`, parseInt(error.code) || 500, false, request.parameters)
    }
    })
  }
  else {
    return Transport.send('discovery', 'purchasedContent', { data })
  }
}

function watched(entityId, progress, completed, watchedOn) {
  if (arguments.length === 1 && Array.isArray(arguments[0])) {
    return Transport.send('discovery', 'watched', arguments[0])
  }
  else {
    return Transport.send('discovery', 'watched', { entityId, progress, completed, watchedOn })
  }
}

function watchNext(title, identifiers, expires, images) {
  return Transport.send('discovery', 'watchNext', { title, identifiers, expires, images })
}

function entitlements(entitlements) {
  return Transport.send('discovery', 'entitlements', { entitlements })
}

function launch(appId, intent) {
  return Transport.send('discovery', 'launch', { appId, intent })
}



function Discovery_signIn(entitlements) {
    const p = Transport.send('discovery', 'signIn', { entitlements })
    
    p.then(_ => {
        setTimeout(_ => {
            signIn(entitlements)
        })    
    })

    return p
}



function Discovery_signOut() {
    const p = Transport.send('discovery', 'signOut', {  })
    
    p.then(_ => {
        setTimeout(_ => {
            signOut()
        })    
    })

    return p
}

function Discovery_listen(...args) {
  return Events.listen('discovery', ...args)
} 

function Discovery_once(...args) {
  return Events.once('discovery', ...args)
}

function Discovery_clear(...args) {
  return Events.clear('discovery', ...args)
}

/* harmony default export */ const Discovery = ({

  events: {
    navigateTo:'navigateTo',
    policyChanged:'policyChanged'
  },
policy: Discovery_policy,
  entityInfo,
  purchasedContent,
  watched,
  watchNext,
  entitlements,
  launch,
  signIn: Discovery_signIn,
  signOut: Discovery_signOut,
  listen: Discovery_listen,
  once: Discovery_once,
  clear: Discovery_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Keyboard/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function email(type, message) {
  return Transport.send('keyboard', 'email', { type, message })
}

function Keyboard_password(message) {
  return Transport.send('keyboard', 'password', { message })
}

function standard(message) {
  return Transport.send('keyboard', 'standard', { message })
}

/* harmony default export */ const Keyboard = ({


  EmailUsage: {
    SIGN_IN: 'signIn',
    SIGN_UP: 'signUp'
  },

email,
  password: Keyboard_password,
  standard
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Lifecycle/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






registerEvents('Lifecycle', Object.values(["inactive","foreground","background","suspended","unloading"]))


const store = {
  _current: 'initializing',
  get current() {
    return this._current
  }
}

Events.listen('Lifecycle', (event, value) => {
  store._current = event
})


;

function Lifecycle_ready() {
    const p = Transport.send('lifecycle', 'ready', {  })
    
    p.then(_ => {
        setTimeout(_ => {
            ready()
        })    
    })

    return p
}

function Lifecycle_close(reason) {
  return Transport.send('lifecycle', 'close', { reason })
}

function Lifecycle_listen(...args) {
  return Events.listen('lifecycle', ...args)
} 

function Lifecycle_once(...args) {
  return Events.once('lifecycle', ...args)
}

function Lifecycle_clear(...args) {
  return Events.clear('lifecycle', ...args)
}

function state() {
  return store.current
}

function finished() {
  if (store.current === 'unloading') {
    return Transport.send('lifecycle', 'finished')
  } else {
    throw 'Cannot call finished() except when in the unloading transition'
  }
}

// public API
/* harmony default export */ const Lifecycle = ({

  events: {
    inactive:'inactive',
    foreground:'foreground',
    background:'background',
    suspended:'suspended',
    unloading:'unloading'
  },


  LifecycleState: {
    INITIALIZING: 'initializing',
    INACTIVE: 'inactive',
    BACKGROUND: 'background',
    FOREGROUND: 'foreground',
    SUSPENDED: 'suspended',
    UNLOADING: 'unloading'
  },


  CloseReason: {
    REMOTE_BUTTON: 'remoteButton',
    USER_EXIT: 'userExit',
    ERROR: 'error'
  },


  state,
  finished,

ready: Lifecycle_ready,
  close: Lifecycle_close,
  listen: Lifecycle_listen,
  once: Lifecycle_once,
  clear: Lifecycle_clear  
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Localization/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('Localization', Object.values(["languageChanged"]))



function locality() {
  return Transport.send('localization', 'locality', {  })
}

function postalCode() {
  return Transport.send('localization', 'postalCode', {  })
}

function countryCode() {
  return Transport.send('localization', 'countryCode', {  })
}
function language() {
  return Prop.prop('localization',  'language', arguments, false, true)
}

function locale() {
  return Transport.send('localization', 'locale', {  })
}

function latlon() {
  return Transport.send('localization', 'latlon', {  })
}

function additionalInfo() {
  return Transport.send('localization', 'additionalInfo', {  })
}

function Localization_listen(...args) {
  return Events.listen('localization', ...args)
} 

function Localization_once(...args) {
  return Events.once('localization', ...args)
}

function Localization_clear(...args) {
  return Events.clear('localization', ...args)
}

/* harmony default export */ const Localization = ({

  events: {
    languageChanged:'languageChanged'
  },
locality,
  postalCode,
  countryCode,
  language,
  locale,
  latlon,
  additionalInfo,
  listen: Localization_listen,
  once: Localization_once,
  clear: Localization_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Parameters/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function initialization() {
  return Transport.send('parameters', 'initialization', {  })
}

/* harmony default export */ const Parameters = ({

initialization
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Profile/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






function approveContentRating() {
  return Transport.send('profile', 'approveContentRating', {  })
}

function approvePurchase() {
  return Transport.send('profile', 'approvePurchase', {  })
}

function flags() {
  return Transport.send('profile', 'flags', {  })
}

/* harmony default export */ const Profile = ({

approveContentRating,
  approvePurchase,
  flags
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/SecondScreen/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */







registerEvents('SecondScreen', Object.values(["launchRequest","closeRequest","friendlyNameChanged"]))



function protocols() {
  return Transport.send('secondscreen', 'protocols', {  })
}

function device(type) {
  return Transport.send('secondscreen', 'device', { type })
}
function friendlyName() {
  return Prop.prop('secondscreen',  'friendlyName', arguments, false, true)
}

function SecondScreen_listen(...args) {
  return Events.listen('secondscreen', ...args)
} 

function SecondScreen_once(...args) {
  return Events.once('secondscreen', ...args)
}

function SecondScreen_clear(...args) {
  return Events.clear('secondscreen', ...args)
}

/* harmony default export */ const SecondScreen = ({

  events: {
    launchRequest:'launchRequest',
    closeRequest:'closeRequest',
    friendlyNameChanged:'friendlyNameChanged'
  },
protocols,
  device,
  friendlyName,
  listen: SecondScreen_listen,
  once: SecondScreen_once,
  clear: SecondScreen_clear
});
;// CONCATENATED MODULE: ./build/sdk/javascript/src/Platform/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */






// public API
/* harmony default export */ const Platform = ({
  Localization: Localization,
  Device: Device,
  Accessibility: Accessibility,
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/Log/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



const prepLog = (type, args) => {
  const colors = {
    Info: 'green',
    Debug: 'gray',
    Warn: 'orange',
    Error: 'red',
  }

  args = Array.from(args)
  return [
    '%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type),
    'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px',
    args,
  ]
}

/* harmony default export */ const Log = ({
  info() {
    Settings.get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments))
  },
  debug() {
    Settings.get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments))
  },
  error() {
    Settings.get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments))
  },
  warn() {
    Settings.get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments))
  },
});

;// CONCATENATED MODULE: ./build/sdk/javascript/src/index.js
/*
 * Copyright 2021 Comcast Cable Communications Management, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */



















var __webpack_exports__Accessibility = __webpack_exports__.yq;
var __webpack_exports__Account = __webpack_exports__.mR;
var __webpack_exports__Advertising = __webpack_exports__.ZL;
var __webpack_exports__Authentication = __webpack_exports__.Vy;
var __webpack_exports__Device = __webpack_exports__.AS;
var __webpack_exports__Discovery = __webpack_exports__.PG;
var __webpack_exports__Events = __webpack_exports__.zW;
var __webpack_exports__Keyboard = __webpack_exports__.N1;
var __webpack_exports__Lifecycle = __webpack_exports__.Fw;
var __webpack_exports__Localization = __webpack_exports__.WH;
var __webpack_exports__Log = __webpack_exports__.Zb;
var __webpack_exports__Metrics = __webpack_exports__.C3;
var __webpack_exports__Parameters = __webpack_exports__.aE;
var __webpack_exports__Platform = __webpack_exports__.t4;
var __webpack_exports__Profile = __webpack_exports__.NZ;
var __webpack_exports__SecondScreen = __webpack_exports__._F;
var __webpack_exports__Settings = __webpack_exports__.Zr;


//# sourceMappingURL=firebolt.js.map

/***/ }),

/***/ "./node_modules/@lightningjs/core/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@lightningjs/core/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _src_lightning_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/lightning.mjs */ "./node_modules/@lightningjs/core/src/lightning.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_src_lightning_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/index.js":
/*!************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ads": () => (/* reexport safe */ _src_Ads__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "AppData": () => (/* reexport safe */ _src_Application__WEBPACK_IMPORTED_MODULE_1__.AppData),
/* harmony export */   "Application": () => (/* reexport safe */ _src_Application__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "AudioPlayer": () => (/* reexport safe */ _src_AudioPlayer__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "Colors": () => (/* reexport safe */ _src_Colors__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "Img": () => (/* reexport safe */ _src_Img__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "Keyboard": () => (/* reexport safe */ _src_Keyboard__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "Language": () => (/* reexport safe */ _src_Language__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "Launch": () => (/* reexport safe */ _src_Launch__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "Lightning": () => (/* reexport safe */ _src_Lightning__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "Locale": () => (/* reexport safe */ _src_Locale__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "Log": () => (/* reexport safe */ _src_Log__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "MediaPlayer": () => (/* reexport safe */ _src_MediaPlayer__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "Metadata": () => (/* reexport safe */ _src_Metadata__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "Metrics": () => (/* reexport safe */ _src_Metrics__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "Pin": () => (/* reexport safe */ _src_Pin__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "Profile": () => (/* reexport safe */ _src_Profile__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "Purchase": () => (/* reexport safe */ _src_Purchase__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "Registry": () => (/* reexport safe */ _src_Registry__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "Router": () => (/* reexport safe */ _src_Router__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "Settings": () => (/* reexport safe */ _src_Settings__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "Storage": () => (/* reexport safe */ _src_Storage__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "TV": () => (/* reexport safe */ _src_TV__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "Utils": () => (/* reexport safe */ _src_Utils__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "VideoPlayer": () => (/* reexport safe */ _src_VideoPlayer__WEBPACK_IMPORTED_MODULE_22__["default"])
/* harmony export */ });
/* harmony import */ var _src_Ads__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _src_Application__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/* harmony import */ var _src_AudioPlayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/AudioPlayer */ "./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js");
/* harmony import */ var _src_Colors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/Colors */ "./node_modules/@lightningjs/sdk/src/Colors/index.js");
/* harmony import */ var _src_Img__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/Img */ "./node_modules/@lightningjs/sdk/src/Img/index.js");
/* harmony import */ var _src_Keyboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/Keyboard */ "./node_modules/@lightningjs/sdk/src/Keyboard/index.js");
/* harmony import */ var _src_Launch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _src_Lightning__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _src_Locale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/Locale */ "./node_modules/@lightningjs/sdk/src/Locale/index.js");
/* harmony import */ var _src_Language__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/Language */ "./node_modules/@lightningjs/sdk/src/Language/index.js");
/* harmony import */ var _src_Log__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _src_MediaPlayer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/MediaPlayer */ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js");
/* harmony import */ var _src_Metrics__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _src_Pin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/* harmony import */ var _src_Profile__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _src_Purchase__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/Purchase */ "./node_modules/@lightningjs/sdk/src/Purchase/index.js");
/* harmony import */ var _src_Registry__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/* harmony import */ var _src_Router__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/Router */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _src_Settings__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _src_Storage__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/Storage */ "./node_modules/@lightningjs/sdk/src/Storage/index.js");
/* harmony import */ var _src_TV__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/TV */ "./node_modules/@lightningjs/sdk/src/TV/index.js");
/* harmony import */ var _src_Utils__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _src_VideoPlayer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/* harmony import */ var _src_Metadata__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/Metadata */ "./node_modules/@lightningjs/sdk/src/Metadata/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




























/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Ads/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Ads/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initAds": () => (/* binding */ initAds)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _VideoPlayer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let consumer

let getAds = () => {
  // todo: enable some default ads during development, maybe from the settings.json
  return Promise.resolve({
    prerolls: [],
    midrolls: [],
    postrolls: [],
  })
}

const initAds = config => {
  if (config.getAds) {
    getAds = config.getAds
  }
}

const state = {
  active: false,
}

const playSlot = (slot = []) => {
  return slot.reduce((promise, ad) => {
    return promise.then(() => {
      return playAd(ad)
    })
  }, Promise.resolve(null))
}

const playAd = ad => {
  return new Promise(resolve => {
    if (state.active === false) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Skipping add due to inactive state')
      return resolve()
    }
    // is it safe to rely on videoplayer plugin already created the video tag?
    const videoEl = document.getElementsByTagName('video')[0]
    videoEl.style.display = 'block'
    videoEl.style.visibility = 'visible'
    videoEl.src = (0,_VideoPlayer__WEBPACK_IMPORTED_MODULE_1__.mediaUrl)(ad.url)
    videoEl.load()

    let timeEvents = null
    let timeout

    const cleanup = () => {
      // remove all listeners
      Object.keys(handlers).forEach(handler =>
        videoEl.removeEventListener(handler, handlers[handler])
      )
      resolve()
    }
    const handlers = {
      play() {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Play ad', ad.url)
        fireOnConsumer('Play', ad)
        sendBeacon(ad.callbacks, 'defaultImpression')
      },
      ended() {
        fireOnConsumer('Ended', ad)
        sendBeacon(ad.callbacks, 'complete')
        cleanup()
      },
      timeupdate() {
        if (!timeEvents && videoEl.duration) {
          // calculate when to fire the time based events (now that duration is known)
          timeEvents = {
            firstQuartile: videoEl.duration / 4,
            midPoint: videoEl.duration / 2,
            thirdQuartile: (videoEl.duration / 4) * 3,
          }
          _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Calculated quartiles times', { timeEvents })
        }
        if (
          timeEvents &&
          timeEvents.firstQuartile &&
          videoEl.currentTime >= timeEvents.firstQuartile
        ) {
          fireOnConsumer('FirstQuartile', ad)
          delete timeEvents.firstQuartile
          sendBeacon(ad.callbacks, 'firstQuartile')
        }
        if (timeEvents && timeEvents.midPoint && videoEl.currentTime >= timeEvents.midPoint) {
          fireOnConsumer('MidPoint', ad)
          delete timeEvents.midPoint
          sendBeacon(ad.callbacks, 'midPoint')
        }
        if (
          timeEvents &&
          timeEvents.thirdQuartile &&
          videoEl.currentTime >= timeEvents.thirdQuartile
        ) {
          fireOnConsumer('ThirdQuartile', ad)
          delete timeEvents.thirdQuartile
          sendBeacon(ad.callbacks, 'thirdQuartile')
        }
      },
      stalled() {
        fireOnConsumer('Stalled', ad)
        timeout = setTimeout(() => {
          cleanup()
        }, 5000) // make timeout configurable
      },
      canplay() {
        timeout && clearTimeout(timeout)
      },
      error() {
        fireOnConsumer('Error', ad)
        cleanup()
      },
      // this doesn't work reliably on sky box, moved logic to timeUpdate event
      // loadedmetadata() {
      //   // calculate when to fire the time based events (now that duration is known)
      //   timeEvents = {
      //     firstQuartile: videoEl.duration / 4,
      //     midPoint: videoEl.duration / 2,
      //     thirdQuartile: (videoEl.duration / 4) * 3,
      //   }
      // },
      abort() {
        cleanup()
      },
      // todo: pause, resume, mute, unmute beacons
    }
    // add all listeners
    Object.keys(handlers).forEach(handler => videoEl.addEventListener(handler, handlers[handler]))

    videoEl.play()
  })
}

const sendBeacon = (callbacks, event) => {
  if (callbacks && callbacks[event]) {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Sending beacon', event, callbacks[event])
    return callbacks[event].reduce((promise, url) => {
      return promise.then(() =>
        fetch(url)
          // always resolve, also in case of a fetch error (so we don't block firing the rest of the beacons for this event)
          // note: for fetch failed http responses don't throw an Error :)
          .then(response => {
            if (response.status === 200) {
              fireOnConsumer('Beacon' + event + 'Sent')
            } else {
              fireOnConsumer('Beacon' + event + 'Failed' + response.status)
            }
            Promise.resolve(null)
          })
          .catch(() => {
            Promise.resolve(null)
          })
      )
    }, Promise.resolve(null))
  } else {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'No callback found for ' + event)
  }
}

const fireOnConsumer = (event, args) => {
  if (consumer) {
    consumer.fire('$ad' + event, args)
    consumer.fire('$adEvent', event, args)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(config, videoPlayerConsumer) {
    if (config.enabled === false) {
      return Promise.resolve({
        prerolls() {
          return Promise.resolve()
        },
      })
    }
    consumer = videoPlayerConsumer

    return new Promise(resolve => {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Starting session')
      getAds(config).then(ads => {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'API result', ads)
        resolve({
          prerolls() {
            if (ads.preroll) {
              state.active = true
              fireOnConsumer('PrerollSlotImpression', ads)
              sendBeacon(ads.preroll.callbacks, 'slotImpression')
              return playSlot(ads.preroll.ads).then(() => {
                fireOnConsumer('PrerollSlotEnd', ads)
                sendBeacon(ads.preroll.callbacks, 'slotEnd')
                state.active = false
              })
            }
            return Promise.resolve()
          },
          midrolls() {
            return Promise.resolve()
          },
          postrolls() {
            return Promise.resolve()
          },
        })
      })
    })
  },
  cancel() {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Cancel Ad')
    state.active = false
  },
  stop() {
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Ad', 'Stop Ad')
    state.active = false
    // fixme: duplication
    const videoEl = document.getElementsByTagName('video')[0]
    videoEl.pause()
    videoEl.removeAttribute('src')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Application/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Application/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppData": () => (/* binding */ AppData),
/* harmony export */   "AppInstance": () => (/* binding */ AppInstance),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ "./node_modules/deepmerge/dist/cjs.js");
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Locale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Locale */ "./node_modules/@lightningjs/sdk/src/Locale/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _VersionLabel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../VersionLabel */ "./node_modules/@lightningjs/sdk/src/VersionLabel/index.js");
/* harmony import */ var _FpsCounter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../FpsCounter */ "./node_modules/@lightningjs/sdk/src/FpsCounter/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Language__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Language */ "./node_modules/@lightningjs/sdk/src/Language/index.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/* harmony import */ var _Colors__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Colors */ "./node_modules/@lightningjs/sdk/src/Colors/index.js");
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../package.json */ "./node_modules/@lightningjs/sdk/package.json");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















let AppInstance
let AppData

const defaultOptions = {
  stage: { w: 1920, h: 1080, clearColor: 0x00000000, canvas2d: false },
  debug: false,
  defaultFontFace: 'RobotoRegular',
  keys: {
    8: 'Back',
    13: 'Enter',
    27: 'Menu',
    37: 'Left',
    38: 'Up',
    39: 'Right',
    40: 'Down',
    174: 'ChannelDown',
    175: 'ChannelUp',
    178: 'Stop',
    250: 'PlayPause',
    191: 'Search', // Use "/" for keyboard
    409: 'Search',
  },
}

const customFontFaces = []

const fontLoader = (fonts, store) =>
  new Promise((resolve, reject) => {
    fonts
      .map(({ family, url, urls, descriptors }) => () => {
        const src = urls
          ? urls.map(url => {
              return 'url(' + url + ')'
            })
          : 'url(' + url + ')'
        const fontFace = new FontFace(family, src, descriptors || {})
        store.push(fontFace)
        _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Loading font', family)
        document.fonts.add(fontFace)
        return fontFace.load()
      })
      .reduce((promise, method) => {
        return promise.then(() => method())
      }, Promise.resolve(null))
      .then(resolve)
      .catch(reject)
  })

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(App, appData, platformSettings) {
  const { width, height } = platformSettings

  if (width && height) {
    defaultOptions.stage['w'] = width
    defaultOptions.stage['h'] = height
    defaultOptions.stage['precision'] = width / 1920
  }

  // support for 720p browser
  if (!width && !height && window.innerHeight === 720) {
    defaultOptions.stage['w'] = 1280
    defaultOptions.stage['h'] = 720
    defaultOptions.stage['precision'] = 1280 / 1920
  }

  return class Application extends _Lightning__WEBPACK_IMPORTED_MODULE_1__["default"].Application {
    constructor(options) {
      const config = deepmerge__WEBPACK_IMPORTED_MODULE_0___default()(defaultOptions, options)
      // Deepmerge breaks HTMLCanvasElement, so restore the passed in canvas.
      if (options.stage.canvas) {
        config.stage.canvas = options.stage.canvas
      }
      super(config)
      this.config = config
    }

    static _template() {
      return {
        w: 1920,
        h: 1080,
      }
    }

    _setup() {
      Promise.all([
        this.loadFonts((App.config && App.config.fonts) || (App.getFonts && App.getFonts()) || []),
        // to be deprecated
        _Locale__WEBPACK_IMPORTED_MODULE_2__["default"].load((App.config && App.config.locale) || (App.getLocale && App.getLocale())),
        App.language && this.loadLanguage(App.language()),
        App.colors && this.loadColors(App.colors()),
      ])
        .then(() => {
          _Metrics__WEBPACK_IMPORTED_MODULE_3__["default"].app.loaded()

          AppData = appData

          AppInstance = this.stage.c({
            ref: 'App',
            type: App,
            zIndex: 1,
            forceZIndexContext: !!platformSettings.showVersion || !!platformSettings.showFps,
          })

          this.childList.a(AppInstance)

          this._refocus()

          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('App version', this.config.version)
          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('SDK version', _package_json__WEBPACK_IMPORTED_MODULE_12__.version)

          if (platformSettings.showVersion) {
            this.childList.a({
              ref: 'VersionLabel',
              type: _VersionLabel__WEBPACK_IMPORTED_MODULE_4__["default"],
              version: this.config.version,
              sdkVersion: _package_json__WEBPACK_IMPORTED_MODULE_12__.version,
              zIndex: 1,
            })
          }

          if (platformSettings.showFps) {
            this.childList.a({
              ref: 'FpsCounter',
              type: _FpsCounter__WEBPACK_IMPORTED_MODULE_5__["default"],
              zIndex: 1,
            })
          }

          super._setup()
        })
        .catch(console.error)
    }

    _handleBack() {
      this.closeApp()
    }

    _handleExit() {
      this.closeApp()
    }

    closeApp() {
      _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Signaling App Close')

      if (platformSettings.onClose && typeof platformSettings.onClose === 'function') {
        platformSettings.onClose(...arguments)
      } else {
        this.close()
      }
    }

    close() {
      _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Closing App')

      _Settings__WEBPACK_IMPORTED_MODULE_7__["default"].clearSubscribers()
      _Registry__WEBPACK_IMPORTED_MODULE_10__["default"].clear()

      this.childList.remove(this.tag('App'))
      this.cleanupFonts()
      // force texture garbage collect
      this.stage.gc()
      this.destroy()
    }

    loadFonts(fonts) {
      return platformSettings.fontLoader && typeof platformSettings.fontLoader === 'function'
        ? platformSettings.fontLoader(fonts, customFontFaces)
        : fontLoader(fonts, customFontFaces)
    }

    cleanupFonts() {
      if ('delete' in document.fonts) {
        customFontFaces.forEach(fontFace => {
          _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('Removing font', fontFace.family)
          document.fonts.delete(fontFace)
        })
      } else {
        _Log__WEBPACK_IMPORTED_MODULE_6__["default"].info('No support for removing manually-added fonts')
      }
    }

    loadLanguage(config) {
      let file = _Utils__WEBPACK_IMPORTED_MODULE_9__["default"].asset('translations.json')
      let language = config

      if (typeof language === 'object') {
        language = config.language || null
        file = config.file || file
      }

      return (0,_Language__WEBPACK_IMPORTED_MODULE_8__.initLanguage)(file, language)
    }

    loadColors(config) {
      let file = _Utils__WEBPACK_IMPORTED_MODULE_9__["default"].asset('colors.json')
      if (config && (typeof config === 'string' || typeof config === 'object')) {
        file = config
      }
      return (0,_Colors__WEBPACK_IMPORTED_MODULE_11__.initColors)(file)
    }

    set focus(v) {
      this._focussed = v
      this._refocus()
    }

    _getFocused() {
      return this._focussed || this.tag('App')
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/AudioPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AudioPlayer)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AudioPlayer {}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Colors/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Colors/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initColors": () => (/* binding */ initColors)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@lightningjs/sdk/src/Colors/utils.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let colors = {
  white: '#ffffff',
  black: '#000000',
  red: '#ff0000',
  green: '#00ff00',
  blue: '#0000ff',
  yellow: '#feff00',
  cyan: '#00feff',
  magenta: '#ff00ff',
}

const normalizedColors = {
  //store for normalized colors
}

const addColors = (colorsToAdd, value) => {
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(colorsToAdd)) {
    // clean up normalizedColors if they exist in the to be added colors
    Object.keys(colorsToAdd).forEach(color => cleanUpNormalizedColors(color))
    colors = Object.assign({}, colors, colorsToAdd)
  } else if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(colorsToAdd) && value) {
    cleanUpNormalizedColors(colorsToAdd)
    colors[colorsToAdd] = value
  }
}

const cleanUpNormalizedColors = color => {
  for (let c in normalizedColors) {
    if (c.indexOf(color) > -1) {
      delete normalizedColors[c]
    }
  }
}

const initColors = file => {
  return new Promise((resolve, reject) => {
    if (typeof file === 'object') {
      addColors(file)
      resolve()
    }
    fetch(file)
      .then(response => response.json())
      .then(json => {
        addColors(json)
        resolve()
      })
      .catch(() => {
        const error = 'Colors file ' + file + ' not found'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      })
  })
}

const normalizeColorToARGB = color => {
  let targetColor = normalizedColors[color] || colors[color] || color
  if (!targetColor) {
    targetColor = color
  }
  const check = /^#([0-9A-F]{3}|[0-9A-F]{6})$/i
  if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isString)(targetColor) && check.test(targetColor)) {
    let hex = check.exec(targetColor)[1]
    if (hex.length === 3) {
      hex = hex
        .split('')
        .map(value => {
          return value + value
        })
        .join('')
    }
    targetColor = `0xff${hex}` * 1
  }
  if (!normalizedColors[color]) {
    normalizedColors[color] = targetColor
  }
  return targetColor || 0xffffffff
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (color => {
  return Color.generate(color)
});

const Color = {
  color: null,
  generate: function(value = this.color) {
    if (normalizedColors[value]) {
      this.color = normalizedColors[value]
    } else {
      this.color = normalizeColorToARGB(value)
    }
    return this
  },
  get() {
    return this.color
  },
  alpha: function(percentage) {
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.calculateAlpha)(this.color, Math.abs(percentage))
    return this
  },
  darker(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = hsl.l * (1 - percentage)
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  lighter(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = hsl.l + (1 - hsl.l) * percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  saturation(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.s = percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  lightness(percentage) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.l = percentage
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  hue(degrees) {
    const hsl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.argbToHSLA)(this.color)
    hsl.h = degrees
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.hslaToARGB)(hsl)
    return this
  },
  mix(argb, p) {
    this.color = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.mergeColors)(this.color, argb, p)
    return this
  },
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Colors/utils.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Colors/utils.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "argbToHSLA": () => (/* binding */ argbToHSLA),
/* harmony export */   "argbToHsva": () => (/* binding */ argbToHsva),
/* harmony export */   "calculateAlpha": () => (/* binding */ calculateAlpha),
/* harmony export */   "getRgbaComponents": () => (/* binding */ getRgbaComponents),
/* harmony export */   "hslaToARGB": () => (/* binding */ hslaToARGB),
/* harmony export */   "hsvaToArgb": () => (/* binding */ hsvaToArgb),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "limitWithinRange": () => (/* binding */ limitWithinRange),
/* harmony export */   "mergeColorAlpha": () => (/* binding */ mergeColorAlpha),
/* harmony export */   "mergeColors": () => (/* binding */ mergeColors)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const isObject = v => {
  return typeof v === 'object' && v !== null
}

const isString = v => {
  return typeof v === 'string'
}

const getRgbaComponents = argb => {
  return {
    r: ((argb / 65536) | 0) % 256,
    g: ((argb / 256) | 0) % 256,
    b: (argb * 1) % 256,
    a: (argb / 16777216) | 0,
  }
}

const limitWithinRange = (num, min, max) => {
  return Math.min(Math.max(num, min), max)
}

const mergeColors = (c1, c2, p) => {
  let r1 = ((c1 / 65536) | 0) % 256
  let g1 = ((c1 / 256) | 0) % 256
  let b1 = c1 % 256
  let a1 = (c1 / 16777216) | 0
  let r2 = ((c2 / 65536) | 0) % 256
  let g2 = ((c2 / 256) | 0) % 256
  let b2 = c2 % 256
  let a2 = (c2 / 16777216) | 0
  let r = r1 * p + r2 * (1 - p)
  let g = g1 * p + g2 * (1 - p)
  let b = b1 * p + b2 * (1 - p)
  let a = a1 * p + a2 * (1 - p)
  return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b)
}

const calculateAlpha = (argb, p) => {
  if (p > 1) {
    p /= 100
  } else if (p < 0) {
    p = 0
  }
  let r = ((argb / 65536) | 0) % 256
  let g = ((argb / 256) | 0) % 256
  let b = argb % 256
  return (r << 16) + (g << 8) + b + ((p * 255) | 0) * 16777216
}

const mergeColorAlpha = (c, alpha) => {
  let a = (((c / 16777216) | 0) * alpha) | 0
  return (
    (((((c >> 16) & 0xff) * a) / 255) & 0xff) +
    ((((c & 0xff00) * a) / 255) & 0xff00) +
    (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
    (a << 24)
  )
}

const getArgbNumber = rgba => {
  rgba[0] = Math.max(0, Math.min(255, rgba[0]))
  rgba[1] = Math.max(0, Math.min(255, rgba[1]))
  rgba[2] = Math.max(0, Math.min(255, rgba[2]))
  rgba[3] = Math.max(0, Math.min(255, rgba[3]))
  let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0)
  if (v < 0) {
    v = 0xffffffff + v + 1
  }
  return v
}

const argbToHsva = argb => {
  const color = getRgbaComponents(argb)
  let r = color.r / 255
  let g = color.g / 255
  let b = color.b / 255
  let h = 0
  let s = 0

  const cMax = Math.max(r, g, b)
  const cMin = Math.min(r, g, b)
  const delta = cMax - cMin

  //calculate hue
  if (delta < 0.00001) {
    h = 0
  } else if (cMax !== 0 || cMin !== 0) {
    if (r === cMax) {
      h = (60 * ((g - b) / delta) + 360) % 360
    } else if (g === cMax) {
      h = (60 * ((b - r) / delta) + 120) % 360
    } else if (b === cMax) {
      h = (60 * ((r - g) / delta) + 240) % 360
    }
  }

  //calc saturation
  if (cMax > 0) {
    s = delta / cMax
  }
  return {
    h,
    s,
    v: cMax,
    a: color.a / 255,
  }
}

const hsvaToArgb = color => {
  const h = color.h
  const c = color.v * color.s
  const m = color.v - c
  const x = c * (1.0 - Math.abs(((h / 60) % 2) - 1))
  let r = 0
  let g = 0
  let b = 0

  if (0 <= h && h < 60) {
    r = c
    g = x
  } else if (60 <= h && h < 120) {
    r = x
    g = c
  } else if (120 <= h && h < 180) {
    g = c
    b = x
  } else if (180 <= h && h < 240) {
    g = x
    b = c
  } else if (240 <= h && h < 300) {
    r = x
    b = c
  } else if (300 <= h && h < 360) {
    r = c
    b = x
  }

  r = Math.round((r + m) * 255.0)
  g = Math.round((g + m) * 255.0)
  b = Math.round((b + m) * 255.0)
  return getArgbNumber([r, g, b, color.a * 255])
}

const argbToHSLA = argb => {
  const col = getRgbaComponents(argb)
  const r = col.r / 255
  const g = col.g / 255
  const b = col.b / 255

  const max = Math.max(r, g, b)
  const min = Math.min(r, g, b)

  let h = 0
  let s = 0
  const l = (min + max) * 0.5
  if (l > 0) {
    const maxMin = max - min
    if (maxMin > 0) {
      const r2 = (max - r) / maxMin
      const g2 = (max - g) / maxMin
      const b2 = (max - b) / maxMin
      if (l < 0.5) {
        s = max + min
      } else {
        s = 2 - max - min
      }

      if (r === max && g === min) {
        h = 5.0 + b2
      } else if (r === max) {
        h = 1.0 - g2
      } else if (g === max && b === min) {
        h = 1.0 + r2
      } else if (g === max) {
        h = 3.0 - b2
      } else if (b === max) {
        h = 3.0 + g2
      } else {
        h = 5.0 - r2
      }
      h = h / 6
    }
  }
  return { h: h % 1, s, l, a: col.a }
}

const hslaToARGB = hsla => {
  let r = 1
  let g = 1
  let b = 1

  let h = hsla.h
  let s = hsla.s
  let l = hsla.l

  if (h < 0) {
    h += 1
  }
  let max = 0
  if (l <= 0.5) {
    max = l * (1.0 + s)
  } else {
    max = l + s - l * s
  }

  if (max > 0) {
    h *= 6.0
    const min = l + l - max
    const minMax = (max - min) / max
    const sextant = Math.floor(h)
    const fract = h - sextant
    const minMaxFract = max * minMax * fract
    const mid1 = min + minMaxFract
    const mid2 = max - minMaxFract

    if (sextant === 0) {
      r = max
      g = mid1
      b = min
    }
    if (sextant === 1) {
      r = mid2
      g = max
      b = min
    }
    if (sextant === 2) {
      r = min
      g = max
      b = mid1
    }
    if (sextant === 3) {
      r = min
      g = mid2
      b = max
    }
    if (sextant === 4) {
      r = mid1
      g = min
      b = max
    }
    if (sextant === 5) {
      r = max
      g = min
      b = mid2
    }
  }
  return getArgbNumber([Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255), hsla.a])
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/FpsCounter/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/FpsCounter/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FpsIndicator)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class FpsIndicator extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      rect: true,
      color: 0xffffffff,
      texture: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Tools.getRoundRect(80, 80, 40),
      h: 80,
      w: 80,
      x: 100,
      y: 100,
      mount: 1,
      Background: {
        x: 3,
        y: 3,
        texture: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Tools.getRoundRect(72, 72, 36),
        color: 0xff008000,
      },
      Counter: {
        w: w => w,
        h: h => h,
        y: 10,
        text: {
          fontSize: 32,
          textAlign: 'center',
        },
      },
      Text: {
        w: w => w,
        h: h => h,
        y: 48,
        text: {
          fontSize: 15,
          textAlign: 'center',
          text: 'FPS',
        },
      },
    }
  }

  _setup() {
    this.config = {
      ...{
        log: false,
        interval: 500,
        threshold: 1,
      },
      ..._Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'showFps'),
    }

    this.fps = 0
    this.lastFps = this.fps - this.config.threshold

    const fpsCalculator = () => {
      this.fps = ~~(1 / this.stage.dt)
    }
    this.stage.on('frameStart', fpsCalculator)
    this.stage.off('framestart', fpsCalculator)
    this.interval = setInterval(this.showFps.bind(this), this.config.interval)
  }

  _firstActive() {
    this.showFps()
  }

  _detach() {
    clearInterval(this.interval)
  }

  showFps() {
    if (Math.abs(this.lastFps - this.fps) <= this.config.threshold) return
    this.lastFps = this.fps
    // green
    let bgColor = 0xff008000
    // orange
    if (this.fps <= 40 && this.fps > 20) bgColor = 0xffffa500
    // red
    else if (this.fps <= 20) bgColor = 0xffff0000

    this.tag('Background').setSmooth('color', bgColor)
    this.tag('Counter').text = `${this.fps}`

    this.config.log && _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('FPS', this.fps)
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScaledImageTexture)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ScaledImageTexture extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.ImageTexture {
  constructor(stage) {
    super(stage)
    this._scalingOptions = undefined
  }

  set options(options) {
    this.resizeMode = this._scalingOptions = options
  }

  _getLookupId() {
    return `${this._src}-${this._scalingOptions.type}-${this._scalingOptions.w}-${this._scalingOptions.h}`
  }

  getNonDefaults() {
    const obj = super.getNonDefaults()
    if (this._src) {
      obj.src = this._src
    }
    return obj
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Img/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Img/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _ScaledImageTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ScaledImageTexture */ "./node_modules/@lightningjs/sdk/src/Img/ScaledImageTexture.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((imageUrl, options) => {
  const imageServerUrl = _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'imageServerUrl')

  // make and return ScaledImageTexture
  const make = options => {
    // local asset, wrap it in Utils.asset()
    if (!/^(?:https?:)?\/\//i.test(imageUrl)) {
      imageUrl = _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].asset(imageUrl)
    }

    // only pass to image server if imageServerUrl is configured
    // and if the asset isn't local to the app (i.e. has same origin)
    if (imageServerUrl && imageUrl.indexOf(window.location.origin) === -1) {
      imageUrl = _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].ensureUrlWithProtocol(
        imageServerUrl + '?' + _Utils__WEBPACK_IMPORTED_MODULE_0__["default"].makeQueryString(imageUrl, options)
      )
    } else {
      // Lightning will handle the resizing and has only 2 flavours (cover and contain)
      if (options.type === 'crop') options.type = 'cover'
      else options.type = 'contain'
    }

    return {
      type: _ScaledImageTexture__WEBPACK_IMPORTED_MODULE_2__["default"],
      src: imageUrl,
      options: options,
    }
  }

  // merge options with default
  const setOptions = options => {
    options = {
      ...{
        type: 'contain',
        w: 0,
        h: 0,
      },
      ...options,
    }
    const imageQuality = Math.max(
      0.1,
      Math.min(1, (parseFloat(_Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'image.quality')) || 100) / 100)
    )

    options.w = options.w * imageQuality
    options.h = options.h * imageQuality
    return options
  }

  // if options are passed, return scaled image right away
  if (options) {
    return make(setOptions(options))
  }

  // otherwise return 'chained' functions
  return {
    // official api
    exact: (w, h) => make(setOptions({ type: 'exact', w, h })),
    landscape: w => make(setOptions({ type: 'landscape', w })),
    portrait: h => make(setOptions({ type: 'portrait', h })),
    cover: (w, h) => make(setOptions({ type: 'cover', w, h })),
    contain: (w, h) => make(setOptions({ type: 'contain', w, h })),
    original: () => make(setOptions({ type: 'contain' })),

    // todo: add positioning - i.e. top, bottom, center, left etc.
  }
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Keyboard/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Keyboard/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Language/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Language/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initLanguage": () => (/* binding */ initLanguage)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let meta = {}
let translations = {}
let language = null
let dictionary = null

const initLanguage = (file, language = null) => {
  return new Promise((resolve, reject) => {
    fetch(file)
      .then(response => response.json())
      .then(json => {
        setTranslations(json)
        // set language (directly or in a promise)
        typeof language === 'object' && 'then' in language && typeof language.then === 'function'
          ? language
              .then(lang =>
                setLanguage(lang)
                  .then(resolve)
                  .catch(reject)
              )
              .catch(e => {
                _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(e)
                reject(e)
              })
          : setLanguage(language)
              .then(resolve)
              .catch(reject)
      })
      .catch(() => {
        const error = 'Language file ' + file + ' not found'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      })
  })
}

const setTranslations = obj => {
  if ('meta' in obj) {
    meta = { ...obj.meta }
    delete obj.meta
  }
  translations = obj
}

const getLanguage = () => {
  return language
}

const setLanguage = lng => {
  language = null
  dictionary = null

  return new Promise((resolve, reject) => {
    if (lng in translations) {
      language = lng
    } else {
      if ('map' in meta && lng in meta.map && meta.map[lng] in translations) {
        language = meta.map[lng]
      } else if ('default' in meta && meta.default in translations) {
        const error =
          'Translations for Language ' +
          language +
          ' not found. Using default language ' +
          meta.default
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn(error)
        language = meta.default
      } else {
        const error = 'Translations for Language ' + language + ' not found.'
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        reject(error)
      }
    }

    if (language) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Setting language to', language)

      const translationsObj = translations[language]
      if (typeof translationsObj === 'object') {
        dictionary = translationsObj
        resolve()
      } else if (typeof translationsObj === 'string') {
        const url = _Utils__WEBPACK_IMPORTED_MODULE_1__["default"].asset(translationsObj)

        fetch(url)
          .then(response => response.json())
          .then(json => {
            // save the translations for this language (to prevent loading twice)
            translations[language] = json
            dictionary = json
            resolve()
          })
          .catch(e => {
            const error = 'Error while fetching ' + url
            _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error, e)
            reject(error)
          })
      }
    }
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  translate(key) {
    let replacements = [...arguments].slice(1)

    // no replacements so just translated string
    if (replacements.length === 0) {
      return (dictionary && dictionary[key]) || key
    } else {
      if (replacements.length === 1 && typeof replacements[0] === 'object') {
        replacements = replacements.pop()
      }

      return Object.keys(
        // maps array input to an object {0: 'item1', 1: 'item2'}
        Array.isArray(replacements) ? Object.assign({}, replacements) : replacements
      ).reduce((text, replacementKey) => {
        return text.replace(
          new RegExp('{\\s?' + replacementKey + '\\s?}', 'g'),
          replacements[replacementKey]
        )
      }, (dictionary && dictionary[key]) || key)
    }
  },

  translations(obj) {
    setTranslations(obj)
  },

  set(language) {
    return setLanguage(language)
  },

  get() {
    return getLanguage()
  },

  available() {
    const languageKeys = Object.keys(translations)
    return languageKeys.map(key => ({ code: key, name: (meta.names && meta.names[key]) || key }))
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Launch/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Launch/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ApplicationInstance": () => (/* binding */ ApplicationInstance),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils */ "./node_modules/@lightningjs/sdk/src/Utils/index.js");
/* harmony import */ var _Profile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _MediaPlayer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MediaPlayer */ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js");
/* harmony import */ var _VideoPlayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../VideoPlayer */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js");
/* harmony import */ var _Storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Storage */ "./node_modules/@lightningjs/sdk/src/Storage/index.js");
/* harmony import */ var _Ads__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _Router__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Router */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _TV__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../TV */ "./node_modules/@lightningjs/sdk/src/TV/index.js");
/* harmony import */ var _Purchase__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../Purchase */ "./node_modules/@lightningjs/sdk/src/Purchase/index.js");
/* harmony import */ var _Pin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/* harmony import */ var _Metadata__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../Metadata */ "./node_modules/@lightningjs/sdk/src/Metadata/index.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















let ApplicationInstance

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((App, appSettings, platformSettings, appData) => {
  ;(0,_Settings__WEBPACK_IMPORTED_MODULE_3__.initSettings)(appSettings, platformSettings)
  ;(0,_Metadata__WEBPACK_IMPORTED_MODULE_12__.initMetadata)(appSettings)

  ;(0,_Utils__WEBPACK_IMPORTED_MODULE_0__.initUtils)(platformSettings)
  ;(0,_Storage__WEBPACK_IMPORTED_MODULE_6__.initStorage)()
  // Initialize plugins
  if (platformSettings.plugins) {
    platformSettings.plugins.profile && (0,_Profile__WEBPACK_IMPORTED_MODULE_1__.initProfile)(platformSettings.plugins.profile)
    platformSettings.plugins.metrics && (0,_Metrics__WEBPACK_IMPORTED_MODULE_2__.initMetrics)(platformSettings.plugins.metrics)
    platformSettings.plugins.mediaPlayer && (0,_MediaPlayer__WEBPACK_IMPORTED_MODULE_4__.initMediaPlayer)(platformSettings.plugins.mediaPlayer)
    platformSettings.plugins.mediaPlayer && (0,_VideoPlayer__WEBPACK_IMPORTED_MODULE_5__.initVideoPlayer)(platformSettings.plugins.mediaPlayer)
    platformSettings.plugins.ads && (0,_Ads__WEBPACK_IMPORTED_MODULE_7__.initAds)(platformSettings.plugins.ads)
    platformSettings.plugins.router && (0,_Router__WEBPACK_IMPORTED_MODULE_8__.initRouter)(platformSettings.plugins.router)
    platformSettings.plugins.tv && (0,_TV__WEBPACK_IMPORTED_MODULE_9__.initTV)(platformSettings.plugins.tv)
    platformSettings.plugins.purchase && (0,_Purchase__WEBPACK_IMPORTED_MODULE_10__.initPurchase)(platformSettings.plugins.purchase)
    platformSettings.plugins.pin && (0,_Pin__WEBPACK_IMPORTED_MODULE_11__.initPin)(platformSettings.plugins.pin)
  }

  const app = (0,_Application__WEBPACK_IMPORTED_MODULE_13__["default"])(App, appData, platformSettings)
  ApplicationInstance = new app(appSettings)
  return ApplicationInstance
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Lightning/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Lightning/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lightningjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/core */ "./node_modules/@lightningjs/core/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lightningjs_core__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Locale/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Locale/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple module for localization of strings.
 *
 * How to use:
 * 1. Create localization file with following JSON format:
 * {
 *   "en" :{
 *     "how": "How do you want your egg today?",
 *     "boiledEgg": "Boiled egg",
 *     "softBoiledEgg": "Soft-boiled egg",
 *     "choice": "How to choose the egg",
 *     "buyQuestion": "I'd like to buy {0} eggs, {1} dollars each."
 *   },
 *
 *   "it": {
 *     "how": "Come vuoi il tuo uovo oggi?",
 *     "boiledEgg": "Uovo sodo",
 *     "softBoiledEgg": "Uovo alla coque",
 *     "choice": "Come scegliere l'uovo",
 *     "buyQuestion": "Mi piacerebbe comprare {0} uova, {1} dollari ciascuna."
 *   }
 * }
 *
 * 2. Use Locale's module load method, specifying path to your localization file and set chosen language, e.g.:
 *    > Locale.load('static/locale/locale.json');
 *    > Locale.setLanguage('en');
 *
 * 3. Use localization strings:
 *    > console.log(Locale.tr.how);
 *    How do you want your egg today?
 *    > console.log(Locale.tr.boiledEgg);
 *    Boiled egg
 *
 * 4. String formatting
 *    > console.log(Locale.tr.buyQuestion.format(10, 0.5));
 *    I'd like to buy 10 eggs, 0.5 dollars each.
 */



let warned = false
const deprecated = (force = false) => {
  if (force === true || warned === false) {
    console.warn(
      [
        "The 'Locale'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'Language'-plugin instead.",
        'https://rdkcentral.github.io/Lightning-SDK/#/plugins/language',
      ].join('\n\n')
    )
  }
  warned = true
}
class Locale {
  constructor() {
    this.__enabled = false
  }

  /**
   * Loads translation object from external json file.
   *
   * @param {String} path Path to resource.
   * @return {Promise}
   */
  async load(path) {
    if (!this.__enabled) {
      return
    }

    await fetch(path)
      .then(resp => resp.json())
      .then(resp => {
        this.loadFromObject(resp)
      })
  }

  /**
   * Sets language used by module.
   *
   * @param {String} lang
   */
  setLanguage(lang) {
    deprecated()
    this.__enabled = true
    this.language = lang
  }

  /**
   * Returns reference to translation object for current language.
   *
   * @return {Object}
   */
  get tr() {
    deprecated(true)
    return this.__trObj[this.language]
  }

  /**
   * Loads translation object from existing object (binds existing object).
   *
   * @param {Object} trObj
   */
  loadFromObject(trObj) {
    deprecated()
    const fallbackLanguage = 'en'
    if (Object.keys(trObj).indexOf(this.language) === -1) {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn('No translations found for: ' + this.language)
      if (Object.keys(trObj).indexOf(fallbackLanguage) > -1) {
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].warn('Using fallback language: ' + fallbackLanguage)
        this.language = fallbackLanguage
      } else {
        const error = 'No translations found for fallback language: ' + fallbackLanguage
        _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(error)
        throw Error(error)
      }
    }

    this.__trObj = trObj
    for (const lang of Object.values(this.__trObj)) {
      for (const str of Object.keys(lang)) {
        lang[str] = new LocalizedString(lang[str])
      }
    }
  }
}

/**
 * Extended string class used for localization.
 */
class LocalizedString extends String {
  /**
   * Returns formatted LocalizedString.
   * Replaces each placeholder value (e.g. {0}, {1}) with corresponding argument.
   *
   * E.g.:
   * > new LocalizedString('{0} and {1} and {0}').format('A', 'B');
   * A and B and A
   *
   * @param  {...any} args List of arguments for placeholders.
   */
  format(...args) {
    const sub = args.reduce((string, arg, index) => string.split(`{${index}}`).join(arg), this)
    return new LocalizedString(sub)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new Locale());


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Log/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Log/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const prepLog = (type, args) => {
  const colors = {
    Info: 'green',
    Debug: 'gray',
    Warn: 'orange',
    Error: 'red',
  }

  args = Array.from(args)
  return [
    '%c' + (args.length > 1 && typeof args[0] === 'string' ? args.shift() : type),
    'background-color: ' + colors[type] + '; color: white; padding: 2px 4px; border-radius: 2px',
    args,
  ]
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  info() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.log.apply(console, prepLog('Info', arguments))
  },
  debug() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.debug.apply(console, prepLog('Debug', arguments))
  },
  error() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.error.apply(console, prepLog('Error', arguments))
  },
  warn() {
    _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'log') && console.warn.apply(console, prepLog('Warn', arguments))
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/MediaPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Mediaplayer),
/* harmony export */   "initMediaPlayer": () => (/* binding */ initMediaPlayer)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const events = [
  'timeupdate',
  'error',
  'ended',
  'loadeddata',
  'canplay',
  'play',
  'playing',
  'pause',
  'loadstart',
  'seeking',
  'seeked',
  'encrypted',
]

let mediaUrl = url => url

const initMediaPlayer = config => {
  if (config.mediaUrl) {
    mediaUrl = config.mediaUrl
  }
}

class Mediaplayer extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  _construct() {
    this._skipRenderToTexture = false
    this._metrics = null
    this._textureMode = _Settings__WEBPACK_IMPORTED_MODULE_2__["default"].get('platform', 'textureMode') || false
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Texture mode: ' + this._textureMode)
    console.warn(
      [
        "The 'MediaPlayer'-plugin in the Lightning-SDK is deprecated and will be removed in future releases.",
        "Please consider using the new 'VideoPlayer'-plugin instead.",
        'https://rdkcentral.github.io/Lightning-SDK/#/plugins/videoplayer',
      ].join('\n\n')
    )
  }

  static _template() {
    return {
      Video: {
        VideoWrap: {
          VideoTexture: {
            visible: false,
            pivot: 0.5,
            texture: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.StaticTexture, options: {} },
          },
        },
      },
    }
  }

  set skipRenderToTexture(v) {
    this._skipRenderToTexture = v
  }

  get textureMode() {
    return this._textureMode
  }

  get videoView() {
    return this.tag('Video')
  }

  _init() {
    //re-use videotag if already there
    const videoEls = document.getElementsByTagName('video')
    if (videoEls && videoEls.length > 0) this.videoEl = videoEls[0]
    else {
      this.videoEl = document.createElement('video')
      this.videoEl.setAttribute('id', 'video-player')
      this.videoEl.style.position = 'absolute'
      this.videoEl.style.zIndex = '1'
      this.videoEl.style.display = 'none'
      this.videoEl.setAttribute('width', '100%')
      this.videoEl.setAttribute('height', '100%')

      this.videoEl.style.visibility = this.textureMode ? 'hidden' : 'visible'
      document.body.appendChild(this.videoEl)
    }
    if (this.textureMode && !this._skipRenderToTexture) {
      this._createVideoTexture()
    }

    this.eventHandlers = []
  }

  _registerListeners() {
    events.forEach(event => {
      const handler = e => {
        if (this._metrics && this._metrics[event] && typeof this._metrics[event] === 'function') {
          this._metrics[event]({ currentTime: this.videoEl.currentTime })
        }
        this.fire(event, { videoElement: this.videoEl, event: e })
      }
      this.eventHandlers.push(handler)
      this.videoEl.addEventListener(event, handler)
    })
  }

  _deregisterListeners() {
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Deregistering event listeners MediaPlayer')
    events.forEach((event, index) => {
      this.videoEl.removeEventListener(event, this.eventHandlers[index])
    })
    this.eventHandlers = []
  }

  _attach() {
    this._registerListeners()
  }

  _detach() {
    this._deregisterListeners()
    this.close()
  }

  _createVideoTexture() {
    const stage = this.stage

    const gl = stage.gl
    const glTexture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, glTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

    this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height }
  }

  _startUpdatingVideoTexture() {
    if (this.textureMode && !this._skipRenderToTexture) {
      const stage = this.stage
      if (!this._updateVideoTexture) {
        this._updateVideoTexture = () => {
          if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
            const gl = stage.gl

            const currentTime = new Date().getTime()

            // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
            // We'll fallback to fixed 30fps in this case.
            const frameCount = this.videoEl.webkitDecodedFrameCount

            const mustUpdate = frameCount
              ? this._lastFrame !== frameCount
              : this._lastTime < currentTime - 30

            if (mustUpdate) {
              this._lastTime = currentTime
              this._lastFrame = frameCount
              try {
                gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl)
                this._lastFrame = this.videoEl.webkitDecodedFrameCount
                this.videoTextureView.visible = true

                this.videoTexture.options.w = this.videoEl.videoWidth
                this.videoTexture.options.h = this.videoEl.videoHeight
                const expectedAspectRatio = this.videoTextureView.w / this.videoTextureView.h
                const realAspectRatio = this.videoEl.videoWidth / this.videoEl.videoHeight
                if (expectedAspectRatio > realAspectRatio) {
                  this.videoTextureView.scaleX = realAspectRatio / expectedAspectRatio
                  this.videoTextureView.scaleY = 1
                } else {
                  this.videoTextureView.scaleY = expectedAspectRatio / realAspectRatio
                  this.videoTextureView.scaleX = 1
                }
              } catch (e) {
                _Log__WEBPACK_IMPORTED_MODULE_3__["default"].error('texImage2d video', e)
                this._stopUpdatingVideoTexture()
                this.videoTextureView.visible = false
              }
              this.videoTexture.source.forceRenderUpdate()
            }
          }
        }
      }
      if (!this._updatingVideoTexture) {
        stage.on('frameStart', this._updateVideoTexture)
        this._updatingVideoTexture = true
      }
    }
  }

  _stopUpdatingVideoTexture() {
    if (this.textureMode) {
      const stage = this.stage
      stage.removeListener('frameStart', this._updateVideoTexture)
      this._updatingVideoTexture = false
      this.videoTextureView.visible = false

      if (this.videoTexture.options.source) {
        const gl = stage.gl
        gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
        gl.clearColor(0, 0, 0, 1)
        gl.clear(gl.COLOR_BUFFER_BIT)
      }
    }
  }

  updateSettings(settings = {}) {
    // The Component that 'consumes' the media player.
    this._consumer = settings.consumer

    if (this._consumer && this._consumer.getMediaplayerSettings) {
      // Allow consumer to add settings.
      settings = Object.assign(settings, this._consumer.getMediaplayerSettings())
    }

    if (!_Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Utils.equalValues(this._stream, settings.stream)) {
      if (settings.stream && settings.stream.keySystem) {
        navigator
          .requestMediaKeySystemAccess(
            settings.stream.keySystem.id,
            settings.stream.keySystem.config
          )
          .then(keySystemAccess => {
            return keySystemAccess.createMediaKeys()
          })
          .then(createdMediaKeys => {
            return this.videoEl.setMediaKeys(createdMediaKeys)
          })
          .then(() => {
            if (settings.stream && settings.stream.src) this.open(settings.stream.src)
          })
          .catch(() => {
            console.error('Failed to set up MediaKeys')
          })
      } else if (settings.stream && settings.stream.src) {
        // This is here to be backwards compatible, will be removed
        // in future sdk release
        if (_Settings__WEBPACK_IMPORTED_MODULE_2__["default"].get('app', 'hls')) {
          if (!window.Hls) {
            window.Hls = class Hls {
              static isSupported() {
                console.warn('hls-light not included')
                return false
              }
            }
          }
          if (window.Hls.isSupported()) {
            if (!this._hls) this._hls = new window.Hls({ liveDurationInfinity: true })
            this._hls.loadSource(settings.stream.src)
            this._hls.attachMedia(this.videoEl)
            this.videoEl.style.display = 'block'
          }
        } else {
          this.open(settings.stream.src)
        }
      } else {
        this.close()
      }
      this._stream = settings.stream
    }

    this._setHide(settings.hide)
    this._setVideoArea(settings.videoPos)
  }

  _setHide(hide) {
    if (this.textureMode) {
      this.tag('Video').setSmooth('alpha', hide ? 0 : 1)
    } else {
      this.videoEl.style.visibility = hide ? 'hidden' : 'visible'
    }
  }

  open(url, settings = { hide: false, videoPosition: null }) {
    // prep the media url to play depending on platform (mediaPlayerplugin)
    url = mediaUrl(url)
    this._metrics = _Metrics__WEBPACK_IMPORTED_MODULE_1__["default"].media(url)
    _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('Playing stream', url)
    if (this.application.noVideo) {
      _Log__WEBPACK_IMPORTED_MODULE_3__["default"].info('noVideo option set, so ignoring: ' + url)
      return
    }
    // close the video when opening same url as current (effectively reloading)
    if (this.videoEl.getAttribute('src') === url) {
      this.close()
    }
    this.videoEl.setAttribute('src', url)

    // force hide, then force show (in next tick!)
    // (fixes comcast playback rollover issue)
    this.videoEl.style.visibility = 'hidden'
    this.videoEl.style.display = 'none'

    setTimeout(() => {
      this.videoEl.style.display = 'block'
      this.videoEl.style.visibility = 'visible'
    })

    this._setHide(settings.hide)
    this._setVideoArea(settings.videoPosition || [0, 0, 1920, 1080])
  }

  close() {
    // We need to pause first in order to stop sound.
    this.videoEl.pause()
    this.videoEl.removeAttribute('src')

    // force load to reset everything without errors
    this.videoEl.load()

    this._clearSrc()

    this.videoEl.style.display = 'none'
  }

  playPause() {
    if (this.isPlaying()) {
      this.doPause()
    } else {
      this.doPlay()
    }
  }

  get muted() {
    return this.videoEl.muted
  }

  set muted(v) {
    this.videoEl.muted = v
  }

  get loop() {
    return this.videoEl.loop
  }

  set loop(v) {
    this.videoEl.loop = v
  }

  isPlaying() {
    return this._getState() === 'Playing'
  }

  doPlay() {
    this.videoEl.play()
  }

  doPause() {
    this.videoEl.pause()
  }

  reload() {
    var url = this.videoEl.getAttribute('src')
    this.close()
    this.videoEl.src = url
  }

  getPosition() {
    return Promise.resolve(this.videoEl.currentTime)
  }

  setPosition(pos) {
    this.videoEl.currentTime = pos
  }

  getDuration() {
    return Promise.resolve(this.videoEl.duration)
  }

  seek(time, absolute = false) {
    if (absolute) {
      this.videoEl.currentTime = time
    } else {
      this.videoEl.currentTime += time
    }
  }

  get videoTextureView() {
    return this.tag('Video').tag('VideoTexture')
  }

  get videoTexture() {
    return this.videoTextureView.texture
  }

  _setVideoArea(videoPos) {
    if (_Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Utils.equalValues(this._videoPos, videoPos)) {
      return
    }

    this._videoPos = videoPos

    if (this.textureMode) {
      this.videoTextureView.patch({
        smooth: {
          x: videoPos[0],
          y: videoPos[1],
          w: videoPos[2] - videoPos[0],
          h: videoPos[3] - videoPos[1],
        },
      })
    } else {
      const precision = this.stage.getRenderPrecision()
      this.videoEl.style.left = Math.round(videoPos[0] * precision) + 'px'
      this.videoEl.style.top = Math.round(videoPos[1] * precision) + 'px'
      this.videoEl.style.width = Math.round((videoPos[2] - videoPos[0]) * precision) + 'px'
      this.videoEl.style.height = Math.round((videoPos[3] - videoPos[1]) * precision) + 'px'
    }
  }

  _fireConsumer(event, args) {
    if (this._consumer) {
      this._consumer.fire(event, args)
    }
  }

  _equalInitData(buf1, buf2) {
    if (!buf1 || !buf2) return false
    if (buf1.byteLength != buf2.byteLength) return false
    const dv1 = new Int8Array(buf1)
    const dv2 = new Int8Array(buf2)
    for (let i = 0; i != buf1.byteLength; i++) if (dv1[i] != dv2[i]) return false
    return true
  }

  error(args) {
    this._fireConsumer('$mediaplayerError', args)
    this._setState('')
    return ''
  }

  loadeddata(args) {
    this._fireConsumer('$mediaplayerLoadedData', args)
  }

  play(args) {
    this._fireConsumer('$mediaplayerPlay', args)
  }

  playing(args) {
    this._fireConsumer('$mediaplayerPlaying', args)
    this._setState('Playing')
  }

  canplay(args) {
    this.videoEl.play()
    this._fireConsumer('$mediaplayerStart', args)
  }

  loadstart(args) {
    this._fireConsumer('$mediaplayerLoad', args)
  }

  seeked() {
    this._fireConsumer('$mediaplayerSeeked', {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1,
    })
  }

  seeking() {
    this._fireConsumer('$mediaplayerSeeking', {
      currentTime: this.videoEl.currentTime,
      duration: this.videoEl.duration || 1,
    })
  }

  durationchange(args) {
    this._fireConsumer('$mediaplayerDurationChange', args)
  }

  encrypted(args) {
    const video = args.videoElement
    const event = args.event
    // FIXME: Double encrypted events need to be properly filtered by Gstreamer
    if (video.mediaKeys && !this._equalInitData(this._previousInitData, event.initData)) {
      this._previousInitData = event.initData
      this._fireConsumer('$mediaplayerEncrypted', args)
    }
  }

  static _states() {
    return [
      class Playing extends this {
        $enter() {
          this._startUpdatingVideoTexture()
        }
        $exit() {
          this._stopUpdatingVideoTexture()
        }
        timeupdate() {
          this._fireConsumer('$mediaplayerProgress', {
            currentTime: this.videoEl.currentTime,
            duration: this.videoEl.duration || 1,
          })
        }
        ended(args) {
          this._fireConsumer('$mediaplayerEnded', args)
          this._setState('')
        }
        pause(args) {
          this._fireConsumer('$mediaplayerPause', args)
          this._setState('Playing.Paused')
        }
        _clearSrc() {
          this._fireConsumer('$mediaplayerStop', {})
          this._setState('')
        }
        static _states() {
          return [class Paused extends this {}]
        }
      },
    ]
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Metadata/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Metadata/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initMetadata": () => (/* binding */ initMetadata)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let metadata = {}

const initMetadata = metadataObj => {
  metadata = metadataObj
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(key, fallback = undefined) {
    return key in metadata ? metadata[key] : fallback
  },
  appId() {
    return this.get('id')
  },
  safeAppId() {
    return this.get('id').replace(/[^0-9a-zA-Z_$]/g, '_')
  },
  appName() {
    return this.get('name')
  },
  appVersion() {
    return (this.get('version') || '').split('-').shift()
  },
  appIcon() {
    return this.get('icon')
  },
  // Version from app store (with commit hash)
  appFullVersion() {
    return this.get('version')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Metrics/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Metrics/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initMetrics": () => (/* binding */ initMetrics)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



let sendMetric = (type, event, params) => {
  _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Sending metric', type, event, params)
}

const initMetrics = config => {
  sendMetric = config.sendMetric
}

// available metric per category
const metrics = {
  app: ['launch', 'loaded', 'ready', 'close'],
  page: ['view', 'leave'],
  user: ['click', 'input'],
  media: [
    'abort',
    'canplay',
    'ended',
    'pause',
    'play',
    // with some videos there occur almost constant suspend events ... should investigate
    // 'suspend',
    'volumechange',
    'waiting',
    'seeking',
    'seeked',
  ],
}

// error metric function (added to each category)
const errorMetric = (type, message, code, visible, params = {}) => {
  params = { params, ...{ message, code, visible } }
  sendMetric(type, 'error', params)
}

const Metric = (type, events, options = {}) => {
  return events.reduce(
    (obj, event) => {
      obj[event] = (name, params = {}) => {
        params = { ...options, ...(name ? { name } : {}), ...params }
        sendMetric(type, event, params)
      }
      return obj
    },
    {
      error(message, code, params) {
        errorMetric(type, message, code, params)
      },
      event(name, params) {
        sendMetric(type, name, params)
      },
    }
  )
}

const Metrics = types => {
  return Object.keys(types).reduce(
    (obj, type) => {
      // media metric works a bit different!
      // it's a function that accepts a url and returns an object with the available metrics
      // url is automatically passed as a param in every metric
      type === 'media'
        ? (obj[type] = url => Metric(type, types[type], { url }))
        : (obj[type] = Metric(type, types[type]))
      return obj
    },
    { error: errorMetric, event: sendMetric }
  )
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Metrics(metrics));


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Pin/dialog.js":
/*!*********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Pin/dialog.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PinDialog)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Pin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Pin */ "./node_modules/@lightningjs/sdk/src/Pin/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class PinInput extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      w: 120,
      h: 150,
      rect: true,
      color: 0xff949393,
      alpha: 0.5,
      shader: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].shaders.RoundedRectangle, radius: 10 },
      Nr: {
        w: w => w,
        y: 24,
        text: {
          text: '',
          textColor: 0xff333333,
          fontSize: 80,
          textAlign: 'center',
          verticalAlign: 'middle',
        },
      },
    }
  }

  set index(v) {
    this.x = v * (120 + 24)
  }

  set nr(v) {
    this._timeout && clearTimeout(this._timeout)

    if (v) {
      this.setSmooth('alpha', 1)
    } else {
      this.setSmooth('alpha', 0.5)
    }

    this.tag('Nr').patch({
      text: {
        text: (v && v.toString()) || '',
        fontSize: v === '*' ? 120 : 80,
      },
    })

    if (v && v !== '*') {
      this._timeout = setTimeout(() => {
        this._timeout = null
        this.nr = '*'
      }, 750)
    }
  }
}

class PinDialog extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      zIndex: 1,
      w: w => w,
      h: h => h,
      rect: true,
      color: 0xdd000000,
      alpha: 0.000001,
      Dialog: {
        w: 648,
        h: 320,
        y: h => (h - 320) / 2,
        x: w => (w - 648) / 2,
        rect: true,
        color: 0xdd333333,
        shader: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].shaders.RoundedRectangle, radius: 10 },
        Info: {
          y: 24,
          x: 48,
          text: { text: 'Please enter your PIN', fontSize: 32 },
        },
        Msg: {
          y: 260,
          x: 48,
          text: { text: '', fontSize: 28, textColor: 0xffffffff },
        },
        Code: {
          x: 48,
          y: 96,
        },
      },
    }
  }

  _init() {
    const children = []
    for (let i = 0; i < 4; i++) {
      children.push({
        type: PinInput,
        index: i,
      })
    }

    this.tag('Code').children = children
  }

  get pin() {
    if (!this._pin) this._pin = ''
    return this._pin
  }

  set pin(v) {
    if (v.length <= 4) {
      const maskedPin = new Array(Math.max(v.length - 1, 0)).fill('*', 0, v.length - 1)
      v.length && maskedPin.push(v.length > this._pin.length ? v.slice(-1) : '*')
      for (let i = 0; i < 4; i++) {
        this.tag('Code').children[i].nr = maskedPin[i] || ''
      }
      this._pin = v
    }
  }

  get msg() {
    if (!this._msg) this._msg = ''
    return this._msg
  }

  set msg(v) {
    this._timeout && clearTimeout(this._timeout)

    this._msg = v
    if (this._msg) {
      this.tag('Msg').text = this._msg
      this.tag('Info').setSmooth('alpha', 0.5)
      this.tag('Code').setSmooth('alpha', 0.5)
    } else {
      this.tag('Msg').text = ''
      this.tag('Info').setSmooth('alpha', 1)
      this.tag('Code').setSmooth('alpha', 1)
    }
    this._timeout = setTimeout(() => {
      this.msg = ''
    }, 2000)
  }

  _firstActive() {
    this.setSmooth('alpha', 1)
  }

  _handleKey(event) {
    if (this.msg) {
      this.msg = false
    } else {
      const val = parseInt(event.key)
      if (val > -1) {
        this.pin += val
      }
    }
  }

  _handleBack() {
    if (this.msg) {
      this.msg = false
    } else {
      if (this.pin.length) {
        this.pin = this.pin.slice(0, this.pin.length - 1)
      } else {
        _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].hide()
        this.resolve(false)
      }
    }
  }

  _handleEnter() {
    if (this.msg) {
      this.msg = false
    } else {
      _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].submit(this.pin)
        .then(val => {
          this.msg = 'Unlocking ...'
          setTimeout(() => {
            _Pin__WEBPACK_IMPORTED_MODULE_1__["default"].hide()
          }, 1000)
          this.resolve(val)
        })
        .catch(e => {
          this.msg = e
          this.reject(e)
        })
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Pin/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Pin/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initPin": () => (/* binding */ initPin)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dialog */ "./node_modules/@lightningjs/sdk/src/Pin/dialog.js");
/* harmony import */ var _Launch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../index */ "./node_modules/@lightningjs/sdk/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






// only used during local development
let unlocked = false
const contextItems = ['purchase', 'parental']

let submit = (pin, context) => {
  return new Promise((resolve, reject) => {
    if (pin.toString() === _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'pin', '0000').toString()) {
      unlocked = true
      resolve(unlocked)
    } else {
      reject('Incorrect pin')
    }
  })
}

let check = context => {
  return new Promise(resolve => {
    resolve(unlocked)
  })
}

const initPin = config => {
  if (config.submit && typeof config.submit === 'function') {
    submit = config.submit
  }
  if (config.check && typeof config.check === 'function') {
    check = config.check
  }
}

let pinDialog = null

const contextCheck = context => {
  if (context === undefined) {
    _index__WEBPACK_IMPORTED_MODULE_3__.Log.info('Please provide context explicitly')
    return contextItems[0]
  } else if (!contextItems.includes(context)) {
    _index__WEBPACK_IMPORTED_MODULE_3__.Log.warn('Incorrect context provided')
    return false
  }
  return context
}

// Public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  show() {
    return new Promise((resolve, reject) => {
      pinDialog = _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.stage.c({
        ref: 'PinDialog',
        type: _dialog__WEBPACK_IMPORTED_MODULE_1__["default"],
        resolve,
        reject,
      })
      _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.childList.a(pinDialog)
      _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.focus = pinDialog
    })
  },
  hide() {
    _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.focus = null
    _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.children = _Launch__WEBPACK_IMPORTED_MODULE_2__.ApplicationInstance.children.map(
      child => child !== pinDialog && child
    )
    pinDialog = null
  },
  submit(pin, context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          submit(pin, context)
            .then(resolve)
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
  unlocked(context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          check(context)
            .then(resolve)
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
  locked(context) {
    return new Promise((resolve, reject) => {
      try {
        context = contextCheck(context)
        if (context) {
          check(context)
            .then(unlocked => resolve(!!!unlocked))
            .catch(reject)
        } else {
          reject('Incorrect Context provided')
        }
      } catch (e) {
        reject(e)
      }
    })
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/defaults.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/defaults.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultProfile": () => (/* binding */ defaultProfile)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Profile/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const defaultProfile = {
  ageRating: 'adult',
  city: 'New York',
  zipCode: '27505',
  countryCode: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getCountryCode)('US'),
  ip: '127.0.0.1',
  household: 'b2244e9d4c04826ccd5a7b2c2a50e7d4',
  language: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLanguage)('en'),
  latlon: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLatLon)([40.7128, 74.006]),
  locale: () => (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getLocale)('en-US'),
  mac: '00:00:00:00:00:00',
  operator: 'metrological',
  platform: 'metrological',
  packages: [],
  uid: 'ee6723b8-7ab3-462c-8d93-dbf61227998e',
  stbType: 'metrological',
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/helpers.js":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/helpers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getCountryCode": () => (/* binding */ getCountryCode),
/* harmony export */   "getLanguage": () => (/* binding */ getLanguage),
/* harmony export */   "getLatLon": () => (/* binding */ getLatLon),
/* harmony export */   "getLocale": () => (/* binding */ getLocale)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const formatLocale = locale => {
  if (locale && locale.length === 2) {
    return `${locale.toLowerCase()}-${locale.toUpperCase()}`
  } else {
    return locale
  }
}

const getLocale = defaultValue => {
  if ('language' in navigator) {
    const locale = formatLocale(navigator.language)
    return Promise.resolve(locale)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const getLanguage = defaultValue => {
  if ('language' in navigator) {
    const language = formatLocale(navigator.language).slice(0, 2)
    return Promise.resolve(language)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const getCountryCode = defaultValue => {
  if ('language' in navigator) {
    const countryCode = formatLocale(navigator.language).slice(3, 5)
    return Promise.resolve(countryCode)
  } else {
    return Promise.resolve(defaultValue)
  }
}

const hasOrAskForGeoLocationPermission = () => {
  return new Promise(resolve => {
    // force to prompt for location permission
    if (_Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'forceBrowserGeolocation') === true) resolve(true)
    if ('permissions' in navigator && typeof navigator.permissions.query === 'function') {
      navigator.permissions.query({ name: 'geolocation' }).then(status => {
        resolve(status.state === 'granted' || status.status === 'granted')
      })
    } else {
      resolve(false)
    }
  })
}

const getLatLon = defaultValue => {
  return new Promise(resolve => {
    hasOrAskForGeoLocationPermission().then(granted => {
      if (granted === true) {
        if ('geolocation' in navigator) {
          navigator.geolocation.getCurrentPosition(
            // success
            result =>
              result && result.coords && resolve([result.coords.latitude, result.coords.longitude]),
            // error
            () => resolve(defaultValue),
            // options
            {
              enableHighAccuracy: true,
              timeout: 5000,
              maximumAge: 0,
            }
          )
        } else {
          return queryForLatLon().then(result => resolve(result || defaultValue))
        }
      } else {
        return queryForLatLon().then(result => resolve(result || defaultValue))
      }
    })
  })
}

const queryForLatLon = () => {
  return new Promise(resolve => {
    fetch('https://geolocation-db.com/json/')
      .then(response => response.json())
      .then(({ latitude, longitude }) =>
        latitude && longitude ? resolve([latitude, longitude]) : resolve(false)
      )
      .catch(() => resolve(false))
  })
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Profile/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Profile/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initProfile": () => (/* binding */ initProfile)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ "./node_modules/@lightningjs/sdk/src/Profile/defaults.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let getInfo = key => {
  const profile = { ..._defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile, ..._Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'profile') }
  return Promise.resolve(typeof profile[key] === 'function' ? profile[key]() : profile[key])
}

let setInfo = (key, params) => {
  if (key in _defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile) _defaults__WEBPACK_IMPORTED_MODULE_1__.defaultProfile[key] = params
}

const initProfile = config => {
  getInfo = config.getInfo
  setInfo = config.setInfo
}

const getOrSet = (key, params) => (params ? setInfo(key, params) : getInfo(key))

// public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ageRating(params) {
    return getOrSet('ageRating', params)
  },
  city(params) {
    return getOrSet('city', params)
  },
  zipCode(params) {
    return getOrSet('zipCode', params)
  },
  countryCode(params) {
    return getOrSet('countryCode', params)
  },
  ip(params) {
    return getOrSet('ip', params)
  },
  household(params) {
    return getOrSet('household', params)
  },
  language(params) {
    return getOrSet('language', params)
  },
  latlon(params) {
    return getOrSet('latlon', params)
  },
  locale(params) {
    return getOrSet('locale', params)
  },
  mac(params) {
    return getOrSet('mac', params)
  },
  operator(params) {
    return getOrSet('operator', params)
  },
  platform(params) {
    return getOrSet('platform', params)
  },
  packages(params) {
    return getOrSet('packages', params)
  },
  uid(params) {
    return getOrSet('uid', params)
  },
  stbType(params) {
    return getOrSet('stbType', params)
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Purchase/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Purchase/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initPurchase": () => (/* binding */ initPurchase)
/* harmony export */ });
/* harmony import */ var _Profile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Profile */ "./node_modules/@lightningjs/sdk/src/Profile/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _helpers_sequence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/sequence */ "./node_modules/@lightningjs/sdk/src/helpers/sequence.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let cspUrl = 'http://payment-csp-example.metrological.com:8080/'
let billingUrl = 'https://payment-sdk.metrological.com/'

let cspEndpoints = {
  assets: {
    uri: '/assets',
    method: 'GET',
  },
  asset: {
    uri: '/assets/:id',
    method: 'GET',
  },
  signature: {
    uri: '/assets/:id/signature',
    method: 'POST',
  },
  subscribe: {
    uri: '/assets/:id/subscribe',
    method: 'POST',
  },
  unsubscribe: {
    uri: '/assets/:id/unsubscribe',
    method: 'POST',
  },
}

const initPurchase = config => {
  if (config.billingUrl) billingUrl = config.billingUrl
}

const createUrl = (uri, baseUrl, params = {}) => {
  return new URL(
    // sprinkle in the params
    Object.keys(params)
      .reduce((res, key) => res.replace(new RegExp(':' + key, 'g'), params[key]), uri)
      // remove any leading slash from uri
      .replace(/^\//, ''),
    // make sure baseUrl always has a trailing slash
    /\/$/.test(baseUrl) ? baseUrl : baseUrl.replace(/$/, '/')
  )
}

const request = (url, method = 'GET', data, headers = {}) => {
  if (method === 'GET' && data) {
    url.search = new URLSearchParams(data)
  }

  return new Promise((resolve, reject) => {
    fetch(url, {
      headers: {
        ...{
          Accept: 'application/json',
          'Content-Type': 'application/json',
        },
        ...headers,
      },
      method: method,
      body: method !== 'GET' && data ? JSON.stringify(data) : null,
    })
      .then(response => (response.ok ? resolve(response.json()) : reject(response.statusText)))
      .catch(reject)
  })
}

const cspRequest = (type, data = null, params = {}) => {
  return new Promise((resolve, reject) => {
    const endpoint = cspEndpoints[type]

    if (!endpoint) {
      reject('No endpoint found for "' + type + '" call')
    } else {
      if (endpoint.callback && typeof endpoint.callback === 'function') {
        endpoint
          .callback(data, params)
          .then(resolve)
          .catch(reject)
      } else {
        request(
          createUrl(endpoint.uri, cspUrl, params),
          endpoint.method,
          {
            ...(endpoint.data || {}),
            ...data,
          },
          endpoint.headers || {}
        )
          .then(resolve)
          .catch(reject)
      }
    }
  })
}

const billingRequest = (uri, data, method = 'POST') => {
  return new Promise((resolve, reject) => {
    request(createUrl(uri, billingUrl), method, data)
      .then(resolve)
      .catch(reject)
  })
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  setup(config) {
    if (config.cspUrl) cspUrl = config.cspUrl
    if (config.endpoints) cspEndpoints = { cspEndpoints, ...config.endpoints }
  },
  assets() {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('assets', { household })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  asset(id) {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('asset', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  signature(id) {
    return new Promise((resolve, reject) => {
      Promise.all([_Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household()]).then(([household]) => {
        cspRequest('signature', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  subscribe(id, transaction) {
    return new Promise((resolve, reject) => {
      cspRequest('subscribe', { ...transaction }, { id })
        .then(resolve)
        .catch(reject)
    })
  },
  unsubscribe(id) {
    return new Promise((resolve, reject) => {
      _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household().then(household => {
        cspRequest('unsubscribe', { household }, { id })
          .then(resolve)
          .catch(reject)
      })
    })
  },
  payment(signature = {}, type = 'in-app') {
    return new Promise((resolve, reject) => {
      Promise.all([
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].household(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].countryCode(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].operator(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].mac(),
        _Profile__WEBPACK_IMPORTED_MODULE_0__["default"].uid(),
      ])
        .then(([household, country, operator, mac, uid]) => {
          billingRequest('/', {
            purchase: signature,
            identifier: _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('app', 'id'),
            name: _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('app', 'id'),
            household,
            country,
            operator,
            mac,
            uid,
            type,
          })
            .then(resolve)
            .catch(reject)
        })
        .catch(reject)
    })
  },
  confirm(transactionId) {
    return new Promise((resolve, reject) => {
      billingRequest('/confirm', {
        transactionId,
      })
        .then(resolve)
        .catch(reject)
    })
  },
  buy(assetId, type) {
    return new Promise((resolve, reject) => {
      let transactionId
      ;(0,_helpers_sequence__WEBPACK_IMPORTED_MODULE_2__["default"])([
        () => this.signature(assetId),
        signature => this.payment(signature, type),
        transaction => {
          transactionId = transaction.transactionId
          return this.subscribe(assetId, transaction)
        },
        () => this.confirm(transactionId),
      ])
        .then(resolve)
        .catch(reject)
    })
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Registry/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Registry/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const registry = {
  eventListeners: [],
  timeouts: [],
  intervals: [],
  targets: [],
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  // Timeouts
  setTimeout(cb, timeout, ...params) {
    const timeoutId = setTimeout(
      () => {
        registry.timeouts = registry.timeouts.filter(id => id !== timeoutId)
        cb.apply(null, params)
      },
      timeout,
      params
    )
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Set Timeout', 'ID: ' + timeoutId)
    registry.timeouts.push(timeoutId)
    return timeoutId
  },

  clearTimeout(timeoutId) {
    if (registry.timeouts.indexOf(timeoutId) > -1) {
      registry.timeouts = registry.timeouts.filter(id => id !== timeoutId)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Clear Timeout', 'ID: ' + timeoutId)
      clearTimeout(timeoutId)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Clear Timeout', 'ID ' + timeoutId + ' not found')
    }
  },

  clearTimeouts() {
    registry.timeouts.forEach(timeoutId => {
      this.clearTimeout(timeoutId)
    })
  },

  // Intervals
  setInterval(cb, interval, ...params) {
    const intervalId = setInterval(
      () => {
        registry.intervals.filter(id => id !== intervalId)
        cb.apply(null, params)
      },
      interval,
      params
    )
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Set Interval', 'ID: ' + intervalId)
    registry.intervals.push(intervalId)
    return intervalId
  },

  clearInterval(intervalId) {
    if (registry.intervals.indexOf(intervalId) > -1) {
      registry.intervals = registry.intervals.filter(id => id !== intervalId)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info('Clear Interval', 'ID: ' + intervalId)
      clearInterval(intervalId)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Clear Interval', 'ID ' + intervalId + ' not found')
    }
  },

  clearIntervals() {
    registry.intervals.forEach(intervalId => {
      this.clearInterval(intervalId)
    })
  },

  // Event listeners
  addEventListener(target, event, handler) {
    target.addEventListener(event, handler)
    const targetIndex =
      registry.targets.indexOf(target) > -1
        ? registry.targets.indexOf(target)
        : registry.targets.push(target) - 1

    registry.eventListeners[targetIndex] = registry.eventListeners[targetIndex] || {}
    registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][event] || []
    registry.eventListeners[targetIndex][event].push(handler)
    _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info(
      'Add eventListener',
      'Target:',
      target,
      'Event: ' + event,
      'Handler:',
      handler.toString()
    )
  },

  removeEventListener(target, event, handler) {
    const targetIndex = registry.targets.indexOf(target)
    if (
      targetIndex > -1 &&
      registry.eventListeners[targetIndex] &&
      registry.eventListeners[targetIndex][event] &&
      registry.eventListeners[targetIndex][event].indexOf(handler) > -1
    ) {
      registry.eventListeners[targetIndex][event] = registry.eventListeners[targetIndex][
        event
      ].filter(fn => fn !== handler)
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].info(
        'Remove eventListener',
        'Target:',
        target,
        'Event: ' + event,
        'Handler:',
        handler.toString()
      )
      target.removeEventListener(event, handler)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error(
        'Remove eventListener',
        'Not found',
        'Target',
        target,
        'Event: ' + event,
        'Handler',
        handler.toString()
      )
    }
  },

  // if `event` is omitted, removes all registered event listeners for target
  // if `target` is also omitted, removes all registered event listeners
  removeEventListeners(target, event) {
    if (target && event) {
      const targetIndex = registry.targets.indexOf(target)
      if (targetIndex > -1) {
        registry.eventListeners[targetIndex][event].forEach(handler => {
          this.removeEventListener(target, event, handler)
        })
      }
    } else if (target) {
      const targetIndex = registry.targets.indexOf(target)
      if (targetIndex > -1) {
        Object.keys(registry.eventListeners[targetIndex]).forEach(_event => {
          this.removeEventListeners(target, _event)
        })
      }
    } else {
      Object.keys(registry.eventListeners).forEach(targetIndex => {
        this.removeEventListeners(registry.targets[targetIndex])
      })
    }
  },

  // Clear everything (to be called upon app close for proper cleanup)
  clear() {
    this.clearTimeouts()
    this.clearIntervals()
    this.removeEventListeners()
    registry.eventListeners = []
    registry.timeouts = []
    registry.intervals = []
    registry.targets = []
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/base.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RoutedApp": () => (/* binding */ RoutedApp)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _utils_router_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/router.js */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class RoutedApp extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      Pages: {
        forceZIndexContext: true,
      },
      /**
       * This is a default Loading page that will be made visible
       * during data-provider on() you CAN override in child-class
       */
      Loading: {
        rect: true,
        w: 1920,
        h: 1080,
        color: 0xff000000,
        visible: false,
        zIndex: 99,
        Label: {
          mount: 0.5,
          x: 960,
          y: 540,
          text: {
            text: 'Loading..',
          },
        },
      },
    }
  }

  static _states() {
    return [
      class Loading extends this {
        $enter() {
          this.tag('Loading').visible = true
        }

        $exit() {
          this.tag('Loading').visible = false
        }
      },
      class Widgets extends this {
        $enter(args, widget) {
          // store widget reference
          this._widget = widget

          // since it's possible that this behaviour
          // is non-remote driven we force a recalculation
          // of the focuspath
          this._refocus()
        }

        _getFocused() {
          // we delegate focus to selected widget
          // so it can consume remotecontrol presses
          return this._widget
        }

        // if we want to widget to widget focus delegation
        reload(widget) {
          this._widget = widget
          this._refocus()
        }

        _handleKey() {
          const restoreFocus = _utils_router_js__WEBPACK_IMPORTED_MODULE_2__.routerConfig.get('autoRestoreRemote')
          /**
           * The Router used to delegate focus back to the page instance on
           * every unhandled key. This is barely usefull in any situation
           * so for now we offer the option to explicity turn that behaviour off
           * so we don't don't introduce a breaking change.
           */
          if (!(0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.isBoolean)(restoreFocus) || restoreFocus === true) {
            _index__WEBPACK_IMPORTED_MODULE_1__["default"].focusPage()
          }
        }
      },
    ]
  }

  /**
   * Return location where pages need to be stored
   */
  get pages() {
    return this.tag('Pages')
  }

  /**
   * Tell router where widgets are stored
   */
  get widgets() {
    return this.tag('Widgets')
  }

  /**
   * we MUST register _handleBack method so the Router
   * can override it
   * @private
   */
  _handleBack() {}

  /**
   * We MUST return Router.activePage() so the new Page
   * can listen to the remote-control.
   */
  _getFocused() {
    return _index__WEBPACK_IMPORTED_MODULE_1__["default"].getActivePage()
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getResumeHash": () => (/* binding */ getResumeHash),
/* harmony export */   "initRouter": () => (/* binding */ initRouter),
/* harmony export */   "navigate": () => (/* binding */ navigate),
/* harmony export */   "navigateQueue": () => (/* binding */ navigateQueue),
/* harmony export */   "step": () => (/* binding */ step)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _utils_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _utils_widgets__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _utils_history__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _utils_route__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _utils_loader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/loader */ "./node_modules/@lightningjs/sdk/src/Router/utils/loader.js");
/* harmony import */ var _utils_regex__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "./node_modules/@lightningjs/sdk/src/Router/base.js");
/* harmony import */ var _Registry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Registry */ "./node_modules/@lightningjs/sdk/src/Registry/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













/*
rouThor ==[x]
 */
let navigateQueue = new Map()
let forcedHash = ''
let resumeHash = ''

/**
 * Start routing the app
 * @param config - route config object
 * @param instance - instance of the app
 */
const startRouter = (config, instance) => {
  ;(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.bootRouter)(config, instance)
  registerListener()
  start()
}

// start translating url
const start = () => {
  let hash = (getHash() || '').replace(/^#/, '')
  const bootKey = '$'
  const params = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams)(hash)
  const bootRequest = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getBootRequest)()
  const rootHash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getRootHash)()
  const isDirectLoad = hash.indexOf(bootKey) !== -1

  // prevent direct reload of wildcard routes
  // expect bootComponent
  if (_utils_regex__WEBPACK_IMPORTED_MODULE_6__.isWildcard.test(hash) && hash !== bootKey) {
    hash = ''
  }

  // store resume point for manual resume
  resumeHash = isDirectLoad ? rootHash : hash || rootHash

  const ready = () => {
    if (!hash && rootHash) {
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(rootHash)) {
        navigate(rootHash)
      } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(rootHash)) {
        rootHash().then(res => {
          if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
            navigate(res.path, res.params)
          } else {
            navigate(res)
          }
        })
      }
    } else {
      queue(hash)
      handleHashChange()
        .then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
        })
        .catch(e => {
          console.error(e)
        })
    }
  }

  if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(bootKey)) {
    if (hash && !isDirectLoad) {
      if (!(0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)) {
        navigate('*', { failedHash: hash })
        return
      }
    }
    navigate(
      bootKey,
      {
        resume: resumeHash,
        reload: bootKey === hash,
      },
      false
    )
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(bootRequest)) {
    bootRequest(params)
      .then(() => {
        ready()
      })
      .catch(e => {
        handleBootError(e)
      })
  } else {
    ready()
  }
}

const handleBootError = e => {
  if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)('!')) {
    navigate('!', { request: { error: e } })
  } else {
    console.error(e)
  }
}

/**
 * start a new request
 * @param url
 * @param args
 * @param store
 */
const navigate = (url, args = {}, store) => {
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(url)) {
    url = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getHashByName)(url)
    if (!url) {
      return
    }
  }

  let hash = getHash()
  if (!(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)() && forcedHash) {
    hash = forcedHash
  }
  if (hash.replace(/^#/, '') !== url) {
    // push request in the queue
    queue(url, args, store)

    setHash(url)
    if (!(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)()) {
      forcedHash = url
      handleHashChange(url)
        .then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
        })
        .catch(e => {
          console.error(e)
        })
    }
  } else if (args.reload) {
    // push request in the queue
    queue(url, args, store)

    handleHashChange(url)
      .then(() => {
        _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
      })
      .catch(e => {
        console.error(e)
      })
  }
}

const queue = (hash, args = {}, store) => {
  hash = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(hash)
  if (!navigateQueue.has(hash)) {
    for (let request of navigateQueue.values()) {
      request.cancel()
    }
    const request = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.createRequest)(hash, args, store)
    navigateQueue.set(decodeURIComponent(hash), request)

    return request
  }
  return false
}

/**
 * Handle change of hash
 * @param override
 * @returns {Promise<void>}
 */
const handleHashChange = async override => {
  const hash = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(override || getHash())
  const queueId = decodeURIComponent(hash)
  let request = navigateQueue.get(queueId)

  // handle hash updated manually
  if (!request && !navigateQueue.size) {
    request = queue(hash)
  }

  const route = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)

  if (!route) {
    if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)('*')) {
      navigate('*', { failedHash: hash })
    } else {
      console.error(`Unable to navigate to: ${hash}`)
    }
    return
  }

  // update current processed request
  request.hash = hash
  request.route = route

  let result = await (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.beforeEachRoute)((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)(), request)

  // test if a local hook is configured for the route
  if (route.beforeNavigate) {
    result = await route.beforeNavigate((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)(), request)
  }

  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(result)) {
    // only if resolve value is explicitly true
    // we continue the current route request
    if (result) {
      return resolveHashChange(request)
    }
  } else {
    // if navigation guard didn't return true
    // we cancel the current request
    request.cancel()
    navigateQueue.delete(queueId)

    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(result)) {
      navigate(result)
    } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(result)) {
      let store = true
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(result.store)) {
        store = result.store
      }
      navigate(result.path, result.params, store)
    }
  }
}

/**
 * Continue processing the hash change if not blocked
 * by global or local hook
 * @param request - {}
 */
const resolveHashChange = request => {
  const hash = request.hash
  const route = request.route
  const queueId = decodeURIComponent(hash)
  // store last requested hash so we can
  // prevent a route that resolved later
  // from displaying itself
  ;(0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.setLastHash)(hash)

  if (route.path) {
    const component = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getComponent)(route.path)
    // if a hook is provided for the current route
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(route.hook)) {
      const urlParams = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getValuesFromHash)(hash, route.path)
      const params = {}
      for (const key of urlParams.keys()) {
        params[key] = urlParams.get(key)
      }
      route.hook(_utils_router__WEBPACK_IMPORTED_MODULE_1__.app, { ...params })
    }
    // if there is a component attached to the route
    if (component) {
      // force page to root state to prevent shared state issues
      const activePage = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage)()
      if (activePage) {
        const keepAlive = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.keepActivePageAlive)((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute)(), request)
        if (activePage && route.path === (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute)() && !keepAlive) {
          activePage._setState('')
        }
      }

      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(component, _utils_router__WEBPACK_IMPORTED_MODULE_1__.stage)) {
        (0,_utils_loader__WEBPACK_IMPORTED_MODULE_5__.load)(request).then(() => {
          _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
          navigateQueue.delete(queueId)
        })
      } else {
        // of the component is not a constructor
        // or a Component instance we can assume
        // that it's a dynamic import
        component()
          .then(contents => {
            return contents.default
          })
          .then(module => {
            (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.storeComponent)(route.path, module)
            return (0,_utils_loader__WEBPACK_IMPORTED_MODULE_5__.load)(request)
          })
          .then(() => {
            _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._refocus()
            navigateQueue.delete(queueId)
          })
      }
    } else {
      navigateQueue.delete(queueId)
    }
  }
}

/**
 * Directional step in history
 * @param direction
 */
const step = (level = 0) => {
  if (!level || isNaN(level)) {
    return false
  }
  const history = (0,_utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistory)()
  // for now we only support negative numbers
  level = Math.abs(level)

  // we can't step back past the amount
  // of history entries
  if (level > history.length) {
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(_utils_router__WEBPACK_IMPORTED_MODULE_1__.app._handleAppClose)) {
      return _utils_router__WEBPACK_IMPORTED_MODULE_1__.app._handleAppClose()
    }
    return false
  } else if (history.length) {
    // for now we only support history back
    const route = history.splice(history.length - level, level)[0]
    // store changed history
    ;(0,_utils_history__WEBPACK_IMPORTED_MODULE_3__.setHistory)(history)
    return navigate(
      route.hash,
      {
        [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack]: true,
        [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState]: route.state,
      },
      false
    )
  } else if (_utils_router__WEBPACK_IMPORTED_MODULE_1__.routerConfig.get('backtrack')) {
    const hashLastPart = /(\/:?[\w%\s-]+)$/
    let hash = (0,_utils_regex__WEBPACK_IMPORTED_MODULE_6__.stripRegex)(getHash())
    let floor = (0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getFloor)(hash)

    // test if we got deep-linked
    if (floor > 1) {
      while (floor--) {
        // strip of last part
        hash = hash.replace(hashLastPart, '')
        // if we have a configured route
        // we navigate to it
        if ((0,_utils_route__WEBPACK_IMPORTED_MODULE_4__.getRouteByHash)(hash)) {
          return navigate(hash, { [_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack]: true }, false)
        }
      }
    }
  }
  return false
}

/**
 * Resume Router's page loading process after
 * the BootComponent became visible;
 */
const resume = () => {
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(resumeHash)) {
    navigate(resumeHash, false)
    resumeHash = ''
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(resumeHash)) {
    resumeHash().then(res => {
      resumeHash = ''
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
        navigate(res.path, res.params)
      } else {
        navigate(res)
      }
    })
  } else {
    console.warn('[Router]: resume() called but no hash found')
  }
}

/**
 * Force reload active hash
 */
const reload = () => {
  if (!isNavigating()) {
    const hash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash)()
    navigate(hash, { reload: true }, false)
  }
}

/**
 * Query if the Router is still processing a Request
 * @returns {boolean}
 */
const isNavigating = () => {
  if (navigateQueue.size) {
    let isProcessing = false
    for (let request of navigateQueue.values()) {
      if (!request.isCancelled) {
        isProcessing = true
      }
    }
    return isProcessing
  }
  return false
}

const getResumeHash = () => {
  return resumeHash
}

/**
 * By default we return the location hash
 * @returns {string}
 */
let getHash = () => {
  return document.location.hash
}

/**
 * Update location hash
 * @param url
 */
let setHash = url => {
  document.location.hash = url
}

/**
 * This can be called from the platform / bootstrapper to override
 * the default getting and setting of the hash
 * @param config
 */
const initRouter = config => {
  if (config.getHash) {
    getHash = config.getHash
  }
  if (config.setHash) {
    setHash = config.setHash
  }
}

/**
 * On hash change we start processing
 */
const registerListener = () => {
  _Registry__WEBPACK_IMPORTED_MODULE_8__["default"].addEventListener(window, 'hashchange', async () => {
    if ((0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.mustUpdateLocationHash)()) {
      try {
        await handleHashChange()
      } catch (e) {
        console.error(e)
      }
    }
  })
}

/**
 * Navigate to root hash
 */
const root = () => {
  const rootHash = (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getRootHash)()
  if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isString)(rootHash)) {
    navigate(rootHash)
  } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(rootHash)) {
    rootHash().then(res => {
      if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(res)) {
        navigate(res.path, res.params)
      } else {
        navigate(res)
      }
    })
  }
}

// export API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  startRouter,
  navigate,
  resume,
  step,
  go: step,
  back: step.bind(null, -1),
  activePage: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage,
  getActivePage() {
    // warning
    return (0,_utils_router__WEBPACK_IMPORTED_MODULE_1__.getActivePage)()
  },
  getActiveRoute: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveRoute,
  getActiveHash: _utils_router__WEBPACK_IMPORTED_MODULE_1__.getActiveHash,
  focusWidget: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.focusWidget,
  getActiveWidget: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.getActiveWidget,
  restoreFocus: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.restoreFocus,
  isNavigating,
  getHistory: _utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistory,
  setHistory: _utils_history__WEBPACK_IMPORTED_MODULE_3__.setHistory,
  getHistoryState: _utils_history__WEBPACK_IMPORTED_MODULE_3__.getHistoryState,
  replaceHistoryState: _utils_history__WEBPACK_IMPORTED_MODULE_3__.replaceHistoryState,
  getQueryStringParams: _utils_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams,
  reload,
  symbols: _utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols,
  App: _base__WEBPACK_IMPORTED_MODULE_7__.RoutedApp,
  // keep backwards compatible
  focusPage: _utils_widgets__WEBPACK_IMPORTED_MODULE_2__.restoreFocus,
  root: root,
  /**
   * Deprecated api methods
   */
  setupRoutes() {
    console.warn('Router: setupRoutes is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  on() {
    console.warn('Router.on() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  before() {
    console.warn('Router.before() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
  after() {
    console.warn('Router.after() is deprecated, consolidate your configuration')
    console.warn('https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration')
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/model/Request.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/model/Request.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Request)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _utils_register__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/register */ "./node_modules/@lightningjs/sdk/src/Router/utils/register.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class Request {
  constructor(hash = '', navArgs, storeCaller) {
    /**
     * Hash we navigate to
     * @type {string}
     * @private
     */
    this._hash = hash

    /**
     * Do we store previous hash in history
     * @type {boolean}
     * @private
     */
    this._storeCaller = storeCaller

    /**
     * Request and navigate data
     * @type {Map}
     * @private
     */
    this._register = new Map()

    /**
     * Flag if the instance is created due to
     * this request
     * @type {boolean}
     * @private
     */
    this._isCreated = false

    /**
     * Flag if the instance is shared between
     * previous and current request
     * @type {boolean}
     * @private
     */
    this._isSharedInstance = false

    /**
     * Flag if the request has been cancelled
     * @type {boolean}
     * @private
     */
    this._cancelled = false

    /**
     * if instance is shared between requests we copy state object
     * from instance before the new request overrides state
     * @type {null}
     * @private
     */
    this._copiedHistoryState = null

    // if there are arguments attached to navigate()
    // we store them in new request
    if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(navArgs)) {
      this._register = (0,_utils_register__WEBPACK_IMPORTED_MODULE_1__.createRegister)(navArgs)
    } else if ((0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(navArgs)) {
      // if second navigate() argument is explicitly
      // set to false we prevent the calling page
      // from ending up in history
      this._storeCaller = navArgs
    }
    // @todo: remove because we can simply check
    // ._storeCaller property
    this._register.set(_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.store, this._storeCaller)
  }

  cancel() {
    _Log__WEBPACK_IMPORTED_MODULE_2__["default"].debug('[router]:', `cancelled ${this._hash}`)
    this._cancelled = true
  }

  get url() {
    return this._hash
  }

  get register() {
    return this._register
  }

  get hash() {
    return this._hash
  }

  set hash(args) {
    this._hash = args
  }

  get route() {
    return this._route
  }

  set route(args) {
    this._route = args
  }

  get provider() {
    return this._provider
  }

  set provider(args) {
    this._provider = args
  }

  get providerType() {
    return this._providerType
  }

  set providerType(args) {
    this._providerType = args
  }

  set page(args) {
    this._page = args
  }

  get page() {
    return this._page
  }

  set isCreated(args) {
    this._isCreated = args
  }

  get isCreated() {
    return this._isCreated
  }

  get isSharedInstance() {
    return this._isSharedInstance
  }

  set isSharedInstance(args) {
    this._isSharedInstance = args
  }

  get isCancelled() {
    return this._cancelled
  }

  set copiedHistoryState(v) {
    this._copiedHistoryState = v
  }

  get copiedHistoryState() {
    return this._copiedHistoryState
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/model/Route.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/model/Route.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Route)
/* harmony export */ });
/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Route {
  constructor(config = {}) {
    // keep backwards compatible
    let type = ['on', 'before', 'after'].reduce((acc, type) => {
      return (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config[type]) ? type : acc
    }, undefined)

    this._cfg = config
    if (type) {
      this._provider = {
        type,
        request: config[type],
      }
    }
  }

  get path() {
    return this._cfg.path
  }

  get component() {
    return this._cfg.component
  }

  get options() {
    return this._cfg.options
  }

  get widgets() {
    return this._cfg.widgets
  }

  get cache() {
    return this._cfg.cache
  }

  get hook() {
    return this._cfg.hook
  }

  get beforeNavigate() {
    return this._cfg.beforeNavigate
  }

  get provider() {
    return this._provider
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/transitions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/transitions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const fade = (i, o) => {
  return new Promise(resolve => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }],
      },
    })
    // resolve on y finish
    i.transition('alpha').on('finish', () => {
      if (o) {
        o.visible = false
      }
      resolve()
    })
  })
}

const crossFade = (i, o) => {
  return new Promise(resolve => {
    i.patch({
      alpha: 0,
      visible: true,
      smooth: {
        alpha: [1, { duration: 0.5, delay: 0.1 }],
      },
    })
    if (o) {
      o.patch({
        smooth: {
          alpha: [0, { duration: 0.5, delay: 0.3 }],
        },
      })
    }
    // resolve on y finish
    i.transition('alpha').on('finish', () => {
      resolve()
    })
  })
}

const moveOnAxes = (axis, direction, i, o) => {
  const bounds = axis === 'x' ? 1920 : 1080
  return new Promise(resolve => {
    i.patch({
      [`${axis}`]: direction ? bounds * -1 : bounds,
      visible: true,
      smooth: {
        [`${axis}`]: [0, { duration: 0.4, delay: 0.2 }],
      },
    })
    // out is optional
    if (o) {
      o.patch({
        [`${axis}`]: 0,
        smooth: {
          [`${axis}`]: [direction ? bounds : bounds * -1, { duration: 0.4, delay: 0.2 }],
        },
      })
    }
    // resolve on y finish
    i.transition(axis).on('finish', () => {
      resolve()
    })
  })
}

const up = (i, o) => {
  return moveOnAxes('y', 0, i, o)
}

const down = (i, o) => {
  return moveOnAxes('y', 1, i, o)
}

const left = (i, o) => {
  return moveOnAxes('x', 0, i, o)
}

const right = (i, o) => {
  return moveOnAxes('x', 1, i, o)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  fade,
  crossFade,
  up,
  down,
  left,
  right,
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/components.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createComponent": () => (/* binding */ createComponent)
/* harmony export */ });
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const createComponent = (stage, type) => {
  return stage.c({
    type,
    visible: false,
    widgets: (0,_widgets__WEBPACK_IMPORTED_MODULE_0__.getReferences)(),
  })
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/emit.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((page, events = [], params = {}) => {
  if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(events)) {
    events = [events]
  }
  events.forEach(e => {
    const event = `_on${(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.ucfirst)(e)}`
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(page[event])) {
      page[event](params)
    }
  })
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cleanHash": () => (/* binding */ cleanHash),
/* harmony export */   "getConfigMap": () => (/* binding */ getConfigMap),
/* harmony export */   "getQueryStringParams": () => (/* binding */ getQueryStringParams),
/* harmony export */   "incorrectParams": () => (/* binding */ incorrectParams),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isComponentConstructor": () => (/* binding */ isComponentConstructor),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isPage": () => (/* binding */ isPage),
/* harmony export */   "isPromise": () => (/* binding */ isPromise),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "objectToQueryString": () => (/* binding */ objectToQueryString),
/* harmony export */   "symbols": () => (/* binding */ symbols),
/* harmony export */   "ucfirst": () => (/* binding */ ucfirst)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const isFunction = v => {
  return typeof v === 'function'
}

const isObject = v => {
  return typeof v === 'object' && v !== null
}

const isBoolean = v => {
  return typeof v === 'boolean'
}

const isPage = v => {
  if (v instanceof _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Element || isComponentConstructor(v)) {
    return true
  }
  return false
}

const isComponentConstructor = type => {
  return type.prototype && 'isComponent' in type.prototype
}

const isArray = v => {
  return Array.isArray(v)
}

const ucfirst = v => {
  return `${v.charAt(0).toUpperCase()}${v.slice(1)}`
}

const isString = v => {
  return typeof v === 'string'
}

const isPromise = method => {
  let result
  if (isFunction(method)) {
    try {
      result = method.apply(null)
    } catch (e) {
      result = e
    }
  } else {
    result = method
  }
  return isObject(result) && isFunction(result.then)
}

const cleanHash = (hash = '') => {
  return hash.replace(/^#/, '').replace(/\/+$/, '')
}

const getConfigMap = () => {
  const routerSettings = _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', 'router')
  const isObj = isObject(routerSettings)
  return [
    'backtrack',
    'gcOnUnload',
    'destroyOnHistoryBack',
    'lazyCreate',
    'lazyDestroy',
    'reuseInstance',
    'autoRestoreRemote',
    'numberNavigation',
    'updateHash',
    'storeSameHash',
  ].reduce((config, key) => {
    config.set(key, isObj ? routerSettings[key] : _Settings__WEBPACK_IMPORTED_MODULE_1__["default"].get('platform', key))
    return config
  }, new Map())
}

const incorrectParams = (cb, route) => {
  const isIncorrect = /^\w*?\s?\(\s?\{.*?\}\s?\)/i
  if (isIncorrect.test(cb.toString())) {
    console.warn(
      [
        `DEPRECATION: The data-provider for route: ${route} is not correct.`,
        '"page" is no longer a property of the params object but is now the first function parameter: ',
        'https://github.com/rdkcentral/Lightning-SDK/blob/feature/router/docs/plugins/router/dataproviding.md#data-providing',
        "It's supported for now but will be removed in a future release.",
      ].join('\n')
    )
    return true
  }
  return false
}

const getQueryStringParams = (hash = (0,_router__WEBPACK_IMPORTED_MODULE_2__.getActiveHash)()) => {
  const resumeHash = (0,_index__WEBPACK_IMPORTED_MODULE_3__.getResumeHash)()
  if ((hash === '$' || !hash) && resumeHash) {
    if (isString(resumeHash)) {
      hash = resumeHash
    }
  }

  let parse = ''
  const getQuery = /([?&].*)/
  const matches = getQuery.exec(hash)
  const params = {}

  if (document.location && document.location.search) {
    parse = document.location.search
  }

  if (matches && matches.length) {
    let hashParams = matches[1]
    if (parse) {
      // if location.search is not empty we
      // remove the leading ? to create a
      // valid string
      hashParams = hashParams.replace(/^\?/, '')
      // we parse hash params last so they we can always
      // override search params with hash params
      parse = `${parse}&${hashParams}`
    } else {
      parse = hashParams
    }
  }

  if (parse) {
    const urlParams = new URLSearchParams(parse)
    for (const [key, value] of urlParams.entries()) {
      params[key] = value
    }
    return params
  } else {
    return false
  }
}

const objectToQueryString = obj => {
  if (!isObject(obj)) {
    return ''
  }
  return (
    '?' +
    Object.keys(obj)
      .map(key => {
        return `${key}=${obj[key]}`
      })
      .join('&')
  )
}

const symbols = {
  route: Symbol('route'),
  hash: Symbol('hash'),
  store: Symbol('store'),
  fromHistory: Symbol('fromHistory'),
  expires: Symbol('expires'),
  resume: Symbol('resume'),
  backtrack: Symbol('backtrack'),
  historyState: Symbol('historyState'),
  queryParams: Symbol('queryParams'),
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/history.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getHistory": () => (/* binding */ getHistory),
/* harmony export */   "getHistoryState": () => (/* binding */ getHistoryState),
/* harmony export */   "replaceHistoryState": () => (/* binding */ replaceHistoryState),
/* harmony export */   "setHistory": () => (/* binding */ setHistory),
/* harmony export */   "updateHistory": () => (/* binding */ updateHistory)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Simple flat array that holds the visited hashes + state Object
 * so the router can navigate back to them
 * @type {Array}
 */
let history = []

const updateHistory = request => {
  const hash = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActiveHash)()
  if (!hash) {
    return
  }

  // navigate storage flag
  const register = request.register
  const forceNavigateStore = register.get(_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.store)

  // test preventStorage on route configuration
  const activeRoute = (0,_route__WEBPACK_IMPORTED_MODULE_1__.getRouteByHash)(hash)
  const preventStorage = (0,_route__WEBPACK_IMPORTED_MODULE_1__.getOption)(activeRoute.options, 'preventStorage')

  // we give prio to navigate storage flag
  let store = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(forceNavigateStore) ? forceNavigateStore : !preventStorage

  if (store) {
    const toStore = hash.replace(/^\//, '')
    const location = locationInHistory(toStore)
    const stateObject = getStateObject((0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)(), request)
    const routerConfig = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getRouterConfig)()

    // store hash if it's not a part of history or flag for
    // storage of same hash is true
    if (location === -1 || routerConfig.get('storeSameHash')) {
      history.push({ hash: toStore, state: stateObject })
    } else {
      // if we visit the same route we want to sync history
      const prev = history.splice(location, 1)[0]
      history.push({ hash: prev.hash, state: stateObject })
    }
  }
}

const locationInHistory = hash => {
  for (let i = 0; i < history.length; i++) {
    if (history[i].hash === hash) {
      return i
    }
  }
  return -1
}

const getHistoryState = hash => {
  let state = null
  if (history.length) {
    // if no hash is provided we get the last
    // pushed history record
    if (!hash) {
      const record = history[history.length - 1]
      // could be null
      state = record.state
    } else {
      if (locationInHistory(hash) !== -1) {
        const record = history[locationInHistory(hash)]
        state = record.state
      }
    }
  }
  return state
}

const replaceHistoryState = (state = null, hash) => {
  if (!history.length) {
    return
  }
  const location = hash ? locationInHistory(hash) : history.length - 1
  if (location !== -1 && (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isObject)(state)) {
    history[location].state = state
  }
}

const getStateObject = (page, request) => {
  // if the new request shared instance with the
  // previous request we used the copied state object
  if (request.isSharedInstance) {
    if (request.copiedHistoryState) {
      return request.copiedHistoryState
    }
  } else if (page && (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isFunction)(page.historyState)) {
    return page.historyState()
  }
  return null
}

const getHistory = () => {
  return history.slice(0)
}

const setHistory = (arr = []) => {
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isArray)(arr)) {
    history = arr
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/loader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/loader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "load": () => (/* binding */ load),
/* harmony export */   "mustReuse": () => (/* binding */ mustReuse)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./provider */ "./node_modules/@lightningjs/sdk/src/Router/utils/provider.js");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components */ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transition */ "./node_modules/@lightningjs/sdk/src/Router/utils/transition.js");
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















/**
 * The actual loading of the component
 * */
const load = async request => {
  let expired = false
  try {
    request = await loader(request)
    if (request && !request.isCancelled) {
      // in case of on() providing we need to reset
      // app state;
      if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Loading') {
        if ((0,_router__WEBPACK_IMPORTED_MODULE_0__.getPreviousState)() === 'Widgets') {
          _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('Widgets', [(0,_widgets__WEBPACK_IMPORTED_MODULE_6__.getActiveWidget)()])
        } else {
          _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
        }
      }
      // Do page transition if instance
      // is not shared between the routes
      if (!request.isSharedInstance && !request.isCancelled) {
        await (0,_transition__WEBPACK_IMPORTED_MODULE_5__.executeTransition)(request.page, (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)())
      }
    } else {
      expired = true
    }
    // on expired we only cleanup
    if (expired || request.isCancelled) {
      _Log__WEBPACK_IMPORTED_MODULE_1__["default"].debug('[router]:', `Rejected ${request.hash} because route to ${(0,_router__WEBPACK_IMPORTED_MODULE_0__.getLastHash)()} started`)
      if (request.isCreated && !request.isSharedInstance) {
        // remove from render-tree
        _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.remove(request.page)
      }
    } else {
      (0,_router__WEBPACK_IMPORTED_MODULE_0__.onRequestResolved)(request)
      // resolve promise
      return request.page
    }
  } catch (request) {
    if (!request.route) {
      console.error(request)
    } else if (!expired) {
      // @todo: revisit
      const { route } = request
      // clean up history if modifier is set
      if ((0,_route__WEBPACK_IMPORTED_MODULE_8__.getOption)(route.options, 'clearHistory')) {
        (0,_history__WEBPACK_IMPORTED_MODULE_10__.setHistory)([])
      } else if (!_regex__WEBPACK_IMPORTED_MODULE_11__.isWildcard.test(route.path)) {
        (0,_history__WEBPACK_IMPORTED_MODULE_10__.updateHistory)(request)
      }

      if (request.isCreated && !request.isSharedInstance) {
        // remove from render-tree
        _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.remove(request.page)
      }
      handleError(request)
    }
  }
}

const loader = async request => {
  const route = request.route
  const hash = request.hash
  const register = request.register

  // todo: grab from Route instance
  let type = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getComponent)(route.path)
  let isConstruct = (0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isComponentConstructor)(type)
  let provide = false

  // if it's an instance bt we're not coming back from
  // history we test if we can re-use this instance
  if (!isConstruct && !register.get(_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.backtrack)) {
    if (!mustReuse(route)) {
      type = type.constructor
      isConstruct = true
    }
  }

  // If page is Lightning Component instance
  if (!isConstruct) {
    request.page = type
    // if we have have a data route for current page
    if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.hasProvider)(route.path)) {
      if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.isPageExpired)(type) || type[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.hash] !== hash) {
        provide = true
      }
    }
    let currentRoute = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)() && (0,_router__WEBPACK_IMPORTED_MODULE_0__.getActivePage)()[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.route]
    // if the new route is equal to the current route it means that both
    // route share the Component instance and stack location / since this case
    // is conflicting with the way before() and after() loading works we flag it,
    // and check platform settings in we want to re-use instance
    if (route.path === currentRoute) {
      request.isSharedInstance = true
      // since we're re-using the instance we must attach
      // historyState to the request to prevent it from
      // being overridden.
      if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isFunction)(request.page.historyState)) {
        request.copiedHistoryState = request.page.historyState()
      }
    }
  } else {
    request.page = (0,_components__WEBPACK_IMPORTED_MODULE_4__.createComponent)(_router__WEBPACK_IMPORTED_MODULE_0__.stage, type)
    _router__WEBPACK_IMPORTED_MODULE_0__.pagesHost.a(request.page)
    // test if need to request data provider
    if ((0,_provider__WEBPACK_IMPORTED_MODULE_3__.hasProvider)(route.path)) {
      provide = true
    }
    request.isCreated = true
  }

  // we store hash and route as properties on the page instance
  // that way we can easily calculate new behaviour on page reload
  request.page[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.hash] = hash
  request.page[_helpers__WEBPACK_IMPORTED_MODULE_2__.symbols.route] = route.path

  try {
    if (provide) {
      // extract attached data-provider for route
      // we're processing
      const { type: loadType, provider } = (0,_provider__WEBPACK_IMPORTED_MODULE_3__.getProvider)(route)

      // update running request
      request.provider = provider
      request.providerType = loadType

      await _provider__WEBPACK_IMPORTED_MODULE_3__.dataHooks[loadType](request)

      // we early exit if the current request is expired
      if (hash !== (0,_router__WEBPACK_IMPORTED_MODULE_0__.getLastHash)()) {
        return false
      } else {
        if (request.providerType !== 'after') {
          (0,_emit__WEBPACK_IMPORTED_MODULE_7__["default"])(request.page, 'dataProvided')
        }
        // resolve promise
        return request
      }
    } else {
      (0,_provider__WEBPACK_IMPORTED_MODULE_3__.addPersistData)(request)
      return request
    }
  } catch (e) {
    request.error = e
    return Promise.reject(request)
  }
}

const handleError = request => {
  if (request && request.error) {
    console.error(request.error)
  } else if (request) {
    _Log__WEBPACK_IMPORTED_MODULE_1__["default"].error(request)
  }

  if (request.page && (0,_router__WEBPACK_IMPORTED_MODULE_0__.routeExists)('!')) {
    (0,_index__WEBPACK_IMPORTED_MODULE_9__.navigate)('!', { request }, false)
  }
}

const mustReuse = route => {
  const opt = (0,_route__WEBPACK_IMPORTED_MODULE_8__.getOption)(route.options, 'reuseInstance')
  const config = _router__WEBPACK_IMPORTED_MODULE_0__.routerConfig.get('reuseInstance')

  // route always has final decision
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(opt)) {
    return opt
  }
  return !((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBoolean)(config) && config === false)
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addPersistData": () => (/* binding */ addPersistData),
/* harmony export */   "dataHooks": () => (/* binding */ dataHooks),
/* harmony export */   "getProvider": () => (/* binding */ getProvider),
/* harmony export */   "hasProvider": () => (/* binding */ hasProvider),
/* harmony export */   "isPageExpired": () => (/* binding */ isPageExpired),
/* harmony export */   "previousState": () => (/* binding */ previousState)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






let previousState

const dataHooks = {
  on: request => {
    previousState = _router__WEBPACK_IMPORTED_MODULE_1__.app.state || ''
    _router__WEBPACK_IMPORTED_MODULE_1__.app._setState('Loading')
    return execProvider(request)
  },
  before: request => {
    return execProvider(request)
  },
  after: request => {
    try {
      execProvider(request, true)
    } catch (e) {
      // for now we fail silently
    }
    return Promise.resolve()
  },
}

const execProvider = (request, emitProvided) => {
  const route = request.route
  const provider = route.provider
  const expires = route.cache ? route.cache * 1000 : 0
  const params = addPersistData(request)
  return provider.request(request.page, { ...params }).then(() => {
    request.page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires] = Date.now() + expires
    if (emitProvided) {
      (0,_emit__WEBPACK_IMPORTED_MODULE_3__["default"])(request.page, 'dataProvided')
    }
  })
}

const addPersistData = ({ page, route, hash, register = new Map() }) => {
  const urlValues = (0,_route__WEBPACK_IMPORTED_MODULE_2__.getValuesFromHash)(hash, route.path)
  const queryParams = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getQueryStringParams)(hash)
  const pageData = new Map([...urlValues, ...register])
  const params = {}

  // make dynamic url data available to the page
  // as instance properties
  for (let [name, value] of pageData) {
    params[name] = value
  }

  if (queryParams) {
    params[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.queryParams] = queryParams
  }

  // check navigation register for persistent data
  if (register.size) {
    const obj = {}
    for (let [k, v] of register) {
      obj[k] = v
    }
    page.persist = obj
  }

  // make url data and persist data available
  // via params property
  page.params = params
  ;(0,_emit__WEBPACK_IMPORTED_MODULE_3__["default"])(page, ['urlParams'], params)

  return params
}

/**
 * Test if page passed cache-time
 * @param page
 * @returns {boolean}
 */
const isPageExpired = page => {
  if (!page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires]) {
    return false
  }

  const expires = page[_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.expires]
  const now = Date.now()

  return now >= expires
}

const hasProvider = path => {
  if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(path)) {
    const record = _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(path)
    return !!record.provider
  }
  return false
}

const getProvider = route => {
  // @todo: fix, route already is passed in
  if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(route.path)) {
    const { provider } = _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(route.path)
    return {
      type: provider.type,
      provider: provider.request,
    }
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/regex.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasLookupId": () => (/* binding */ hasLookupId),
/* harmony export */   "hasRegex": () => (/* binding */ hasRegex),
/* harmony export */   "isNamedGroup": () => (/* binding */ isNamedGroup),
/* harmony export */   "isWildcard": () => (/* binding */ isWildcard),
/* harmony export */   "stripRegex": () => (/* binding */ stripRegex)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const hasRegex = /\{\/(.*?)\/([igm]{0,3})\}/g
const isWildcard = /^[!*$]$/
const hasLookupId = /\/:\w+?@@([0-9]+?)@@/
const isNamedGroup = /^\/:/

/**
 * Test if a route is part regular expressed
 * and replace it for a simple character
 * @param route
 * @returns {*}
 */
const stripRegex = (route, char = 'R') => {
  // if route is part regular expressed we replace
  // the regular expression for a character to
  // simplify floor calculation and backtracking
  if (hasRegex.test(route)) {
    route = route.replace(hasRegex, char)
  }
  return route
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/register.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/register.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRegister": () => (/* binding */ createRegister)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Create a local request register
 * @param flags
 * @returns {Map<any, any>}
 */
const createRegister = flags => {
  const reg = new Map()
  // store user defined and router
  // defined flags in register
  ;[...Object.keys(flags), ...Object.getOwnPropertySymbols(flags)].forEach(key => {
    reg.set(key, flags[key])
  })
  return reg
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/route.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createRequest": () => (/* binding */ createRequest),
/* harmony export */   "createRoute": () => (/* binding */ createRoute),
/* harmony export */   "getFloor": () => (/* binding */ getFloor),
/* harmony export */   "getHashByName": () => (/* binding */ getHashByName),
/* harmony export */   "getOption": () => (/* binding */ getOption),
/* harmony export */   "getRouteByHash": () => (/* binding */ getRouteByHash),
/* harmony export */   "getValuesFromHash": () => (/* binding */ getValuesFromHash),
/* harmony export */   "keepActivePageAlive": () => (/* binding */ keepActivePageAlive)
/* harmony export */ });
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _model_Request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../model/Request */ "./node_modules/@lightningjs/sdk/src/Router/model/Request.js");
/* harmony import */ var _model_Route__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../model/Route */ "./node_modules/@lightningjs/sdk/src/Router/model/Route.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Simple route length calculation
 * @param route {string}
 * @returns {number} - floor
 */
const getFloor = route => {
  return (0,_regex__WEBPACK_IMPORTED_MODULE_0__.stripRegex)(route).split('/').length
}

/**
 * return all stored routes that live on the same floor
 * @param floor
 * @returns {Array}
 */
const getRoutesByFloor = floor => {
  const matches = []
  // simple filter of level candidates
  for (let [route] of _router__WEBPACK_IMPORTED_MODULE_1__.routes.entries()) {
    if (getFloor(route) === floor) {
      matches.push(route)
    }
  }
  return matches
}

/**
 * return a matching route by provided hash
 * hash: home/browse/12 will match:
 * route: home/browse/:categoryId
 * @param hash {string}
 * @returns {boolean|{}} - route
 */
const getRouteByHash = hash => {
  // @todo: clean up on handleHash
  hash = hash.replace(/^#/, '')

  const getUrlParts = /(\/?:?[^/]+)/g
  // grab possible candidates from stored routes
  const candidates = getRoutesByFloor(getFloor(hash))
  // break hash down in chunks
  const hashParts = hash.match(getUrlParts) || []

  // to simplify the route matching and prevent look around
  // in our getUrlParts regex we get the regex part from
  // route candidate and store them so that we can reference
  // them when we perform the actual regex against hash
  let regexStore = []

  let matches = candidates.filter(route => {
    let isMatching = true
    // replace regex in route with lookup id => @@{storeId}@@
    if (_regex__WEBPACK_IMPORTED_MODULE_0__.hasRegex.test(route)) {
      const regMatches = route.match(_regex__WEBPACK_IMPORTED_MODULE_0__.hasRegex)
      if (regMatches && regMatches.length) {
        route = regMatches.reduce((fullRoute, regex) => {
          const lookupId = regexStore.length
          fullRoute = fullRoute.replace(regex, `@@${lookupId}@@`)
          regexStore.push(regex.substring(1, regex.length - 1))
          return fullRoute
        }, route)
      }
    }

    const routeParts = route.match(getUrlParts) || []

    for (let i = 0, j = routeParts.length; i < j; i++) {
      const routePart = routeParts[i]
      const hashPart = hashParts[i]

      // Since we support catch-all and regex driven name groups
      // we first test for regex lookup id and see if the regex
      // matches the value from the hash
      if (_regex__WEBPACK_IMPORTED_MODULE_0__.hasLookupId.test(routePart)) {
        const routeMatches = _regex__WEBPACK_IMPORTED_MODULE_0__.hasLookupId.exec(routePart)
        const storeId = routeMatches[1]
        const routeRegex = regexStore[storeId]

        // split regex and modifiers so we can use both
        // to create a new RegExp
        // eslint-disable-next-line
                const regMatches = /\/([^\/]+)\/([igm]{0,3})/.exec(routeRegex)

        if (regMatches && regMatches.length) {
          const expression = regMatches[1]
          const modifiers = regMatches[2]

          const regex = new RegExp(`^/${expression}$`, modifiers)

          if (!regex.test(hashPart)) {
            isMatching = false
          }
        }
      } else if (_regex__WEBPACK_IMPORTED_MODULE_0__.isNamedGroup.test(routePart)) {
        // we kindly skip namedGroups because this is dynamic
        // we only need to the static and regex drive parts
        continue
      } else if (hashPart && routePart.toLowerCase() !== hashPart.toLowerCase()) {
        isMatching = false
      }
    }
    return isMatching
  })

  if (matches.length) {
    if (matches.indexOf(hash) !== -1) {
      const match = matches[matches.indexOf(hash)]
      return _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(match)
    } else {
      // we give prio to static routes over dynamic
      matches = matches.sort(a => {
        return _regex__WEBPACK_IMPORTED_MODULE_0__.isNamedGroup.test(a) ? -1 : 1
      })
      // would be strange if this fails
      // but still we test
      if ((0,_router__WEBPACK_IMPORTED_MODULE_1__.routeExists)(matches[0])) {
        return _router__WEBPACK_IMPORTED_MODULE_1__.routes.get(matches[0])
      }
    }
  }
  return false
}

const getValuesFromHash = (hash = '', path) => {
  // replace the regex definition from the route because
  // we already did the matching part
  path = (0,_regex__WEBPACK_IMPORTED_MODULE_0__.stripRegex)(path, '')

  const getUrlParts = /(\/?:?[\w%\s:.-]+)/g
  const hashParts = hash.match(getUrlParts) || []
  const routeParts = path.match(getUrlParts) || []
  const getNamedGroup = /^\/:([\w-]+)\/?/

  return routeParts.reduce((storage, value, index) => {
    const match = getNamedGroup.exec(value)
    if (match && match.length) {
      storage.set(match[1], decodeURIComponent(hashParts[index].replace(/^\//, '')))
    }
    return storage
  }, new Map())
}

const getOption = (stack, prop) => {
  // eslint-disable-next-line
    if(stack && stack.hasOwnProperty(prop)){
    return stack[prop]
  }
  // we explicitly return undefined since we're testing
  // for explicit test values
}

/**
 * create and return new Route instance
 * @param config
 */
const createRoute = config => {
  // we need to provide a bit of additional logic
  // for the bootComponent
  if (config.path === '$') {
    let options = {
      preventStorage: true,
    }
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.isObject)(config.options)) {
      options = {
        ...config.options,
        ...options,
      }
    }
    config.options = options
    // if configured add reference to bootRequest
    // as router after provider
    if (_router__WEBPACK_IMPORTED_MODULE_1__.bootRequest) {
      config.after = _router__WEBPACK_IMPORTED_MODULE_1__.bootRequest
    }
  }
  return new _model_Route__WEBPACK_IMPORTED_MODULE_3__["default"](config)
}

/**
 * Create a new Router request object
 * @param url
 * @param args
 * @param store
 * @returns {*}
 */
const createRequest = (url, args, store) => {
  return new _model_Request__WEBPACK_IMPORTED_MODULE_2__["default"](url, args, store)
}

const getHashByName = obj => {
  if (!obj.to && !obj.name) {
    return false
  }
  const route = getRouteByName(obj.to || obj.name)
  const hasDynamicGroup = /\/:([\w-]+)\/?/
  let hash = route

  // if route contains dynamic group
  // we replace them with the provided params
  if (hasDynamicGroup.test(route)) {
    if (obj.params) {
      const keys = Object.keys(obj.params)
      hash = keys.reduce((acc, key) => {
        return acc.replace(`:${key}`, obj.params[key])
      }, route)
    }
    if (obj.query) {
      return `${hash}${(0,_helpers__WEBPACK_IMPORTED_MODULE_4__.objectToQueryString)(obj.query)}`
    }
  }
  return hash
}

const getRouteByName = name => {
  for (let [path, route] of _router__WEBPACK_IMPORTED_MODULE_1__.routes.entries()) {
    if (route.name === name) {
      return path
    }
  }
  return false
}

const keepActivePageAlive = (route, request) => {
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_4__.isString)(route)) {
    const routes = (0,_router__WEBPACK_IMPORTED_MODULE_1__.getRoutes)()
    if (routes.has(route)) {
      route = routes.get(route)
    } else {
      return false
    }
  }

  const register = request.register
  const routeOptions = route.options

  if (register.has('keepAlive')) {
    return register.get('keepAlive')
  } else if (routeOptions && routeOptions.keepAlive) {
    return routeOptions.keepAlive
  }

  return false
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/router.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterEachRoute": () => (/* binding */ afterEachRoute),
/* harmony export */   "app": () => (/* binding */ app),
/* harmony export */   "application": () => (/* binding */ application),
/* harmony export */   "beforeEachRoute": () => (/* binding */ beforeEachRoute),
/* harmony export */   "bootRequest": () => (/* binding */ bootRequest),
/* harmony export */   "bootRouter": () => (/* binding */ bootRouter),
/* harmony export */   "components": () => (/* binding */ components),
/* harmony export */   "getActiveHash": () => (/* binding */ getActiveHash),
/* harmony export */   "getActivePage": () => (/* binding */ getActivePage),
/* harmony export */   "getActiveRoute": () => (/* binding */ getActiveRoute),
/* harmony export */   "getBootRequest": () => (/* binding */ getBootRequest),
/* harmony export */   "getComponent": () => (/* binding */ getComponent),
/* harmony export */   "getLastHash": () => (/* binding */ getLastHash),
/* harmony export */   "getPreviousState": () => (/* binding */ getPreviousState),
/* harmony export */   "getRootHash": () => (/* binding */ getRootHash),
/* harmony export */   "getRouterConfig": () => (/* binding */ getRouterConfig),
/* harmony export */   "getRoutes": () => (/* binding */ getRoutes),
/* harmony export */   "mustUpdateLocationHash": () => (/* binding */ mustUpdateLocationHash),
/* harmony export */   "onRequestResolved": () => (/* binding */ onRequestResolved),
/* harmony export */   "pagesHost": () => (/* binding */ pagesHost),
/* harmony export */   "routeExists": () => (/* binding */ routeExists),
/* harmony export */   "routerConfig": () => (/* binding */ routerConfig),
/* harmony export */   "routes": () => (/* binding */ routes),
/* harmony export */   "setActiveHash": () => (/* binding */ setActiveHash),
/* harmony export */   "setActivePage": () => (/* binding */ setActivePage),
/* harmony export */   "setLastHash": () => (/* binding */ setLastHash),
/* harmony export */   "setPreviousState": () => (/* binding */ setPreviousState),
/* harmony export */   "stage": () => (/* binding */ stage),
/* harmony export */   "storeComponent": () => (/* binding */ storeComponent),
/* harmony export */   "updateHash": () => (/* binding */ updateHash),
/* harmony export */   "widgetsHost": () => (/* binding */ widgetsHost)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index */ "./node_modules/@lightningjs/sdk/src/Router/index.js");
/* harmony import */ var _route__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./route */ "./node_modules/@lightningjs/sdk/src/Router/utils/route.js");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components */ "./node_modules/@lightningjs/sdk/src/Router/utils/components.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _regex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./regex */ "./node_modules/@lightningjs/sdk/src/Router/utils/regex.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/* harmony import */ var _widgets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./widgets */ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js");
/* harmony import */ var _history__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./history */ "./node_modules/@lightningjs/sdk/src/Router/utils/history.js");
/* harmony import */ var _Application__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Application */ "./node_modules/@lightningjs/sdk/src/Application/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/**
 * @type {Lightning.Application}
 */
let application

/**
 * Actual instance of the app
 * @type {Lightning.Component}
 */
let app

/**
 * Component that hosts all routed pages
 * @type {Lightning.Component}
 */
let pagesHost

/**
 * @type {Lightning.Stage}
 */
let stage

/**
 * Platform driven Router configuration
 * @type {Map<string>}
 */
let routerConfig

/**
 * Component that hosts all attached widgets
 * @type {Lightning.Component}
 */
let widgetsHost

/**
 * Hash we point the browser to when we boot the app
 * and there is no deep-link provided
 * @type {string|Function}
 */
let rootHash

/**
 * Boot request will fire before app start
 * can be used to execute some global logic
 * and can be configured
 */
let bootRequest

/**
 * Flag if we need to update the browser location hash.
 * Router can work without.
 * @type {boolean}
 */
let updateHash = true

/**
 * Will be called before a route starts, can be overridden
 * via routes config
 * @param from - route we came from
 * @param to - route we navigate to
 * @returns {Promise<*>}
 */
// eslint-disable-next-line
let beforeEachRoute = async (from, to)=>{
  return true
}

/**
 *  * Will be called after a navigate successfully resolved,
 * can be overridden via routes config
 */
let afterEachRoute = () => {}

/**
 * All configured routes
 * @type {Map<string, object>}
 */
let routes = new Map()

/**
 * Store all page components per route
 * @type {Map<string, object>}
 */
let components = new Map()

/**
 * Flag if router has been initialised
 * @type {boolean}
 */
let initialised = false

/**
 * Current page being rendered on screen
 * @type {null}
 */
let activePage = null
let activeHash
let activeRoute

/**
 *  During the process of a navigation request a new
 *  request can start, to prevent unwanted behaviour
 *  the navigate()-method stores the last accepted hash
 *  so we can invalidate any prior requests
 */
let lastAcceptedHash

/**
 * With on()-data providing behaviour the Router forced the App
 * in a Loading state. When the data-provider resolves we want to
 * change the state back to where we came from
 */
let previousState

const mixin = app => {
  // by default the Router Baseclass provides the component
  // reference in which we store our pages
  if (app.pages) {
    pagesHost = app.pages.childList
  }
  // if the app is using widgets we grab refs
  // and hide all the widgets
  if (app.widgets && app.widgets.children) {
    widgetsHost = app.widgets.childList
    // hide all widgets on boot
    widgetsHost.forEach(w => (w.visible = false))
  }
  app._handleBack = e => {
    (0,_index__WEBPACK_IMPORTED_MODULE_1__.step)(-1)
    e.preventDefault()
  }
}

const bootRouter = (config, instance) => {
  let { appInstance, routes } = config

  // if instance is provided and it's and Lightning Component instance
  if (instance && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(instance)) {
    app = instance
  }
  if (!app) {
    app = appInstance || _Application__WEBPACK_IMPORTED_MODULE_9__.AppInstance
  }

  application = app.application
  pagesHost = application.childList
  stage = app.stage
  routerConfig = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.getConfigMap)()

  mixin(app)

  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isArray)(routes)) {
    setup(config)
  } else if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(routes)) {
    console.warn('[Router]: Calling Router.route() directly is deprecated.')
    console.warn(
      'Use object config: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration'
    )
  }
}

const setup = config => {
  if (!initialised) {
    init(config)
  }
  config.routes.forEach(r => {
    const path = (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.cleanHash)(r.path)
    if (!routeExists(path)) {
      const route = (0,_route__WEBPACK_IMPORTED_MODULE_2__.createRoute)(r)
      routes.set(path, route)
      // if route has a configured component property
      // we store it in a different map to simplify
      // the creating and destroying per route
      if (route.component) {
        let type = route.component
        if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isComponentConstructor)(type)) {
          if (!routerConfig.get('lazyCreate')) {
            type = (0,_components__WEBPACK_IMPORTED_MODULE_3__.createComponent)(stage, type)
            pagesHost.a(type)
          }
        }
        components.set(path, type)
      }
    } else {
      console.error(`${path} already exists in routes configuration`)
    }
  })
}

const init = config => {
  rootHash = config.root
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.boot)) {
    bootRequest = config.boot
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(config.updateHash)) {
    updateHash = config.updateHash
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.beforeEachRoute)) {
    beforeEachRoute = config.beforeEachRoute
  }
  if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config.afterEachRoute)) {
    afterEachRoute = config.afterEachRoute
  }
  if (config.bootComponent) {
    console.warn(
      '[Router]: Boot Component is now available as a special router: https://rdkcentral.github.io/Lightning-SDK/#/plugins/router/configuration?id=special-routes'
    )
    console.warn(
      '[Router]: setting { bootComponent } property will be deprecated in a future release'
    )
    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isPage)(config.bootComponent)) {
      config.routes.push({
        path: '$',
        component: config.bootComponent,
        // we try to assign the bootRequest as after data-provider
        // so it will behave as any other component
        after: bootRequest || null,
        options: {
          preventStorage: true,
        },
      })
    } else {
      console.error(`[Router]: ${config.bootComponent} is not a valid boot component`)
    }
  }
  initialised = true
}

const storeComponent = (route, type) => {
  if (components.has(route)) {
    components.set(route, type)
  }
}

const getComponent = route => {
  if (components.has(route)) {
    return components.get(route)
  }
  return null
}
/**
 * Test if router needs to update browser location hash
 * @returns {boolean}
 */
const mustUpdateLocationHash = () => {
  if (!routerConfig || !routerConfig.size) {
    return false
  }
  // we need support to either turn change hash off
  // per platform or per app
  const updateConfig = routerConfig.get('updateHash')
  return !(((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(updateConfig) && !updateConfig) || ((0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isBoolean)(updateHash) && !updateHash))
}

/**
 * Will be called when a new navigate() request has completed
 * and has not been expired due to it's async nature
 * @param request
 */
const onRequestResolved = request => {
  const hash = request.hash
  const route = request.route
  const register = request.register
  const page = request.page

  // clean up history if modifier is set
  if ((0,_route__WEBPACK_IMPORTED_MODULE_2__.getOption)(route.options, 'clearHistory')) {
    (0,_history__WEBPACK_IMPORTED_MODULE_8__.setHistory)([])
  } else if (hash && !_regex__WEBPACK_IMPORTED_MODULE_5__.isWildcard.test(route.path)) {
    (0,_history__WEBPACK_IMPORTED_MODULE_8__.updateHistory)(request)
  }

  // we only update the stackLocation if a route
  // is not expired before it resolves
  storeComponent(route.path, page)

  if (request.isSharedInstance || !request.isCreated) {
    (0,_emit__WEBPACK_IMPORTED_MODULE_6__["default"])(page, 'changed')
  } else if (request.isCreated) {
    (0,_emit__WEBPACK_IMPORTED_MODULE_6__["default"])(page, 'mounted')
  }

  // only update widgets if we have a host
  if (widgetsHost) {
    (0,_widgets__WEBPACK_IMPORTED_MODULE_7__.updateWidgets)(route.widgets, page)
  }

  // we want to clean up if there is an
  // active page that is not being shared
  // between current and previous route
  if (getActivePage() && !request.isSharedInstance) {
    cleanUp(activePage, request)
  }

  // provide history object to active page
  if (register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState) && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.isFunction)(page.historyState)) {
    page.historyState(register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.historyState))
  }

  setActivePage(page)

  activeHash = request.hash
  activeRoute = route.path

  // cleanup all cancelled requests
  for (let request of _index__WEBPACK_IMPORTED_MODULE_1__.navigateQueue.values()) {
    if (request.isCancelled && request.hash) {
      _index__WEBPACK_IMPORTED_MODULE_1__.navigateQueue["delete"](request.hash)
    }
  }

  afterEachRoute(request)

  _Log__WEBPACK_IMPORTED_MODULE_4__["default"].info('[route]:', route.path)
  _Log__WEBPACK_IMPORTED_MODULE_4__["default"].info('[hash]:', hash)
}

const cleanUp = (page, request) => {
  const route = activeRoute
  const register = request.register
  const lazyDestroy = routerConfig.get('lazyDestroy')
  const destroyOnBack = routerConfig.get('destroyOnHistoryBack')
  const keepAlive = register.get('keepAlive')
  const isFromHistory = register.get(_helpers__WEBPACK_IMPORTED_MODULE_0__.symbols.backtrack)

  let doCleanup = false

  // if this request is executed due to a step back in history
  // and we have configured to destroy active page when we go back
  // in history or lazyDestory is enabled
  if (isFromHistory && (destroyOnBack || lazyDestroy)) {
    doCleanup = true
  }

  // clean up if lazyDestroy is enabled and the keepAlive flag
  // in navigation register is false
  if (lazyDestroy && !keepAlive) {
    doCleanup = true
  }

  // if the current and new request share the same route blueprint
  if (activeRoute === request.route.path) {
    doCleanup = true
  }

  if (doCleanup) {
    // grab original class constructor if
    // statemachine routed else store constructor
    storeComponent(route, page._routedType || page.constructor)

    // actual remove of page from memory
    pagesHost.remove(page)

    // force texture gc() if configured
    // so we can cleanup textures in the same tick
    if (routerConfig.get('gcOnUnload')) {
      stage.gc()
    }
  } else {
    // If we're not removing the page we need to
    // reset it's properties
    page.patch({
      x: 0,
      y: 0,
      scale: 1,
      alpha: 1,
      visible: false,
    })
  }
}

const getActiveHash = () => {
  return activeHash
}

const setActiveHash = hash => {
  activeHash = hash
}

const setActivePage = page => {
  activePage = page
}

const getActivePage = () => {
  return activePage
}

const getActiveRoute = () => {
  return activeRoute
}

const getLastHash = () => {
  return lastAcceptedHash
}

const setLastHash = hash => {
  lastAcceptedHash = hash
}

const setPreviousState = state => {
  previousState = state
}

const getPreviousState = () => {
  return previousState
}

const routeExists = key => {
  return routes.has(key)
}

const getRootHash = () => {
  return rootHash
}

const getBootRequest = () => {
  return bootRequest
}

const getRouterConfig = () => {
  return routerConfig
}

const getRoutes = () => {
  return routes
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/transition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/transition.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "executeTransition": () => (/* binding */ executeTransition)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transitions */ "./node_modules/@lightningjs/sdk/src/Router/transitions.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * execute transition between new / old page and
 * toggle the defined widgets
 * @todo: platform override default transition
 * @param pageIn
 * @param pageOut
 */
const executeTransition = (pageIn, pageOut = null) => {
  const transition = pageIn.pageTransition || pageIn.easing
  const hasCustomTransitions = !!(pageIn.smoothIn || pageIn.smoothInOut || transition)
  const transitionsDisabled = (0,_router__WEBPACK_IMPORTED_MODULE_0__.getRouterConfig)().get('disableTransitions')

  if (pageIn.easing) {
    console.warn('easing() method is deprecated and will be removed. Use pageTransition()')
  }

  // default behaviour is a visibility toggle
  if (!hasCustomTransitions || transitionsDisabled) {
    pageIn.visible = true
    if (pageOut) {
      pageOut.visible = false
    }
    return Promise.resolve()
  }

  if (transition) {
    let type
    try {
      type = transition.call(pageIn, pageIn, pageOut)
    } catch (e) {
      type = 'crossFade'
    }

    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isPromise)(type)) {
      return type
    }

    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isString)(type)) {
      const fn = _transitions__WEBPACK_IMPORTED_MODULE_2__["default"][type]
      if (fn) {
        return fn(pageIn, pageOut)
      }
    }

    // keep backwards compatible for now
    if (pageIn.smoothIn) {
      // provide a smooth function that resolves itself
      // on transition finish
      const smooth = (p, v, args = {}) => {
        return new Promise(resolve => {
          pageIn.visible = true
          pageIn.setSmooth(p, v, args)
          pageIn.transition(p).on('finish', () => {
            resolve()
          })
        })
      }
      return pageIn.smoothIn({ pageIn, smooth })
    }
  }
  return _transitions__WEBPACK_IMPORTED_MODULE_2__["default"].crossFade(pageIn, pageOut)
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Router/utils/widgets.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "focusWidget": () => (/* binding */ focusWidget),
/* harmony export */   "getActiveWidget": () => (/* binding */ getActiveWidget),
/* harmony export */   "getReferences": () => (/* binding */ getReferences),
/* harmony export */   "handleRemote": () => (/* binding */ handleRemote),
/* harmony export */   "restoreFocus": () => (/* binding */ restoreFocus),
/* harmony export */   "setActiveWidget": () => (/* binding */ setActiveWidget),
/* harmony export */   "updateWidgets": () => (/* binding */ updateWidgets)
/* harmony export */ });
/* harmony import */ var _router__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./router */ "./node_modules/@lightningjs/sdk/src/Router/utils/router.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "./node_modules/@lightningjs/sdk/src/Router/utils/helpers.js");
/* harmony import */ var _emit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./emit */ "./node_modules/@lightningjs/sdk/src/Router/utils/emit.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let activeWidget = null

const getReferences = () => {
  if (!_router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost) {
    return
  }
  return _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.get().reduce((storage, widget) => {
    const key = widget.ref.toLowerCase()
    storage[key] = widget
    return storage
  }, {})
}

/**
 * update the visibility of the available widgets
 * for the current page / route
 * @param page
 */
const updateWidgets = (widgets, page) => {
  // force lowercase lookup
  const configured = (widgets || []).map(ref => ref.toLowerCase())

  _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.forEach(widget => {
    widget.visible = configured.indexOf(widget.ref.toLowerCase()) !== -1
    if (widget.visible) {
      (0,_emit__WEBPACK_IMPORTED_MODULE_2__["default"])(widget, ['activated'], page)
    }
  })
  if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Widgets' && activeWidget && !activeWidget.visible) {
    _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
  }
}

const getWidgetByName = name => {
  name = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.ucfirst)(name)
  return _router__WEBPACK_IMPORTED_MODULE_0__.widgetsHost.getByRef(name) || false
}

/**
 * delegate app focus to a on-screen widget
 * @param name - {string}
 */
const focusWidget = name => {
  const widget = getWidgetByName(name)
  if (widget) {
    setActiveWidget(widget)

    // if app is already in 'Widgets' state we can assume that
    // focus has been delegated from one widget to another so
    // we need to set the new widget reference and trigger a
    // new focus calculation of Lightning's focuspath
    if (_router__WEBPACK_IMPORTED_MODULE_0__.app.state === 'Widgets') {
      _router__WEBPACK_IMPORTED_MODULE_0__.app.reload(activeWidget)
    } else {
      _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('Widgets', [activeWidget])
    }
  }
}

const handleRemote = (type, name) => {
  if (type === 'widget') {
    focusWidget(name)
  } else if (type === 'page') {
    restoreFocus()
  }
}

const restoreFocus = () => {
  activeWidget = null
  _router__WEBPACK_IMPORTED_MODULE_0__.app._setState('')
}

const getActiveWidget = () => {
  return activeWidget
}

const setActiveWidget = instance => {
  activeWidget = instance
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Settings/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Settings/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initSettings": () => (/* binding */ initSettings)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const settings = {}
const subscribers = {}

const initSettings = (appSettings, platformSettings) => {
  settings['app'] = appSettings
  settings['platform'] = platformSettings
  settings['user'] = {}
}

const publish = (key, value) => {
  subscribers[key] && subscribers[key].forEach(subscriber => subscriber(value))
}

const dotGrab = (obj = {}, key) => {
  if (obj === null) return undefined
  const keys = key.split('.')
  for (let i = 0; i < keys.length; i++) {
    obj = obj[keys[i]] = obj[keys[i]] !== undefined ? obj[keys[i]] : {}
  }
  return typeof obj === 'object' && obj !== null ? (Object.keys(obj).length ? obj : undefined) : obj
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(type, key, fallback = undefined) {
    const val = dotGrab(settings[type], key)
    return val !== undefined ? val : fallback
  },
  has(type, key) {
    return !!this.get(type, key)
  },
  set(key, value) {
    settings['user'][key] = value
    publish(key, value)
  },
  subscribe(key, callback) {
    subscribers[key] = subscribers[key] || []
    subscribers[key].push(callback)
  },
  unsubscribe(key, callback) {
    if (callback) {
      const index = subscribers[key] && subscribers[key].findIndex(cb => cb === callback)
      index > -1 && subscribers[key].splice(index, 1)
    } else {
      if (key in subscribers) {
        subscribers[key] = []
      }
    }
  },
  clearSubscribers() {
    for (const key of Object.getOwnPropertyNames(subscribers)) {
      delete subscribers[key]
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Storage/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Storage/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initStorage": () => (/* binding */ initStorage)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var localCookie_module_localCookie_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! localCookie/module/localCookie.js */ "./node_modules/localCookie/module/localCookie.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




let namespace
let lc

const initStorage = () => {
  namespace = _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'id')
  // todo: pass options (for example to force the use of cookies)
  lc = new localCookie_module_localCookie_js__WEBPACK_IMPORTED_MODULE_1__["default"]()
}

const namespacedKey = key => (namespace ? [namespace, key].join('.') : key)

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  get(key) {
    try {
      return JSON.parse(lc.getItem(namespacedKey(key)))
    } catch (e) {
      return null
    }
  },
  set(key, value) {
    try {
      lc.setItem(namespacedKey(key), JSON.stringify(value))
      return true
    } catch (e) {
      return false
    }
  },
  remove(key) {
    lc.removeItem(namespacedKey(key))
  },
  clear() {
    if (namespace) {
      lc.keys().forEach(key => {
        // remove the item if in the namespace
        key.indexOf(namespace + '.') === 0 ? lc.removeItem(key) : null
      })
    } else {
      lc.clear()
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/TV/defaults.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/TV/defaults.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "channels": () => (/* binding */ channels),
/* harmony export */   "randomChannel": () => (/* binding */ randomChannel)
/* harmony export */ });
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const defaultChannels = [
  {
    number: 1,
    name: 'Metro News 1',
    description: 'New York Cable News Channel',
    entitled: true,
    program: {
      title: 'The Morning Show',
      description: "New York's best morning show",
      startTime: new Date(new Date() - 60 * 5 * 1000).toUTCString(), // started 5 minutes ago
      duration: 60 * 30, // 30 minutes
      ageRating: 0,
    },
  },
  {
    number: 2,
    name: 'MTV',
    description: 'Music Television',
    entitled: true,
    program: {
      title: 'Beavis and Butthead',
      description: 'American adult animated sitcom created by Mike Judge',
      startTime: new Date(new Date() - 60 * 20 * 1000).toUTCString(), // started 20 minutes ago
      duration: 60 * 45, // 45 minutes
      ageRating: 18,
    },
  },
  {
    number: 3,
    name: 'NBC',
    description: 'NBC TV Network',
    entitled: false,
    program: {
      title: 'The Tonight Show Starring Jimmy Fallon',
      description: 'Late-night talk show hosted by Jimmy Fallon on NBC',
      startTime: new Date(new Date() - 60 * 10 * 1000).toUTCString(), // started 10 minutes ago
      duration: 60 * 60, // 1 hour
      ageRating: 10,
    },
  },
]

const channels = () => _Settings__WEBPACK_IMPORTED_MODULE_0__["default"].get('platform', 'tv', defaultChannels)

const randomChannel = () => channels()[~~(channels.length * Math.random())]


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/TV/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/TV/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initTV": () => (/* binding */ initTV)
/* harmony export */ });
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaults */ "./node_modules/@lightningjs/sdk/src/TV/defaults.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





let currentChannel
const callbacks = {}

const emit = (event, ...args) => {
  callbacks[event] &&
    callbacks[event].forEach(cb => {
      cb.apply(null, args)
    })
}

// local mock methods
let methods = {
  getChannel() {
    if (!currentChannel) currentChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.randomChannel)()
    return new Promise((resolve, reject) => {
      if (currentChannel) {
        const channel = { ...currentChannel }
        delete channel.program
        resolve(channel)
      } else {
        reject('No channel found')
      }
    })
  },
  getProgram() {
    if (!currentChannel) currentChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.randomChannel)()
    return new Promise((resolve, reject) => {
      currentChannel.program ? resolve(currentChannel.program) : reject('No program found')
    })
  },
  setChannel(number) {
    return new Promise((resolve, reject) => {
      if (number) {
        const newChannel = (0,_defaults__WEBPACK_IMPORTED_MODULE_1__.channels)().find(c => c.number === number)
        if (newChannel) {
          currentChannel = newChannel
          const channel = { ...currentChannel }
          delete channel.program
          emit('channelChange', channel)
          resolve(channel)
        } else {
          reject('Channel not found')
        }
      } else {
        reject('No channel number supplied')
      }
    })
  },
}

const initTV = config => {
  methods = {}
  if (config.getChannel && typeof config.getChannel === 'function') {
    methods.getChannel = config.getChannel
  }
  if (config.getProgram && typeof config.getProgram === 'function') {
    methods.getProgram = config.getProgram
  }
  if (config.setChannel && typeof config.setChannel === 'function') {
    methods.setChannel = config.setChannel
  }
  if (config.emit && typeof config.emit === 'function') {
    config.emit(emit)
  }
}

// public API
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  channel(number = null) {
    return new Promise((resolve, reject) => {
      try {
        // call setChannel when number argument is passed, otherwise getChannel
        methods[number ? 'setChannel' : 'getChannel'](number)
          .then(channel => {
            // to do: ensure consistent formatting of channel info here?
            resolve(channel)
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  program() {
    return new Promise((resolve, reject) => {
      try {
        methods
          .getProgram()
          .then(program => {
            // to do: ensure consistent formatting of program info here?
            resolve(program)
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  entitled() {
    return new Promise((resolve, reject) => {
      try {
        methods
          .getChannel()
          .then(channel => {
            'entitled' in channel ? resolve(!!channel.entitled) : reject()
          })
          .catch(reject)
      } catch (e) {
        reject(e)
      }
    })
  },
  addEventListener(event, cb) {
    if (typeof cb === 'function') {
      callbacks[event] = callbacks[event] || []
      callbacks[event].push(cb)
    } else {
      _Log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Please provide a function as a callback')
    }
  },
  removeEventListener(event, cb = false) {
    if (callbacks[event] && callbacks[event].length) {
      callbacks[event] = cb ? callbacks[event].filter(_cb => _cb === cb) : []
    }
  },
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/Utils/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/Utils/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cleanUpPathName": () => (/* binding */ cleanUpPathName),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "ensureUrlWithProtocol": () => (/* binding */ ensureUrlWithProtocol),
/* harmony export */   "initUtils": () => (/* binding */ initUtils),
/* harmony export */   "makeFullStaticPath": () => (/* binding */ makeFullStaticPath)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let basePath
let proxyUrl

const initUtils = config => {
  basePath = ensureUrlWithProtocol(makeFullStaticPath(window.location.pathname, config.path || '/'))

  if (config.proxyUrl) {
    proxyUrl = ensureUrlWithProtocol(config.proxyUrl)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  asset(relPath) {
    return basePath + relPath
  },
  proxyUrl(url, options = {}) {
    return proxyUrl ? proxyUrl + '?' + makeQueryString(url, options) : url
  },
  makeQueryString() {
    return makeQueryString(...arguments)
  },
  // since imageworkers don't work without protocol
  ensureUrlWithProtocol() {
    return ensureUrlWithProtocol(...arguments)
  },
});

const ensureUrlWithProtocol = url => {
  if (/^\/\//.test(url)) {
    return window.location.protocol + url
  }
  if (!/^(?:https?:)/i.test(url)) {
    return window.location.origin + url
  }
  return url
}

const makeFullStaticPath = (pathname = '/', path) => {
  // ensure path has traling slash
  path = path.charAt(path.length - 1) !== '/' ? path + '/' : path

  // if path is URL, we assume it's already the full static path, so we just return it
  if (/^(?:https?:)?(?:\/\/)/.test(path)) {
    return path
  }

  if (path.charAt(0) === '/') {
    return path
  } else {
    // cleanup the pathname (i.e. remove possible index.html)
    pathname = cleanUpPathName(pathname)

    // remove possible leading dot from path
    path = path.charAt(0) === '.' ? path.substr(1) : path
    // ensure path has leading slash
    path = path.charAt(0) !== '/' ? '/' + path : path
    return pathname + path
  }
}

const cleanUpPathName = pathname => {
  if (pathname.slice(-1) === '/') return pathname.slice(0, -1)
  const parts = pathname.split('/')
  if (parts[parts.length - 1].indexOf('.') > -1) parts.pop()
  return parts.join('/')
}

const makeQueryString = (url, options = {}, type = 'url') => {
  // add operator as an option
  options.operator = 'metrological' // Todo: make this configurable (via url?)
  // add type (= url or qr) as an option, with url as the value
  options[type] = url

  return Object.keys(options)
    .map(key => {
      return encodeURIComponent(key) + '=' + encodeURIComponent('' + options[key])
    })
    .join('&')
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VersionLabel/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VersionLabel/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VersionLabel)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class VersionLabel extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      rect: true,
      color: 0xbb0078ac,
      h: 40,
      w: 100,
      x: w => w - 50,
      y: h => h - 50,
      mount: 1,
      Text: {
        w: w => w,
        h: h => h,
        y: 5,
        x: 20,
        text: {
          fontSize: 22,
          lineHeight: 26,
        },
      },
    }
  }

  _firstActive() {
    this.tag('Text').text = `APP - v${this.version}\nSDK - v${this.sdkVersion}`
    this.tag('Text').loadTexture()
    this.w = this.tag('Text').renderWidth + 40
    this.h = this.tag('Text').renderHeight + 5
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VideoTexture)
/* harmony export */ });
/* harmony import */ var _Lightning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Lightning */ "./node_modules/@lightningjs/sdk/src/Lightning/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class VideoTexture extends _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].Component {
  static _template() {
    return {
      Video: {
        alpha: 1,
        visible: false,
        pivot: 0.5,
        texture: { type: _Lightning__WEBPACK_IMPORTED_MODULE_0__["default"].textures.StaticTexture, options: {} },
      },
    }
  }

  set videoEl(v) {
    this._videoEl = v
  }

  get videoEl() {
    return this._videoEl
  }

  get videoView() {
    return this.tag('Video')
  }

  get videoTexture() {
    return this.videoView.texture
  }

  get isVisible() {
    return this.videoView.alpha === 1 && this.videoView.visible === true
  }

  _init() {
    this._createVideoTexture()
  }

  _createVideoTexture() {
    const stage = this.stage

    const gl = stage.gl
    const glTexture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, glTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    this.videoTexture.options = { source: glTexture, w: this.videoEl.width, h: this.videoEl.height }

    this.videoView.w = this.videoEl.width / this.stage.getRenderPrecision()
    this.videoView.h = this.videoEl.height / this.stage.getRenderPrecision()
  }

  start() {
    const stage = this.stage
    this._lastTime = 0
    if (!this._updateVideoTexture) {
      this._updateVideoTexture = () => {
        if (this.videoTexture.options.source && this.videoEl.videoWidth && this.active) {
          const gl = stage.gl

          const currentTime = new Date().getTime()
          const getVideoPlaybackQuality = this.videoEl.getVideoPlaybackQuality()

          // When BR2_PACKAGE_GST1_PLUGINS_BAD_PLUGIN_DEBUGUTILS is not set in WPE, webkitDecodedFrameCount will not be available.
          // We'll fallback to fixed 30fps in this case.
          // As 'webkitDecodedFrameCount' is about to deprecate, check for the 'totalVideoFrames'
          const frameCount = getVideoPlaybackQuality
            ? getVideoPlaybackQuality.totalVideoFrames
            : this.videoEl.webkitDecodedFrameCount

          const mustUpdate = frameCount
            ? this._lastFrame !== frameCount
            : this._lastTime < currentTime - 30

          if (mustUpdate) {
            this._lastTime = currentTime
            this._lastFrame = frameCount
            try {
              gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
              gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false)
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.videoEl)
              this._lastFrame = this.videoEl.webkitDecodedFrameCount
              this.videoView.visible = true

              this.videoTexture.options.w = this.videoEl.width
              this.videoTexture.options.h = this.videoEl.height
              const expectedAspectRatio = this.videoView.w / this.videoView.h
              const realAspectRatio = this.videoEl.width / this.videoEl.height

              if (expectedAspectRatio > realAspectRatio) {
                this.videoView.scaleX = realAspectRatio / expectedAspectRatio
                this.videoView.scaleY = 1
              } else {
                this.videoView.scaleY = expectedAspectRatio / realAspectRatio
                this.videoView.scaleX = 1
              }
            } catch (e) {
              _Log__WEBPACK_IMPORTED_MODULE_1__["default"].error('texImage2d video', e)
              this.stop()
            }
            this.videoTexture.source.forceRenderUpdate()
          }
        }
      }
    }
    if (!this._updatingVideoTexture) {
      stage.on('frameStart', this._updateVideoTexture)
      this._updatingVideoTexture = true
    }
  }

  stop() {
    const stage = this.stage
    stage.removeListener('frameStart', this._updateVideoTexture)
    this._updatingVideoTexture = false
    this.videoView.visible = false

    if (this.videoTexture.options.source) {
      const gl = stage.gl
      gl.bindTexture(gl.TEXTURE_2D, this.videoTexture.options.source)
      gl.clearColor(0, 0, 0, 1)
      gl.clear(gl.COLOR_BUFFER_BIT)
    }
  }

  position(top, left) {
    this.videoView.patch({
      smooth: {
        x: left,
        y: top,
      },
    })
  }

  size(width, height) {
    this.videoView.patch({
      smooth: {
        w: width,
        h: height,
      },
    })
  }

  show() {
    this.videoView.setSmooth('alpha', 1)
  }

  hide() {
    this.videoView.setSmooth('alpha', 0)
  }
}


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  abort: 'Abort',
  canplay: 'CanPlay',
  canplaythrough: 'CanPlayThrough',
  durationchange: 'DurationChange',
  emptied: 'Emptied',
  encrypted: 'Encrypted',
  ended: 'Ended',
  error: 'Error',
  interruptbegin: 'InterruptBegin',
  interruptend: 'InterruptEnd',
  loadeddata: 'LoadedData',
  loadedmetadata: 'LoadedMetadata',
  loadstart: 'LoadStart',
  pause: 'Pause',
  play: 'Play',
  playing: 'Playing',
  progress: 'Progress',
  ratechange: 'Ratechange',
  seeked: 'Seeked',
  seeking: 'Seeking',
  stalled: 'Stalled',
  // suspend: 'Suspend', // this one is called a looooot for some videos
  timeupdate: 'TimeUpdate',
  volumechange: 'VolumeChange',
  waiting: 'Waiting',
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/VideoPlayer/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "initVideoPlayer": () => (/* binding */ initVideoPlayer),
/* harmony export */   "mediaUrl": () => (/* binding */ mediaUrl),
/* harmony export */   "setUpVideoTexture": () => (/* binding */ setUpVideoTexture),
/* harmony export */   "setupVideoTag": () => (/* binding */ setupVideoTag)
/* harmony export */ });
/* harmony import */ var _michieljs_execute_as_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @michieljs/execute-as-promise */ "./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js");
/* harmony import */ var _Metrics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Metrics */ "./node_modules/@lightningjs/sdk/src/Metrics/index.js");
/* harmony import */ var _Log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Log */ "./node_modules/@lightningjs/sdk/src/Log/index.js");
/* harmony import */ var _Ads__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Ads */ "./node_modules/@lightningjs/sdk/src/Ads/index.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/events.js");
/* harmony import */ var _helpers_autoSetupMixin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/autoSetupMixin */ "./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js");
/* harmony import */ var _helpers_easeExecution__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/easeExecution */ "./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js");
/* harmony import */ var _Launch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Launch */ "./node_modules/@lightningjs/sdk/src/Launch/index.js");
/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Settings */ "./node_modules/@lightningjs/sdk/src/Settings/index.js");
/* harmony import */ var _VideoTexture__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./VideoTexture */ "./node_modules/@lightningjs/sdk/src/VideoPlayer/VideoTexture.js");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














let mediaUrl = url => url
let videoEl
let videoTexture
let metrics
let consumer
let precision = 1
let textureMode = false

const initVideoPlayer = config => {
  if (config.mediaUrl) {
    mediaUrl = config.mediaUrl
  }
}

// todo: add this in a 'Registry' plugin
// to be able to always clean this up on app close
let eventHandlers = {}

const state = {
  adsEnabled: false,
  playing: false,
  _playingAds: false,
  get playingAds() {
    return this._playingAds
  },
  set playingAds(val) {
    if (this._playingAds !== val) {
      this._playingAds = val
      fireOnConsumer(val === true ? 'AdStart' : 'AdEnd')
    }
  },
  skipTime: false,
  playAfterSeek: null,
}

const hooks = {
  play() {
    state.playing = true
  },
  pause() {
    state.playing = false
  },
  seeked() {
    state.playAfterSeek === true && videoPlayerPlugin.play()
    state.playAfterSeek = null
  },
  abort() {
    deregisterEventListeners()
  },
}

const withPrecision = val => Math.round(precision * val) + 'px'

const fireOnConsumer = (event, args) => {
  if (consumer) {
    consumer.fire('$videoPlayer' + event, args, videoEl.currentTime)
    consumer.fire('$videoPlayerEvent', event, args, videoEl.currentTime)
  }
}

const fireHook = (event, args) => {
  hooks[event] && typeof hooks[event] === 'function' && hooks[event].call(null, event, args)
}

let customLoader = null
let customUnloader = null

const loader = (url, videoEl, config) => {
  return customLoader && typeof customLoader === 'function'
    ? customLoader(url, videoEl, config)
    : new Promise(resolve => {
        url = mediaUrl(url)
        videoEl.setAttribute('src', url)
        videoEl.load()
        resolve()
      })
}

const unloader = videoEl => {
  return customUnloader && typeof customUnloader === 'function'
    ? customUnloader(videoEl)
    : new Promise(resolve => {
        videoEl.removeAttribute('src')
        videoEl.load()
        resolve()
      })
}

const setupVideoTag = () => {
  const videoEls = document.getElementsByTagName('video')
  if (videoEls && videoEls.length) {
    return videoEls[0]
  } else {
    const videoEl = document.createElement('video')
    const platformSettingsWidth = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'width')
      ? _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'width')
      : 1920
    const platformSettingsHeight = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'height')
      ? _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'height')
      : 1080
    videoEl.setAttribute('id', 'video-player')
    videoEl.setAttribute('width', withPrecision(platformSettingsWidth))
    videoEl.setAttribute('height', withPrecision(platformSettingsHeight))
    videoEl.style.position = 'absolute'
    videoEl.style.zIndex = '1'
    videoEl.style.display = 'none'
    videoEl.style.visibility = 'hidden'
    videoEl.style.top = withPrecision(0)
    videoEl.style.left = withPrecision(0)
    videoEl.style.width = withPrecision(platformSettingsWidth)
    videoEl.style.height = withPrecision(platformSettingsHeight)
    document.body.appendChild(videoEl)
    return videoEl
  }
}

const setUpVideoTexture = () => {
  if (!_Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.tag('VideoTexture')) {
    const el = _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage.c({
      type: _VideoTexture__WEBPACK_IMPORTED_MODULE_9__["default"],
      ref: 'VideoTexture',
      zIndex: 0,
      videoEl,
    })
    _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.childList.addAt(el, 0)
  }
  return _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.tag('VideoTexture')
}

const registerEventListeners = () => {
  _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('VideoPlayer', 'Registering event listeners')
  Object.keys(_events__WEBPACK_IMPORTED_MODULE_4__["default"]).forEach(event => {
    const handler = e => {
      // Fire a metric for each event (if it exists on the metrics object)
      if (metrics && metrics[event] && typeof metrics[event] === 'function') {
        metrics[event]({ currentTime: videoEl.currentTime })
      }
      // fire an internal hook
      fireHook(event, { videoElement: videoEl, event: e })

      // fire the event (with human friendly event name) to the consumer of the VideoPlayer
      fireOnConsumer(_events__WEBPACK_IMPORTED_MODULE_4__["default"][event], { videoElement: videoEl, event: e })
    }

    eventHandlers[event] = handler
    videoEl.addEventListener(event, handler)
  })
}

const deregisterEventListeners = () => {
  _Log__WEBPACK_IMPORTED_MODULE_2__["default"].info('VideoPlayer', 'Deregistering event listeners')
  Object.keys(eventHandlers).forEach(event => {
    videoEl.removeEventListener(event, eventHandlers[event])
  })
  eventHandlers = {}
}

const videoPlayerPlugin = {
  consumer(component) {
    consumer = component
  },

  loader(loaderFn) {
    customLoader = loaderFn
  },

  unloader(unloaderFn) {
    customUnloader = unloaderFn
  },

  position(top = 0, left = 0) {
    videoEl.style.left = withPrecision(left)
    videoEl.style.top = withPrecision(top)
    if (textureMode === true) {
      videoTexture.position(top, left)
    }
  },

  size(width = 1920, height = 1080) {
    videoEl.style.width = withPrecision(width)
    videoEl.style.height = withPrecision(height)
    videoEl.width = parseFloat(videoEl.style.width)
    videoEl.height = parseFloat(videoEl.style.height)
    if (textureMode === true) {
      videoTexture.size(width, height)
    }
  },

  area(top = 0, right = 1920, bottom = 1080, left = 0) {
    this.position(top, left)
    this.size(right - left, bottom - top)
  },

  open(url, config = {}) {
    if (!this.canInteract) return
    metrics = _Metrics__WEBPACK_IMPORTED_MODULE_1__["default"].media(url)

    this.hide()
    deregisterEventListeners()

    if (this.src == url) {
      this.clear().then(this.open(url, config))
    } else {
      const adConfig = { enabled: state.adsEnabled, duration: 300 }
      if (config.videoId) {
        adConfig.caid = config.videoId
      }
      _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].get(adConfig, consumer).then(ads => {
        state.playingAds = true
        ads.prerolls().then(() => {
          state.playingAds = false
          loader(url, videoEl, config)
            .then(() => {
              registerEventListeners()
              this.show()
              this.play()
            })
            .catch(e => {
              fireOnConsumer('error', { videoElement: videoEl, event: e })
            })
        })
      })
    }
  },

  reload() {
    if (!this.canInteract) return
    const url = videoEl.getAttribute('src')
    this.close()
    this.open(url)
  },

  close() {
    _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].cancel()
    if (state.playingAds) {
      state.playingAds = false
      _Ads__WEBPACK_IMPORTED_MODULE_3__["default"].stop()
      // call self in next tick
      setTimeout(() => {
        this.close()
      })
    }
    if (!this.canInteract) return
    this.clear()
    this.hide()
    deregisterEventListeners()
  },

  clear() {
    if (!this.canInteract) return
    // pause the video first to disable sound
    this.pause()
    if (textureMode === true) videoTexture.stop()
    return unloader(videoEl).then(() => {
      fireOnConsumer('Clear', { videoElement: videoEl })
    })
  },

  play() {
    if (!this.canInteract) return
    if (textureMode === true) videoTexture.start()
    ;(0,_michieljs_execute_as_promise__WEBPACK_IMPORTED_MODULE_0__["default"])(videoEl.play, null, videoEl).catch(e => {
      fireOnConsumer('error', { videoElement: videoEl, event: e })
    })
  },

  pause() {
    if (!this.canInteract) return
    videoEl.pause()
  },

  playPause() {
    if (!this.canInteract) return
    this.playing === true ? this.pause() : this.play()
  },

  mute(muted = true) {
    if (!this.canInteract) return
    videoEl.muted = muted
  },

  loop(looped = true) {
    videoEl.loop = looped
  },

  seek(time) {
    if (!this.canInteract) return
    if (!this.src) return
    // define whether should continue to play after seek is complete (in seeked hook)
    if (state.playAfterSeek === null) {
      state.playAfterSeek = !!state.playing
    }
    // pause before actually seeking
    this.pause()
    // currentTime always between 0 and the duration of the video (minus 0.1s to not set to the final frame and stall the video)
    videoEl.currentTime = Math.max(0, Math.min(time, this.duration - 0.1))
  },

  skip(seconds) {
    if (!this.canInteract) return
    if (!this.src) return

    state.skipTime = (state.skipTime || videoEl.currentTime) + seconds
    ;(0,_helpers_easeExecution__WEBPACK_IMPORTED_MODULE_6__["default"])(() => {
      this.seek(state.skipTime)
      state.skipTime = false
    }, 300)
  },

  show() {
    if (!this.canInteract) return
    if (textureMode === true) {
      videoTexture.show()
    } else {
      videoEl.style.display = 'block'
      videoEl.style.visibility = 'visible'
    }
  },

  hide() {
    if (!this.canInteract) return
    if (textureMode === true) {
      videoTexture.hide()
    } else {
      videoEl.style.display = 'none'
      videoEl.style.visibility = 'hidden'
    }
  },

  enableAds(enabled = true) {
    state.adsEnabled = enabled
  },

  /* Public getters */
  get duration() {
    return videoEl && (isNaN(videoEl.duration) ? Infinity : videoEl.duration)
  },

  get currentTime() {
    return videoEl && videoEl.currentTime
  },

  get muted() {
    return videoEl && videoEl.muted
  },

  get looped() {
    return videoEl && videoEl.loop
  },

  get src() {
    return videoEl && videoEl.getAttribute('src')
  },

  get playing() {
    return state.playing
  },

  get playingAds() {
    return state.playingAds
  },

  get canInteract() {
    // todo: perhaps add an extra flag wether we allow interactions (i.e. pauze, mute, etc.) during ad playback
    return state.playingAds === false
  },

  get top() {
    return videoEl && parseFloat(videoEl.style.top)
  },

  get left() {
    return videoEl && parseFloat(videoEl.style.left)
  },

  get bottom() {
    return videoEl && parseFloat(videoEl.style.top - videoEl.style.height)
  },

  get right() {
    return videoEl && parseFloat(videoEl.style.left - videoEl.style.width)
  },

  get width() {
    return videoEl && parseFloat(videoEl.style.width)
  },

  get height() {
    return videoEl && parseFloat(videoEl.style.height)
  },

  get visible() {
    if (textureMode === true) {
      return videoTexture.isVisible
    } else {
      return videoEl && videoEl.style.display === 'block'
    }
  },

  get adsEnabled() {
    return state.adsEnabled
  },

  // prefixed with underscore to indicate 'semi-private'
  // because it's not recommended to interact directly with the video element
  get _videoEl() {
    return videoEl
  },

  get _consumer() {
    return consumer
  },
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_helpers_autoSetupMixin__WEBPACK_IMPORTED_MODULE_5__["default"])(videoPlayerPlugin, () => {
  precision =
    (_Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance &&
      _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage &&
      _Launch__WEBPACK_IMPORTED_MODULE_7__.ApplicationInstance.stage.getRenderPrecision()) ||
    precision

  videoEl = setupVideoTag()

  textureMode = _Settings__WEBPACK_IMPORTED_MODULE_8__["default"].get('platform', 'textureMode', false)
  if (textureMode === true) {
    videoEl.setAttribute('crossorigin', 'anonymous')
    videoTexture = setUpVideoTexture()
  }
}));


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/autoSetupMixin.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((sourceObject, setup = () => {}) => {
  let ready = false

  const doSetup = () => {
    if (ready === false) {
      setup()
      ready = true
    }
  }

  return Object.keys(sourceObject).reduce((obj, key) => {
    if (typeof sourceObject[key] === 'function') {
      obj[key] = function() {
        doSetup()
        return sourceObject[key].apply(sourceObject, arguments)
      }
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).get === 'function') {
      obj.__defineGetter__(key, function() {
        doSetup()
        return Object.getOwnPropertyDescriptor(sourceObject, key).get.apply(sourceObject)
      })
    } else if (typeof Object.getOwnPropertyDescriptor(sourceObject, key).set === 'function') {
      obj.__defineSetter__(key, function() {
        doSetup()
        return Object.getOwnPropertyDescriptor(sourceObject, key).set.sourceObject[key].apply(
          sourceObject,
          arguments
        )
      })
    } else {
      obj[key] = sourceObject[key]
    }
    return obj
  }, {})
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/easeExecution.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let timeout = null

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((cb, delay) => {
  clearTimeout(timeout)
  timeout = setTimeout(() => {
    cb()
  }, delay)
});


/***/ }),

/***/ "./node_modules/@lightningjs/sdk/src/helpers/sequence.js":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/src/helpers/sequence.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (steps => {
  return steps.reduce((promise, method) => {
    return promise
      .then(function() {
        return method(...arguments)
      })
      .catch(e => Promise.reject(e))
  }, Promise.resolve(null))
});


/***/ }),

/***/ "./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@michieljs/execute-as-promise/src/execute-as-promise.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((method, args = null, context = null) => {
  let result
  if (method && typeof method === 'function') {
    try {
      result = method.apply(context, args)
    } catch (e) {
      result = e
    }
  } else {
    result = method
  }

  // if it looks like a duck .. ehm ... promise and talks like a promise, let's assume it's a promise
  if (
    result !== null &&
    typeof result === 'object' &&
    result.then &&
    typeof result.then === 'function'
  ) {
    return result
  }
  // otherwise make it into a promise
  else {
    return new Promise((resolve, reject) => {
      if (result instanceof Error) {
        reject(result)
      } else {
        resolve(result)
      }
    })
  }
});


/***/ }),

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/***/ ((module) => {



var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),

/***/ "./node_modules/localCookie/module/localCookie.js":
/*!********************************************************!*\
  !*** ./node_modules/localCookie/module/localCookie.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
class localCookie{constructor(e){return e=e||{},this.forceCookies=e.forceCookies||!1,!0===this._checkIfLocalStorageWorks()&&!0!==e.forceCookies?{getItem:this._getItemLocalStorage,setItem:this._setItemLocalStorage,removeItem:this._removeItemLocalStorage,clear:this._clearLocalStorage}:{getItem:this._getItemCookie,setItem:this._setItemCookie,removeItem:this._removeItemCookie,clear:this._clearCookies}}_checkIfLocalStorageWorks(){if("undefined"==typeof localStorage)return!1;try{return localStorage.setItem("feature_test","yes"),"yes"===localStorage.getItem("feature_test")&&(localStorage.removeItem("feature_test"),!0)}catch(e){return!1}}_getItemLocalStorage(e){return window.localStorage.getItem(e)}_setItemLocalStorage(e,t){return window.localStorage.setItem(e,t)}_removeItemLocalStorage(e){return window.localStorage.removeItem(e)}_clearLocalStorage(){return window.localStorage.clear()}_getItemCookie(e){var t=document.cookie.match(RegExp("(?:^|;\\s*)"+function(e){return e.replace(/([.*+?\^${}()|\[\]\/\\])/g,"\\$1")}(e)+"=([^;]*)"));return t&&""===t[1]&&(t[1]=null),t?t[1]:null}_setItemCookie(e,t){var o=new Date,r=new Date(o.getTime()+15768e7);document.cookie=`${e}=${t}; expires=${r.toUTCString()};`}_removeItemCookie(e){document.cookie=`${e}=;Max-Age=-99999999;`}_clearCookies(){document.cookie.split(";").forEach(e=>{document.cookie=e.replace(/^ +/,"").replace(/=.*/,"=;expires=Max-Age=-99999999")})}}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (localCookie);


/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "App": () => (/* binding */ App)
/* harmony export */ });
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");
/* harmony import */ var _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebolt-js/sdk */ "./node_modules/@firebolt-js/sdk/dist/firebolt.js");
/* harmony import */ var _MyButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MyButton */ "./src/MyButton.js");


//import { Wifi } from '@firebolt-js/manage-sdk';
//import {Button} from './button.js';



// const videoUrlList = ['https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest(format=mpd-time-csf)',
// 'https://dash.akamaized.net/dash264/TestCasesHEVC/1a/2/BBB_OnDemand_HEVC_MultiRate.mpd',
// 'https://livesim.dashif.org/livesim/mup_300/tsbd_500/testpic_2s/Manifest.mpd']

// const LifecycleColors = {
//   // BLUE
//   BOOT: "0xff0000ff",
//   // RED
//   INACTIVE: "0xffff0000",
//   // ORANGE
//   BACKGROUND: "0xffE69738",
//   // GREEN
//   FOREGROUND: "0xff00aa00",
// };

class App extends _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.Component {
  static getFonts() {
    return [
      { family: "Regular", url: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("fonts/Roboto-Regular.ttf") },
    ];
  }

  static _template() {
    return {
      HelloWorld: {
        w: 1920,
        h: 1080,
        y: 0,
        rect: true,
        color: 0xffffffff,
        src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset('images/dark9.jpg'),
        
        FireboltStatus: {
          // Lifecycle: {
          //   mountX: 0.5,
          //   x: 960,
          //   y: 100,
          //   text: {
          //     text: "Lifecycle not Ready!",
          //     fontFace: "Regular",
          //     fontSize: 50,
          //   },
          // },
          Rdklogo: {
            x: 70,
            y: 50,
            w: 300,
            h: 100,
            zIndex: 10,
            shadowColor: 0xffff00ff,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/rdk-logo.gif"),
          },
          Alexalogo: {
            x: 1050,
            y: 5,
            w: 150,
            h: 150,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/alexa.png"),
          },
         
          Belllogo: {
            x: 1250,
            y: 30,
            w: 100,
            h: 100,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/sett.png"),
          },
          Notifilogo: {
            x: 1450,
            y: 30,
            w: 100,
            h: 100,
            src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset("images/noti.png"),
          },
          CurrentTime: {
            mountX: 0.5,
            x: 1700,
            y: 40,
            w: 200,
            h: 100,// Adjust the Y position as needed
            text: {
              text: "",
              fontFace: "Regular",
              fontSize: 70,
              textColor: 0xff09f676,
            },
          },
          Device: {
            mountX: 0.5,
            x: 960,
            y: 900,
            text: {
              text: "Device not Ready!",

              fontFace: "Regular",
              fontSize: 35,
              textColor: 0xff09f676,
            },
          },
          Localization: {
            mountX: 0.5,
            x: 960,
            y: 950,
            text: {
              text: "loaclization API ==> ",
              fontFace: "Regular",
              fontSize: 35,
              textColor: 0xff09f676,
          }
        },
        Metrics:{
          mountX: 0.5,
          x: 960,
          y: 1000,
          text: {
            text: "Metrics API ==> ",
            fontFace: "Regular",
            fontSize: 35,
            textColor: 0xff09f676,

        },
        },
      },
        Playbutton: {
          type: _MyButton__WEBPACK_IMPORTED_MODULE_2__.MyButton,
          mount: 0.5,
          x: 150,
          y: 130,
          text: {
            text: "Explore",
            fontFace: 'Regular',
            fontSize: 25,
            textColor: 0xffffffff,
          },
          signals: {
            onClick: "$onItemSelect(obj)",
          },
        },
      },
      Slider: {
        w: 800,
        h: 350,
        x: 480,
        y: 350,
        mount: 0.5,
        Wrapper: {
          
        },
        
      },
      VideoSection: {
        alpha: 1,
        x: 0,
        y: 0,
        w: 1920,
        h: 1080,
        color: "0xff000000",
        rect: true,
        visible: false,
        HelpMsg: {
          x: 80,
          y: 50,
          w: 1920,
          text: {
            text: "Play the Video using AAMP Player",
            fontSize: 40,
            fontFace: "Regular",
            textAlign: "center",
            lineHeight: 50,
          },
          color: "0xffffffff",
          alpha: 1,
        },
        Video: {
          x: 0,
          y: 0,
          w: 1920, // Set to your desired width
          h: 1080, // Set to your desired height
          type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.components.VideoItem, // Use the appropriate Lightning video
        },
      },
    };
  }
  _getFocused() {
    return this.tag("Playbutton");
  }

  _init() {
    this.index = 0;
    this.dataLength = 5;
    const buttons = [];
    // this._player = new AAMPMediaPlayer();

    for (let i = 0; i < this.dataLength; i++) {
      buttons.push(
        { type: _MyButton__WEBPACK_IMPORTED_MODULE_2__.MyButton, x: i * (300 + 30), item: { label: `Train`, src: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.asset(`images/cardImage${i + 1}.jpg`)} }, 
      );
    }

    this.tag('Wrapper').children = buttons;
    this._updateCurrentTime();

  // Update the time every second (1000 milliseconds)
  setInterval(() => {
    this._updateCurrentTime();
  }, 1000);
    
  }

  $onItemSelect(obj) {
   
    const url = 'https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest(format=mpd-time-csf)';
    this._player = new AAMPMediaPlayer();
    this._player.load(url);
    this._setState("VideoPlay");


  }
  

  _updateCurrentTime() {
    const currentTime = new Date();
    const hours = currentTime.getHours().toString().padStart(2, "0");
    const minutes = currentTime.getMinutes().toString().padStart(2, "0");
    const seconds = currentTime.getSeconds().toString().padStart(2, "0");
    const formattedTime = `${hours}:${minutes}`;
    this.tag("CurrentTime").text.text = `${formattedTime}`;
  }
  
  repositionWrapper() {
    const wrapper = this.tag('Wrapper');
    const sliderW = this.tag('Slider').w;
    const currentWrapperX = wrapper.transition('x').targetvalue || wrapper.x;
    const currentFocus = wrapper.children[this.index];
    const currentFocusX = currentFocus.x + currentWrapperX;
    const currentFocusOuterWidth = currentFocus.x + currentFocus.w;

    if (currentFocusX < 0) {
      wrapper.setSmooth('x', - currentFocus.x);
    }
    else if (currentFocusOuterWidth > sliderW) {
      wrapper.setSmooth('x', sliderW - (currentFocusOuterWidth));
    }
  }

  _handleLeft() {
    if (this.index === 0) {
      this.index = this.dataLength - 1;
    }
    else {
      this.index -= 1;
    }
    this.repositionWrapper();
  }

  _handleRight() {
    if (this.index === this.dataLength - 1) {
      this.index = 0;
    }
    else {
      this.index += 1;
    }
    this.repositionWrapper();
  }


  _getSliderFocused() {
    return this.tag('Slider.Wrapper').children[this.index];
    }
  

  // initiatePlayer() {
  //   const url =
  //     "https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest(format=mpd-time-csf)";
  //   this._player = new AAMPMediaPlayer();
  //   this._player.load(url);
  // }

  static _states() {
    return [
      class LaunchView extends this {
        _getFocused() {
          return this.tag("Playbutton");
        }
        // handleButtonEnter() {
        //   console.log("Enter fired");
        //   this.initiatePlayer();
        //   this._setState("VideoPlay");
        // }
        _getFocused() {
          return this._getSliderFocused();
          }
      },
      class VideoPlay extends this {
        _getFocused() {
          return this.tag("Video");
        }
        $enter() {
          this.tag("Video").visible = true;
          this.tag("HelloWorld").visible = false;
          this.tag("Slider").visible = false;
        }
        _handleBack() {
          console.log("back to launchView");
          this.tag("Video").visible = false;
         
          this.tag("HelloWorld").visible = true;
          this.tag("Slider").visible = true;
          
          this._setState("LaunchView");
          if (this._player) {

            this._player.stop();

            this._player = null;

          }
        }
      },
    ];
  }

  _active() {
    console.log("active set state to launchView");
    this._setState("LaunchView");

    // Device.audio().then((supportedAudioProfiles) => {
    //   const newAudio = "audio profile **" + supportedAudioProfiles.stereo;
    //   //Log.info(supportedAudioProfiles.stereo);
    //   Log.info("Device", newAudio);
    //   //this.tag('Device').text.text = newAudio + ' :: ';
    //   this.tag("Device").text.text = supportedAudioProfiles + " :: ";
    //   //console.log("Is stereo supported",supportedAudioProfiles.stereo);
    //   console.log("Is stereo supported", supportedAudioProfiles.stereo);
    // });
   
    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.distributor().then((distributor) => {
      const deviceDistributor = "distributor:" + distributor;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(deviceDistributor);
      this.tag("Device").text.text = deviceDistributor + " :: ";
    });

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.platform().then((platform) => {
      const devicePlatform = "platform:" + platform;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(devicePlatform);
      this.tag("Device").text.text += devicePlatform + " :: ";
    });

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Device.version().then((version) => {
      const deviceVersion =
        "version:" +
        version.sdk.readable +
        " : v" +
        version.sdk.major +
        "." +
        version.sdk.minor +
        "." +
        version.sdk.patch;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(deviceVersion);
      this.tag("Device").text.text += deviceVersion;
    });
    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Localization.language().then(lang => {
      const langu = "language:" + lang;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(langu);
      this.tag("Localization").text.text += langu + " ::";
       
    })
    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Localization.countryCode().then(code => {
      const C_Code = " Country_Code:" + code;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(C_Code);
      this.tag("Localization").text.text += C_Code + " ";
        console.log(code)
    })

    _firebolt_js_sdk__WEBPACK_IMPORTED_MODULE_1__.Metrics.action("user", "The user did foo", null).then(success => {
      const met_act = " action : " + success;
      _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Log.info(met_act);
      this.tag("Metrics").text.text += met_act + " ";
       
    })
  }
}

/***/ }),

/***/ "./src/MyButton.js":
/*!*************************!*\
  !*** ./src/MyButton.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MyButton": () => (/* binding */ MyButton)
/* harmony export */ });
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");


class MyButton extends _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.Component {
  static _template() {
    return {
      w: 300,
      h: 450,
      
      y: 180,
      Image: {
        x: 80,
        w: w => w,
        h: h => h - 50,
      },
    };
  }



  set item(obj) {
    const { label, src, videoUrl } = obj;
    this._videoUrl = videoUrl;
    this.patch({
      Image: { src },
    });
  }

  _handleEnter() {
    console.log('Enter pressed');
    // this.signal("onClick");
    this.fireAncestors('$onItemSelect', {
     // videoUrl: this._videoUrl
      // item: this._item,

    })

  }

  _focus() {
    console.log('Button Focus');
    this.patch({
      smooth: { color: 0xff005500, scale: 1.1 },
      shader: { type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.shaders.Outline, stroke: 1.1, color: 0xff09f676 },
    });
  }


  _unfocus() {
    console.log('Button Unfocus');
    this.patch({
      smooth: { color: 0xffffffff, scale: 1.0 },
      shader: { type: _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Lightning.shaders.Outline, stroke: 0, color: 0x0000000 },
    });
  }
}

/***/ }),

/***/ "./src/settings.js":
/*!*************************!*\
  !*** ./src/settings.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "appData": () => (/* binding */ appData),
/* harmony export */   "appSettings": () => (/* binding */ appSettings),
/* harmony export */   "platformSettings": () => (/* binding */ platformSettings)
/* harmony export */ });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../package.json */ "./package.json");



const isDevelopment = "development" === 'development';

const appData = {};

const appSettings = {
  version: _package_json__WEBPACK_IMPORTED_MODULE_0__.version,
  stage: {
    clearColor: '0x000000',
  },
  debug: false,
  
};

const platformSettings = {
  log: true,
  path: "./static",
  showVersion: false,
  
};


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/EventEmitter.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/EventEmitter.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventEmitter)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This is a partial (and more efficient) implementation of the event emitter.
 * It attempts to maintain a one-to-one mapping between events and listeners, skipping an array lookup.
 * Only if there are multiple listeners, they are combined in an array.
 */
class EventEmitter {

    constructor() {
        // This is set (and kept) to true when events are used at all.
        this._hasEventListeners = false;
    }

    on(name, listener) {
        if (!this._hasEventListeners) {
            this._eventFunction = {}
            this._eventListeners = {}
            this._hasEventListeners = true;
        }

        const current = this._eventFunction[name];
        if (!current) {
            this._eventFunction[name] = listener;
        } else {
            if (this._eventFunction[name] !== EventEmitter.combiner) {
                this._eventListeners[name] = [this._eventFunction[name], listener];
                this._eventFunction[name] = EventEmitter.combiner;
            } else {
                this._eventListeners[name].push(listener);
            }
        }
    }

    once(name, listener) {
        const wrapper = (arg1, arg2, arg3) => {
            listener(arg1, arg2, arg3);
            this.off(name, wrapper);
        }
        wrapper.__originalFunc = listener;
        this.on(name, wrapper);
    }

    has(name, listener) {
        if (this._hasEventListeners) {
            const current = this._eventFunction[name];
            if (current) {
                if (current === EventEmitter.combiner) {
                    const listeners = this._eventListeners[name];
                    for (const l of listeners) {
                        if (l === listener || l.__originalFunc == listener) {
                            return true;
                        }
                    }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                    return true;
                }
            }
        }
        return false;
    }

    off(name, listener) {
        if (this._hasEventListeners) {
            const current = this._eventFunction[name];
            if (current) {
                if (current === EventEmitter.combiner) {
                    const listeners = this._eventListeners[name];
                    let index = listeners.indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    index = listeners.map((l) => l.__originalFunc).indexOf(listener);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                    if (listeners.length === 1) {
                        this._eventFunction[name] = listeners[0];
                        this._eventListeners[name] = undefined;
                    }
                } else if (this._eventFunction[name] === listener || this._eventFunction[name].__originalFunc === listener) {
                    this._eventFunction[name] = undefined;
                }
            }
        }
    }

    removeListener(name, listener) {
        this.off(name, listener);
    }

    emit(name, arg1, arg2, arg3) {
        if (this._hasEventListeners) {
            const func = this._eventFunction[name];
            if (func) {
                if (func === EventEmitter.combiner) {
                    func(this, name, arg1, arg2, arg3);
                } else {
                    func(arg1, arg2, arg3);
                }
            }
        }
    }

    listenerCount(name) {
        if (this._hasEventListeners) {
            const func = this._eventFunction[name];
            if (func) {
                if (func === EventEmitter.combiner) {
                    return this._eventListeners[name].length;
                } else {
                    return 1;
                }
            }
        }
        return 0;
    }

    removeAllListeners(name) {
        if (this._hasEventListeners) {
            delete this._eventFunction[name];
            delete this._eventListeners[name];
        }
    }

}

EventEmitter.combiner = function(object, name, arg1, arg2, arg3) {
    const listeners = object._eventListeners[name];
    if (listeners) {
        /* Because listener may detach itself while being invoked and therefore invalidate the iterator,
           we need to create a copy to loop over it */
        for (const listener of [...listeners]) {
            listener(arg1, arg2, arg3);
        }
    }
}

EventEmitter.addAsMixin = function(cls) {
    cls.prototype.on = EventEmitter.prototype.on;
    cls.prototype.once = EventEmitter.prototype.once;
    cls.prototype.has = EventEmitter.prototype.has;
    cls.prototype.off = EventEmitter.prototype.off;
    cls.prototype.removeListener = EventEmitter.prototype.removeListener;
    cls.prototype.emit = EventEmitter.prototype.emit;
    cls.prototype.listenerCount = EventEmitter.prototype.listenerCount;
    cls.prototype.removeAllListeners = EventEmitter.prototype.removeAllListeners;
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/Animation.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/Animation.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Animation)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Animation extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(manager, settings, element) {
        super();

        this.manager = manager;

        this._settings = settings;

        this._element = element;

        this._state = Animation.STATES.IDLE;

        this._p = 0;
        this._delayLeft = 0;
        this._repeatsLeft = 0;

        this._stopDelayLeft = 0;
        this._stopP = 0;
    }

    start() {
        if (this._element && this._element.attached) {
            this._p = 0;
            this._delayLeft = this.settings.delay;
            this._repeatsLeft = this.settings.repeat;
            this._state = Animation.STATES.PLAYING;
            this.emit('start');
            this.checkActive();
        } else {
            console.warn("[Lightning] Element must be attached before starting animation");
        }
    }

    play() {
        if (this._state === Animation.STATES.PAUSED) {
            // Continue.;
            this._state = Animation.STATES.PLAYING;
            this.checkActive();
            this.emit('resume');
        } else if (this._state == Animation.STATES.STOPPING && this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.REVERSE) {
            // Continue.;
            this._state = Animation.STATES.PLAYING;
            this.emit('stopContinue');
        } else if (this._state != Animation.STATES.PLAYING && this._state != Animation.STATES.FINISHED) {
            // Restart.;
            this.start();
        }
    }

    pause() {
        if (this._state === Animation.STATES.PLAYING) {
            this._state = Animation.STATES.PAUSED;
            this.emit('pause');
        }
    }

    replay() {
        if (this._state == Animation.STATES.FINISHED) {
            this.start();
        } else {
            this.play();
        }
    }

    skipDelay() {
        this._delayLeft = 0;
        this._stopDelayLeft = 0;
    }

    finish() {
        if (this._state === Animation.STATES.PLAYING) {
            this._delayLeft = 0;
            this._p = 1;
        } else if (this._state === Animation.STATES.STOPPING) {
            this._stopDelayLeft = 0;
            this._p = 0;
        }
    }

    stop() {
        if (this._state === Animation.STATES.STOPPED || this._state === Animation.STATES.IDLE) return;

        this._stopDelayLeft = this.settings.stopDelay || 0;

        if (((this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.IMMEDIATE) && !this._stopDelayLeft) || this._delayLeft > 0) {
            // Stop upon next progress.;
            this._state = Animation.STATES.STOPPING;
            this.emit('stop');
        } else {
            if (this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
                this._stopP = 0;
            }

            this._state = Animation.STATES.STOPPING;
            this.emit('stop');
        }

        this.checkActive();
    }

    stopNow() {
        if (this._state !== Animation.STATES.STOPPED || this._state !== Animation.STATES.IDLE) {
            this._state = Animation.STATES.STOPPING;
            this._p = 0;
            this.emit('stop');
            this.reset();
            this._state = Animation.STATES.STOPPED;
            this.emit('stopFinish');
        }
    }

    isPaused() {
        return this._state === Animation.STATES.PAUSED;
    }

    isPlaying() {
        return this._state === Animation.STATES.PLAYING;
    }

    isStopping() {
        return this._state === Animation.STATES.STOPPING;
    }

    isFinished() {
        return this._state === Animation.STATES.FINISHED;
    }

    checkActive() {
        if (this.isActive()) {
            this.manager.addActive(this);
        }
    }

    isActive() {
        return (this._state == Animation.STATES.PLAYING || this._state == Animation.STATES.STOPPING) && this._element && this._element.attached;
    }

    progress(dt) {
        if (!this._element) return;
        this._progress(dt);
        this.apply();
    }

    _progress(dt) {
        if (this._state == Animation.STATES.STOPPING) {
            this._stopProgress(dt);
            return;
        }

        if (this._state != Animation.STATES.PLAYING) {
            return;
        }

        if (this._delayLeft > 0) {
            this._delayLeft -= dt;

            if (this._delayLeft < 0) {
                dt = -this._delayLeft;
                this._delayLeft = 0;

                this.emit('delayEnd');
            } else {
                return;
            }
        }

        if (this.settings.duration === 0) {
            this._p = 1;
        } else if (this.settings.duration > 0) {
            this._p += dt / this.settings.duration;
        }
        if (this._p >= 1) {
            // Finished!;
            if (this.settings.repeat == -1 || this._repeatsLeft > 0) {
                if (this._repeatsLeft > 0) {
                    this._repeatsLeft--;
                }
                this._p = this.settings.repeatOffset;
                this.emit('progress', this._p);
                
                if (this.settings.repeatDelay) {
                    this._delayLeft = this.settings.repeatDelay;
                }

                this.emit('repeat', this._repeatsLeft);
            } else {
                this._p = 1;
                this.emit('progress', this._p);
                
                this._state = Animation.STATES.FINISHED;
                this.emit('finish');
                if (this.settings.autostop) {
                    this.stop();
                }
            }
        } else {
            this.emit('progress', this._p);
        }
    }
    
    _stopProgress(dt) {
        let duration = this._getStopDuration();

        if (this._stopDelayLeft > 0) {
            this._stopDelayLeft -= dt;

            if (this._stopDelayLeft < 0) {
                dt = -this._stopDelayLeft;
                this._stopDelayLeft = 0;

                this.emit('stopDelayEnd');
            } else {
                return;
            }
        }
        if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.IMMEDIATE) {
            this._state = Animation.STATES.STOPPED;
            this.emit('stopFinish');
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.REVERSE) {
            if (duration === 0) {
                this._p = 0;
            } else if (duration > 0) {
                this._p -= dt / duration;
            }

            if (this._p <= 0) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
            this._progressStopTransition(dt);
            if (this._stopP >= 1) {
                this._p = 0;
                this._state = Animation.STATES.STOPPED;
                this.emit('stopFinish');
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.ONETOTWO) {
            if (this._p < 2) {
                if (duration === 0) {
                    this._p = 2;
                } else if (duration > 0) {
                    if (this._p < 1) {
                        this._p += dt / this.settings.duration;
                    } else {
                        this._p += dt / duration;
                    }
                }
                if (this._p >= 2) {
                    this._p = 2;
                    this._state = Animation.STATES.STOPPED;
                    this.emit('stopFinish');
                } else {
                    this.emit('progress', this._p);
                }
            }
        } else if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FORWARD) {
            if (this._p < 1) {
                if (this.settings.duration == 0) {
                    this._p = 1;
                } else {
                    this._p += dt / this.settings.duration;
                }
                if (this._p >= 1) {
                    if (this.settings.stopMethod == _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FORWARD) {
                        this._p = 1;
                        this._state = Animation.STATES.STOPPED;
                        this.emit('stopFinish');
                    } else {
                        if (this._repeatsLeft > 0) {
                            this._repeatsLeft--;
                            this._p = 0;
                            this.emit('repeat', this._repeatsLeft);
                        } else {
                            this._p = 1;
                            this._state = Animation.STATES.STOPPED;
                            this.emit('stopFinish');
                        }
                    }
                } else {
                    this.emit('progress', this._p);
                }
            }
        }
        
    }
    
    _progressStopTransition(dt) {
        if (this._stopP < 1) {
            if (this._stopDelayLeft > 0) {
                this._stopDelayLeft -= dt;

                if (this._stopDelayLeft < 0) {
                    dt = -this._stopDelayLeft;
                    this._stopDelayLeft = 0;

                    this.emit('delayEnd');
                } else {
                    return;
                }
            }
            
            const duration = this._getStopDuration();

            if (duration == 0) {
                this._stopP = 1;
            } else {
                this._stopP += dt / duration;
            }
            if (this._stopP >= 1) {
                // Finished!;
                this._stopP = 1;
            }
        }
    }

    _getStopDuration() {
        return this.settings.stopDuration || this.settings.duration;
    }

    apply() {
        if (this._state === Animation.STATES.STOPPED) {
            this.reset();
        } else {
            let factor = 1;
            if (this._state === Animation.STATES.STOPPING && this.settings.stopMethod === _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].STOP_METHODS.FADE) {
                factor = (1 - this.settings.stopTimingFunctionImpl(this._stopP));
            }
            this._settings.apply(this._element, this._p, factor);
        }
    }

    reset() {
        this._settings.reset(this._element);
    }

    get state() {
        return this._state;
    }

    get p() {
        return this._p;
    }

    get delayLeft() {
        return this._delayLeft;
    }

    get element() {
        return this._element;
    }

    get frame() {
        return Math.round(this._p * this._settings.duration * 60);
    }

    get settings() {
        return this._settings;
    }

}

Animation.STATES = {
    IDLE: 0,
    PLAYING: 1,
    STOPPING: 2,
    STOPPED: 3,
    FINISHED: 4,
    PAUSED: 5
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationActionSettings)
/* harmony export */ });
/* harmony import */ var _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tools/MultiSpline.mjs */ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs");
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AnimationActionSettings {

    constructor(animationSettings) {

        this.animationSettings = animationSettings;

        /**
         * The selector that selects the elements.
         * @type {string}
         */
        this._selector = "";

        /**
         * The value items, ordered by progress offset.
         * @type {MultiSpline}
         * @private;
         */
        this._items = new _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();

        /**
         * The affected properties (paths).
         * @private;
         */
        this._props = [];

        /**
         * Property setters, indexed according to props.
         * @private;
         */
        this._propSetters = [];

        this._resetValue = undefined;
        this._hasResetValue = false;

        this._hasColorProperty = undefined;
    }

    getResetValue() {
        if (this._hasResetValue) {
            return this._resetValue;
        } else {
            return this._items.getValue(0);
        }
    }

    apply(element, p, factor) {
        const elements = this.getAnimatedElements(element);

        let v = this._items.getValue(p);

        if (v === undefined || !elements.length) {
            return;
        }

        if (factor !== 1) {
            // Stop factor.;
            let sv = this.getResetValue();

            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(v) && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(sv)) {
                if (this.hasColorProperty()) {
                    v = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].mergeColors(v, sv, factor);
                } else {
                    v = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].mergeNumbers(v, sv, factor);
                }
            }
        }

        // Apply transformation to all components.;
        const n = this._propSetters.length;

        const m = elements.length;
        for (let j = 0; j < m; j++) {
            for (let i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
            }
        }
    }
    
    getAnimatedElements(element) {
        return element.select(this._selector);
    }

    reset(element) {
        const elements = this.getAnimatedElements(element);

        let v = this.getResetValue();

        if (v === undefined || !elements.length) {
            return;
        }

        // Apply transformation to all components.
        const n = this._propSetters.length;

        const m = elements.length;
        for (let j = 0; j < m; j++) {
            for (let i = 0; i < n; i++) {
                this._propSetters[i](elements[j], v);
            }
        }
    }
    
    set selector(v) {
        this._selector = v;
    }

    set t(v) {
        this.selector = v;
    }

    get resetValue() {
        return this._resetValue;
    }
    
    set resetValue(v) {
        this._resetValue = v;
        this._hasResetValue = (v !== undefined);
    }

    set rv(v) {
        this.resetValue = v;
    }

    set value(v) {
        this._items.parse(this.hasColorProperty(), v);
    }

    set v(v) {
        this.value = v;
    }

    set properties(v) {
        if (!Array.isArray(v)) {
            v = [v];
        }

        this._props = [];

        v.forEach((prop) => {
            this._props.push(prop);
            this._propSetters.push(_tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].getSetter(prop));
        });
    }

    set property(v) {
        this._hasColorProperty = undefined;
        this.properties = v;
    }

    set p(v) {
        this.properties = v;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].patchObject(this, settings);
    }

    hasColorProperty() {
        if (this._hasColorProperty === undefined) {
            this._hasColorProperty = this._props.length ? _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isColorProperty(this._props[0]) : false;
        }
        return this._hasColorProperty;
    }
}

AnimationActionSettings.prototype.isAnimationActionSettings = true;








/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationManager)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimationSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs");
/* harmony import */ var _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Animation.mjs */ "./node_modules/@lightningjs/core/src/animation/Animation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class AnimationManager {

    constructor(stage) {
        this.stage = stage;

        this.stage.on('frameStart', () => this.progress());

        /**
         * All running animations on attached subjects.
         * @type {Set<Animation>}
         */
        this.active = new Set();
    }

    progress() {
        if (this.active.size) {
            let dt = this.stage.dt;

            let filter = false;
            this.active.forEach(function(a) {
                if (a.isActive()) {
                    a.progress(dt);
                } else {
                    filter = true;
                }
            });

            if (filter) {
                this.active = new Set([...this.active].filter(t => t.isActive()));
            }
        }
    }

    createAnimation(element, settings) {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            // Convert plain object to proper settings object.
            settings = this.createSettings(settings);
        }

        return new _Animation_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](
            this,
            settings,
            element
        );
    }

    createSettings(settings) {
        const animationSettings = new _AnimationSettings_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]();
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].patchObject(animationSettings, settings);
        return animationSettings;
    }

    addActive(transition) {
        this.active.add(transition);
    }
}







/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/AnimationSettings.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationSettings)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _AnimationActionSettings_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationActionSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationActionSettings.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class AnimationSettings {
    constructor() {
        /**
         * @type {AnimationActionSettings[]}
         */
        this._actions = [];

        this.delay = 0;
        this.duration = 1;

        this.repeat = 0;
        this.repeatOffset = 0;
        this.repeatDelay = 0;

        this.autostop = false;

        this.stopMethod = AnimationSettings.STOP_METHODS.FADE;
        this._stopTimingFunction = 'ease';
        this._stopTimingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(this._stopTimingFunction);
        this.stopDuration = 0;
        this.stopDelay = 0;
    }

    get actions() {
        return this._actions;
    }

    set actions(v) {
        this._actions = [];
        for (let i = 0, n = v.length; i < n; i++) {
            const e = v[i];
            if (!e.isAnimationActionSettings) {
                const aas = new _AnimationActionSettings_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
                aas.patch(e);
                this._actions.push(aas);
            } else {
                this._actions.push(e);
            }
        }
    }

    /**
     * Applies the animation to the specified element, for the specified progress between 0 and 1.
     * @param {Element} element;
     * @param {number} p;
     * @param {number} factor;
     */
    apply(element, p, factor = 1) {
        this._actions.forEach(function(action) {
            action.apply(element, p, factor);
        });
    }

    /**
     * Resets the animation to the reset values.
     * @param {Element} element;
     */
    reset(element) {
        this._actions.forEach(function(action) {
            action.reset(element);
        });
    }

    get stopTimingFunction() {
        return this._stopTimingFunction;
    }

    set stopTimingFunction(v) {
        this._stopTimingFunction = v;
        this._stopTimingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(v);
    }

    get stopTimingFunctionImpl() {
        return this._stopTimingFunctionImpl;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(this, settings);
    }

}

AnimationSettings.STOP_METHODS = {
    FADE: 'fade',
    REVERSE: 'reverse',
    FORWARD: 'forward',
    IMMEDIATE: 'immediate',
    ONETOTWO: 'onetotwo'
};



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/Transition.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/Transition.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Transition)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Transition extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(manager, settings, element, property) {
        super();

        this.manager = manager;

        this._settings = settings;

        this._element = element;

        this._getter = element.constructor.getGetter(property);
        this._setter = element.constructor.getSetter(property);

        this._merger = settings.merger;

        if (!this._merger) {
            this._merger = element.constructor.getMerger(property);
        }

        this._startValue = this._getter(this._element);
        this._targetValue = this._startValue;

        this._p = 1;
        this._delayLeft = 0;
    }

    start(targetValue) {
        this._startValue = this._getter(this._element);

        if (!this.isAttached()) {
            // We don't support transitions on non-attached elements. Just set value without invoking listeners.
            this._targetValue = targetValue;
            this._p = 1;
            this._updateDrawValue();
        } else {
            if (targetValue === this._startValue) {
                this.reset(targetValue, 1);
            } else {
                this._targetValue = targetValue;
                this._p = 0;
                this._delayLeft = this._settings.delay;
                this.emit('start');
                this.add();
            }
        }
    }

    finish() {
        if (this._p < 1) {
            // Value setting and will must be invoked (async) upon next transition cycle.
            this._p = 1;
        }
    }

    stop() {
        // Just stop where the transition is at.
        this.emit('stop');
        this.manager.removeActive(this);
    }

    pause() {
        this.stop();
    }

    play() {
        this.manager.addActive(this);
    }

    reset(targetValue, p) {
        if (!this.isAttached()) {
            // We don't support transitions on non-attached elements. Just set value without invoking listeners.
            this._startValue = this._getter(this._element);
            this._targetValue = targetValue;
            this._p = 1;
            this._updateDrawValue();
        } else {
            this._startValue = this._getter(this._element);
            this._targetValue = targetValue;
            this._p = p;
            this.add();
        }
    }

    _updateDrawValue() {
        this._setter(this._element, this.getDrawValue());
    }

    add() {
        this.manager.addActive(this);
    }

    isAttached() {
        return this._element.attached;
    }

    isRunning() {
        return (this._p < 1.0);
    }

    progress(dt) {
        if (!this.isAttached()) {
            // Skip to end of transition so that it is removed.
            this._p = 1;
        }

        if (this.p < 1) {
            if (this.delayLeft > 0) {
                this._delayLeft -= dt;

                if (this.delayLeft < 0) {
                    dt = -this.delayLeft;
                    this._delayLeft = 0;

                    this.emit('delayEnd');
                } else {
                    return;
                }
            }

            if (this._settings.duration == 0) {
                this._p = 1;
            } else {
                this._p += dt / this._settings.duration;
            }
            if (this._p >= 1) {
                // Finished!;
                this._p = 1;
            }
        }

        this._updateDrawValue();

        this.invokeListeners();
    }

    invokeListeners() {
        this.emit('progress', this.p);
        if (this.p === 1) {
            this.emit('finish');
        }
    }

    updateTargetValue(targetValue) {
        let t = this._settings.timingFunctionImpl(this.p);
        if (t === 1) {
            this._targetValue = targetValue;
        } else if (t === 0) {
            this._startValue = this._targetValue;
            this._targetValue = targetValue;
        } else {
            this._startValue = targetValue - ((targetValue - this._targetValue) / (1 - t));
            this._targetValue = targetValue;
        }
    }

    getDrawValue() {
        if (this.p >= 1) {
            return this.targetValue;
        } else {
            let v = this._settings._timingFunctionImpl(this.p);
            return this._merger(this.targetValue, this.startValue, v);
        }
    }

    skipDelay() {
        this._delayLeft = 0;
    }

    get startValue() {
        return this._startValue;
    }

    get targetValue() {
        return this._targetValue;
    }

    get p() {
        return this._p;
    }

    get delayLeft() {
        return this._delayLeft;
    }

    get element() {
        return this._element;
    }

    get settings() {
        return this._settings;
    }

    set settings(v) {
        this._settings = v;
    }

}

Transition.prototype.isTransition = true;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitionManager)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransitionSettings.mjs */ "./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs");
/* harmony import */ var _Transition_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transition.mjs */ "./node_modules/@lightningjs/core/src/animation/Transition.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class TransitionManager {

    constructor(stage) {
        this.stage = stage;

        this.stage.on('frameStart', () => this.progress());

        /**
         * All transitions that are running and attached.
         * (we don't support transitions on un-attached elements to prevent memory leaks)
         * @type {Set<Transition>}
         */
        this.active = new Set();

        this.defaultTransitionSettings = new _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this.stage);
    }

    progress() {
        if (this.active.size) {
            let dt = this.stage.dt;

            let filter = false;
            this.active.forEach(function(a) {
                a.progress(dt);
                if (!a.isRunning()) {
                    filter = true;
                }
            });

            if (filter) {
                this.active = new Set([...this.active].filter(t => (t.isRunning())));
            }
        }
    }

    createSettings(settings) {
        const transitionSettings = new _TransitionSettings_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]();
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(transitionSettings, settings);
        return transitionSettings;
    }

    addActive(transition) {
        this.active.add(transition);
    }

    removeActive(transition) {
        this.active.delete(transition);
    }
}






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/animation/TransitionSettings.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitionSettings)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TransitionSettings {
    constructor(stage) {
        this.stage = stage;
        this._timingFunction = 'ease';
        this._timingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(this._timingFunction);
        this.delay = 0;
        this.duration = 0.2;
        this.merger = null;
    }

    get timingFunction() {
        return this._timingFunction;
    }

    set timingFunction(v) {
        this._timingFunction = v;
        this._timingFunctionImpl = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getTimingFunction(v);
    }

    get timingFunctionImpl() {
        return this._timingFunctionImpl;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(this, settings);
    }
}

TransitionSettings.prototype.isTransitionSettings = true;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/Application.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/Application.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Application)
/* harmony export */ });
/* harmony import */ var _Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tree/Stage.mjs */ "./node_modules/@lightningjs/core/src/tree/Stage.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Application extends _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(options = {}, properties) {
        // Save options temporarily to avoid having to pass it through the constructor.
        Application._temp_options = options;

        // Booting flag is used to postpone updateFocusSettings;
        Application.booting = true;
        const stage = new _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](options.stage);
        super(stage, properties);
        Application.booting = false;

        this.__updateFocusCounter = 0;
        this.__keypressTimers = new Map();
        this.__hoveredChild = null;

        // We must construct while the application is not yet attached.
        // That's why we 'init' the stage later (which actually emits the attach event).
        this.stage.init();

        // Initially, the focus settings are updated after both the stage and application are constructed.
        this.updateFocusSettings();

        this.__keymap = this.getOption('keys');

        if (this.__keymap) {
            this.stage.platform.registerKeydownHandler((e) => {
                this._receiveKeydown(e);
            });

            this.stage.platform.registerKeyupHandler((e) => {
                this._receiveKeyup(e);
            });
        }

        if (this.getOption("enablePointer")) {
            this.stage.platform.registerClickHandler((e) => {
                this._receiveClick(e);
            });

            this.stage.platform.registerHoverHandler((e) => {
                this._receiveHover(e);
            });

            this.stage.platform.registerScrollWheelHandler((e) => {
                this._recieveScrollWheel(e);
            });

            this.cursor = 'default';
        }
    }

    getOption(name) {
        return this.__options[name];
    }

    _setOptions(o) {
        this.__options = {};

        let opt = (name, def) => {
            let value = o[name];

            if (value === undefined) {
                this.__options[name] = def;
            } else {
                this.__options[name] = value;
            }
        }

        opt('debug', false);
        opt('keys', {
            38: "Up",
            40: "Down",
            37: "Left",
            39: "Right",
            13: "Enter",
            8: "Back",
            27: "Exit"
        });
        opt('enablePointer', false);
    }

    __construct() {
        this.stage.setApplication(this);

        this._setOptions(Application._temp_options);
        delete Application._temp_options;

        super.__construct();
    }

    __init() {
        super.__init();
        this.__updateFocus();
    }

    updateFocusPath() {
        this.__updateFocus();
    }

    __updateFocus() {
        const notOverridden = this.__updateFocusRec();

        if (!Application.booting && notOverridden) {
            this.updateFocusSettings();
        }
    }

    __updateFocusRec() {
        const updateFocusId = ++this.__updateFocusCounter;
        this.__updateFocusId = updateFocusId;

        const newFocusPath = this.__getFocusPath();
        const newFocusedComponent = newFocusPath[newFocusPath.length - 1];
        const prevFocusedComponent = this._focusPath ? this._focusPath[this._focusPath.length - 1] : undefined;

        if (!prevFocusedComponent) {
            // Focus events.
            this._focusPath = [];
            for (let i = 0, n = newFocusPath.length; i < n; i++) {
                this._focusPath.push(newFocusPath[i]);
                this._focusPath[i]._focus(newFocusedComponent, undefined);
                const focusOverridden = (this.__updateFocusId !== updateFocusId);
                if (focusOverridden) {
                    return false;
                }
            }
            return true;
        } else {
            let m = Math.min(this._focusPath.length, newFocusPath.length);
            let index;
            for (index = 0; index < m; index++) {
                if (this._focusPath[index] !== newFocusPath[index]) {
                    break;
                }
            }

            if (this._focusPath.length !== newFocusPath.length || index !== newFocusPath.length) {

                if (this.getOption('debug')) {
                    console.log('[Lightning] Focus changed: ' + newFocusedComponent.getLocationString());
                }

                // Unfocus events.
                for (let i = this._focusPath.length - 1; i >= index; i--) {
                    const unfocusedElement = this._focusPath.pop();
                    unfocusedElement._unfocus(newFocusedComponent, prevFocusedComponent);
                    const focusOverridden = (this.__updateFocusId !== updateFocusId);
                    if (focusOverridden) {
                        return false;
                    }
                }

                // Focus events.
                for (let i = index, n = newFocusPath.length; i < n; i++) {
                    this._focusPath.push(newFocusPath[i]);
                    this._focusPath[i]._focus(newFocusedComponent, prevFocusedComponent);
                    const focusOverridden = (this.__updateFocusId !== updateFocusId);
                    if (focusOverridden) {
                        return false;
                    }
                }

                // Focus changed events.
                for (let i = 0; i < index; i++) {
                    this._focusPath[i]._focusChange(newFocusedComponent, prevFocusedComponent);
                }
            }
        }

        return true;
    }

    updateFocusSettings() {
        const focusedComponent = this._focusPath[this._focusPath.length - 1];

        // Get focus settings. These can be used for dynamic application-wide settings that depend on the
        // focus directly (such as the application background).
        const focusSettings = {};
        const defaultSetFocusSettings = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._setFocusSettings;
        for (let i = 0, n = this._focusPath.length; i < n; i++) {
            if (this._focusPath[i]._setFocusSettings !== defaultSetFocusSettings) {
                this._focusPath[i]._setFocusSettings(focusSettings);
            }
        }

        const defaultHandleFocusSettings = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].prototype._handleFocusSettings;
        for (let i = 0, n = this._focusPath.length; i < n; i++) {
            if (this._focusPath[i]._handleFocusSettings !== defaultHandleFocusSettings) {
                this._focusPath[i]._handleFocusSettings(focusSettings, this.__prevFocusSettings, focusedComponent);
            }
        }

        this.__prevFocusSettings = focusSettings;
    }

    _handleFocusSettings(settings, prevSettings, focused, prevFocused) {
        // Override to handle focus-based settings.
    }

    __getFocusPath() {
        const path = [this];
        let current = this;
        do {
            const nextFocus = current._getFocused();
            if (!nextFocus || (nextFocus === current)) {
                // Found!;
                break;
            }


            let ptr = nextFocus.cparent;
            if (ptr === current) {
                path.push(nextFocus);
            } else {
                // Not an immediate child: include full path to descendant.
                const newParts = [nextFocus];
                do {
                    if (!ptr) {
                        current._throwError("Return value for _getFocused must be an attached descendant component but its '" + nextFocus.getLocationString() + "'");
                    }
                    newParts.push(ptr);
                    ptr = ptr.cparent;
                } while (ptr !== current);

                // Add them reversed.
                for (let i = 0, n = newParts.length; i < n; i++) {
                    path.push(newParts[n - i - 1]);
                }
            }

            current = nextFocus;
        } while(true);

        return path;
    }

    get focusPath() {
        return this._focusPath;
    }

    /**
     * Injects an event in the state machines, top-down from application to focused component.
     */
    focusTopDownEvent(events, ...args) {
        const path = this.focusPath;
        const n = path.length;

        // Multiple events.
        for (let i = 0; i < n; i++) {
            const event = path[i]._getMostSpecificHandledMember(events);
            if (event !== undefined) {
                const returnValue = path[i][event](...args);
                if (returnValue !== false) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Injects an event in the state machines, bottom-up from focused component to application.
     */
    focusBottomUpEvent(events, ...args) {
        const path = this.focusPath;
        const n = path.length;

        // Multiple events.
        for (let i = n - 1; i >= 0; i--) {
            const event = path[i]._getMostSpecificHandledMember(events);
            if (event !== undefined) {
                const returnValue = path[i][event](...args);
                if (returnValue !== false) {
                    return true;
                }
            }
        }

        return false;
    }

    _receiveKeydown(e) {
        const obj = e;
        const key = this.__keymap[e.keyCode];
        const path = this.focusPath;

        let keys;
        if (key) {
            keys = Array.isArray(key) ? key : [key];
        }

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                const hasTimer = this.__keypressTimers.has(keys[i]);
                // prevent event from getting fired when the timeout is still active
                if (path[path.length - 1].longpress && hasTimer) {
                    return;
                }

                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}`, "_captureKey"], obj)) {
                    this.stage.application.focusBottomUpEvent([`_handle${keys[i]}`, "_handleKey"], obj);
                }
            }
        } else {
            if (!this.stage.application.focusTopDownEvent(["_captureKey"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKey"], obj);
            }
        }

        this.updateFocusPath();

        const consumer = path[path.length - 1];

        if (keys && consumer.longpress) {
            for (let i = 0, n = keys.length; i < n; i++) {
                this._startLongpressTimer(keys[i], consumer);
            }
        }
    }

    /**
     * Keyup listener
     * To take away some confusion we add `Release` to the event to prevent ending up with method names like:
     *  _handleLeftUp / _handleUpUp / _handleEnterUp etc
     *
     * @param e
     * @private
     */
    _receiveKeyup(e) {
        const obj = e;
        const key = this.__keymap[e.keyCode];

        let keys;
        if (key) {
            keys = Array.isArray(key) ? key : [key];
        }

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                if (!this.stage.application.focusTopDownEvent([`_capture${keys[i]}Release`, "_captureKeyRelease"], obj)) {
                    this.stage.application.focusBottomUpEvent([`_handle${keys[i]}Release`, "_handleKeyRelease"], obj);
                }
            }
        } else {
            if (!this.stage.application.focusTopDownEvent(["_captureKeyRelease"], obj)) {
                this.stage.application.focusBottomUpEvent(["_handleKeyRelease"], obj);
            }
        }

        this.updateFocusPath();

        if (keys) {
            for (let i = 0, n = keys.length; i < n; i++) {
                if (this.__keypressTimers.has(keys[i])) {
                    // keyup has fired before end of timeout so we clear it
                    clearTimeout(this.__keypressTimers.get(keys[i]));
                    // delete so we can register it again
                    this.__keypressTimers.delete(keys[i]);
                }
            }
        }
    }

    /**
     * Registers and starts a timer for the pressed key. Timer will be cleared when the key is released
     * before the timer goes off.
     *
     * If key is not release (keyup) the longpress handler will be fired.
     * Configuration can be via the Components template:
     *
     * static _template() {
     *     return {
     *         w:100, h:100,
     *         longpress:{up:700, down:500}
     *     }
     * }     *
     * // this will get called when up has been pressed for 700ms
     * _handleUpLong() {
     *
     * }
     *
     * @param key
     * @param element
     * @private
     */
    _startLongpressTimer(key, element) {
        const config = element.longpress;
        const lookup = key.toLowerCase();

        if (config[lookup]) {
            const timeout = config[lookup];
            if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(timeout)) {
                element._throwError("config value for longpress must be a number");
            } else {
                this.__keypressTimers.set(key, setTimeout(() => {
                    if (!this.stage.application.focusTopDownEvent([`_capture${key}Long`, "_captureKey"], {})) {
                        this.stage.application.focusBottomUpEvent([`_handle${key}Long`, "_handleKey"], {});
                    }

                    this.__keypressTimers.delete(key);
                }, timeout || 500 /* prevent 0ms */));
            }
        }
        return;
    }

    _recieveScrollWheel(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            if (!this.fireTopDownScrollWheelHandler("_captureScroll", obj)) {
                this.fireBottomUpScrollWheelHandler("_handleScroll", obj);
            }
        }
    }

    fireTopDownScrollWheelHandler(event, obj) {
        let children = this.stage.application.children;
        let affected = this._findChildren([], children).reverse();
        let n = affected.length;

        while(n--) {
            const child = affected[n];
            if (child && child[event]) {
                child._captureScroll(obj);
                return true; 
            }
        }
        return false;
    }

    fireBottomUpScrollWheelHandler(event, obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);
        let child = target;

        // Search tree bottom up for a handler
        while (child !== null) {
            if (child && child[event]) {
                child._handleScroll(obj);
                return true;
            }
            child = child.parent;
        }
        return false;
    }

    _receiveClick(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            this.stage.application.fireBottomUpClickHandler(obj);
        }
    }

    fireBottomUpClickHandler(obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);
        let child = target;

        // Search tree bottom up for a handler
        while (child !== null) {
            if (child && child["_handleClick"]) {
                child._handleClick(target);
                break;
            }
            child = child.parent;
        }
    }

    _receiveHover(e) {
        const obj = e;
        const {clientX, clientY} = obj;

        if (clientX <= this.stage.w && clientY <= this.stage.h) {
            this.stage.application.fireBottomUpHoverHandler(obj);
        }
    }

    fireBottomUpHoverHandler(obj) {
        const {clientX, clientY} = obj;
        const target = this._getTargetChild(clientX, clientY);

        // Only fire handlers when pointer target changes
        if (target !== this.__hoveredChild) {

            let hoveredBranch = new Set();
            let newHoveredBranch = new Set();

            if (target) {
                newHoveredBranch = new Set(target.getAncestors());
            }

            if (this.__hoveredChild) {
                hoveredBranch = new Set(this.__hoveredChild.getAncestors());
                for (const elem of [...hoveredBranch].filter((e) => !newHoveredBranch.has(e))) {
                    const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(elem);
                    if (c["_handleUnhover"]) {
                        c._handleUnhover(elem);
                    }
                    if (elem.parent && elem.parent.cursor) {
                        this.stage.getCanvas().style.cursor = elem.parent.cursor;
                    }
                }
            }

            this.__hoveredChild = target;

            const diffBranch = [...newHoveredBranch].filter((e) => !hoveredBranch.has(e))
            for (const elem of diffBranch) {
                const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(elem);
                if (c["_handleHover"]) {
                    c._handleHover(elem);
                }
            }

            // New element hover cursor
            const lastElement = diffBranch[0];
            if (lastElement && lastElement.cursor) {
                this.stage.getCanvas().style.cursor = lastElement.cursor;
            }

            // Rerun _handleHover for target element in case it's been hovered
            // back from its child
            if (diffBranch.length === 0 && target) {
                const c = _Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getComponent(target);
                if (c["_handleHover"]) {
                    c._handleHover(target);
                }
            }
        }
    }

    _getTargetChild(clientX, clientY) {
        let children = this.stage.application.children;
        let affected = this._findChildren([], children);
        let hoverableChildren = this._withinClickableRange(affected, clientX, clientY);

        hoverableChildren.sort((a,b) => {
            // Sort by zIndex and then id
            if (a.zIndex > b.zIndex) {
                return 1;
            } else if (a.zIndex < b.zIndex) {
                return -1;
            } else {
                return a.id > b.id ? 1: -1;
            }
        });

        if (hoverableChildren.length) {
            // Assume target has highest zIndex (id when zIndex equal)
            return hoverableChildren.slice(-1)[0];
        } else {
            return null;
        }
    }

    _findChildren(bucket, children) {
        let n = children.length;
        while (n--) {
            const child = children[n];
            // only add active children
            if (child.__active && child.collision) {
                if (child.collision === true) {
                    bucket.push(child);
                }
                if (child.hasChildren()) {
                    this._findChildren(bucket, child.children);
                }
            }
        }
        return bucket;
    }

    _withinClickableRange(affectedChildren, cursorX, cursorY) {
        let n = affectedChildren.length;
        const candidates = [];

        // loop through affected children
        // and perform collision detection
        while (n--) {
            const child = affectedChildren[n];
            const precision = this.stage.getRenderPrecision();
            const ctx = child.core._worldContext;

            const cx = ctx.px * precision;
            const cy = ctx.py * precision;
            const cw = child.finalW * ctx.ta * precision;
            const ch = child.finalH * ctx.td * precision;

            if (cx > this.stage.w || cy > this.stage.h) {
                continue;
            }

            if (child.parent.core._scissor) {
                const scissor = child.parent.core._scissor.map((v) => v * precision);
                if (!this._testCollision(cursorX, cursorY, ...scissor))
                    continue
            }

            if (this._testCollision(cursorX, cursorY, cx, cy, cw, ch)) {
                candidates.push(child);
            }
        }
        return candidates;
    }

    _testCollision(px, py, cx, cy, cw, ch) {
        if (px >= cx &&
            px <= cx + cw &&
            py >= cy &&
            py <= cy + ch) {
            return true;
        }
        return false;
    }

    destroy() {
        if (!this._destroyed) {
            this._destroy();
            this.stage.destroy();
            this._destroyed = true;
        }
    }

    _destroy() {
        // This forces the _detach, _disabled and _active events to be called.
        this.stage.setApplication(undefined);
        this._updateAttachedFlag();
        this._updateEnabledFlag();

        if (this.__keypressTimers.size) {
            for (const timer of this.__keypressTimers.values()) {
                clearTimeout(timer);
            }

            this.__keypressTimers.clear();
        }
    }

    getCanvas() {
        return this.stage.getCanvas();
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/Component.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/Component.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _StateMachine_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StateMachine.mjs */ "./node_modules/@lightningjs/core/src/application/StateMachine.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @extends StateMachine
 */
class Component extends _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage, properties) {
        super(stage);

        // Encapsulate tags to prevent leaking.
        this.tagRoot = true;

        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(properties)) {
            Object.assign(this, properties);
        }

        this.__initialized = false;
        this.__firstActive = false;
        this.__firstEnable = false;

        this.__signals = undefined;

        this.__passSignals = undefined;

        this.__construct();

        // Quick-apply template.
        const func = this.constructor.getTemplateFunc(this);
        func.f(this, func.a);

        this._build();
    }

    __start() {
        _StateMachine_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].setupStateMachine(this);
        this._onStateChange = Component.prototype.__onStateChange;
    }

    get state() {
        return this._getState();
    }

    __onStateChange() {
        /* FIXME: Workaround for case, where application was shut but component still lives */
        if (this.application) {
            this.application.updateFocusPath();
        }
    }

    _refocus() {
        /* FIXME: Workaround for case, where application was shut but component still lives */
        if (this.application) {
            this.application.updateFocusPath();
        }
    }

    static bindProp(name, func = null) {
        return {__propertyBinding: true, __name: name, __func: func};
    }

    __bindProperty(propObj, targetObj, targetProp) {
        // 1. find binding position: find object and property name to be bound
        const obj = targetObj;
        const prop = targetProp;
        const propDependencies = Array.isArray(propObj.__name) ? propObj.__name : [propObj.__name];

        // 2. create setters for every given dependency
        for (let i = 0; i < propDependencies.length; i++) {
            const propName = propDependencies[i];
            const func = propObj.__func ? propObj.__func : (context) => context[propName];

            if (!this.hasOwnProperty(propName)) {
                this[`__prop_bindings_${propName}`] = [{__obj: obj, __prop: prop, __func: func}];
                Object.defineProperty(this, propName, {
                    set: (value) => {
                        this[`__prop_${propName}`] = value;
                        for (const {__obj, __prop, __func} of this[`__prop_bindings_${propName}`]) {
                            __obj[__prop] = __func(this);
                        }
                    },
                    get: () => this[`__prop_${propName}`]
                });
            } else {
                this[`__prop_bindings_${propName}`].push({__obj: obj, __prop: prop, __func: func});
            }
        }
    }

    /**
     * Returns a high-performance template patcher.
     */
    static getTemplateFunc(ctx) {
        // We need a different template function per patch id.
        const name = "_templateFunc";

        // Be careful with class-based static inheritance.
        const hasName = '__has' + name;
        if (this[hasName] !== this) {
            this[hasName] = this;
            this[name] = this.parseTemplate(this._template(ctx));
        }
        return this[name];
    }

    static parseTemplate(obj) {
        const context = {
            loc: [],
            store: [],
            rid: 0
        };

        this.parseTemplateRec(obj, context, "element");

        const code = context.loc.join(";\n");
        const f = new Function("element", "store", code);
        return {f: f, a: context.store};
    }

    static parseTemplateRec(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            let value = obj[key];
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isUcChar(key.charCodeAt(0))) {
                // Value must be expanded as well.
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    // Ref.
                    const childCursor = `r${key.replace(/[^a-z0-9]/gi, "") + context.rid}`;
                    let type = value.type ? value.type : _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
                    if (type === _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]) {
                        loc.push(`var ${childCursor} = element.stage.createElement()`);
                    } else {
                        store.push(type);
                        loc.push(`var ${childCursor} = new store[${store.length - 1}](${cursor}.stage)`);
                    }
                    loc.push(`${childCursor}.ref = "${key}"`);
                    context.rid++;

                    // Enter sub.
                    this.parseTemplateRec(value, context, childCursor);

                    loc.push(`${cursor}.childList.add(${childCursor})`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value)) {
                    // Dynamic assignment.
                    store.push(value);
                    loc.push(`${cursor}.childList.add(store[${store.length - 1}])`);
                }
            } else {
                if (key === "text") {
                    const propKey = cursor + "__text";
                    loc.push(`var ${propKey} = ${cursor}.enableTextTexture()`);
                    if (value.__propertyBinding === true) {
                        // Allow binding entire objects to text property
                        store.push(value);
                        loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                    } else {
                        this.parseTemplatePropRec(value, context, propKey);
                    }
                } else if (key === "shader" && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    const shaderCursor = `${cursor}["shader"]`
                    store.push(value);
                    loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                    this.parsePropertyBindings(value, context, shaderCursor);
                } else if (key === "texture" && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value)) {
                    const propKey = cursor + "__texture";
                    const type = value.type;
                    if (type) {
                        store.push(type);
                        loc.push(`var ${propKey} = new store[${store.length - 1}](${cursor}.stage)`);
                        this.parseTemplatePropRec(value, context, propKey);
                        loc.push(`${cursor}["${key}"] = ${propKey}`);
                    } else {
                        loc.push(`${propKey} = ${cursor}.texture`);
                        this.parseTemplatePropRec(value, context, propKey);
                    }
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else {
                    // Property;
                    if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(value)) {
                        loc.push(`${cursor}["${key}"] = ${value}`);
                    } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(value)) {
                        loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                    } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) || Array.isArray(value)) {
                        // Dynamic assignment.
                        // Because literal objects may contain dynamics, we store the full object.
                        store.push(value);
                        loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                    } else {
                        // String etc.
                        loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                    }
                }
            }
        });
    }

    static parseTemplatePropRec(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            if (key !== "type") {
                const value = obj[key];
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(value)) {
                    loc.push(`${cursor}["${key}"] = ${value}`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(value)) {
                    loc.push(`${cursor}["${key}"] = ${value ? "true" : "false"}`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(value) || Array.isArray(value)) {
                    // Dynamic assignment.
                    // Because literal objects may contain dynamics, we store the full object.
                    store.push(value);
                    loc.push(`${cursor}["${key}"] = store[${store.length - 1}]`);
                } else {
                    // String etc.
                    loc.push(`${cursor}["${key}"] = ${JSON.stringify(value)}`);
                }
            }
        });
    }

    static parsePropertyBindings(obj, context, cursor) {
        const store = context.store;
        const loc = context.loc;
        const keys = Object.keys(obj);
        keys.forEach(key => {
            if (key !== "type") {
                const value = obj[key];
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(value) && value.__propertyBinding === true) {
                    store.push(value);
                    loc.push(`element.__bindProperty(store[${store.length - 1}], ${cursor}, "${key}")`);
                }
            }
        });
    }

    _onSetup() {
        if (!this.__initialized) {
            this._setup();
        }
    }

    _setup() {
    }

    _onAttach() {
        if (!this.__initialized) {
            this.__init();
            this.__initialized = true;
        }

        this._attach();
    }

    _attach() {
    }

    _onDetach() {
        this._detach();
    }

    _detach() {
    }

    _onEnabled() {
        if (!this.__firstEnable) {
            this._firstEnable();
            this.__firstEnable = true;
        }

        this._enable();
    }

    _firstEnable() {
    }

    _enable() {
    }

    _onDisabled() {
        this._disable();
    }

    _disable() {
    }

    _onActive() {
        if (!this.__firstActive) {
            this._firstActive();
            this.__firstActive = true;
        }

        this._active();
    }

    _firstActive() {
    }

    _active() {
    }

    _onInactive() {
        this._inactive();
    }

    _inactive() {
    }

    get application() {
        return this.stage.application;
    }

    __construct() {
        this._construct();
    }

    _construct() {
    }

    _build() {
    }

    __init() {
        this._init();
    }

    _init() {
    }

    _focus(newTarget, prevTarget) {
    }

    _unfocus(newTarget) {
    }

    _focusChange(target, newTarget) {
    }

    _getFocused() {
        // Override to delegate focus to child components.
        return this;
    }

    _setFocusSettings(settings) {
        // Override to add custom settings. See Application._handleFocusSettings().
    }

    _handleFocusSettings(settings) {
        // Override to react on custom settings. See Application._handleFocusSettings().
    }

    static _template() {
        return {};
    }

    hasFinalFocus() {
        let path = this.application._focusPath;
        return path && path.length && path[path.length - 1] === this;
    }

    hasFocus() {
        let path = this.application._focusPath;
        return path && (path.indexOf(this) >= 0);
    }

    get cparent() {
        return Component.getParent(this);
    }

    seekAncestorByType(type) {
        let c = this.cparent;
        while (c) {
            if (c.constructor === type) {
                return c;
            }
            c = c.cparent;
        }
    }

    getSharedAncestorComponent(element) {
        let ancestor = this.getSharedAncestor(element);
        while (ancestor && !ancestor.isComponent) {
            ancestor = ancestor.parent;
        }
        return ancestor;
    }

    get signals() {
        return this.__signals;
    }

    set signals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        this.__signals = v;
    }

    set alterSignals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        if (!this.__signals) {
            this.__signals = {};
        }
        for (let key in v) {
            const d = v[key];
            if (d === undefined) {
                delete this.__signals[key];
            } else {
                this.__signals[key] = v;
            }
        }
    }

    get passSignals() {
        return this.__passSignals || {};
    }

    set passSignals(v) {
        this.__passSignals = Object.assign(this.__passSignals || {}, v);
    }

    set alterPassSignals(v) {
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._throwError("Signals: specify an object with signal-to-fire mappings");
        }
        if (!this.__passSignals) {
            this.__passSignals = {};
        }
        for (let key in v) {
            const d = v[key];
            if (d === undefined) {
                delete this.__passSignals[key];
            } else {
                this.__passSignals[key] = v;
            }
        }
    }

    /**
     * Signals the parent of the specified event.
     * A parent/ancestor that wishes to handle the signal should set the 'signals' property on this component.
     * @param {string} event
     * @param {...*} args
     */
    signal(event, ...args) {
        return this._signal(event, args);
    }

    _signal(event, args) {
        const signalParent = this._getParentSignalHandler();
        if (signalParent) {
            if (this.__signals) {
                let fireEvent = this.__signals[event];
                if (fireEvent === false) {
                    // Ignore event.
                    return;
                }
                if (fireEvent) {
                    if (fireEvent === true) {
                        fireEvent = event;
                    }
 
                    if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(fireEvent)) {
                        return fireEvent(...args);
                    }

                    if (signalParent._hasMethod(fireEvent)) {
                        return signalParent[fireEvent](...args);
                    }
                }
            }

            let passSignal = (this.__passSignals && this.__passSignals[event]);
            if (passSignal) {
                // Bubble up.
                if (passSignal && passSignal !== true) {
                    // Replace signal name.
                    event = passSignal;
                }

                return signalParent._signal(event, args);
            }
        }
    }

    _getParentSignalHandler() {
        return this.cparent ? this.cparent._getSignalHandler() : null;
    }

    _getSignalHandler() {
        if (this._signalProxy) {
            return this.cparent ? this.cparent._getSignalHandler() : null;
        }
        return this;
    }

    get _signalProxy() {
        return false;
    }

    fireAncestors(name, ...args) {
        if (!name.startsWith('$')) {
            throw new Error("Ancestor event name must be prefixed by dollar sign.");
        }

        const parent = this._getParentSignalHandler();
        if (parent) {
            return parent._doFireAncestors(name, args);
        }
    }

    _doFireAncestors(name, args) {
        if (this._hasMethod(name)) {
            return this.fire(name, ...args);
        } else {
            const signalParent = this._getParentSignalHandler();
            if (signalParent) {
                return signalParent._doFireAncestors(name, args);
            }
        }
    }

    static collectSubComponents(subs, element) {
        if (element.hasChildren()) {
            const childList = element.__childList;
            for (let i = 0, n = childList.length; i < n; i++) {
                const child = childList.getAt(i);
                if (child.isComponent) {
                    subs.push(child);
                } else {
                    Component.collectSubComponents(subs, child);
                }
            }
        }
    }

    static getComponent(element) {
        let parent = element;
        while (parent && !parent.isComponent) {
            parent = parent.parent;
        }
        return parent;
    }

    static getParent(element) {
        return Component.getComponent(element.parent);
    }
}

Component.prototype.isComponent = true;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/application/StateMachine.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/application/StateMachine.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StateMachine)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class StateMachine {

    constructor() {
        StateMachine.setupStateMachine(this);
    }

    static setupStateMachine(target) {
        const targetConstructor = target.constructor;
        const router = StateMachine.create(targetConstructor);
        Object.setPrototypeOf(target, router.prototype);
        target.constructor = targetConstructor;
        target._initStateMachine();
    }

    /**
     * Creates a state machine implementation.
     * It extends the original type and should be used when creating new instances.
     * The original type is available as static property 'original', and it must be used when subclassing as follows:
     * const type = StateMachine.create(class YourNewStateMachineClass extends YourBaseStateMachineClass.original {  })
     * @param {Class} type
     * @returns {StateMachine}
     */
    static create(type) {
        if (!type.hasOwnProperty('_sm')) {
            // Only need to run once.
            const stateMachineType = new StateMachineType(type);
            type._sm = stateMachineType;
        }

        return type._sm.router;
    }

    /**
     * Calls the specified method if it exists.
     * @param {string} event
     * @param {*...} args
     */
    fire(event, ...args) {
        if (this._hasMethod(event)) {
            return this[event](...args);
        }
    }

    /**
     * Returns the current state path (for example "Initialized.Loading").
     * @returns {string}
     * @protected
     */
    _getState() {
        return this._state.__path;
    }

    /**
     * Returns true iff statePath is (an ancestor of) currentStatePath.
     * @param {string} statePath
     * @param {string} currentStatePath
     * @returns {Boolean}
     * @protected
     */
    _inState(statePath, currentStatePath = this._state.__path) {
        const state = this._sm.getStateByPath(statePath);
        const currentState = this._sm.getStateByPath(currentStatePath);
        const level = state.__level;
        const stateAtLevel = StateMachine._getStateAtLevel(currentState, level);
        return (stateAtLevel === state);
    }

    /**
     * Returns true if the specified class member is defined for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMember(name) {
        return !!this.constructor.prototype[name];
    }

    /**
     * Returns true if the specified class member is a method for the currently set state.
     * @param {string} name
     * @returns {boolean}
     * @protected
     */
    _hasMethod(name) {
        const member = this.constructor.prototype[name];
        return !!member && (typeof member === "function")
    }

    /**
     * Switches to the specified state.
     * @param {string} statePath
     *   Substates are seperated by a underscores (for example "Initialized.Loading").
     * @param {*[]} [args]
     *   Args that are supplied in $enter and $exit events.
     * @protected
     */
    _setState(statePath, args) {
        const setStateId = ++this._setStateCounter;
        this._setStateId = setStateId;

        if (this._state.__path !== statePath) {
            // Performance optimization.
            let newState = this._sm._stateMap[statePath];
            if (!newState) {
                // Check for super state.
                newState = this._sm.getStateByPath(statePath);
            }

            const prevState = this._state;

            const hasDifferentEnterMethod = (newState.prototype.$enter !== this._state.prototype.$enter);
            const hasDifferentExitMethod = (newState.prototype.$exit !== this._state.prototype.$exit);
            if (hasDifferentEnterMethod || hasDifferentExitMethod) {
                const sharedState = StateMachine._getSharedState(this._state, newState);
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path,
                    sharedState: sharedState.__path
                };
                const sharedLevel = sharedState.__level;

                if (hasDifferentExitMethod) {
                    const exitStates = StateMachine._getStatesUntilLevel(this._state, sharedLevel);
                    for (let i = 0, n = exitStates.length; i < n; i++) {
                        this.__setState(exitStates[i]);
                        this._callExit(this._state, args, context);
                        const stateChangeOverridden = (this._setStateId !== setStateId);
                        if (stateChangeOverridden) {
                            return;
                        }
                    }
                }

                if (hasDifferentEnterMethod) {
                    const enterStates = StateMachine._getStatesUntilLevel(newState, sharedLevel).reverse();
                    for (let i = 0, n = enterStates.length; i < n; i++) {
                        this.__setState(enterStates[i]);
                        this._callEnter(this._state, args, context);
                        const stateChangeOverridden = (this._setStateId !== setStateId);
                        if (stateChangeOverridden) {
                            return;
                        }
                    }
                }

            }

            this.__setState(newState);

            if (this._changedState) {
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path
                };

                if (args) {
                    this._changedState(context, ...args);
                } else {
                    this._changedState(context);
                }
            }

            if (this._onStateChange) {
                const context = {
                    newState: newState.__path,
                    prevState: prevState.__path
                };
                this._onStateChange(context);
            }

        }
    }

    _callEnter(state, args = [], context) {
        const hasParent = !!state.__parent;
        if (state.prototype.$enter) {
            if (!hasParent || (state.__parent.prototype.$enter !== state.prototype.$enter)) {
                state.prototype.$enter.apply(this, [context, ...args]);
            }
        }
    }

    _callExit(state, args = [], context) {
        const hasParent = !!state.__parent;
        if (state.prototype.$exit) {
            if (!hasParent || (state.__parent.prototype.$exit !== state.prototype.$exit)) {
                state.prototype.$exit.apply(this, [context, ...args]);
            }
        }
    }

    __setState(state) {
        this._state = state;
        this._stateIndex = state.__index;
        this.constructor = state;
    }

    _initStateMachine() {
        this._state = null;
        this._stateIndex = 0;
        this._setStateCounter = 0;
        this._sm = this._routedType._sm;
        this.__setState(this._sm.getStateByPath(""));
        const context = {newState: "", prevState: undefined, sharedState: undefined};
        this._callEnter(this._state, [], context);
        this._onStateChange = undefined;
    }

    /**
     * Between multiple member names, select the one specified in the deepest state.
     * If multiple member names are specified in the same deepest state, the first one in the array is returned.
     * @param {string[]} memberNames
     * @returns {string|undefined}
     * @protected
     */
    _getMostSpecificHandledMember(memberNames) {
        let cur = this._state;
        do {
            for (let i = 0, n = memberNames.length; i < n; i++) {
                const memberName = memberNames[i];
                if (!cur.__parent) {
                    if (cur.prototype[memberName]) {
                        return memberName;
                    }
                } else {
                    const alias = StateMachineType.getStateMemberAlias(cur.__path, memberName);
                    if (this[alias]) {
                        return memberName;
                    }
                }
            }
            cur = cur.__parent;
        } while (cur);
    }

    static _getStatesUntilLevel(state, level) {
        const states = [];
        while (state.__level > level) {
            states.push(state);
            state = state.__parent;
        }
        return states;
    }

    static _getSharedState(state1, state2) {
        const state1Array = StateMachine._getAncestorStates(state1);
        const state2Array = StateMachine._getAncestorStates(state2);
        const n = Math.min(state1Array.length, state2Array.length);
        for (let i = 0; i < n; i++) {
            if (state1Array[i] !== state2Array[i]) {
                return state1Array[i - 1];
            }
        }
        return state1Array[n - 1];
    }

    static _getAncestorStates(state) {
        const result = [];
        do {
            result.push(state);
        } while(state = state.__parent);
        return result.reverse();
    }

    static _getStateAtLevel(state, level) {
        if (level > state.__level) {
            return undefined;
        }

        while(level < state.__level) {
            state = state.__parent;
        }
        return state;
    }
}

class StateMachineType {

    constructor(type) {
        this._type = type;
        this._router = null;

        this.init();
    }

    get router() {
        return this._router;
    }

    init() {
        this._router = this._createRouter();

        this._stateMap = this._getStateMap();

        this._addStateMemberDelegatorsToRouter();

    }

    _createRouter() {
        const type = this._type;

        const router = class StateMachineRouter extends type {
            constructor() {
                super(...arguments);
                if (!this.constructor.hasOwnProperty('_isRouter')) {
                    throw new Error(`You need to extend ${type.name}.original instead of ${type.name}.`);
                }
            }
        };
        router._isRouter = true;
        router.prototype._routedType = type;
        router.original = type;

        this._mixinStateMachineMethods(router);

        return router;
    }

    _mixinStateMachineMethods(router) {
        // Mixin the state machine methods, so that we reuse the methods instead of re-creating them.
        const names = Object.getOwnPropertyNames(StateMachine.prototype);
        for (let i = 0, n = names.length; i < n; i++) {
            const name = names[i];
            if (name !== "constructor") {
                const descriptor = Object.getOwnPropertyDescriptor(StateMachine.prototype, name);
                Object.defineProperty(router.prototype, name, descriptor);
            }
        }
    }

    _addStateMemberDelegatorsToRouter() {
        const members = this._getAllMemberNames();

        members.forEach(member => {
            this._addMemberRouter(member);
        });
    }

    /**
     * @note We are generating code because it yields much better performance.
     */
    _addMemberRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member);
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        let type = undefined;
        descriptors.forEach(descriptor => {
            if (descriptor) {
                const descType = this._getDescriptorType(descriptor);
                if (type && (type !== descType)) {
                    console.warn(`[Lightning] Member ${member} in ${this._type.name} has inconsistent types.`);
                    return;
                }
                type = descType;
            }
        });

        switch(type) {
            case "method":
                this._addMethodRouter(member, descriptors, aliases);
                break;
            case "getter":
                this._addGetterSetterRouters(member);
                break;
            case "property":
                console.warn("[Lightning] Fixed properties are not supported; please use a getter instead!")
                break;
        }
    }

    _getDescriptor(state, member, isValid = () => true) {
        let type = state;
        let curState = state;

        do {
            const descriptor = Object.getOwnPropertyDescriptor(type.prototype, member);
            if (descriptor) {
                if (isValid(descriptor)) {
                    descriptor._source = curState;
                    return descriptor;
                }
            }
            type = Object.getPrototypeOf(type);
            if (type && type.hasOwnProperty('__state')) {
                curState = type;
            }
        } while(type && type.prototype);
        return undefined;
    }

    _getDescriptorType(descriptor) {
        if (descriptor.get || descriptor.set) {
            return 'getter';
        } else {
            if (typeof descriptor.value === "function") {
                return 'method';
            } else {
                return 'property';
            }
        }
    }

    static _supportsSpread() {
        if (this.__supportsSpread === undefined) {
            this.__supportsSpread = false;
            try {
                const func = new Function("return [].concat(...arguments);");
                func();
                this.__supportsSpread = true;
            } catch(e) {}
        }
        return this.__supportsSpread;
    }

    _addMethodRouter(member, descriptors, aliases) {
        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        const supportsSpread = StateMachineType._supportsSpread();
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    if (supportsSpread) {
                        code.push(`if (i < ${i}) return this["${cur}"](...arguments); else`);
                    } else {
                        code.push(`if (i < ${i}) return this["${cur}"].apply(this, arguments); else`);
                    }
                } else {
                    code.push(`if (i < ${i}) return ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            if (supportsSpread) {
                code.push(`return this["${cur}"](...arguments);`);
            } else {
                code.push(`return this["${cur}"].apply(this, arguments);`);
            }
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function([], functionBody);

        const descriptor = {value: router};
        Object.defineProperty(this._router.prototype, member, descriptor);
    }

    _addGetterSetterRouters(member) {
        const getter = this._getGetterRouter(member);
        const setter = this._getSetterRouter(member);
        const descriptor = {
            get: getter,
            set: setter
        };
        Object.defineProperty(this._router.prototype, member, descriptor);
    }

    _getGetterRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.get));
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    code.push(`if (i < ${i}) return this["${cur}"]; else`);
                } else {
                    code.push(`if (i < ${i}) return ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            code.push(`return this["${cur}"];`);
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function([], functionBody);
        return router;
    }

    _getSetterRouter(member) {
        const statePaths = Object.keys(this._stateMap);
        const descriptors = [];
        const aliases = [];
        statePaths.forEach((statePath, index) => {
            const state = this._stateMap[statePath];
            const descriptor = this._getDescriptor(state, member, (descriptor => descriptor.set));
            if (descriptor) {
                descriptors[index] = descriptor;

                // Add to prototype.
                const alias = StateMachineType.getStateMemberAlias(descriptor._source.__path, member);
                aliases[index] = alias;

                if (!this._router.prototype.hasOwnProperty(alias)) {
                    Object.defineProperty(this._router.prototype, alias, descriptor);
                }
            } else {
                descriptors[index] = null;
                aliases[index] = null;
            }
        });

        const code = [
            // The line ensures that, while debugging, your IDE won't open many tabs.
            "//@ sourceURL=StateMachineRouter.js",
            "var i = this._stateIndex;"
        ];
        let cur = aliases[0];
        for (let i = 1, n = aliases.length; i < n; i++) {
            const alias = aliases[i];
            if (alias !== cur) {
                if (cur) {
                    code.push(`if (i < ${i}) this["${cur}"] = arg; else`);
                } else {
                    code.push(`if (i < ${i}) ; else`);
                }
            }
            cur = alias;
        }
        if (cur) {
            code.push(`this["${cur}"] = arg;`);
        } else {
            code.push(`;`);
        }
        const functionBody = code.join("\n");
        const router = new Function(["arg"], functionBody);
        return router;
    }

    static getStateMemberAlias(path, member) {
        return "$" + (path ? path + "." : "") + member;
    }

    _getAllMemberNames() {
        const stateMap = this._stateMap;
        const map = Object.keys(stateMap);
        let members = new Set();
        map.forEach(statePath => {
            if (statePath === "") {
                // Root state can be skipped: if the method only occurs in the root state, we don't need to re-delegate it based on state.
                return;
            }
            const state = stateMap[statePath];
            const names = this._getStateMemberNames(state);
            names.forEach(name => {
                members.add(name);
            })
        });
        return [...members];
    }

    _getStateMemberNames(state) {
        let type = state;
        let members = new Set();
        const isRoot = this._type === state;
        do {
            const names = this._getStateMemberNamesForType(type);
            names.forEach(name => {
                members.add(name)
            });

            type = Object.getPrototypeOf(type);
        } while(type && type.prototype && (!type.hasOwnProperty("__state") || isRoot));

        return members;
    }

    _getStateMemberNamesForType(type) {
        const memberNames = Object.getOwnPropertyNames(type.prototype);
        return memberNames.filter(memberName => {
            return (memberName !== "constructor") && !StateMachineType._isStateLocalMember(memberName);
        });
    }

    static _isStateLocalMember(memberName) {
        return (memberName === "$enter") || (memberName === "$exit");
    }

    getStateByPath(statePath) {
        if (this._stateMap[statePath]) {
            return this._stateMap[statePath];
        }

        // Search for closest match.
        const parts = statePath.split(".");
        while(parts.pop()) {
            const statePath = parts.join(".");
            if (this._stateMap[statePath]) {
                return this._stateMap[statePath];
            }
        }
    }

    _getStateMap() {
        if (!this._stateMap) {
            this._stateMap = this._createStateMap();
        }
        return this._stateMap;
    }

    _createStateMap() {
        const stateMap = {};
        this._addState(this._type, null, "", stateMap);
        return stateMap;
    }

    _addState(state, parentState, name, stateMap) {
        state.__state = true;
        state.__name = name;

        this._addStaticStateProperty(state, parentState);

        const parentPath = (parentState ? parentState.__path : "");
        let path = (parentPath ? parentPath + "." : "") + name;
        state.__path = path;
        state.__level = parentState ? parentState.__level + 1 : 0;
        state.__parent = parentState;
        state.__index = Object.keys(stateMap).length;
        stateMap[path] = state;

        const states = state._states;
        if (states) {
            const isInheritedFromParent = (parentState && parentState._states === states);
            if (!isInheritedFromParent) {
                const subStates = state._states();
                subStates.forEach(subState => {
                    const stateName = StateMachineType._getStateName(subState);
                    this._addState(subState, state, stateName, stateMap);
                });
            }
        }
    }

    static _getStateName(state) {
        const name = state.name;

        const index = name.indexOf('$');
        if (index > 0) {
            // Strip off rollup name suffix.
            return name.substr(0, index);
        }

        return name;
    }

    _addStaticStateProperty(state, parentState) {
        if (parentState) {
            const isClassStateLevel = parentState && !parentState.__parent;
            if (isClassStateLevel) {
                this._router[state.__name] = state;
            } else {
                parentState[state.__name] = state;
            }
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/BloomComponent.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/BloomComponent.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BloomComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class BloomComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        const onUpdate = function(element, elementCore) {
            if ((elementCore._recalc & (2 + 128))) {
                const w = elementCore.w;
                const h = elementCore.h;
                let cur = elementCore;
                do {
                    cur = cur._children[0];
                    cur._element.w = w;
                    cur._element.h = h;
                } while(cur._children);
            }
        };

        return {
            Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true,
                BloomBase: {shader: {type: BloomBaseShader},
                    Content: {}
                }
            },
            Layers: {
                L0: {rtt: true, onUpdate: onUpdate, scale: 2, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L1: {rtt: true, onUpdate: onUpdate, scale: 4, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L2: {rtt: true, onUpdate: onUpdate, scale: 8, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L3: {rtt: true, onUpdate: onUpdate, scale: 16, pivot: 0, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}}
            }
        }
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap.Content");
        this._layers = this.sel("Layers");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;
    }

    _build() {
        const filterShaderSettings = [{x:1,y:0,kernelRadius:3},{x:0,y:1,kernelRadius:3},{x:1.5,y:0,kernelRadius:3},{x:0,y:1.5,kernelRadius:3}];
        const filterShaders = filterShaderSettings.map(s => {
            const shader = this.stage.createShader(Object.assign({type: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]}, s));
            return shader;
        });

        this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
        this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

        // Notice that 1.5 filters should be applied before 1.0 filters.
        this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
        this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }

    _setLayerTexture(element, texture, steps) {
        if (!steps.length) {
            element.texture = texture;
        } else {
            const step = steps.pop();
            const child = element.stage.c({rtt: true, shader: step});

            // Recurse.
            this._setLayerTexture(child, texture, steps);

            element.childList.add(child);
        }
        return element;
    }

    get content() {
        return this.sel('Textwrap.Content');
    }

    set content(v) {
        this.sel('Textwrap.Content').patch(v);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    getLayer(i) {
        return this._layers.sel("L" + i);
    }

    getLayerContents(i) {
        return this.getLayer(i).sel("Content");
    }

    _onResize() {
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        let fw = w + paddingX * 2;
        let fh = h + paddingY * 2;
        this._textwrap.w = fw;
        this._wrapper.x = paddingX;
        this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
        this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
        this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
        this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
        this._textwrap.x = -paddingX;

        this._textwrap.h = fh;
        this._wrapper.y = paddingY;
        this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
        this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
        this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
        this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
        this._textwrap.y = -paddingY;

        this.w = w;
        this.h = h;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._update();
    }

    get amount() {
        return this._amount;
    }

    _update() {
        let v = Math.min(4, Math.max(0, this._amount));
        if (v > 0) {
            this.getLayer(0).visible = (v > 0);
            this.getLayer(1).visible = (v > 1);
            this.getLayer(2).visible = (v > 2);
            this.getLayer(3).visible = (v > 3);
        }
    }

    set shader(s) {
        super.shader = s;
        if (!this.renderToTexture) {
            console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
        }
    }

    _firstActive() {
        this._build();
    }

}

class BloomBaseShader extends _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {
}

BloomBaseShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float m = max(max(color.r, color.g), color.b);
        float c = max(0.0, (m - 0.80)) * 5.0;
        color = color * c;
        gl_FragColor = color;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/BorderComponent.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/BorderComponent.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BorderComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class BorderComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            Content: {},
            Borders: {
                Top: {rect: true, visible: false, mountY: 1},
                Right: {rect: true, visible: false},
                Bottom: {rect: true, visible: false},
                Left: {rect: true, visible: false, mountX: 1}
            }
        };
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);

        this._borderTop = this.tag("Top");
        this._borderRight = this.tag("Right");
        this._borderBottom = this.tag("Bottom");
        this._borderLeft = this.tag("Left");

        this.onAfterUpdate = function (element) {
            const content = element.childList.first;
            let w = element.core.w || content.renderWidth;
            let h = element.core.h || content.renderHeight;
            element._borderTop.w = w;
            element._borderBottom.y = h;
            element._borderBottom.w = w;
            element._borderLeft.h = h + element._borderTop.h + element._borderBottom.h;
            element._borderLeft.y = -element._borderTop.h;
            element._borderRight.x = w;
            element._borderRight.h = h + element._borderTop.h + element._borderBottom.h;
            element._borderRight.y = -element._borderTop.h;
        };

        this.borderWidth = 1;
    }

    get content() {
        return this.sel('Content');
    }

    set content(v) {
        this.sel('Content').patch(v, true);
    }

    get borderWidth() {
        return this.borderWidthTop;
    }

    get borderWidthTop() {
        return this._borderTop.h;
    }

    get borderWidthRight() {
        return this._borderRight.w;
    }

    get borderWidthBottom() {
        return this._borderBottom.h;
    }

    get borderWidthLeft() {
        return this._borderLeft.w;
    }

    set borderWidth(v) {
        this.borderWidthTop = v;
        this.borderWidthRight = v;
        this.borderWidthBottom = v;
        this.borderWidthLeft = v;
    }

    set borderWidthTop(v) {
        this._borderTop.h = v;
        this._borderTop.visible = (v > 0);
    }

    set borderWidthRight(v) {
        this._borderRight.w = v;
        this._borderRight.visible = (v > 0);
    }

    set borderWidthBottom(v) {
        this._borderBottom.h = v;
        this._borderBottom.visible = (v > 0);
    }

    set borderWidthLeft(v) {
        this._borderLeft.w = v;
        this._borderLeft.visible = (v > 0);
    }

    get colorBorder() {
        return this.colorBorderTop;
    }

    get colorBorderTop() {
        return this._borderTop.color;
    }

    get colorBorderRight() {
        return this._borderRight.color;
    }

    get colorBorderBottom() {
        return this._borderBottom.color;
    }

    get colorBorderLeft() {
        return this._borderLeft.color;
    }

    set colorBorder(v) {
        this.colorBorderTop = v;
        this.colorBorderRight = v;
        this.colorBorderBottom = v;
        this.colorBorderLeft = v;
    }

    set colorBorderTop(v) {
        this._borderTop.color = v;
    }

    set colorBorderRight(v) {
        this._borderRight.color = v;
    }

    set colorBorderBottom(v) {
        this._borderBottom.color = v;
    }

    set colorBorderLeft(v) {
        this._borderLeft.color = v;
    }

    get borderTop() {
        return this._borderTop;
    }

    set borderTop(settings) {
        this.borderTop.patch(settings);
    }

    get borderRight() {
        return this._borderRight;
    }

    set borderRight(settings) {
        this.borderRight.patch(settings);
    }

    get borderBottom() {
        return this._borderBottom;
    }

    set borderBottom(settings) {
        this.borderBottom.patch(settings);
    }

    get borderLeft() {
        return this._borderLeft;
    }

    set borderLeft(settings) {
        this.borderLeft.patch(settings);
    }

    set borders(settings) {
        this.borderTop = settings;
        this.borderLeft = settings;
        this.borderBottom = settings;
        this.borderRight = settings;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FastBlurComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/c2d/shaders/BlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs");
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/MultiSpline.mjs */ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









class FastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    static _template() {
        return {}
    }

    get wrap() {
        return this.tag("Wrap");
    }

    set content(v) {
        return this.wrap.content = v;
    }

    get content() {
        return this.wrap.content;
    }

    set padding(v) {
        this.wrap._paddingX = v;
        this.wrap._paddingY = v;
        this.wrap._updateBlurSize();
    }

    set paddingX(v) {
        this.wrap._paddingX = v;
        this.wrap._updateBlurSize();
    }

    set paddingY(v) {
        this.wrap._paddingY = v;
        this.wrap._updateBlurSize();
    }

    set amount(v) {
        return this.wrap.amount = v;
    }

    get amount() {
        return this.wrap.amount;
    }

    _onResize() {
        this.wrap.w = this.renderWidth;
        this.wrap.h = this.renderHeight;
    }

    get _signalProxy() {
        return true;
    }

    _build() {
        this.patch({
            Wrap: {type: this.stage.gl ? WebGLFastBlurComponent : C2dFastBlurComponent}
        });
    }

}


class C2dFastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            forceZIndexContext: true,
            rtt: true,
            Textwrap: {shader: {type: _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_4__["default"]}, Content: {}}
        }
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap>Content");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;

    }

    static getSpline() {
        if (!this._multiSpline) {
            this._multiSpline = new _tools_MultiSpline_mjs__WEBPACK_IMPORTED_MODULE_6__["default"]();
            this._multiSpline.parse(false, {0: 0, 0.25: 1.5, 0.5: 5.5, 0.75: 18, 1: 39});
        }
        return this._multiSpline;
    }

    get content() {
        return this.sel('Textwrap>Content');
    }

    set content(v) {
        this.sel('Textwrap>Content').patch(v, true);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        this._wrapper.x = paddingX;
        this._textwrap.x = -paddingX;

        this._wrapper.y = paddingY;
        this._textwrap.y = -paddingY;

        this._textwrap.w = w + paddingX * 2;
        this._textwrap.h = h + paddingY * 2;
    }

    get amount() {
        return this._amount;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._textwrap.shader.kernelRadius = C2dFastBlurComponent._amountToKernelRadius(v);
    }

    static _amountToKernelRadius(v) {
        return C2dFastBlurComponent.getSpline().getValue(Math.min(1, v * 0.25));
    }

    get _signalProxy() {
        return true;
    }

}

class WebGLFastBlurComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        const onUpdate = function(element, elementCore) {
            if ((elementCore._recalc & (2 + 128))) {
                const w = elementCore.w;
                const h = elementCore.h;
                let cur = elementCore;
                do {
                    cur = cur._children[0];
                    cur._element.w = w;
                    cur._element.h = h;
                } while(cur._children);
            }
        };

        return {
            Textwrap: {rtt: true, forceZIndexContext: true, renderOffscreen: true, Content: {}},
            Layers: {
                L0: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L1: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L2: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}},
                L3: {rtt: true, onUpdate: onUpdate, renderOffscreen: true, visible: false, Content: {shader: {type: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_2__["default"]}}}
            },
            Result: {shader: {type: FastBlurOutputShader}, visible: false}
        }
    }

    get _signalProxy() {
        return true;
    }

    constructor(stage) {
        super(stage);
        this._textwrap = this.sel("Textwrap");
        this._wrapper = this.sel("Textwrap>Content");
        this._layers = this.sel("Layers");
        this._output = this.sel("Result");

        this._amount = 0;
        this._paddingX = 0;
        this._paddingY = 0;
    }

    _buildLayers() {
        const filterShaderSettings = [{x:1,y:0,kernelRadius:1},{x:0,y:1,kernelRadius:1},{x:1.5,y:0,kernelRadius:1},{x:0,y:1.5,kernelRadius:1}];
        const filterShaders = filterShaderSettings.map(s => {
            const shader = _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].create(this.stage, Object.assign({type: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]}, s));
            return shader;
        });

        this._setLayerTexture(this.getLayerContents(0), this._textwrap.getTexture(), []);
        this._setLayerTexture(this.getLayerContents(1), this.getLayer(0).getTexture(), [filterShaders[0], filterShaders[1]]);

        // Notice that 1.5 filters should be applied before 1.0 filters.
        this._setLayerTexture(this.getLayerContents(2), this.getLayer(1).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
        this._setLayerTexture(this.getLayerContents(3), this.getLayer(2).getTexture(), [filterShaders[0], filterShaders[1], filterShaders[2], filterShaders[3]]);
    }

    _setLayerTexture(element, texture, steps) {
        if (!steps.length) {
            element.texture = texture;
        } else {
            const step = steps.pop();
            const child = element.stage.c({rtt: true, shader: step});

            // Recurse.
            this._setLayerTexture(child, texture, steps);

            element.childList.add(child);
        }
        return element;
    }

    get content() {
        return this.sel('Textwrap>Content');
    }

    set content(v) {
        this.sel('Textwrap>Content').patch(v, true);
    }

    set padding(v) {
        this._paddingX = v;
        this._paddingY = v;
        this._updateBlurSize();
    }

    set paddingX(v) {
        this._paddingX = v;
        this._updateBlurSize();
    }

    set paddingY(v) {
        this._paddingY = v;
        this._updateBlurSize();
    }

    getLayer(i) {
        return this._layers.sel("L" + i);
    }

    getLayerContents(i) {
        return this.getLayer(i).sel("Content");
    }

    _onResize() {
        this._updateBlurSize();
    }

    _updateBlurSize() {
        let w = this.renderWidth;
        let h = this.renderHeight;

        let paddingX = this._paddingX;
        let paddingY = this._paddingY;

        let fw = w + paddingX * 2;
        let fh = h + paddingY * 2;
        this._textwrap.w = fw;
        this._wrapper.x = paddingX;
        this.getLayer(0).w = this.getLayerContents(0).w = fw / 2;
        this.getLayer(1).w = this.getLayerContents(1).w = fw / 4;
        this.getLayer(2).w = this.getLayerContents(2).w = fw / 8;
        this.getLayer(3).w = this.getLayerContents(3).w = fw / 16;
        this._output.x = -paddingX;
        this._textwrap.x = -paddingX;
        this._output.w = fw;

        this._textwrap.h = fh;
        this._wrapper.y = paddingY;
        this.getLayer(0).h = this.getLayerContents(0).h = fh / 2;
        this.getLayer(1).h = this.getLayerContents(1).h = fh / 4;
        this.getLayer(2).h = this.getLayerContents(2).h = fh / 8;
        this.getLayer(3).h = this.getLayerContents(3).h = fh / 16;
        this._output.y = -paddingY;
        this._textwrap.y = -paddingY;
        this._output.h = fh;

        this.w = w;
        this.h = h;
    }

    /**
     * Sets the amount of blur. A value between 0 and 4. Goes up exponentially for blur.
     * Best results for non-fractional values.
     * @param v;
     */
    set amount(v) {
        this._amount = v;
        this._update();
    }

    get amount() {
        return this._amount;
    }

    _update() {
        let v = Math.min(4, Math.max(0, this._amount));
        if (v === 0) {
            this._textwrap.renderToTexture = false;
            this._output.shader.otherTextureSource = null;
            this._output.visible = false;
        } else {
            this._textwrap.renderToTexture = true;
            this._output.visible = true;

            this.getLayer(0).visible = (v > 0);
            this.getLayer(1).visible = (v > 1);
            this.getLayer(2).visible = (v > 2);
            this.getLayer(3).visible = (v > 3);

            if (v <= 1) {
                this._output.texture = this._textwrap.getTexture();
                this._output.shader.otherTextureSource = this.getLayer(0).getTexture();
                this._output.shader.a = v;
            } else if (v <= 2) {
                this._output.texture = this.getLayer(0).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(1).getTexture();
                this._output.shader.a = v - 1;
            } else if (v <= 3) {
                this._output.texture = this.getLayer(1).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(2).getTexture();
                this._output.shader.a = v - 2;
            } else if (v <= 4) {
                this._output.texture = this.getLayer(2).getTexture();
                this._output.shader.otherTextureSource = this.getLayer(3).getTexture();
                this._output.shader.a = v - 3;
            }
        }
    }

    set shader(s) {
        super.shader = s;
        if (!this.renderToTexture) {
            console.warn("[Lightning] Please enable renderToTexture to use with a shader.");
        }
    }

    _firstActive() {
        this._buildLayers();
    }

}

/**
 * Shader that combines two textures into one output.
 */
class FastBlurOutputShader extends _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_3__["default"] {

    constructor(ctx) {
        super(ctx);

        this._a = 0;
        this._otherTextureSource = null;
    }

    get a() {
        return this._a;
    }

    set a(v) {
        this._a = v;
        this.redraw();
    }

    set otherTextureSource(v) {
        this._otherTextureSource = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("a", this._a, this.gl.uniform1f);
        this._setUniform("uSampler2", 1, this.gl.uniform1i);
    }

    beforeDraw(operation) {
        let glTexture = this._otherTextureSource ? this._otherTextureSource.nativeTexture : null;

        let gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.activeTexture(gl.TEXTURE0);
    }
}

FastBlurOutputShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uSampler2;
    uniform float a;
    void main(void){
        if (a == 1.0) {
            gl_FragColor = texture2D(uSampler2, vTextureCoord) * vColor;
        } else {
            gl_FragColor = ((1.0 - a) * texture2D(uSampler, vTextureCoord) + (a * texture2D(uSampler2, vTextureCoord))) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/ListComponent.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/ListComponent.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ListComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../tools/ObjectListWrapper.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ListComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._wrapper = super._children.a({});

        this._reloadVisibleElements = false;

        this._visibleItems = new Set();

        this._index = 0;

        this._started = false;

        /**
         * The transition definition that is being used when scrolling the items.
         * @type TransitionSettings
         */
        this._scrollTransitionSettings = this.stage.transitions.createSettings({});

        /**
         * The scroll area size in pixels per item.
         */
        this._itemSize = 100;

        this._viewportScrollOffset = 0;

        this._itemScrollOffset = 0;

        /**
         * Should the list jump when scrolling between end to start, or should it be continuous, like a carrousel?
         */
        this._roll = false;

        /**
         * Allows restricting the start scroll position.
         */
        this._rollMin = 0;

        /**
         * Allows restricting the end scroll position.
         */
        this._rollMax = 0;

        /**
         * Definition for a custom animation that is applied when an item is (partially) selected.
         * @type AnimationSettings
         */
        this._progressAnimation = null;

        /**
         * Inverts the scrolling direction.
         * @type {boolean}
         * @private
         */
        this._invertDirection = false;

        /**
         * Layout the items horizontally or vertically?
         * @type {boolean}
         * @private
         */
        this._horizontal = true;

        this.itemList = new ListItems(this);
    }

    _allowChildrenAccess() {
        return false;
    }

    get items() {
        return this.itemList.get();
    }

    set items(children) {
        this.itemList.patch(children);
    }

    start() {
        this._wrapper.transition(this.property, this._scrollTransitionSettings);
        this._scrollTransition = this._wrapper.transition(this.property);
        this._scrollTransition.on('progress', p => this.update());

        this.setIndex(0, true, true);

        this._started = true;

        this.update();
    }

    setIndex(index, immediate = false, closest = false) {
        let nElements = this.length;
        if (!nElements) return;

        this.emit('unfocus', this.getElement(this.realIndex), this._index, this.realIndex);

        if (closest) {
            // Scroll to same offset closest to the index.
            let offset = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);
            let o = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this.index, nElements);
            let diff = offset - o;
            if (diff > 0.5 * nElements) {
                diff -= nElements;
            } else if (diff < -0.5 * nElements) {
                diff += nElements;
            }
            this._index += diff;
        } else {
            this._index = index;
        }

        if (this._roll || (this.viewportSize > this._itemSize * nElements)) {
            this._index = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this._index, nElements);
        }

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
        let value = direction * this._index * this._itemSize;

        if (this._roll) {
            let min, max, scrollDelta;
            if (direction == 1) {
                max = (nElements - 1) * this._itemSize;
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;

                max -= scrollDelta;

                min = this.viewportSize - (this._itemSize + scrollDelta);

                if (this._rollMin) min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;

                value = Math.max(Math.min(value, max), min);
            } else {
                max = (nElements * this._itemSize - this.viewportSize);
                scrollDelta = this._viewportScrollOffset * this.viewportSize - this._itemScrollOffset * this._itemSize;

                max += scrollDelta;

                let min = scrollDelta;

                if (this._rollMin) min -= this._rollMin;
                if (this._rollMax) max += this._rollMax;

                value = Math.min(Math.max(-max, value), -min);
            }
        }

        this._scrollTransition.start(value);

        if (immediate) {
            this._scrollTransition.finish();
        }

        this.emit('focus', this.getElement(this.realIndex), this._index, this.realIndex);
    }

    getAxisPosition() {
        let target = -this._scrollTransition._targetValue;

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);
        let value = -direction * this._index * this._itemSize;

        return this._viewportScrollOffset * this.viewportSize + (value - target);
    }

    update() {
        if (!this._started) return;

        let nElements = this.length;
        if (!nElements) return;

        let direction = (this._horizontal ^ this._invertDirection ? -1 : 1);

        // Map position to index value.
        let v = (this._horizontal ? this._wrapper.x : this._wrapper.y);

        let viewportSize = this.viewportSize;
        let scrollDelta = this._viewportScrollOffset * viewportSize - this._itemScrollOffset * this._itemSize;
        v += scrollDelta;

        let s, e, ps, pe;
        if (direction == -1) {
            s = Math.floor(-v / this._itemSize);
            ps = 1 - ((-v / this._itemSize) - s);
            e = Math.floor((viewportSize - v) / this._itemSize);
            pe = (((viewportSize - v) / this._itemSize) - e);
        } else {
            s = Math.ceil(v / this._itemSize);
            ps = 1 + (v / this._itemSize) - s;
            e = Math.ceil((v - viewportSize) / this._itemSize);
            pe = e - ((v - viewportSize) / this._itemSize);
        }
        if (this._roll || (viewportSize > this._itemSize * nElements)) {
            // Don't show additional items.
            if (e >= nElements) {
                e = nElements - 1;
                pe = 1;
            }
            if (s >= nElements) {
                s = nElements - 1;
                ps = 1;
            }
            if (e <= -1) {
                e = 0;
                pe = 1;
            }
            if (s <= -1) {
                s = 0;
                ps = 1;
            }
        }

        let offset = -direction * s * this._itemSize;

        let item;
        for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
            let realIndex = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);

            let element = this.getElement(realIndex);
            item = element.parent;
            this._visibleItems.delete(item);
            if (this._horizontal) {
                item.x = offset + scrollDelta;
            } else {
                item.y = offset + scrollDelta;
            }

            let wasVisible = item.visible;
            item.visible = true;

            if (!wasVisible || this._reloadVisibleElements) {
                // Turned visible.
                this.emit('visible', index, realIndex);
            }



            if (this._progressAnimation) {
                let p = 1;
                if (index == s) {
                    p = ps;
                } else if (index == e) {
                    p = pe;
                }

                // Use animation to progress.
                this._progressAnimation.apply(element, p);
            }

            offset += this._itemSize;
        }

        // Handle item visibility.
        let self = this;
        this._visibleItems.forEach(function(invisibleItem) {
            invisibleItem.visible = false;
            self._visibleItems.delete(invisibleItem);
        });

        for (let index = s; (direction == -1 ? index <= e : index >= e); (direction == -1 ? index++ : index--)) {
            let realIndex = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(index, nElements);
            this._visibleItems.add(this.getWrapper(realIndex));
        }

        this._reloadVisibleElements = false;
    }

    setPrevious() {
        this.setIndex(this._index - 1);
    }

    setNext() {
        this.setIndex(this._index + 1);
    }

    getWrapper(index) {
        return this._wrapper.children[index];
    }

    getElement(index) {
        let e = this._wrapper.children[index];
        return e ? e.children[0] : null;
    }

    reload() {
        this._reloadVisibleElements = true;
        this.update();
    }

    get element() {
        let e = this._wrapper.children[this.realIndex];
        return e ? e.children[0] : null;
    }

    get length() {
        return this._wrapper.children.length;
    }

    get property() {
        return this._horizontal ? 'x' : 'y';
    }

    get viewportSize() {
        return this._horizontal ? this.w : this.h;
    }

    get index() {
        return this._index;
    }

    get realIndex() {
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getModuloIndex(this._index, this.length);
    }

    get itemSize() {
        return this._itemSize;
    }

    set itemSize(v) {
        this._itemSize = v;
        this.update();
    }

    get viewportScrollOffset() {
        return this._viewportScrollOffset;
    }

    set viewportScrollOffset(v) {
        this._viewportScrollOffset = v;
        this.update();
    }

    get itemScrollOffset() {
        return this._itemScrollOffset;
    }

    set itemScrollOffset(v) {
        this._itemScrollOffset = v;
        this.update();
    }

    get scrollTransitionSettings() {
        return this._scrollTransitionSettings;
    }

    set scrollTransitionSettings(v) {
        this._scrollTransitionSettings.patch(v);
    }

    set scrollTransition(v) {
        this._scrollTransitionSettings.patch(v);
    }

    get scrollTransition() {
        return this._scrollTransition;
    }

    get progressAnimation() {
        return this._progressAnimation;
    }

    set progressAnimation(v) {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObjectLiteral(v)) {
            this._progressAnimation = this.stage.animations.createSettings(v);
        } else {
            this._progressAnimation = v;
        }
        this.update();
    }

    get roll() {
        return this._roll;
    }

    set roll(v) {
        this._roll = v;
        this.update();
    }

    get rollMin() {
        return this._rollMin;
    }

    set rollMin(v) {
        this._rollMin = v;
        this.update();
    }

    get rollMax() {
        return this._rollMax;
    }

    set rollMax(v) {
        this._rollMax = v;
        this.update();
    }

    get invertDirection() {
        return this._invertDirection;
    }

    set invertDirection(v) {
        if (!this._started) {
            this._invertDirection = v;
        }
    }

    get horizontal() {
        return this._horizontal;
    }

    set horizontal(v) {
        if (v !== this._horizontal) {
            if (!this._started) {
                this._horizontal = v;
            }
        }
    }

}


class ListItems extends _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(list) {
        let wrap = (item => {
            let parent = item.stage.createElement();
            parent.add(item);
            parent.visible = false;
            return parent;
        })

        super(list._wrapper._children, wrap);
        this.list = list;
    }

    onAdd(item, index) {
        super.onAdd(item, index);
        this.checkStarted(index);
    }

    checkStarted(index) {
        this.list._reloadVisibleElements = true;
        if (!this.list._started) {
            this.list.start();
        } else {
            if (this.list.length === 1) {
                this.list.setIndex(0, true, true);
            } else {
                if (this.list._index >= this.list.length) {
                    this.list.setIndex(0);
                }
            }
            this.list.update();
        }
    }

    onRemove(item, index) {
        super.onRemove(item, index);
        let ri = this.list.realIndex;
        if (ri === index) {
            if (ri === this.list.length) {
                ri--;
            }
            if (ri >= 0) {
                this.list.setIndex(ri);
            }
        } else if (ri > index) {
            this.list.setIndex(ri - 1);
        }

        this.list._reloadVisibleElements = true;
    }

    onSet(item, index) {
        super.onSet(item, index);
        this.checkStarted(index);
    }

    onSync(removed, added, order) {
        super.onSync(removed, added, order);
        this.checkStarted(0);
    }

    get _signalProxy() {
        return true;
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SmoothScaleComponent)
/* harmony export */ });
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SmoothScaleComponent extends _application_Component_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    static _template() {
        return {
            ContentWrap: {renderOffscreen: true, forceZIndexContext: true, onAfterUpdate: SmoothScaleComponent._updateDimensions,
                Content: {}
            },
            Scale: {visible: false}
        }
    }

    constructor(stage) {
        super(stage);

        this._smoothScale = 1;
        this._iterations = 0;
    }

    get content() {
        return this.tag('Content');
    }

    set content(v) {
        this.tag('Content').patch(v, true);
    }

    get smoothScale() {
        return this._smoothScale;
    }

    set smoothScale(v) {
        if (this._smoothScale !== v) {
            let its = 0;
            while(v < 0.5 && its < 12) {
                its++;
                v = v * 2;
            }

            this.scale = v;
            this._setIterations(its);

            this._smoothScale = v;
        }
    }

    _setIterations(its) {
        if (this._iterations !== its) {
            const scalers = this.sel("Scale").childList;
            const content = this.sel("ContentWrap");
            while (scalers.length < its) {
                const first = scalers.length === 0;
                const texture = (first ? content.getTexture() : scalers.last.getTexture());
                scalers.a({rtt: true, renderOffscreen: true, texture: texture});
            }

            SmoothScaleComponent._updateDimensions(this.tag("ContentWrap"), true);

            const useScalers = (its > 0);
            this.patch({
                ContentWrap: {renderToTexture: useScalers},
                Scale: {visible: useScalers}
            });

            for (let i = 0, n = scalers.length; i < n; i++) {
                scalers.getAt(i).patch({
                    visible: i < its,
                    renderOffscreen: i !== its - 1
                });
            }
            this._iterations = its;
        }
    }

    static _updateDimensions(contentWrap, force) {
        const content = contentWrap.children[0];
        let w = content.renderWidth;
        let h = content.renderHeight;
        if (w !== contentWrap.w || h !== contentWrap.h || force) {
            contentWrap.w = w;
            contentWrap.h = h;

            const scalers = contentWrap.parent.tag("Scale").children;
            for (let i = 0, n = scalers.length; i < n; i++) {
                w = w * 0.5;
                h = h * 0.5;
                scalers[i].w = w;
                scalers[i].h = h;
            }
        }
    }

    get _signalProxy() {
        return true;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexContainer)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _layout_FlexLayout_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layout/FlexLayout.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class FlexContainer {


    constructor(item) {
        this._item = item;

        this._layout = new _layout_FlexLayout_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        this._horizontal = true;
        this._reverse = false;
        this._wrap = false;
        this._alignItems = 'stretch';
        this._justifyContent = 'flex-start';
        this._alignContent = 'flex-start';

        this._paddingLeft = 0;
        this._paddingTop = 0;
        this._paddingRight = 0;
        this._paddingBottom = 0;
    }

    get item() {
        return this._item;
    }

    _changedDimensions() {
        this._item.changedDimensions();
    }

    _changedContents() {
        this._item.changedContents();
    }

    get direction() {
        return (this._horizontal ? "row" : "column") + (this._reverse ? "-reverse" : "");
    }

    set direction(f) {
        if (this.direction === f) return;

        this._horizontal = (f === 'row' || f === 'row-reverse');
        this._reverse = (f === 'row-reverse' || f === 'column-reverse');

        this._changedContents();
    }

    set wrap(v) {
        this._wrap = v;
        this._changedContents();
    }

    get wrap() {
        return this._wrap;
    }

    get alignItems() {
        return this._alignItems;
    }

    set alignItems(v) {
        if (this._alignItems === v) return;
        if (FlexContainer.ALIGN_ITEMS.indexOf(v) === -1) {
            throw new Error("Unknown alignItems, options: " + FlexContainer.ALIGN_ITEMS.join(","));
        }
        this._alignItems = v;

        this._changedContents();
    }

    get alignContent() {
        return this._alignContent;
    }

    set alignContent(v) {
        if (this._alignContent === v) return;
        if (FlexContainer.ALIGN_CONTENT.indexOf(v) === -1) {
            throw new Error("Unknown alignContent, options: " + FlexContainer.ALIGN_CONTENT.join(","));
        }
        this._alignContent = v;

        this._changedContents();
    }

    get justifyContent() {
        return this._justifyContent;
    }

    set justifyContent(v) {
        if (this._justifyContent === v) return;

        if (FlexContainer.JUSTIFY_CONTENT.indexOf(v) === -1) {
            throw new Error("Unknown justifyContent, options: " + FlexContainer.JUSTIFY_CONTENT.join(","));
        }
        this._justifyContent = v;

        this._changedContents();
    }

    set padding(v) {
        this.paddingLeft = v;
        this.paddingTop = v;
        this.paddingRight = v;
        this.paddingBottom = v;
    }

    get padding() {
        return this.paddingLeft;
    }
    
    set paddingLeft(v) {
        this._paddingLeft = v;
        this._changedDimensions();
    }
    
    get paddingLeft() {
        return this._paddingLeft;
    }

    set paddingTop(v) {
        this._paddingTop = v;
        this._changedDimensions();
    }

    get paddingTop() {
        return this._paddingTop;
    }

    set paddingRight(v) {
        this._paddingRight = v;
        this._changedDimensions();
    }

    get paddingRight() {
        return this._paddingRight;
    }

    set paddingBottom(v) {
        this._paddingBottom = v;
        this._changedDimensions();
    }

    get paddingBottom() {
        return this._paddingBottom;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

}

FlexContainer.ALIGN_ITEMS = ["flex-start", "flex-end", "center", "stretch"];
FlexContainer.ALIGN_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "stretch"];
FlexContainer.JUSTIFY_CONTENT = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexItem.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexItem.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexItem)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/* harmony import */ var _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlexContainer.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class FlexItem {

    constructor(item) {
        this._ctr = null;
        this._item = item;
        this._grow = 0;
        this._shrink = FlexItem.SHRINK_AUTO;
        this._alignSelf = undefined;
        this._minWidth = 0;
        this._minHeight = 0;
        this._maxWidth = 0;
        this._maxHeight = 0;

        this._marginLeft = 0;
        this._marginTop = 0;
        this._marginRight = 0;
        this._marginBottom = 0;
    }

    get item() {
        return this._item;
    }

    get grow() {
        return this._grow;
    }

    set grow(v) {
        if (this._grow === v) return;

        this._grow = parseInt(v) || 0;

        this._changed();
    }

    get shrink() {
        if (this._shrink === FlexItem.SHRINK_AUTO) {
            return this._getDefaultShrink();
        }
        return this._shrink;
    }

    _getDefaultShrink() {
        if (this.item.isFlexEnabled()) {
            return 1;
        } else {
            // All non-flex containers are absolutely positioned items with fixed dimensions, and by default not shrinkable.
            return 0;
        }
    }

    set shrink(v) {
        if (this._shrink === v) return;

        this._shrink = parseInt(v) || 0;

        this._changed();
    }

    get alignSelf() {
        return this._alignSelf;
    }

    set alignSelf(v) {
        if (this._alignSelf === v) return;

        if (v === undefined) {
            this._alignSelf = undefined;
        } else {
            if (_FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ALIGN_ITEMS.indexOf(v) === -1) {
                throw new Error("Unknown alignSelf, options: " + _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ALIGN_ITEMS.join(","));
            }
            this._alignSelf = v;
        }

        this._changed();
    }

    get minWidth() {
        return this._minWidth;
    }

    set minWidth(v) {
        this._minWidth = Math.max(0, v);
        this._item.changedDimensions(true, false);
    }

    get minHeight() {
        return this._minHeight;
    }

    set minHeight(v) {
        this._minHeight = Math.max(0, v);
        this._item.changedDimensions(false, true);
    }

    get maxWidth() {
        return this._maxWidth;
    }

    set maxWidth(v) {
        this._maxWidth = Math.max(0, v);
        this._item.changedDimensions(true, false);
    }

    get maxHeight() {
        return this._maxHeight;
    }

    set maxHeight(v) {
        this._maxHeight = Math.max(0, v);
        this._item.changedDimensions(false, true);
    }

    /**
     * @note margins behave slightly different than in HTML with regard to shrinking.
     * In HTML, (outer) margins can be removed when shrinking. In this engine, they will not shrink at all.
     */
    set margin(v) {
        this.marginLeft = v;
        this.marginTop = v;
        this.marginRight = v;
        this.marginBottom = v;
    }

    get margin() {
        return this.marginLeft;
    }

    set marginLeft(v) {
        this._marginLeft = v;
        this._changed();
    }

    get marginLeft() {
        return this._marginLeft;
    }

    set marginTop(v) {
        this._marginTop = v;
        this._changed();
    }

    get marginTop() {
        return this._marginTop;
    }

    set marginRight(v) {
        this._marginRight = v;
        this._changed();
    }

    get marginRight() {
        return this._marginRight;
    }

    set marginBottom(v) {
        this._marginBottom = v;
        this._changed();
    }

    get marginBottom() {
        return this._marginBottom;
    }
    
    _changed() {
        if (this.ctr) this.ctr._changedContents();
    }

    set ctr(v) {
        this._ctr = v;
    }

    get ctr() {
        return this._ctr;
    }

    patch(settings) {
        _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

    _resetLayoutSize() {
        this._resetHorizontalAxisLayoutSize();
        this._resetVerticalAxisLayoutSize();
    }

    _resetCrossAxisLayoutSize() {
        if (this.ctr._horizontal) {
            this._resetVerticalAxisLayoutSize();
        } else {
            this._resetHorizontalAxisLayoutSize();
        }
    }

    _resetHorizontalAxisLayoutSize() {
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, true);
        if (this._minWidth) {
            w = Math.max(this._minWidth, w);
        }
        if (this._maxWidth) {
            w = Math.min(this._maxWidth, w);
        }
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, true, w);
    }

    _resetVerticalAxisLayoutSize() {
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, false);
        if (this._minHeight) {
            h = Math.max(this._minHeight, h);
        }
        if (this._maxHeight) {
            h = Math.min(this._maxHeight, h);
        }
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, false, h);
    }

    _getCrossAxisMinSizeSetting() {
        return this._getMinSizeSetting(!this.ctr._horizontal);
    }

    _getCrossAxisMaxSizeSetting() {
        return this._getMaxSizeSetting(!this.ctr._horizontal);
    }

    _getMainAxisMaxSizeSetting() {
        return this._getMaxSizeSetting(this.ctr._horizontal);
    }

    _getMinSizeSetting(horizontal) {
        if (horizontal) {
            return this._minWidth;
        } else {
            return this._minHeight;
        }
    }

    _getMaxSizeSetting(horizontal) {
        if (horizontal) {
            return this._maxWidth;
        } else {
            return this._maxHeight;
        }
    }

    _getMainAxisMinSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisMinSize(this.item, this.ctr._horizontal);
    }

    _getCrossAxisMinSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisMinSize(this.item, !this.ctr._horizontal);
    }

    _getMainAxisLayoutSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, this.ctr._horizontal);
    }

    _getMainAxisLayoutPos() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutPos(this.item, this.ctr._horizontal);
    }

    _setMainAxisLayoutPos(pos) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutPos(this.item, this.ctr._horizontal, pos);
    }

    _setCrossAxisLayoutPos(pos) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutPos(this.item, !this.ctr._horizontal, pos);
    }

    _getCrossAxisLayoutSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, !this.ctr._horizontal);
    }

    _resizeCrossAxis(size) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resizeAxis(this.item, !this.ctr._horizontal, size);
    }

    _resizeMainAxis(size) {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].resizeAxis(this.item, this.ctr._horizontal, size);
    }

    _getMainAxisPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, this.ctr._horizontal);
    }

    _getCrossAxisPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, !this.ctr._horizontal);
    }

    _getMainAxisMargin() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalMargin(this.item, this.ctr._horizontal);
    }

    _getCrossAxisMargin() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalMargin(this.item, !this.ctr._horizontal);
    }

    _getHorizontalMarginOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getMarginOffset(this.item, true);
    }

    _getVerticalMarginOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getMarginOffset(this.item, false);
    }

    _getMainAxisMinSizeWithPaddingAndMargin() {
        return this._getMainAxisMinSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }

    _getCrossAxisMinSizeWithPaddingAndMargin() {
        return this._getCrossAxisMinSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }

    _getMainAxisLayoutSizeWithPaddingAndMargin() {
        return this._getMainAxisLayoutSize() + this._getMainAxisPadding() + this._getMainAxisMargin();
    }

    _getCrossAxisLayoutSizeWithPaddingAndMargin() {
        return this._getCrossAxisLayoutSize() + this._getCrossAxisPadding() + this._getCrossAxisMargin();
    }

    _hasFixedCrossAxisSize() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, !this.ctr._horizontal);
    }

    _hasRelCrossAxisSize() {
        return !!(this.ctr._horizontal ? this.item.funcH : this.item.funcW);
    }

}


FlexItem.SHRINK_AUTO = -1;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexTarget)
/* harmony export */ });
/* harmony import */ var _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FlexContainer.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexContainer.mjs");
/* harmony import */ var _FlexItem_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FlexItem.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexItem.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * This is the connection between the render tree with the layout tree of this flex container/item.
 */
class FlexTarget {

    constructor(target) {
        this._target = target;

        /**
         * Possible values (only in case of container):
         * bit 0: has changed or contains items with changes
         * bit 1: width changed
         * bit 2: height changed
         */
        this._recalc = 0;
        
        this._enabled = false;

        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;

        this._originalX = 0;
        this._originalY = 0;
        this._originalWidth = 0;
        this._originalHeight = 0;

        this._flex = null;
        this._flexItem = null;
        this._flexItemDisabled = false;

        this._items = null;
    }

    get flexLayout() {
        return this.flex ? this.flex._layout : null;
    }

    layoutFlexTree() {
        if (this.isFlexEnabled() && this.isChanged()) {
            this.flexLayout.layoutTree();
        }
    }

    get target() {
        return this._target;
    }

    get flex() {
        return this._flex;
    }

    set flex(v) {
        if (!v) {
            if (this.isFlexEnabled()) {
                this._disableFlex();
            }
        } else {
            if (!this.isFlexEnabled()) {
                this._enableFlex();
            }
            this._flex.patch(v);
        }
    }

    get flexItem() {
        if (this._flexItemDisabled) {
            return false;
        }
        this._ensureFlexItem();
        return this._flexItem;
    }

    set flexItem(v) {
        if (v === false) {
            if (!this._flexItemDisabled) {
                const parent = this.flexParent;
                this._flexItemDisabled = true;
                this._checkEnabled();
                if (parent) {
                    parent._clearFlexItemsCache();
                    parent.changedContents();
                }
            }
        } else {
            this._ensureFlexItem();

            this._flexItem.patch(v);

            if (this._flexItemDisabled) {
                this._flexItemDisabled = false;
                this._checkEnabled();
                const parent = this.flexParent;
                if (parent) {
                    parent._clearFlexItemsCache();
                    parent.changedContents();
                }
            }
        }
    }

    _enableFlex() {
        this._flex = new _FlexContainer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        this._checkEnabled();
        this.changedDimensions();
        this._enableChildrenAsFlexItems();
    }

    _disableFlex() {
        this.changedDimensions();
        this._flex = null;
        this._checkEnabled();
        this._disableChildrenAsFlexItems();
    }

    _enableChildrenAsFlexItems() {
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.layout._enableFlexItem();
            }
        }
    }

    _disableChildrenAsFlexItems() {
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const child = children[i];
                child.layout._disableFlexItem();
            }
        }
    }

    _enableFlexItem() {
        this._ensureFlexItem();
        const flexParent = this._target._parent._layout;
        this._flexItem.ctr = flexParent._flex;
        flexParent.changedContents();
        this._checkEnabled();
    }

    _disableFlexItem() {
        if (this._flexItem) {
            this._flexItem.ctr = null;
        }

        // We keep the flexItem object because it may contain custom settings.
        this._checkEnabled();

        // Offsets have been changed. We can't recover them, so we'll just clear them instead.
        this._resetOffsets();
    }

    _resetOffsets() {
        this.x = 0;
        this.y = 0;
    }

    _ensureFlexItem() {
        if (!this._flexItem) {
            this._flexItem = new _FlexItem_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        }
    }

    _checkEnabled() {
        const enabled = this.isEnabled();
        if (this._enabled !== enabled) {
            if (enabled) {
                this._enable();
            } else {
                this._disable();
            }
            this._enabled = enabled;
        }
    }
    
    _enable() {
        this._setupTargetForFlex();
        this._target.enableFlexLayout();
    }

    _disable() {
        this._restoreTargetToNonFlex();
        this._target.disableFlexLayout();
    }

    isEnabled() {
        return this.isFlexEnabled() || this.isFlexItemEnabled();
    }

    isFlexEnabled() {
        return this._flex !== null;
    }

    isFlexItemEnabled() {
        return this.flexParent !== null;
    }

    _restoreTargetToNonFlex() {
        const target = this._target;
        target.x = this._originalX;
        target.y = this._originalY;
        target.setDimensions(this._originalWidth, this._originalHeight);
    }

    _setupTargetForFlex() {
        const target = this._target;
        this._originalX = target._x;
        this._originalY = target._y;
        this._originalWidth = target._w;
        this._originalHeight = target._h;
    }
    
    setParent(from, to) {
        if (from && from.isFlexContainer()) {
            from._layout._changedChildren();
        }

        if (to && to.isFlexContainer()) {
            this._enableFlexItem();
            to._layout._changedChildren();
        }
        this._checkEnabled();
    }

    get flexParent() {
        if (this._flexItemDisabled) {
            return null;
        }

        const parent = this._target._parent;
        if (parent && parent.isFlexContainer()) {
            return parent._layout;
        }
        return null;
    }

    setVisible(v) {
        const parent = this.flexParent;
        if (parent) {
            parent._changedChildren();
        }
    }

    get items() {
        if (!this._items) {
            this._items = this._getFlexItems();
        }
        return this._items;
    }

    _getFlexItems() {
        const items = [];
        const children = this._target._children;
        if (children) {
            for (let i = 0, n = children.length; i < n; i++) {
                const item = children[i];
                if (item.visible) {
                    if (item.isFlexItem()) {
                        items.push(item.layout);
                    }
                }
            }
        }
        return items;
    }

    _changedChildren() {
        this._clearFlexItemsCache();
        this.changedContents();
    }

    _clearFlexItemsCache() {
        this._items = null;
    }

    setLayout(x, y, w, h) {
        let originalX = this._originalX;
        let originalY = this._originalY;
        if (this.funcX) {
            originalX = this.funcX(_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentAxisSizeWithPadding(this, true));
        }
        if (this.funcY) {
            originalY = this.funcY(_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].getParentAxisSizeWithPadding(this, false));
        }

        if (this.isFlexItemEnabled()) {
            this.target.setLayout(x + originalX, y + originalY, w, h);
        } else {
            // Reuse the x,y 'settings'.
            this.target.setLayout(originalX, originalY, w, h);
        }
    }

    changedDimensions(changeWidth = true, changeHeight = true) {
        this._updateRecalc(changeWidth, changeHeight);
    }

    changedContents() {
        this._updateRecalc();
    }

    forceLayout() {
        this._updateRecalc();
    }

    isChanged() {
        return this._recalc > 0;
    }

    _updateRecalc(changeExternalWidth = false, changeExternalHeight = false) {
        if (this.isFlexEnabled()) {
            const layout = this._flex._layout;

            // When something internal changes, it can have effect on the external dimensions.
            changeExternalWidth = changeExternalWidth || layout.isAxisFitToContents(true);
            changeExternalHeight = changeExternalHeight || layout.isAxisFitToContents(false);
        }

        const recalc = 1 + (changeExternalWidth ? 2 : 0) + (changeExternalHeight ? 4 : 0);
        const newRecalcFlags = this.getNewRecalcFlags(recalc);
        this._recalc |= recalc;
        if (newRecalcFlags > 1) {
            if (this.flexParent) {
                this.flexParent._updateRecalcBottomUp(recalc);
            } else {
                this._target.triggerLayout();
            }
        } else {
            this._target.triggerLayout();
        }
    }

    getNewRecalcFlags(flags) {
        return (7 - this._recalc) & flags;
    }

    _updateRecalcBottomUp(childRecalc) {
        const newRecalc = this._getRecalcFromChangedChildRecalc(childRecalc);
        const newRecalcFlags = this.getNewRecalcFlags(newRecalc);
        this._recalc |= newRecalc;
        if (newRecalcFlags > 1) {
            const flexParent = this.flexParent;
            if (flexParent) {
                flexParent._updateRecalcBottomUp(newRecalc);
            } else {
                this._target.triggerLayout();
            }
        } else {
            this._target.triggerLayout();
        }
    }

    _getRecalcFromChangedChildRecalc(childRecalc) {
        const layout = this._flex._layout;

        const mainAxisRecalcFlag = layout._horizontal ? 1 : 2;
        const crossAxisRecalcFlag = layout._horizontal ? 2 : 1;

        const crossAxisDimensionsChangedInChild = (childRecalc & crossAxisRecalcFlag);
        if (!crossAxisDimensionsChangedInChild) {
            const mainAxisDimensionsChangedInChild = (childRecalc & mainAxisRecalcFlag);
            if (mainAxisDimensionsChangedInChild) {
                const mainAxisIsWrapping = layout.isWrapping();
                if (mainAxisIsWrapping) {
                    const crossAxisIsFitToContents = layout.isCrossAxisFitToContents();
                    if (crossAxisIsFitToContents) {
                        // Special case: due to wrapping, the cross axis size may be changed.
                        childRecalc += crossAxisRecalcFlag;
                    }
                }
            }
        }

        let isWidthDynamic = layout.isAxisFitToContents(true);
        let isHeightDynamic = layout.isAxisFitToContents(false);

        if (layout.shrunk) {
            // If during previous layout this container was 'shrunk', any changes may change the 'min axis size' of the
            // contents, leading to a different axis size on this container even when it was not 'fit to contents'.
            if (layout._horizontal) {
                isWidthDynamic = true;
            } else {
                isHeightDynamic = true;
            }
        }

        const localRecalc = 1 + (isWidthDynamic ? 2 : 0) + (isHeightDynamic ? 4 : 0);

        const combinedRecalc = childRecalc & localRecalc;
        return combinedRecalc;
    }

    get recalc() {
        return this._recalc;
    }

    clearRecalcFlag() {
        this._recalc = 0;
    }

    enableLocalRecalcFlag() {
        this._recalc = 1;
    }

    get originalX() {
        return this._originalX;
    }

    setOriginalXWithoutUpdatingLayout(v) {
        this._originalX = v;
    }

    get originalY() {
        return this._originalY;
    }

    setOriginalYWithoutUpdatingLayout(v) {
        this._originalY = v;
    }

    get originalWidth() {
        return this._originalWidth;
    }

    set originalWidth(v) {
        if (this._originalWidth !== v) {
            this._originalWidth = v;
            this.changedDimensions(true, false);
        }
    }

    get originalHeight() {
        return this._originalHeight;
    }

    set originalHeight(v) {
        if (this._originalHeight !== v) {
            this._originalHeight = v;
            this.changedDimensions(false, true);
        }
    }

    get funcX() {
        return this._target.funcX;
    }

    get funcY() {
        return this._target.funcY;
    }

    get funcW() {
        return this._target.funcW;
    }

    get funcH() {
        return this._target.funcH;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexUtils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class FlexUtils {

    static getParentAxisSizeWithPadding(item, horizontal) {
        const target = item.target;
        const parent = target.getParent();
        if (!parent) {
            return 0;
        } else {
            const flexParent = item.flexParent;
            if (flexParent) {
                // Use pending layout size.
                return this.getAxisLayoutSize(flexParent, horizontal) + this.getTotalPadding(flexParent, horizontal);
            } else {
                // Use 'absolute' size.
                return horizontal ? parent.w : parent.h;
            }
        }
    }

    static getRelAxisSize(item, horizontal) {
        if (horizontal) {
            if (item.funcW) {
                if (this._allowRelAxisSizeFunction(item, true)) {
                    return item.funcW(this.getParentAxisSizeWithPadding(item, true));
                } else {
                    return 0;
                }
            } else {
                return item.originalWidth;
            }
        } else {
            if (item.funcH) {
                if (this._allowRelAxisSizeFunction(item, false)) {
                    return item.funcH(this.getParentAxisSizeWithPadding(item, false));
                } else {
                    return 0;
                }
            } else {
                return item.originalHeight;
            }
        }
    }

    static _allowRelAxisSizeFunction(item, horizontal) {
        const flexParent = item.flexParent;
        if (flexParent && flexParent._flex._layout.isAxisFitToContents(horizontal)) {
            // We don't allow relative width on fit-to-contents because it leads to conflicts.
            return false;
        }
        return true;
    }

    static isZeroAxisSize(item, horizontal) {
        if (horizontal) {
            return !item.originalWidth && !item.funcW;
        } else {
            return !item.originalHeight && !item.funcH;
        }
    }

    static getAxisLayoutPos(item, horizontal) {
        return horizontal ? item.x : item.y;
    }

    static getAxisLayoutSize(item, horizontal) {
        return horizontal ? item.w : item.h;
    }

    static setAxisLayoutPos(item, horizontal, pos) {
        if (horizontal) {
            item.x = pos;
        } else {
            item.y = pos;
        }
    }

    static setAxisLayoutSize(item, horizontal, size) {
        if (horizontal) {
            item.w = size;
        } else {
            item.h = size;
        }
    }

    static getAxisMinSize(item, horizontal) {
        let minSize = this.getPlainAxisMinSize(item, horizontal);

        let flexItemMinSize = 0;
        if (item.isFlexItemEnabled()) {
            flexItemMinSize = item._flexItem._getMinSizeSetting(horizontal);
        }

        const hasLimitedMinSize = (flexItemMinSize > 0);
        if (hasLimitedMinSize) {
            minSize = Math.max(minSize, flexItemMinSize);
        }
        return minSize;
    }

    static getPlainAxisMinSize(item, horizontal) {
        if (item.isFlexEnabled()) {
            return item._flex._layout.getAxisMinSize(horizontal);
        } else {
            const isShrinkable = (item.flexItem.shrink !== 0);
            if (isShrinkable) {
                return 0;
            } else {
                return this.getRelAxisSize(item, horizontal);
            }
        }
    }

    static resizeAxis(item, horizontal, size) {
        if (item.isFlexEnabled()) {
            const isMainAxis = (item._flex._horizontal === horizontal);
            if (isMainAxis) {
                item._flex._layout.resizeMainAxis(size);
            } else {
                item._flex._layout.resizeCrossAxis(size);
            }
        } else {
            this.setAxisLayoutSize(item, horizontal, size);
        }
    }


    static getPaddingOffset(item, horizontal) {
        if (item.isFlexEnabled()) {
            const flex = item._flex;
            if (horizontal) {
                return flex.paddingLeft;
            } else {
                return flex.paddingTop;
            }
        } else {
            return 0;
        }
    }

    static getTotalPadding(item, horizontal) {
        if (item.isFlexEnabled()) {
            const flex = item._flex;
            if (horizontal) {
                return flex.paddingRight + flex.paddingLeft;
            } else {
                return flex.paddingTop + flex.paddingBottom;
            }
        } else {
            return 0;
        }
    }

    static getMarginOffset(item, horizontal) {
        const flexItem = item.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginLeft;
            } else {
                return flexItem.marginTop;
            }
        } else {
            return 0;
        }
    }

    static getTotalMargin(item, horizontal) {
        const flexItem = item.flexItem;
        if (flexItem) {
            if (horizontal) {
                return flexItem.marginRight + flexItem.marginLeft;
            } else {
                return flexItem.marginTop + flexItem.marginBottom;
            }
        } else {
            return 0;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContentAligner)
/* harmony export */ });
/* harmony import */ var _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SpacingCalculator.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ContentAligner {

    constructor(layout) {
        this._layout = layout;
        this._totalCrossAxisSize = 0;
    }

    get _lines() {
        return this._layout._lines;
    }

    init() {
        this._totalCrossAxisSize = this._getTotalCrossAxisSize();
    }

    align() {
        const crossAxisSize = this._layout.crossAxisSize;
        const remainingSpace = crossAxisSize - this._totalCrossAxisSize;

        const {spacingBefore, spacingBetween} = this._getSpacing(remainingSpace);

        const lines = this._lines;

        const mode = this._layout._flexContainer.alignContent;
        let growSize = 0;
        if (mode === "stretch" && lines.length && (remainingSpace > 0)) {
            growSize = remainingSpace / lines.length;
        }

        let currentPos = spacingBefore;
        for (let i = 0, n = lines.length; i < n; i++) {
            const crossAxisLayoutOffset = currentPos;
            const aligner = lines[i].createItemAligner();

            let finalCrossAxisLayoutSize = lines[i].crossAxisLayoutSize + growSize;

            aligner.setCrossAxisLayoutSize(finalCrossAxisLayoutSize);
            aligner.setCrossAxisLayoutOffset(crossAxisLayoutOffset);

            aligner.align();

            if (aligner.recursiveResizeOccured) {
                lines[i].setItemPositions();
            }

            currentPos += finalCrossAxisLayoutSize;
            currentPos += spacingBetween;
        }
    }

    get totalCrossAxisSize() {
        return this._totalCrossAxisSize;
    }

    _getTotalCrossAxisSize() {
        const lines = this._lines;
        let total = 0;
        for (let i = 0, n = lines.length; i < n; i++) {
            const line = lines[i];
            total += line.crossAxisLayoutSize;
        }
        return total;
    }

    _getSpacing(remainingSpace) {
        const mode = this._layout._flexContainer.alignContent;
        const numberOfItems = this._lines.length;
        return _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getSpacing(mode, numberOfItems, remainingSpace);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/FlexLayout.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlexLayout)
/* harmony export */ });
/* harmony import */ var _ContentAligner_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ContentAligner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/ContentAligner.mjs");
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/* harmony import */ var _LineLayouter_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LineLayouter.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs");
/* harmony import */ var _ItemCoordinatesUpdater_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ItemCoordinatesUpdater.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Layouts a flex container (and descendants).
 */
class FlexLayout {

    constructor(flexContainer) {
        this._flexContainer = flexContainer;

        this._lineLayouter = new _LineLayouter_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);

        this._resizingMainAxis = false;
        this._resizingCrossAxis = false;

        this._cachedMainAxisSizeAfterLayout = 0;
        this._cachedCrossAxisSizeAfterLayout = 0;

        this._shrunk = false;
    }

    get shrunk() {
        return this._shrunk;
    }

    get recalc() {
        return this.item.recalc;
    }

    layoutTree() {
        const isSubTree = (this.item.flexParent !== null);
        if (isSubTree) {
            // Use the dimensions set by the parent flex tree.
            this._updateSubTreeLayout();
        } else {
            this.updateTreeLayout();
        }
        this.updateItemCoords();
    }

    updateTreeLayout() {
        if (this.recalc) {
            this._performUpdateLayoutTree();
        } else {
            this._performUpdateLayoutTreeFromCache();
        }
    }

    _performUpdateLayoutTree() {
        this._setInitialAxisSizes();
        this._layoutAxes();
        this._refreshLayoutCache();
    }

    _refreshLayoutCache() {
        this._cachedMainAxisSizeAfterLayout = this.mainAxisSize;
        this._cachedCrossAxisSizeAfterLayout = this.crossAxisSize;
    }

    _performUpdateLayoutTreeFromCache() {
        const sizeMightHaveChanged = (this.item.funcW || this.item.funcH);
        if (sizeMightHaveChanged) {
            // Update after all.
            this.item.enableLocalRecalcFlag();
            this._performUpdateLayoutTree();
        } else {
            this.mainAxisSize = this._cachedMainAxisSizeAfterLayout;
            this.crossAxisSize = this._cachedCrossAxisSizeAfterLayout;
        }
    }

    updateItemCoords() {
        const updater = new _ItemCoordinatesUpdater_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        updater.finalize();
    }

    _updateSubTreeLayout() {
        // The dimensions of this container are guaranteed not to have changed.
        // That's why we can safely 'reuse' those and re-layout the contents.
        const crossAxisSize = this.crossAxisSize;
        this._layoutMainAxis();
        this.performResizeCrossAxis(crossAxisSize);
    }

    _setInitialAxisSizes() {
        if (this.item.isFlexItemEnabled()) {
            this.item.flexItem._resetLayoutSize();
        } else {
            this.mainAxisSize = this._getMainAxisBasis();
            this.crossAxisSize = this._getCrossAxisBasis();
        }
        this._resizingMainAxis = false;
        this._resizingCrossAxis = false;
        this._shrunk = false;
    }

    _layoutAxes() {
        this._layoutMainAxis();
        this._layoutCrossAxis();
    }

    /**
     * @pre mainAxisSize should exclude padding.
     */
    _layoutMainAxis() {
        this._layoutLines();
        this._fitMainAxisSizeToContents();
    }

    _layoutLines() {
        this._lineLayouter.layoutLines();
    }

    get _lines() {
        return this._lineLayouter.lines;
    }

    _fitMainAxisSizeToContents() {
        if (!this._resizingMainAxis) {
            if (this.isMainAxisFitToContents()) {
                this.mainAxisSize = this._lineLayouter.mainAxisContentSize;
            }
        }
    }

    /**
     * @pre crossAxisSize should exclude padding.
     */
    _layoutCrossAxis() {
        const aligner = new _ContentAligner_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        aligner.init();
        this._totalCrossAxisSize = aligner.totalCrossAxisSize;
        this._fitCrossAxisSizeToContents();
        aligner.align();
    }

    _fitCrossAxisSizeToContents() {
        if (!this._resizingCrossAxis) {
            if (this.isCrossAxisFitToContents()) {
                this.crossAxisSize = this._totalCrossAxisSize;
            }
        }
    }

    isWrapping() {
        return this._flexContainer.wrap;
    }

    isAxisFitToContents(horizontal) {
        if (this._horizontal === horizontal) {
            return this.isMainAxisFitToContents();
        } else {
            return this.isCrossAxisFitToContents();
        }
    }

    isMainAxisFitToContents() {
        return !this.isWrapping() && !this._hasFixedMainAxisBasis();
    }

    isCrossAxisFitToContents() {
        return !this._hasFixedCrossAxisBasis();
    }

    _hasFixedMainAxisBasis() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, this._horizontal);
    }

    _hasFixedCrossAxisBasis() {
        return !_FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isZeroAxisSize(this.item, !this._horizontal);
    }

    getAxisMinSize(horizontal) {
        if (this._horizontal === horizontal) {
            return this._getMainAxisMinSize();
        } else {
            return this._getCrossAxisMinSize();
        }
    }

    _getMainAxisMinSize() {
        return this._lineLayouter.mainAxisMinSize;
    }

    _getCrossAxisMinSize() {
        return this._lineLayouter.crossAxisMinSize;
    }

    resizeMainAxis(size) {
        if (this.mainAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeMainAxis(size);
            } else {
                if (this._checkValidCacheMainAxisResize()) {
                    this.mainAxisSize = size;
                    this._fitCrossAxisSizeToContents();
                } else {
                    // Cache miss.
                    this.item.enableLocalRecalcFlag();
                    this.performResizeMainAxis(size);
                }
            }
        }
    }

    _checkValidCacheMainAxisResize(size) {
        const isFinalMainAxisSize = (size === this.targetMainAxisSize);
        if (isFinalMainAxisSize) {
            return true;
        }
        const canIgnoreCacheMiss = !this.isCrossAxisFitToContents();
        if (canIgnoreCacheMiss) {
            // Allow other main axis resizes and check if final resize matches the target main axis size
            //  (ItemCoordinatesUpdater).
            return true;
        }
        return false;
    }

    performResizeMainAxis(size) {
        const isShrinking = (size < this.mainAxisSize);
        this._shrunk = isShrinking;

        this.mainAxisSize = size;

        this._resizingMainAxis = true;
        this._layoutAxes();
        this._resizingMainAxis = false;
    }

    resizeCrossAxis(size) {
        if (this.crossAxisSize !== size) {
            if (this.recalc > 0) {
                this.performResizeCrossAxis(size);
            } else {
                this.crossAxisSize = size;
            }
        }
    }

    performResizeCrossAxis(size) {
        this.crossAxisSize = size;

        this._resizingCrossAxis = true;
        this._layoutCrossAxis();
        this._resizingCrossAxis = false;
    }

    get targetMainAxisSize() {
        return this._horizontal ? this.item.target.w : this.item.target.h;
    }

    get targetCrossAxisSize() {
        return this._horizontal ? this.item.target.h : this.item.target.w;
    }

    getParentFlexContainer() {
        return this.item.isFlexItemEnabled() ? this.item.flexItem.ctr : null;
    }

    _getHorizontalPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, true);
    }

    _getVerticalPadding() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getTotalPadding(this.item, false);
    }

    _getHorizontalPaddingOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPaddingOffset(this.item, true);
    }

    _getVerticalPaddingOffset() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getPaddingOffset(this.item, false);
    }

    _getMainAxisBasis() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, this._horizontal);
    }

    _getCrossAxisBasis() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRelAxisSize(this.item, !this._horizontal);
    }

    get _horizontal() {
        return this._flexContainer._horizontal;
    }

    get _reverse() {
        return this._flexContainer._reverse;
    }

    get item() {
        return this._flexContainer.item;
    }

    get items() {
        return this.item.items;
    }

    get resizingMainAxis() {
        return this._resizingMainAxis;
    }

    get resizingCrossAxis() {
        return this._resizingCrossAxis;
    }

    get numberOfItems() {
        return this.items.length;
    }

    get mainAxisSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, this._horizontal);
    }

    get crossAxisSize() {
        return _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getAxisLayoutSize(this.item, !this._horizontal);
    }

    set mainAxisSize(v) {
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, this._horizontal, v);
    }

    set crossAxisSize(v) {
        _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].setAxisLayoutSize(this.item, !this._horizontal, v);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/ItemCoordinatesUpdater.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemCoordinatesUpdater)
/* harmony export */ });
/* harmony import */ var _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../FlexUtils.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ItemCoordinatesUpdater {

    constructor(layout) {
        this._layout = layout;
        this._isReverse = this._flexContainer._reverse;
        this._horizontalPaddingOffset = this._layout._getHorizontalPaddingOffset();
        this._verticalPaddingOffset = this._layout._getVerticalPaddingOffset();
    }

    get _flexContainer() {
        return this._layout._flexContainer;
    }

    finalize() {
        const parentFlex = this._layout.getParentFlexContainer();
        if (parentFlex) {
            // We must update it from the parent to set padding offsets and reverse position.
            const updater = new ItemCoordinatesUpdater(parentFlex._layout);
            updater._finalizeItemAndChildren(this._flexContainer.item);
        } else {
            this._finalizeRoot();
            this._finalizeItems();
        }
    }

    _finalizeRoot() {
        const item = this._flexContainer.item;
        let x = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, true);
        let y = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, false);
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, true);
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, false);

        w += this._layout._getHorizontalPadding();
        h += this._layout._getVerticalPadding();

        item.clearRecalcFlag();

        item.setLayout(x, y, w, h);
    }

    _finalizeItems() {
        const items = this._layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const validCache = this._validateItemCache(item);

            // Notice that we must also finalize a cached items, as it's coordinates may have changed.
            this._finalizeItem(item);

            if (!validCache) {
                this._finalizeItemChildren(item);
            }
        }
    }

    _validateItemCache(item) {
        if (item.recalc === 0) {
            if (item.isFlexEnabled()) {
                const layout = item._flex._layout;

                const dimensionsMatchPreviousResult = (item.w === item.target.w && item.h === item.target.h);
                if (dimensionsMatchPreviousResult) {
                    // Cache is valid.
                    return true;
                } else {
                    const crossAxisSize = layout.crossAxisSize;
                    layout.performResizeMainAxis(layout.mainAxisSize);
                    layout.performResizeCrossAxis(crossAxisSize);
                }
            }
        }
        return false;
    }

    _finalizeItemAndChildren(item) {
        this._finalizeItem(item);
        this._finalizeItemChildren(item);
    }

    _finalizeItem(item) {
        if (this._isReverse) {
            this._reverseMainAxisLayoutPos(item);
        }

        let x = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, true);
        let y = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutPos(item, false);
        let w = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, true);
        let h = _FlexUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getAxisLayoutSize(item, false);

        x += this._horizontalPaddingOffset;
        y += this._verticalPaddingOffset;

        const flex = item.flex;
        if (flex) {
            w += item._flex._layout._getHorizontalPadding();
            h += item._flex._layout._getVerticalPadding();
        }

        const flexItem = item.flexItem;
        if (flexItem) {
            x += flexItem._getHorizontalMarginOffset();
            y += flexItem._getVerticalMarginOffset();
        }

        item.clearRecalcFlag();
        item.setLayout(x, y, w, h);
    }

    _finalizeItemChildren(item) {
        const flex = item._flex;
        if (flex) {
            const updater = new ItemCoordinatesUpdater(flex._layout);
            updater._finalizeItems();
        }
    }

    _reverseMainAxisLayoutPos(item) {
        const endPos = (item.flexItem._getMainAxisLayoutPos() + item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin());
        const reversedPos = this._layout.mainAxisSize - endPos;
        item.flexItem._setMainAxisLayoutPos(reversedPos);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/LineLayouter.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineLayouter)
/* harmony export */ });
/* harmony import */ var _line_LineLayout_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./line/LineLayout.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Distributes items over layout lines.
 */
class LineLayouter {

    constructor(layout) {
        this._layout = layout;
        this._mainAxisMinSize = -1;
        this._crossAxisMinSize = -1;
        this._mainAxisContentSize = 0;
    }

    get lines() {
        return this._lines;
    }

    get mainAxisMinSize() {
        if (this._mainAxisMinSize === -1) {
            this._mainAxisMinSize = this._getMainAxisMinSize();
        }
        return this._mainAxisMinSize;
    }

    get crossAxisMinSize() {
        if (this._crossAxisMinSize === -1) {
            this._crossAxisMinSize = this._getCrossAxisMinSize();
        }
        return this._crossAxisMinSize;
    }

    get mainAxisContentSize() {
        return this._mainAxisContentSize;
    }

    layoutLines() {
        this._setup();
        const items = this._layout.items;
        const wrap = this._layout.isWrapping();

        let startIndex = 0;
        let i;
        const n = items.length;
        for (i = 0; i < n; i++) {
            const item = items[i];

            this._layoutFlexItem(item);

            // Get predicted main axis size.
            const itemMainAxisSize = item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();

            if (wrap && (i > startIndex)) {
                const isOverflowing = (this._curMainAxisPos + itemMainAxisSize > this._mainAxisSize);
                if (isOverflowing) {
                    this._layoutLine(startIndex, i - 1);
                    this._curMainAxisPos = 0;
                    startIndex = i;
                }
            }

            this._addToMainAxisPos(itemMainAxisSize);
        }

        if (startIndex < i) {
            this._layoutLine(startIndex, i - 1);
        }
    }

    _layoutFlexItem(item) {
        if (item.isFlexEnabled()) {
            item.flexLayout.updateTreeLayout();
        } else {
            item.flexItem._resetLayoutSize();
        }
    }

    _setup() {
        this._mainAxisSize = this._layout.mainAxisSize;
        this._curMainAxisPos = 0;
        this._maxMainAxisPos = 0;
        this._lines = [];

        this._mainAxisMinSize = -1;
        this._crossAxisMinSize = -1;
        this._mainAxisContentSize = 0;
    }

    _addToMainAxisPos(itemMainAxisSize) {
        this._curMainAxisPos += itemMainAxisSize;
        if (this._curMainAxisPos > this._maxMainAxisPos) {
            this._maxMainAxisPos = this._curMainAxisPos;
        }
    }

    _layoutLine(startIndex, endIndex) {
        const availableSpace = this._getAvailableMainAxisLayoutSpace();
        const line = new _line_LineLayout_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this._layout, startIndex, endIndex, availableSpace);
        line.performLayout();
        this._lines.push(line);

        if (this._mainAxisContentSize === 0 || (this._curMainAxisPos > this._mainAxisContentSize)) {
            this._mainAxisContentSize = this._curMainAxisPos;
        }
    }

    _getAvailableMainAxisLayoutSpace() {
        if (!this._layout.resizingMainAxis && this._layout.isMainAxisFitToContents()) {
            return 0;
        } else {
            return this._mainAxisSize - this._curMainAxisPos;
        }
    }

    _getCrossAxisMinSize() {
        let crossAxisMinSize = 0;
        const items = this._layout.items;
        for (let i = 0, n = items.length; i < n; i++) {
            const item = items[i];
            const itemCrossAxisMinSize = item.flexItem._getCrossAxisMinSizeWithPaddingAndMargin();
            crossAxisMinSize = Math.max(crossAxisMinSize, itemCrossAxisMinSize);
        }
        return crossAxisMinSize;
    }

    _getMainAxisMinSize() {
        if (this._lines.length === 1) {
            return this._lines[0].getMainAxisMinSize();
        } else {
            // Wrapping lines: specified width is used as min width (in accordance to W3C flexbox).
            return this._layout.mainAxisSize;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpacingCalculator)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SpacingCalculator {

    static getSpacing(mode, numberOfItems, remainingSpace) {
        const itemGaps = (numberOfItems - 1);
        let spacePerGap;

        let spacingBefore, spacingBetween;

        switch(mode) {
            case "flex-start":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
            case "flex-end":
                spacingBefore = remainingSpace;
                spacingBetween = 0;
                break;
            case "center":
                spacingBefore = remainingSpace / 2;
                spacingBetween = 0;
                break;
            case "space-between":
                spacingBefore = 0;
                spacingBetween = Math.max(0, remainingSpace) / itemGaps;
                break;
            case "space-around":
                if (remainingSpace < 0) {
                    return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                    spacePerGap = remainingSpace / (itemGaps + 1);
                    spacingBefore = 0.5 * spacePerGap;
                    spacingBetween = spacePerGap;
                }
                break;
            case "space-evenly":
                if (remainingSpace < 0) {
                    return this.getSpacing("center", numberOfItems, remainingSpace);
                } else {
                    spacePerGap = remainingSpace / (itemGaps + 2);
                    spacingBefore = spacePerGap;
                    spacingBetween = spacePerGap;
                }
                break;
            case "stretch":
                spacingBefore = 0;
                spacingBetween = 0;
                break;
            default:
                throw new Error("Unknown mode: " + mode);
        }

        return {spacingBefore, spacingBetween}
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemAligner)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ItemAligner {

    constructor(line) {
        this._line = line;
        this._crossAxisLayoutSize = 0;
        this._crossAxisLayoutOffset = 0;
        this._alignItemsSetting = null;
        this._recursiveResizeOccured = false;
        this._isCrossAxisFitToContents = false;
    }

    get _layout() {
        return this._line._layout;
    }

    get _flexContainer() {
        return this._layout._flexContainer;
    }

    setCrossAxisLayoutSize(size) {
        this._crossAxisLayoutSize = size;
    }

    setCrossAxisLayoutOffset(offset) {
        this._crossAxisLayoutOffset = offset;
    }

    align() {
        this._alignItemsSetting = this._flexContainer.alignItems;

        this._isCrossAxisFitToContents = this._layout.isAxisFitToContents(!this._flexContainer._horizontal);

        this._recursiveResizeOccured = false;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            this._alignItem(item);
        }
    }

    get recursiveResizeOccured() {
        return this._recursiveResizeOccured;
    }

    _alignItem(item) {
        const flexItem = item.flexItem;
        let align = flexItem.alignSelf || this._alignItemsSetting;

        if (align === "stretch" && this._preventStretch(flexItem)) {
            align = "flex-start";
        }

        if (align !== "stretch" && !this._isCrossAxisFitToContents) {
            if (flexItem._hasRelCrossAxisSize()) {
                // As cross axis size might have changed, we need to recalc the relative flex item's size.
                flexItem._resetCrossAxisLayoutSize();
            }
        }

        switch(align) {
            case "flex-start":
                this._alignItemFlexStart(flexItem);
                break;
            case "flex-end":
                this._alignItemFlexEnd(flexItem);
                break;
            case "center":
                this._alignItemFlexCenter(flexItem);
                break;
            case "stretch":
                this._alignItemStretch(flexItem);
                break;
        }
    }

    _alignItemFlexStart(flexItem) {
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);
    }

    _alignItemFlexEnd(flexItem) {
        const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + (this._crossAxisLayoutSize - itemCrossAxisSize));
    }

    _alignItemFlexCenter(flexItem) {
        const itemCrossAxisSize = flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin();
        const center = (this._crossAxisLayoutSize - itemCrossAxisSize) / 2;
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset + center);
    }

    _alignItemStretch(flexItem) {
        flexItem._setCrossAxisLayoutPos(this._crossAxisLayoutOffset);

        const mainAxisLayoutSizeBeforeResize = flexItem._getMainAxisLayoutSize();
        let size = this._crossAxisLayoutSize - flexItem._getCrossAxisMargin() - flexItem._getCrossAxisPadding();

        const crossAxisMinSizeSetting = flexItem._getCrossAxisMinSizeSetting();
        if (crossAxisMinSizeSetting > 0) {
            size = Math.max(size, crossAxisMinSizeSetting);
        }

        const crossAxisMaxSizeSetting = flexItem._getCrossAxisMaxSizeSetting();
        const crossAxisMaxSizeSettingEnabled = (crossAxisMaxSizeSetting > 0);
        if (crossAxisMaxSizeSettingEnabled) {
            size = Math.min(size, crossAxisMaxSizeSetting);
        }

        flexItem._resizeCrossAxis(size);
        const mainAxisLayoutSizeAfterResize = flexItem._getMainAxisLayoutSize();

        const recursiveResize = (mainAxisLayoutSizeAfterResize !== mainAxisLayoutSizeBeforeResize);
        if (recursiveResize) {
            // Recursive resize can happen when this flex item has the opposite direction than the container
            // and is wrapping and auto-sizing. Due to item/content stretching the main axis size of the flex
            // item may decrease. If it does so, we must re-justify-content the complete line.
            // Notice that we don't account for changes to the (if autosized) main axis size caused by recursive
            // resize, which may cause the container's main axis to not shrink to the contents properly.
            // This is by design, because if we had re-run the main axis layout, we could run into issues such
            // as slow layout or endless loops.
            this._recursiveResizeOccured = true;
        }
    }

    _preventStretch(flexItem) {
        const hasFixedCrossAxisSize = flexItem._hasFixedCrossAxisSize();
        const forceStretch = (flexItem.alignSelf === "stretch");
        return hasFixedCrossAxisSize && !forceStretch;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ItemPositioner)
/* harmony export */ });
/* harmony import */ var _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../SpacingCalculator.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/SpacingCalculator.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ItemPositioner {

    constructor(lineLayout) {
        this._line = lineLayout;
    }

    get _layout() {
        return this._line._layout;
    }

    position() {
        const {spacingBefore, spacingBetween} = this._getSpacing();

        let currentPos = spacingBefore;

        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];

            item.flexItem._setMainAxisLayoutPos(currentPos);
            currentPos += item.flexItem._getMainAxisLayoutSizeWithPaddingAndMargin();
            currentPos += spacingBetween;
        }
    }

    _getSpacing() {
        const remainingSpace = this._line._availableSpace;
        let mode = this._layout._flexContainer.justifyContent;
        const numberOfItems = this._line.numberOfItems;

        return _SpacingCalculator_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getSpacing(mode, numberOfItems, remainingSpace);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/LineLayout.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LineLayout)
/* harmony export */ });
/* harmony import */ var _SizeShrinker_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SizeShrinker.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs");
/* harmony import */ var _SizeGrower_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SizeGrower.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs");
/* harmony import */ var _ItemPositioner_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ItemPositioner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemPositioner.mjs");
/* harmony import */ var _ItemAligner_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ItemAligner.mjs */ "./node_modules/@lightningjs/core/src/flex/layout/line/ItemAligner.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class LineLayout {

    constructor(layout, startIndex, endIndex, availableSpace) {
        this._layout = layout;
        this.items = layout.items;
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this._availableSpace = availableSpace;
    }

    performLayout() {
        this._setItemSizes();
        this.setItemPositions();
        this._calcLayoutInfo();
    }

    _setItemSizes() {
        if (this._availableSpace > 0) {
            this._growItemSizes(this._availableSpace);
        } else if (this._availableSpace < 0) {
            this._shrinkItemSizes(-this._availableSpace);
        }
    }

    _growItemSizes(amount) {
        const grower = new _SizeGrower_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);
        grower.grow(amount);
        this._availableSpace -= grower.getGrownSize();
    }

    _shrinkItemSizes(amount) {
        const shrinker = new _SizeShrinker_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        shrinker.shrink(amount);
        this._availableSpace += shrinker.getShrunkSize();
    }

    setItemPositions() {
        const positioner = new _ItemPositioner_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        positioner.position();
    }

    createItemAligner() {
        return new _ItemAligner_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
    }

    _calcLayoutInfo() {
        this._calcCrossAxisMaxLayoutSize();
    }

    getMainAxisMinSize() {
        let mainAxisMinSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            mainAxisMinSize += item.flexItem._getMainAxisMinSizeWithPaddingAndMargin();
        }
        return mainAxisMinSize;
    }
    
    get numberOfItems() {
        return this.endIndex - this.startIndex + 1;
    }

    get crossAxisLayoutSize() {
        const noSpecifiedCrossAxisSize = (this._layout.isCrossAxisFitToContents() && !this._layout.resizingCrossAxis);
        const shouldFitToContents = (this._layout.isWrapping() || noSpecifiedCrossAxisSize);
        if (shouldFitToContents) {
            return this._crossAxisMaxLayoutSize;
        } else {
            return this._layout.crossAxisSize;
        }
    }

    _calcCrossAxisMaxLayoutSize() {
        this._crossAxisMaxLayoutSize = this._getCrossAxisMaxLayoutSize();
    }

    _getCrossAxisMaxLayoutSize() {
        let crossAxisMaxSize = 0;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            const item = this.items[i];
            crossAxisMaxSize = Math.max(crossAxisMaxSize, item.flexItem._getCrossAxisLayoutSizeWithPaddingAndMargin());
        }
        return crossAxisMaxSize;
    }


}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/SizeGrower.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SizeGrower)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SizeGrower {

    constructor(line) {
        this._line = line;
        this._amountRemaining = 0;
        this._grownSize = 0;
    }

    grow(amount) {
        this._grownSize = 0;

        this._amountRemaining = amount;
        let totalGrowAmount = this._getTotalGrowAmount();
        if (totalGrowAmount) {
            const items = this._line.items;
            do {
                let amountPerGrow = this._amountRemaining / totalGrowAmount;
                for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const growAmount = flexItem.grow;
                    const isGrowableItem = (growAmount > 0);
                    if (isGrowableItem) {
                        let grow = growAmount * amountPerGrow;
                        const maxSize = flexItem._getMainAxisMaxSizeSetting();
                        const size = flexItem._getMainAxisLayoutSize();
                        if (maxSize > 0) {
                            if (size >= maxSize) {
                                // Already fully grown.
                                grow = 0;
                            } else {
                                const maxGrow = maxSize - size;
                                const isFullyGrown = (grow >= maxGrow);
                                if (isFullyGrown) {
                                    grow = maxGrow;

                                    // Destribute remaining amount over the other flex items.
                                    totalGrowAmount -= growAmount;
                                }
                            }
                        }

                        if (grow > 0) {
                            const finalSize = size + grow;
                            flexItem._resizeMainAxis(finalSize);

                            this._grownSize += grow;
                            this._amountRemaining -= grow;

                            if (Math.abs(this._amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while(totalGrowAmount && (Math.abs(this._amountRemaining) > 10e-6));
        }
    }

    _getTotalGrowAmount() {
        let total = 0;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;

            if (flexItem.grow) {
                const maxSize = flexItem._getMainAxisMaxSizeSetting();
                const size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully grown.
                if (maxSize === 0 || size < maxSize) {
                    total += flexItem.grow;
                }
            }
        }
        return total;
    }

    getGrownSize() {
        return this._grownSize;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/flex/layout/line/SizeShrinker.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SizeShrinker)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class SizeShrinker {

    constructor(line) {
        this._line = line;
        this._amountRemaining = 0;
        this._shrunkSize = 0;
    }

    shrink(amount) {
        this._shrunkSize = 0;

        this._amountRemaining = amount;
        let totalShrinkAmount = this._getTotalShrinkAmount();
        if (totalShrinkAmount) {
            const items = this._line.items;
            do {
                let amountPerShrink = this._amountRemaining / totalShrinkAmount;
                for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
                    const item = items[i];
                    const flexItem = item.flexItem;
                    const shrinkAmount = flexItem.shrink;
                    const isShrinkableItem = (shrinkAmount > 0);
                    if (isShrinkableItem) {
                        let shrink = shrinkAmount * amountPerShrink;
                        const minSize = flexItem._getMainAxisMinSize();
                        const size = flexItem._getMainAxisLayoutSize();
                        if (size > minSize) {
                            const maxShrink = size - minSize;
                            const isFullyShrunk = (shrink >= maxShrink);
                            if (isFullyShrunk) {
                                shrink = maxShrink;

                                // Destribute remaining amount over the other flex items.
                                totalShrinkAmount -= shrinkAmount;
                            }

                            const finalSize = size - shrink;
                            flexItem._resizeMainAxis(finalSize);

                            this._shrunkSize += shrink;
                            this._amountRemaining -= shrink;

                            if (Math.abs(this._amountRemaining) < 10e-6) {
                                return;
                            }
                        }
                    }
                }
            } while(totalShrinkAmount && (Math.abs(this._amountRemaining) > 10e-6));
        }
    }

    _getTotalShrinkAmount() {
        let total = 0;
        const items = this._line.items;
        for (let i = this._line.startIndex; i <= this._line.endIndex; i++) {
            const item = items[i];
            const flexItem = item.flexItem;

            if (flexItem.shrink) {
                const minSize = flexItem._getMainAxisMinSize();
                const size = flexItem._getMainAxisLayoutSize();

                // Exclude those already fully shrunk.
                if (size > minSize) {
                    total += flexItem.shrink;
                }
            }
        }
        return total;
    }

    getShrunkSize() {
        return this._shrunkSize;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/lightning.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/lightning.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _application_Application_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./application/Application.mjs */ "./node_modules/@lightningjs/core/src/application/Application.mjs");
/* harmony import */ var _application_Component_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./application/Component.mjs */ "./node_modules/@lightningjs/core/src/application/Component.mjs");
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tree/Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _tree_core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tree/core/ElementCore.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs");
/* harmony import */ var _tree_core_ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tree/core/ElementTexturizer.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs");
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _tools_Tools_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./tools/Tools.mjs */ "./node_modules/@lightningjs/core/src/tools/Tools.mjs");
/* harmony import */ var _tools_ObjMerger_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./tools/ObjMerger.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs");
/* harmony import */ var _tools_ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./tools/ObjectListProxy.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs");
/* harmony import */ var _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tools/ObjectListWrapper.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs");
/* harmony import */ var _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./textures/RectangleTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs");
/* harmony import */ var _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./textures/NoiseTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs");
/* harmony import */ var _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./textures/TextTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs");
/* harmony import */ var _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./textures/ImageTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs");
/* harmony import */ var _textures_HtmlTexture_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./textures/HtmlTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs");
/* harmony import */ var _textures_StaticTexture_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./textures/StaticTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs");
/* harmony import */ var _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./textures/StaticCanvasTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs");
/* harmony import */ var _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./textures/SourceTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs");
/* harmony import */ var _components_ListComponent_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/ListComponent.mjs */ "./node_modules/@lightningjs/core/src/components/ListComponent.mjs");
/* harmony import */ var _components_FastBlurComponent_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/FastBlurComponent.mjs */ "./node_modules/@lightningjs/core/src/components/FastBlurComponent.mjs");
/* harmony import */ var _components_BloomComponent_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/BloomComponent.mjs */ "./node_modules/@lightningjs/core/src/components/BloomComponent.mjs");
/* harmony import */ var _components_SmoothScaleComponent_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/SmoothScaleComponent.mjs */ "./node_modules/@lightningjs/core/src/components/SmoothScaleComponent.mjs");
/* harmony import */ var _components_BorderComponent_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/BorderComponent.mjs */ "./node_modules/@lightningjs/core/src/components/BorderComponent.mjs");
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _renderer_webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./renderer/webgl/WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./renderer/webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./renderer/common/shaders/GrayscaleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./renderer/webgl/shaders/BoxBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_DitheringShader_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./renderer/webgl/shaders/DitheringShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_CircularPushShader_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./renderer/webgl/shaders/CircularPushShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_InversionShader_mjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./renderer/webgl/shaders/InversionShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./renderer/webgl/shaders/LinearBlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_OutlineShader_mjs__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./renderer/webgl/shaders/OutlineShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_PixelateShader_mjs__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./renderer/webgl/shaders/PixelateShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RadialFilterShader_mjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./renderer/webgl/shaders/RadialFilterShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RoundedRectangleShader_mjs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./renderer/webgl/shaders/RoundedRectangleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_FadeOutShader_mjs__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./renderer/webgl/shaders/FadeOutShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_VignetteShader_mjs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./renderer/webgl/shaders/VignetteShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_SpinnerShader_mjs__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./renderer/webgl/shaders/SpinnerShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_HoleShader_mjs__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./renderer/webgl/shaders/HoleShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_RadialGradientShader_mjs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./renderer/webgl/shaders/RadialGradientShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_Light3dShader_mjs__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./renderer/webgl/shaders/Light3dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_PerspectiveShader_mjs__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./renderer/webgl/shaders/PerspectiveShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs");
/* harmony import */ var _renderer_webgl_shaders_MagnifierShader_mjs__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./renderer/webgl/shaders/MagnifierShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs");
/* harmony import */ var _renderer_c2d_C2dShader_mjs__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./renderer/c2d/C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./renderer/c2d/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./renderer/c2d/shaders/BlurShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs");
/* harmony import */ var _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./tree/Stage.mjs */ "./node_modules/@lightningjs/core/src/tree/Stage.mjs");
/* harmony import */ var _renderer_webgl_shaders_SpinnerShader2_mjs__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./renderer/webgl/shaders/SpinnerShader2.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





























































const lightning = {
    Application: _application_Application_mjs__WEBPACK_IMPORTED_MODULE_0__["default"],
    Component: _application_Component_mjs__WEBPACK_IMPORTED_MODULE_1__["default"],
    Base: _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"],
    Utils: _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"],
    StageUtils: _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_4__["default"],
    Element: _tree_Element_mjs__WEBPACK_IMPORTED_MODULE_5__["default"],
    Tools: _tools_Tools_mjs__WEBPACK_IMPORTED_MODULE_9__["default"],
    Stage: _tree_Stage_mjs__WEBPACK_IMPORTED_MODULE_50__["default"],
    ElementCore: _tree_core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_6__["default"],
    ElementTexturizer: _tree_core_ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_7__["default"],
    Texture: _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_8__["default"],
    EventEmitter: _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_26__["default"],
    shaders: {
        Grayscale: _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__.WebGLGrayscaleShader,
        BoxBlur: _renderer_webgl_shaders_BoxBlurShader_mjs__WEBPACK_IMPORTED_MODULE_30__["default"],
        Dithering: _renderer_webgl_shaders_DitheringShader_mjs__WEBPACK_IMPORTED_MODULE_31__["default"],
        CircularPush: _renderer_webgl_shaders_CircularPushShader_mjs__WEBPACK_IMPORTED_MODULE_32__["default"],
        Inversion: _renderer_webgl_shaders_InversionShader_mjs__WEBPACK_IMPORTED_MODULE_33__["default"],
        LinearBlur: _renderer_webgl_shaders_LinearBlurShader_mjs__WEBPACK_IMPORTED_MODULE_34__["default"],
        Outline: _renderer_webgl_shaders_OutlineShader_mjs__WEBPACK_IMPORTED_MODULE_35__["default"],
        Pixelate: _renderer_webgl_shaders_PixelateShader_mjs__WEBPACK_IMPORTED_MODULE_36__["default"],
        RadialFilter: _renderer_webgl_shaders_RadialFilterShader_mjs__WEBPACK_IMPORTED_MODULE_37__["default"],
        RoundedRectangle: _renderer_webgl_shaders_RoundedRectangleShader_mjs__WEBPACK_IMPORTED_MODULE_38__["default"],
        Spinner2: _renderer_webgl_shaders_SpinnerShader2_mjs__WEBPACK_IMPORTED_MODULE_51__["default"],
        FadeOut: _renderer_webgl_shaders_FadeOutShader_mjs__WEBPACK_IMPORTED_MODULE_39__["default"],
        Hole: _renderer_webgl_shaders_HoleShader_mjs__WEBPACK_IMPORTED_MODULE_42__["default"],
        Vignette: _renderer_webgl_shaders_VignetteShader_mjs__WEBPACK_IMPORTED_MODULE_40__["default"],
        Spinner: _renderer_webgl_shaders_SpinnerShader_mjs__WEBPACK_IMPORTED_MODULE_41__["default"],
        RadialGradient: _renderer_webgl_shaders_RadialGradientShader_mjs__WEBPACK_IMPORTED_MODULE_43__["default"],
        Light3d: _renderer_webgl_shaders_Light3dShader_mjs__WEBPACK_IMPORTED_MODULE_44__["default"],
        Perspective: _renderer_webgl_shaders_PerspectiveShader_mjs__WEBPACK_IMPORTED_MODULE_45__["default"],
        Magnifier: _renderer_webgl_shaders_MagnifierShader_mjs__WEBPACK_IMPORTED_MODULE_46__["default"],
        WebGLShader: _renderer_webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_27__["default"],
        WebGLDefaultShader: _renderer_webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_28__["default"],
        C2dShader: _renderer_c2d_C2dShader_mjs__WEBPACK_IMPORTED_MODULE_47__["default"],
        C2dDefaultShader: _renderer_c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_48__["default"],
        c2d: {
            Grayscale: _renderer_common_shaders_GrayscaleShader_mjs__WEBPACK_IMPORTED_MODULE_29__.C2dGrayscaleShader,
            Blur: _renderer_c2d_shaders_BlurShader_mjs__WEBPACK_IMPORTED_MODULE_49__["default"]
        }
    },
    textures: {
        RectangleTexture: _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_13__["default"],
        NoiseTexture: _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_14__["default"],
        TextTexture: _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_15__["default"],
        ImageTexture: _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_16__["default"],
        HtmlTexture: _textures_HtmlTexture_mjs__WEBPACK_IMPORTED_MODULE_17__["default"],
        StaticTexture: _textures_StaticTexture_mjs__WEBPACK_IMPORTED_MODULE_18__["default"],
        StaticCanvasTexture: _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_19__["default"],
        SourceTexture: _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_20__["default"]
    },
    components: {
        FastBlurComponent: _components_FastBlurComponent_mjs__WEBPACK_IMPORTED_MODULE_22__["default"],
        BloomComponent: _components_BloomComponent_mjs__WEBPACK_IMPORTED_MODULE_23__["default"],
        SmoothScaleComponent: _components_SmoothScaleComponent_mjs__WEBPACK_IMPORTED_MODULE_24__["default"],
        BorderComponent: _components_BorderComponent_mjs__WEBPACK_IMPORTED_MODULE_25__["default"],
        ListComponent: _components_ListComponent_mjs__WEBPACK_IMPORTED_MODULE_21__["default"]
    },
    tools: {
        ObjMerger: _tools_ObjMerger_mjs__WEBPACK_IMPORTED_MODULE_10__["default"],
        ObjectListProxy: _tools_ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_11__["default"],
        ObjectListWrapper: _tools_ObjectListWrapper_mjs__WEBPACK_IMPORTED_MODULE_12__["default"]
    }
};

if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isWeb) {
    window.lng = lightning;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lightning);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PlatformLoader)
/* harmony export */ });
/* harmony import */ var _browser_WebPlatform_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser/WebPlatform.mjs */ "./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class PlatformLoader {
    static load(options) {
        if (options.platform) {
            return options.platform;
        } else {
            return _browser_WebPlatform_mjs__WEBPACK_IMPORTED_MODULE_0__["default"];
        }
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageWorker)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ImageWorker {

    constructor(options = {}) {
        this._items = new Map();
        this._id = 0;

        this._initWorker();
    }

    destroy() {
        if (this._worker) {
            this._worker.terminate();
        }
    }

    _initWorker() {
        const code = `(${createWorker.toString()})()`;
        const blob = new Blob([code.replace('"use strict";', '')]); // firefox adds "use strict"; to any function which might block worker execution so knock it off
        const blobURL = (window.URL ? URL : webkitURL).createObjectURL(blob, {
            type: 'application/javascript; charset=utf-8'
        });
        this._worker = new Worker(blobURL);

        this._worker.postMessage({type: 'config', config: {path: window.location.href, protocol: window.location.protocol}});

        this._worker.onmessage = (e) => {
            if (e.data && e.data.id) {
                const id = e.data.id;
                const item = this._items.get(id);
                if (item) {
                    if (e.data.type == 'data') {
                        this.finish(item, e.data.info);
                    } else {
                        this.error(item, e.data.info);
                    }
                }
            }
        }
    }

    create(src) {
        const id = ++this._id;
        const item = new ImageWorkerImage(this, id, src);
        this._items.set(id, item);
        this._worker.postMessage({type: "add", id: id, src: src});
        return item;
    }

    cancel(image) {
        this._worker.postMessage({type: "cancel", id: image.id});
        this._items.delete(image.id);
    }

    error(image, info) {
        image.error(info);
        this._items.delete(image.id);
    }

    finish(image, info) {
        image.load(info);
        this._items.delete(image.id);
    }

}

class ImageWorkerImage {

    constructor(manager, id, src) {
        this._manager = manager;
        this._id = id;
        this._src = src;
        this._onError = null;
        this._onLoad = null;
    }

    get id() {
        return this._id;
    }

    get src() {
        return this._src;
    }

    set onError(f) {
        this._onError = f;
    }

    set onLoad(f) {
        this._onLoad = f;
    }

    cancel() {
        this._manager.cancel(this);
    }

    load(info) {
        if (this._onLoad) {
            this._onLoad(info);
        }
    }

    error(info) {
        if (this._onError) {
            this._onError(info);
        }
    }

}

/**
 * Notice that, within the createWorker function, we must only use ES5 code to keep it ES5-valid after babelifying, as
 *  the converted code of this section is converted to a blob and used as the js of the web worker thread.
 */
const createWorker = function() {

    function ImageWorkerServer() {

        this.items = new Map();

        var t = this;
        onmessage = function(e) {
            t._receiveMessage(e);
        }

    }

    ImageWorkerServer.isPathAbsolute = function(path) {
        return /^(?:\/|[a-z]+:\/\/)/.test(path) || path.substr(0, 5) == 'data:';
    };

    ImageWorkerServer.prototype._receiveMessage = function(e) {
        if (e.data.type === 'config') {
            this.config = e.data.config;

            var base = this.config.path;
            // the constructing of the basepath fails
            // if location.hash contains a slash
            var hasHashPath = /#.*?\//;
            if(hasHashPath.test(base)){
                base = base.replace(/#.*$/,'');
            }

            var parts = base.split("/");
            parts.pop();
            this._relativeBase = parts.join("/") + "/";

        } else if (e.data.type === 'add') {
            this.add(e.data.id, e.data.src);
        } else if (e.data.type === 'cancel') {
            this.cancel(e.data.id);
        }
    };

    ImageWorkerServer.prototype.add = function(id, src) {
        // Convert relative URLs.
        if (!ImageWorkerServer.isPathAbsolute(src)) {
            src = this._relativeBase + src;
        }

        if (src.substr(0,2) === "//") {
            // This doesn't work for image workers.
            src = this.config.protocol + src;
        }

        var item = new ImageWorkerServerItem(id, src);
        var t = this;
        item.onFinish = function(result) {
            t.finish(item, result);
        };
        item.onError = function(info) {
            t.error(item, info);
        };
        this.items.set(id, item);
        item.start();
    };

    ImageWorkerServer.prototype.cancel = function(id) {
        var item = this.items.get(id);
        if (item) {
            item.cancel();
            this.items.delete(id);
        }
    }

    ImageWorkerServer.prototype.finish = function(item, {imageBitmap, hasAlphaChannel}) {
        postMessage({
            type: "data",
            id: item.id,
            info: {
                imageBitmap,
                hasAlphaChannel
            }
        }, [imageBitmap]);
        this.items.delete(item.id);
    };

    ImageWorkerServer.prototype.error = function(item, {type, message}) {
        postMessage({
            type: "error",
            id: item.id,
            info: {
                type,
                message
            }
        });
        this.items.delete(item.id);
    };

    ImageWorkerServer.isWPEBrowser = function() {
        return (navigator.userAgent.indexOf("WPE") !== -1);
    };

    function ImageWorkerServerItem(id, src) {

        this._onError = undefined;
        this._onFinish = undefined;
        this._id = id;
        this._src = src;
        this._xhr = undefined;
        this._mimeType = undefined;
        this._canceled = false;

    }

    Object.defineProperty(ImageWorkerServerItem.prototype, 'id', {
        get: function() {
            return this._id;
        }
    });

    Object.defineProperty(ImageWorkerServerItem.prototype, 'onFinish', {
        get: function() {
            return this._onFinish;
        },
        set: function(f) {
            this._onFinish = f;
        }
    });

    Object.defineProperty(ImageWorkerServerItem.prototype, 'onError', {
        get: function() {
            return this._onError;
        },
        set: function(f) {
            this._onError = f;
        }
    });

    ImageWorkerServerItem.prototype.start = function() {
        this._xhr = new XMLHttpRequest();
        this._xhr.open("GET", this._src, true);
        this._xhr.responseType = "blob";

        var t = this;
        this._xhr.onerror = function(oEvent) {
            t.error({type: "connection", message: "Connection error"});
        };

        this._xhr.onload = function(oEvent) {
            var blob = t._xhr.response;
            t._mimeType = blob.type;

            t._createImageBitmap(blob);
        };

        this._xhr.send();
    };

    ImageWorkerServerItem.prototype._createImageBitmap = function(blob) {
        var t = this;
        createImageBitmap(blob, {premultiplyAlpha: 'premultiply', colorSpaceConversion: 'none', imageOrientation: 'none'}).then(function(imageBitmap) {
            t.finish({
                imageBitmap,
                hasAlphaChannel: t._hasAlphaChannel()
            });
        }).catch(function(e) {
            t.error({type: "parse", message: "Error parsing image data"});
        });
    };

    ImageWorkerServerItem.prototype._hasAlphaChannel = function() {
        if (ImageWorkerServer.isWPEBrowser()) {
            // When using unaccelerated rendering image (https://github.com/WebPlatformForEmbedded/WPEWebKit/blob/wpe-20170728/Source/WebCore/html/ImageBitmap.cpp#L52),
            // everything including JPG images are in RGBA format. Upload is way faster when using an alpha channel.
            // @todo: after hardware acceleration is fixed and re-enabled, JPG should be uploaded in RGB to get the best possible performance and memory usage.
            return true;
        } else {
            return (this._mimeType.indexOf("image/png") !== -1);
        }
    };

    ImageWorkerServerItem.prototype.cancel = function() {
        if (this._canceled) return;
        if (this._xhr) {
            this._xhr.abort();
        }
        this._canceled = true;
    };

    ImageWorkerServerItem.prototype.error = function(type, message) {
        if (!this._canceled && this._onError) {
            this._onError({type, message});
        }
    };

    ImageWorkerServerItem.prototype.finish = function(info) {
        if (!this._canceled && this._onFinish) {
            this._onFinish(info);
        }
    };

    var worker = new ImageWorkerServer();
};


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs":
/*!******************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/platforms/browser/WebPlatform.mjs ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebPlatform)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _ImageWorker_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageWorker.mjs */ "./node_modules/@lightningjs/core/src/platforms/browser/ImageWorker.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Platform-specific functionality.
 */
class WebPlatform {

    init(stage) {
        this.stage = stage;
        this._looping = false;
        this._awaitingLoop = false;

        if (this.stage.getOption("useImageWorker")) {
            if (!window.createImageBitmap || !window.Worker) {
                console.warn("[Lightning] Can't use image worker because browser does not have createImageBitmap and Web Worker support");
            } else {
                this._imageWorker = new _ImageWorker_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]();
            }
        }
    }

    destroy() {
        if (this._imageWorker) {
            this._imageWorker.destroy();
        }
        this._removeKeyHandler();
        this._removeClickHandler();
        this._removeHoverHandler();
        this._removeScrollWheelHandler();
    }

    startLoop() {
        this._looping = true;
        if (!this._awaitingLoop) {
            this.loop();
        }
    }

    stopLoop() {
        this._looping = false;
    }

    loop() {
        let self = this;
        let lp = function() {
            self._awaitingLoop = false;
            if (self._looping) {
                self.stage.drawFrame();
                requestAnimationFrame(lp);
                self._awaitingLoop = true;
            }
        }
        requestAnimationFrame(lp);
    }

    uploadGlTexture(gl, textureSource, source, options) {
        if (source instanceof ImageData || source instanceof HTMLImageElement || source instanceof HTMLVideoElement || (window.ImageBitmap && source instanceof ImageBitmap)) {
            // Web-specific data types.
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, source);
        } else if (source instanceof HTMLCanvasElement) {
            // Workaround for some browsers (e.g. Tizen) as they do not convert canvas data to texture correctly, sometimes causing artifacts.
            const ctx = source.getContext('2d');
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, options.format, options.type, ctx.getImageData(0, 0, source.width, source.height));
        } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, options.internalFormat, textureSource.w, textureSource.h, 0, options.format, options.type, source);
        }
    }

    loadSrcTexture({src, hasAlpha}, cb) {
        let cancelCb = undefined;
        let isPng = (src.indexOf(".png") >= 0) || src.substr(0, 21) == 'data:image/png;base64';
        if (this._imageWorker) {
            // WPE-specific image parser.
            const image = this._imageWorker.create(src);
            image.onError = function(err) {
                return cb("Image load error");
            };
            image.onLoad = function({imageBitmap, hasAlphaChannel}) {
                cb(null, {
                    source: imageBitmap,
                    renderInfo: {src: src},
                    hasAlpha: hasAlphaChannel,
                    premultiplyAlpha: true
                });
            };
            cancelCb = function() {
                image.cancel();
            }
        } else {
            let image = new Image();

            // On the PS4 platform setting the `crossOrigin` attribute on
            // images can cause CORS failures.
            if (!(src.substr(0,5) == "data:") && !_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isPS4) {
                // Base64.
                image.crossOrigin = "Anonymous";
            }
            image.onerror = function(err) {
                // Ignore error message when cancelled.
                if (image.src) {
                    return cb("Image load error");
                }
            };
            image.onload = function() {
                cb(null, {
                    source: image,
                    renderInfo: {src: src},
                    hasAlpha: isPng || hasAlpha
                });
            };
            image.src = src;

            cancelCb = function() {
                image.onerror = null;
                image.onload = null;
                image.removeAttribute('src');
            }
        }

        return cancelCb;
    }

    createWebGLContext(w, h) {
        let canvas = this.stage.getOption('canvas') || document.createElement('canvas');

        if (w && h) {
            canvas.width = w;
            canvas.height = h;
        }

        let opts = {
            alpha: true,
            antialias: false,
            premultipliedAlpha: true,
            stencil: true,
            preserveDrawingBuffer: false
        };

        let gl = canvas.getContext('webgl', opts) || canvas.getContext('experimental-webgl', opts);
        if (!gl) {
            throw new Error('This browser does not support webGL.');
        }

        return gl;
    }

    createCanvasContext(w, h) {
        let canvas = this.stage.getOption('canvas') || document.createElement('canvas');

        if (w && h) {
            canvas.width = w;
            canvas.height = h;
        }

        let c2d = canvas.getContext('2d');
        if (!c2d) {
            throw new Error('This browser does not support 2d canvas.');
        }

        return c2d;
    }

    getHrTime() {
        return window.performance ? window.performance.now() : (new Date()).getTime();
    }

    getDrawingCanvas() {
        // We can't reuse this canvas because textures may load async.
        return document.createElement('canvas');
    }

    getTextureOptionsForDrawingCanvas(canvas) {
        let options = {};
        options.source = canvas;
        return options;
    }

    nextFrame(changes) {
        /* WebGL blits automatically */
    }

    registerKeydownHandler(keyhandler) {
        this._keydownListener = (e) => {
            keyhandler(e);
        };
        window.addEventListener('keydown', this._keydownListener);
    }

    registerKeyupHandler(keyhandler) {
        this._keyupListener = (e) => {
            keyhandler(e);
        };
        window.addEventListener('keyup', this._keyupListener);
    }

    _removeKeyHandler() {
        if (this._keydownListener) {
            window.removeEventListener('keydown', this._keydownListener);
        }

        if (this._keyupListener) {
            window.removeEventListener('keyup', this._keyupListener);
        }
    }

    registerClickHandler(clickHandler) {
        this._clickListener = e => {
            clickHandler(e);
        };
        window.addEventListener('mousedown', this._clickListener);
    }

    _removeClickHandler() {
        if (this._clickListener) {
            window.removeEventListener('mousedown', this._clickListener);
        }
    }

    registerHoverHandler(hoverHandler) {
        this._hoverListener = e => {
            hoverHandler(e);
        };
        window.addEventListener('mousemove', this._hoverListener);
    }

    _removeHoverHandler() {
        if (this._hoverListener) {
            window.removeEventListener('mousemove', this._hoverListener);
        }
    }

    registerScrollWheelHandler(registerScrollWheelHandler) {
        this._scrollWheelListener = e => {
            registerScrollWheelHandler(e);
        }
        window.addEventListener('wheel', this._scrollWheelListener);
    }

    _removeScrollWheelHandler() {
        if (this._scrollWheelListener) {
            window.removeEventListener('wheel', this._scrollWheelListener);
        }
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/Renderer.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Renderer)
/* harmony export */ });
/* harmony import */ var _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Renderer {

    constructor(stage) {
        this.stage = stage;
        this._defaultShader = undefined;
    }

    gc(aggressive) {
    }

    destroy() {
    }

    getDefaultShader(ctx = this.stage.ctx) {
        if (!this._defaultShader) {
            this._defaultShader = this._createDefaultShader(ctx);
        }
        return this._defaultShader;
    }

    _createDefaultShader(ctx) {
    }

    isValidShaderType(shaderType) {
        return (shaderType.prototype instanceof this._getShaderBaseType());
    }

    createShader(ctx, settings) {
        const shaderType = settings.type;
        // If shader type is not correct, use a different platform.
        if (!this.isValidShaderType(shaderType)) {
            const convertedShaderType = this._getShaderAlternative(shaderType);
            if (!convertedShaderType) {
                console.warn("[Lightning] Shader has no implementation for render target: " + shaderType.name);
                return this._createDefaultShader(ctx);
            }
            return new convertedShaderType(ctx);
        } else {
            const shader = new shaderType(ctx);
            _tree_Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
            return shader;
        }
    }

    _getShaderBaseType() {
    }

    _getShaderAlternative(shaderType) {
        return this.getDefaultShader();
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        console.warn('[Lightning] copyRenderTexture not supported by renderer');
    }
}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreQuadList)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dCoreQuadList extends _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this.renderContexts = [];
        this.modes = [];
    }

    setRenderContext(index, v) {
        this.renderContexts[index] = v;
    }

    setSimpleTc(index, v) {
        if (v) {
            this.modes[index] |= 1;
        } else {
            this.modes[index] -= (this.modes[index] & 1);
        }
    }

    setWhite(index, v) {
        if (v) {
            this.modes[index] |= 2;
        } else {
            this.modes[index] -= (this.modes[index] & 2);
        }
    }

    getRenderContext(index) {
        return this.renderContexts[index];
    }

    getSimpleTc(index) {
        return (this.modes[index] & 1);
    }

    getWhite(index) {
        return (this.modes[index] & 2);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreQuadOperation)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dCoreQuadOperation extends _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    getRenderContext(index) {
        return this.quads.getRenderContext(this.index + index);
    }

    getSimpleTc(index) {
        return this.quads.getSimpleTc(this.index + index);
    }

    getWhite(index) {
        return this.quads.getWhite(this.index + index);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dCoreRenderExecutor)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class C2dCoreRenderExecutor extends _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    init() {
        this._mainRenderTexture = this.ctx.stage.getCanvas();
    }

    _renderQuadOperation(op) {
        let shader = op.shader;

        if (op.length || op.shader.addEmpty()) {
            const target = this._renderTexture || this._mainRenderTexture;
            shader.beforeDraw(op, target);
            shader.draw(op, target);
            shader.afterDraw(op, target);
        }
    }

    _clearRenderTexture() {
        const ctx = this._getContext();

        let clearColor = [0, 0, 0, 0];
        if (this._mainRenderTexture.ctx === ctx) {
            clearColor = this.ctx.stage.getClearColor();
        }

        const renderTexture = ctx.canvas;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (!clearColor[0] && !clearColor[1] && !clearColor[2] && !clearColor[3]) {
            ctx.clearRect(0, 0, renderTexture.width, renderTexture.height);
        } else {
            ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaStringFromArray(clearColor);
            // Do not use fillRect because it produces artifacts.
            ctx.globalCompositeOperation = 'copy';
            ctx.beginPath();
            ctx.rect(0, 0, renderTexture.width, renderTexture.height);
            ctx.closePath();
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        }
    }
    
    _getContext() {
        if (this._renderTexture) {
            return this._renderTexture.ctx;
        } else {
            return this._mainRenderTexture.ctx;
        } 
    }

    _restoreContext() {
        const ctx = this._getContext();
        ctx.restore();
        ctx.save();
        ctx._scissor = null;
    }

    _setScissor(area) {
        const ctx = this._getContext();

        if (!C2dCoreRenderExecutor._equalScissorAreas(ctx.canvas, ctx._scissor, area)) {
            // Clipping is stored in the canvas context state.
            // We can't reset clipping alone so we need to restore the full context.
            this._restoreContext();

            let precision = this.ctx.stage.getRenderPrecision();
            if (area) {
                ctx.beginPath();
                ctx.rect(Math.round(area[0] * precision), Math.round(area[1] * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
                ctx.closePath();
                ctx.clip();
            }
            ctx._scissor = area;
        }
    }

    static _equalScissorAreas(canvas, area, current) {
        if (!area) {
            area = [0, 0, canvas.width, canvas.height]
        }
        if (!current) {
            current = [0, 0, canvas.width, canvas.height]
        }
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].equalValues(area, current)
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dRenderer)
/* harmony export */ });
/* harmony import */ var _C2dCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./C2dCoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadList.mjs");
/* harmony import */ var _C2dCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./C2dCoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreQuadOperation.mjs");
/* harmony import */ var _C2dCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./C2dCoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dCoreRenderExecutor.mjs");
/* harmony import */ var _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../tree/core/CoreRenderState.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs");
/* harmony import */ var _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _Renderer_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Renderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs");
/* harmony import */ var _C2dTextureTintManager_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./C2dTextureTintManager.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










class C2dRenderer extends _Renderer_mjs__WEBPACK_IMPORTED_MODULE_6__["default"] {

    constructor(stage) {
        super(stage);

        this.tintManager = new _C2dTextureTintManager_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](stage);

        this.setupC2d(this.stage.c2d.canvas);
    }

    destroy() {
        this.tintManager.destroy();
    }

    _createDefaultShader(ctx) {
        return new _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](ctx);
    }

    _getShaderBaseType() {
        return _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]
    }

    _getShaderAlternative(shaderType) {
        return shaderType.getC2d && shaderType.getC2d();
    }

    createCoreQuadList(ctx) {
        return new _C2dCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](ctx);
    }

    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new _C2dCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }

    createCoreRenderExecutor(ctx) {
        return new _C2dCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](ctx);
    }
    
    createCoreRenderState(ctx) {
        return new _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](ctx);
    }

    createRenderTexture(w, h, pw, ph) {
        const canvas = document.createElement('canvas');
        canvas.width = pw;
        canvas.height = ph;
        this.setupC2d(canvas);
        return canvas;
    }
    
    freeRenderTexture(nativeTexture) {
        this.tintManager.delete(nativeTexture);
    }

    gc(aggressive) {
        this.tintManager.gc(aggressive);
    }

    uploadTextureSource(textureSource, options) {
        // For canvas, we do not need to upload.
        if (options.source.buffer) {
            // Convert RGBA buffer to canvas.
            const canvas = document.createElement('canvas');
            canvas.width = options.w;
            canvas.height = options.h;

            const imageData = new ImageData(new Uint8ClampedArray(options.source.buffer), options.w, options.h);
            canvas.getContext('2d').putImageData(imageData, 0, 0);
            return canvas;
        }

        return options.source;
    }

    freeTextureSource(textureSource) {
        this.tintManager.delete(textureSource.nativeTexture);
    }

    addQuad(renderState, quads, index) {
        // Render context changes while traversing so we save it by ref.
        const elementCore = quads.quadElements[index];
        quads.setRenderContext(index, elementCore._renderContext);
        quads.setWhite(index, elementCore.isWhite());
        quads.setSimpleTc(index, elementCore.hasSimpleTexCoords());
    }

    isRenderTextureReusable(renderState, renderTextureInfo) {
        // @todo: check render coords/matrix, maybe move this to core?
        return false;
    }

    finishRenderState(renderState) {
    }

    setupC2d(canvas) {
        const ctx = canvas.getContext('2d');
        canvas.ctx = ctx;

        ctx._scissor = null;

        // Save base state so we can restore the defaults later.
        canvas.ctx.save();
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dShader)
/* harmony export */ });
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class C2dShader extends _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    beforeDraw(operation) {
    }

    draw(operation) {
    }

    afterDraw(operation) {
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/C2dTextureTintManager.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ C2dTextureTintManager)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class C2dTextureTintManager {

    constructor(stage) {
        this.stage = stage;
        this._usedMemory = 0;
        this._cachedNativeTextures = new Set();
    }

    destroy() {
        this.gc(true);
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;

        this.stage.addMemoryUsage(delta);
    }

    delete(nativeTexture) {
        // Should be called when native texture is cleaned up.
        if (this._hasCache(nativeTexture)) {
            const cache = this._getCache(nativeTexture);
            const prevMemUsage = cache.memoryUsage;
            cache.clear();
            this._cachedNativeTextures.delete(nativeTexture);
            this._addMemoryUsage(cache.memoryUsage - prevMemUsage);
        }
    }

    getTintTexture(nativeTexture, color) {
        const frame = this.stage.frameCounter;

        this._cachedNativeTextures.add(nativeTexture);

        const cache = this._getCache(nativeTexture);

        const item = cache.get(color);
        item.lf = frame;

        if (item.tx) {
            if (nativeTexture.update > item.u) {
                // Native texture was updated in the mean time: renew.
                this._tintTexture(item.tx, nativeTexture, color)
            }

            return item.tx;
        } else {
            const before = cache.memoryUsage;

            // Find blanco tint texture.
            let target = cache.reuseTexture(frame);
            if (target) {
                target.ctx.clearRect(0, 0, target.width, target.height);
            } else {
                // Allocate new.
                target = document.createElement('canvas');
                target.width = nativeTexture.w;
                target.height = nativeTexture.h;
                target.ctx = target.getContext('2d');
            }

            this._tintTexture(target, nativeTexture, color);
            cache.set(color, target, frame);

            const after = cache.memoryUsage;

            if (after !== before) {
                this._addMemoryUsage(after - before);
            }

            return target;
        }
    }

    _tintTexture(target, source, color) {
        let col = color.toString(16);
        while (col.length < 6) {
            col = "0" + col;
        }
        target.ctx.fillStyle = '#' + col;
        target.ctx.globalCompositeOperation = 'copy';
        target.ctx.fillRect(0, 0, source.w, source.h);
        target.ctx.globalCompositeOperation = 'multiply';
        target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);

        // Alpha-mix the texture.
        target.ctx.globalCompositeOperation = 'destination-in';
        target.ctx.drawImage(source, 0, 0, source.w, source.h, 0, 0, target.width, target.height);
    }

    _hasCache(nativeTexture) {
        return !!nativeTexture._tintCache;
    }

    _getCache(nativeTexture) {
        if (!nativeTexture._tintCache) {
            nativeTexture._tintCache = new C2dTintCache(nativeTexture);
        }
        return nativeTexture._tintCache;
    }

    gc(aggressive = false) {
        const frame = this.stage.frameCounter;
        let delta = 0;
        this._cachedNativeTextures.forEach(texture => {
            const cache = this._getCache(texture);
            if (aggressive) {
                delta += cache.memoryUsage;
                cache.clear();
            } else {
                const before = cache.memoryUsage;
                cache.cleanup(frame);
                cache.releaseBlancoTextures();
                delta += (cache.memoryUsage - before);
            }
        });

        if (aggressive) {
            this._cachedNativeTextures.clear();
        }

        if (delta) {
            this._addMemoryUsage(delta);
        }
    }

}

class C2dTintCache {

    constructor(nativeTexture) {
        this._tx = nativeTexture;
        this._colors = new Map();
        this._blancoTextures = null;
        this._lastCleanupFrame = 0;
        this._memTextures = 0;
    }

    get memoryUsage() {
        return this._memTextures * this._tx.w * this._tx.h;
    }

    releaseBlancoTextures() {
        this._memTextures -= this._blancoTextures.length;
        this._blancoTextures = [];
    }

    clear() {
        // Dereference the textures.
        this._blancoTextures = null;
        this._colors.clear();
        this._memTextures = 0;
    }

    get(color) {
        let item = this._colors.get(color);
        if (!item) {
            item = {lf: -1, tx: undefined, u: -1};
            this._colors.set(color, item);
        }
        return item;
    }

    set(color, texture, frame) {
        const item = this.get(color);
        item.lf = frame;
        item.tx = texture;
        item.u = frame;
        this._memTextures++;
    }

    cleanup(frame) {
        // We only need to clean up once per frame.
        if (this._lastCleanupFrame !== frame) {

            // We limit blanco textures reuse to one frame only to prevent memory usage growth.
            this._blancoTextures = [];

            this._colors.forEach((item, color) => {
                // Clean up entries that were not used last frame.
                if (item.lf < frame - 1) {
                    if (item.tx) {
                        // Keep as reusable blanco texture.
                        this._blancoTextures.push(item.tx);
                    }
                    this._colors.delete(color);
                }
            });

            this._lastCleanupFrame = frame;
        }
    }

    reuseTexture(frame) {
        // Try to reuse textures, because creating them every frame is expensive.
        this.cleanup(frame);
        if (this._blancoTextures && this._blancoTextures.length) {
            this._memTextures--;
            return this._blancoTextures.pop();
        }
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs":
/*!********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/shaders/BlurShader.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class BlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._kernelRadius = 1;
    }

    get kernelRadius() {
        return this._kernelRadius;
    }

    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }

    useDefault() {
        return this._amount === 0;
    }

    _beforeDrawEl({target}) {
        target.ctx.filter = "blur(" + this._kernelRadius + "px)";
    }

    _afterDrawEl({target}) {
        target.ctx.filter = "none";
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultShader)
/* harmony export */ });
/* harmony import */ var _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../C2dShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class DefaultShader extends _C2dShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);
        this._rectangleTexture = ctx.stage.rectangleTexture.source.nativeTexture;
        this._tintManager = this.ctx.stage.renderer.tintManager;
    }

    draw(operation, target) {
        const ctx = target.ctx;
        let length = operation.length;
        for (let i = 0; i < length; i++) {
            const tx = operation.getTexture(i);
            const vc = operation.getElementCore(i);
            const rc = operation.getRenderContext(i);
            const white = operation.getWhite(i);
            const stc = operation.getSimpleTc(i);

            //@todo: try to optimize out per-draw transform setting. split translate, transform.
            const precision = this.ctx.stage.getRenderPrecision();
            ctx.setTransform(rc.ta * precision, rc.tc * precision, rc.tb * precision, rc.td * precision, rc.px * precision, rc.py * precision);

            const rect = (tx === this._rectangleTexture);
            const info = {operation, target, index: i, rect};

            if (rect) {
                // Check for gradient.
                if (white) {
                    ctx.fillStyle = 'white';
                } else {
                    this._setColorGradient(ctx, vc);
                }

                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);
                ctx.fillRect(0, 0, vc.w, vc.h);
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
            } else {
                // @todo: set image smoothing based on the texture.

                // @todo: optimize by registering whether identity texcoords are used.
                ctx.globalAlpha = rc.alpha;
                this._beforeDrawEl(info);

                // @todo: test if rounding yields better performance.

                // Notice that simple texture coords can be turned on even though vc._ulx etc are not simple, because
                //  we are rendering a render-to-texture (texcoords were stashed). Same is true for 'white' color btw.
                const sourceX = stc ? 0 : (vc._ulx * tx.w);
                const sourceY = stc ? 0 : (vc._uly * tx.h);
                const sourceW = (stc ? 1 : (vc._brx - vc._ulx)) * tx.w;
                const sourceH = (stc ? 1 : (vc._bry - vc._uly)) * tx.h;

                let colorize = !white;
                if (colorize) {
                    // @todo: cache the tint texture for better performance.

                    // Draw to intermediate texture with background color/gradient.
                    // This prevents us from having to create a lot of render texture canvases.

                    // Notice that we don't support (non-rect) gradients, only color tinting for c2d. We'll just take the average color.
                    let color = vc._colorUl;
                    if (vc._colorUl !== vc._colorUr || vc._colorUr !== vc._colorBl || vc._colorBr !== vc._colorBl) {
                        color = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mergeMultiColorsEqual([vc._colorUl, vc._colorUr, vc._colorBl, vc._colorBr]);
                    }

                    const alpha = ((color / 16777216) | 0) / 255.0;
                    ctx.globalAlpha *= alpha;

                    const rgb = color & 0x00FFFFFF;
                    const tintTexture = this._tintManager.getTintTexture(tx, rgb);

                    // Actually draw result.
                    ctx.fillStyle = 'white';
                    ctx.drawImage(tintTexture, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                } else {
                    ctx.fillStyle = 'white';
                    ctx.drawImage(tx, sourceX, sourceY, sourceW, sourceH, 0, 0, vc.w, vc.h);
                }
                this._afterDrawEl(info);
                ctx.globalAlpha = 1.0;
            }
        }
    }

    _setColorGradient(ctx, vc, w = vc.w, h = vc.h, transparency = true) {
        let color = vc._colorUl;
        let gradient;
        //@todo: quick single color check.
        //@todo: cache gradient/fill style (if possible, probably context-specific).

        if (vc._colorUl === vc._colorUr) {
            if (vc._colorBl === vc._colorBr) {
                if (vc._colorUl === vc.colorBl) {
                    // Single color.
                } else {
                    // Vertical gradient.
                    gradient = ctx.createLinearGradient(0, 0, 0, h);
                    if (transparency) {
                        gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorUl));
                        gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorBl));
                    } else {
                        gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorUl));
                        gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorBl));

                    }
                }
            } else {
                // Not supported gradient.
            }
        } else {
            if (vc._colorUl === vc._colorBl && vc._colorUr === vc._colorBr) {
                // Horizontal gradient.
                gradient = ctx.createLinearGradient(0, 0, w, 0);
                if (transparency) {
                    gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorUl));
                    gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(vc._colorBr));
                } else {
                    gradient.addColorStop(0, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorUl));
                    gradient.addColorStop(1, _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(vc._colorBr));
                }
            }
        }

        if (gradient) {
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = transparency ? _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(color) : _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbString(color);
        }
    }

    _beforeDrawEl(info) {
    }

    _afterDrawEl(info) {
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/common/shaders/GrayscaleShader.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "C2dGrayscaleShader": () => (/* binding */ C2dGrayscaleShader),
/* harmony export */   "WebGLGrayscaleShader": () => (/* binding */ WebGLGrayscaleShader)
/* harmony export */ });
/* harmony import */ var _c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../c2d/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/shaders/DefaultShader.mjs");
/* harmony import */ var _webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../webgl/shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class WebGLGrayscaleShader extends _webgl_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    static getC2d() {
        return C2dGrayscaleShader;
    }


    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }

}

WebGLGrayscaleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        float grayness = 0.2 * color.r + 0.6 * color.g + 0.2 * color.b;
        gl_FragColor = vec4(amount * vec3(grayness, grayness, grayness) + (1.0 - amount) * color.rgb, color.a);
    }
`;

class C2dGrayscaleShader extends _c2d_shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    static getWebGL() {
        return WebGLGrayscaleShader;
    }


    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    _beforeDrawEl({target}) {
        target.ctx.filter = "grayscale(" + this._amount + ")";
    }

    _afterDrawEl({target}) {
        target.ctx.filter = "none";
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SparkRenderer)
/* harmony export */ });
/* harmony import */ var _webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/WebGLRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs");
/* harmony import */ var _shaders_SparkShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/SparkShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SparkRenderer extends _webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
    }

    _createDefaultShader(ctx) {
        return new _shaders_SparkShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](ctx);
    }

    createCoreRenderExecutor(ctx) {
        global.beginDrawing();
        let ret = super.createCoreRenderExecutor(ctx);
        global.endDrawing();
        return ret;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/spark/shaders/SparkShader.mjs ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SparkShader)
/* harmony export */ });
/* harmony import */ var _webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../webgl/WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SparkShader extends _webgl_WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    enableAttribs() {
        // Enables the attribs in the shader program.
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
            gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            // Some shaders may ignore the color.
            gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
            gl.enableVertexAttribArray(this._attrib("aColor"));
        }
    }

    disableAttribs() {
        // Disables the attribs in the shader program.
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aColor"));
        }
    }

    setupUniforms(operation) {
        this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }

    draw(operation) {
        let gl = this.gl;

        let length = operation.length;

        if (length) {
            let glTexture = operation.getTexture(0);
            let pos = 0;
            for (let i = 0; i < length; i++) {
                let tx = operation.getTexture(i);
                if (glTexture !== tx) {
                    if (glTexture.options && glTexture.options.imageRef) {
                        let elementPostion = (i > 0) ? (i - 1) : i;
                        const precision = this.ctx.stage.getOption('precision');
                        let vc = operation.getElementCore(elementPostion);
                        this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                    } else {
                        gl.bindTexture(gl.TEXTURE_2D, glTexture);
                        gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                    }
                    glTexture = tx;
                    pos = i;
                }
            }
            if (pos < length) {
                if (glTexture.options && glTexture.options.imageRef) {
                    const precision = this.ctx.stage.getOption('precision');
                    let vc = operation.getElementCore(pos);
                    this.ctx.stage.platform.paint(gl, glTexture.options.imageRef, vc._worldContext.px*precision, vc._worldContext.py*precision, vc._colorUl, vc);
                } else {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                }
            }
        }
    }

}

SparkShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

SparkShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreQuadList)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreQuadList extends _tree_core_CoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        // Allocate a fairly big chunk of memory that should be enough to support ~100000 (default) quads.
        // We do not (want to) handle memory overflow.
        const byteSize = ctx.stage.getOption('bufferMemory');

        this.dataLength = 0;

        this.data = new ArrayBuffer(byteSize);
        this.floats = new Float32Array(this.data);
        this.uints = new Uint32Array(this.data);
    }

    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return index * 80;
    }

    getQuadContents() {
        // Debug: log contents of quad buffer.
        let floats = this.floats;
        let uints = this.uints;
        let lines = [];
        for (let i = 1; i <= this.length; i++) {
            let str = 'entry ' + i + ': ';
            for (let j = 0; j < 4; j++) {
                let b = i * 20 + j * 4;
                str += floats[b] + ',' + floats[b+1] + ':' + floats[b+2] + ',' + floats[b+3] + '[' + uints[b+4].toString(16) + '] ';
            }
            lines.push(str);
        }

        return lines;
    }


}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreQuadOperation)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreQuadOperation extends _tree_core_CoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        super(ctx, shader, shaderOwner, renderTextureInfo, scissor, index);

        this.extraAttribsDataByteOffset = 0;
    }

    getAttribsDataByteOffset(index) {
        // Where this quad can be found in the attribs buffer.
        return this.quads.getAttribsDataByteOffset(this.index + index);
    }

    /**
     * Returns the relative pixel coordinates in the shader owner to gl position coordinates in the render texture.
     * @param x
     * @param y
     * @return {number[]}
     */
    getNormalRenderTextureCoords(x, y) {
        let coords = this.shaderOwner.getRenderTextureCoords(x, y);
        coords[0] /= this.getRenderWidth();
        coords[1] /= this.getRenderHeight();
        coords[0] = coords[0] * 2 - 1;
        coords[1] = 1 - coords[1] * 2;
        return coords;
    }

    getProjection() {
        if (this.renderTextureInfo === null) {
            return this.ctx.renderExec._projection;
        } else {
            return this.renderTextureInfo.nativeTexture.projection;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLCoreRenderExecutor)
/* harmony export */ });
/* harmony import */ var _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/core/CoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class WebGLCoreRenderExecutor extends _tree_core_CoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx)

        this.gl = this.ctx.stage.gl;

        this.init();
    }

    init() {
        let gl = this.gl;

        // Create new sharable buffer for params.
        this._attribsBuffer = gl.createBuffer();

        let maxQuads = Math.floor(this.renderState.quads.data.byteLength / 80);

        // Init webgl arrays.
        let allIndices = new Uint16Array(maxQuads * 6);

        // fill the indices with the quads to draw.
        for (let i = 0, j = 0; i < maxQuads; i += 6, j += 4) {
            allIndices[i] = j;
            allIndices[i + 1] = j + 1;
            allIndices[i + 2] = j + 2;
            allIndices[i + 3] = j;
            allIndices[i + 4] = j + 2;
            allIndices[i + 5] = j + 3;
        }

        // The quads buffer can be (re)used to draw a range of quads.
        this._quadsBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, allIndices, gl.STATIC_DRAW);

        // The matrix that causes the [0,0 - W,H] box to map to [-1,-1 - 1,1] in the end results.
        this._projection = new Float32Array([2/this.ctx.stage.coordsWidth, -2/this.ctx.stage.coordsHeight]);

    }

    destroy() {
        super.destroy();
        this.gl.deleteBuffer(this._attribsBuffer);
        this.gl.deleteBuffer(this._quadsBuffer);
    }

    _reset() {
        super._reset();

        let gl = this.gl;
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);

        this._stopShaderProgram();
        this._setupBuffers();
    }

    _setupBuffers() {
        let gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._quadsBuffer);
        let element = new Float32Array(this.renderState.quads.data, 0, this.renderState.quads.dataLength);
        gl.bindBuffer(gl.ARRAY_BUFFER, this._attribsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, element, gl.DYNAMIC_DRAW);
    }

    _setupQuadOperation(quadOperation) {
        super._setupQuadOperation(quadOperation);
        this._useShaderProgram(quadOperation.shader, quadOperation);
    }

    _renderQuadOperation(op) {
        let shader = op.shader;

        if (op.length || op.shader.addEmpty()) {
            shader.beforeDraw(op);
            shader.draw(op);
            shader.afterDraw(op);
        }
    }

    /**
     * @param {WebGLShader} shader;
     * @param {CoreQuadOperation} operation;
     */
    _useShaderProgram(shader, operation) {
        if (!shader.hasSameProgram(this._currentShaderProgram)) {
            if (this._currentShaderProgram) {
                this._currentShaderProgram.stopProgram();
            }
            shader.useProgram();
            this._currentShaderProgram = shader;
        }
        shader.setupUniforms(operation);
    }

    _stopShaderProgram() {
        if (this._currentShaderProgram) {
            // The currently used shader program should be stopped gracefully.
            this._currentShaderProgram.stopProgram();
            this._currentShaderProgram = null;
        }
    }

    _bindRenderTexture(renderTexture) {
        super._bindRenderTexture(renderTexture);

        let gl = this.gl;
        if (!this._renderTexture) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0,0,this.ctx.stage.w,this.ctx.stage.h);
        } else {
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._renderTexture.framebuffer);
            gl.viewport(0,0,this._renderTexture.w, this._renderTexture.h);
        }
    }

    _clearRenderTexture() {
        super._clearRenderTexture();
        let gl = this.gl;
        if (!this._renderTexture) {
            let glClearColor = this.ctx.stage.getClearColor();
            if (glClearColor) {
                gl.clearColor(glClearColor[0] * glClearColor[3], glClearColor[1] * glClearColor[3], glClearColor[2] * glClearColor[3], glClearColor[3]);
                gl.clear(gl.COLOR_BUFFER_BIT);
            }
        } else {
            // Clear texture.
            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }
    }

    _setScissor(area) {
        super._setScissor(area);

        if (this._scissor === area) {
            return;
        }
        this._scissor = area;

        let gl = this.gl;
        if (!area) {
            gl.disable(gl.SCISSOR_TEST);
        } else {
            gl.enable(gl.SCISSOR_TEST);
            let precision = this.ctx.stage.getRenderPrecision();
            let y = area[1];
            if (this._renderTexture === null) {
                // Flip.
                y = (this.ctx.stage.h / precision - (area[1] + area[3]));
            }
            gl.scissor(Math.round(area[0] * precision), Math.round(y * precision), Math.round(area[2] * precision), Math.round(area[3] * precision));
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLRenderer)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _WebGLCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGLCoreQuadList.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadList.mjs");
/* harmony import */ var _WebGLCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WebGLCoreQuadOperation.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreQuadOperation.mjs");
/* harmony import */ var _WebGLCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebGLCoreRenderExecutor.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLCoreRenderExecutor.mjs");
/* harmony import */ var _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../tree/core/CoreRenderState.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs");
/* harmony import */ var _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shaders/DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/* harmony import */ var _Renderer_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Renderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/Renderer.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











class WebGLRenderer extends _Renderer_mjs__WEBPACK_IMPORTED_MODULE_8__["default"] {

    constructor(stage) {
        super(stage);
        this.shaderPrograms = new Map();
    }

    destroy() {
        this.shaderPrograms.forEach(shaderProgram => shaderProgram.destroy());
    }

    _createDefaultShader(ctx) {
        return new _shaders_DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](ctx);
    }

    _getShaderBaseType() {
        return _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]
    }

    _getShaderAlternative(shaderType) {
        return shaderType.getWebGL && shaderType.getWebGL();
    }

    createCoreQuadList(ctx) {
        return new _WebGLCoreQuadList_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](ctx);
    }

    createCoreQuadOperation(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {
        return new _WebGLCoreQuadOperation_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](ctx, shader, shaderOwner, renderTextureInfo, scissor, index);
    }

    createCoreRenderExecutor(ctx) {
        return new _WebGLCoreRenderExecutor_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](ctx);
    }
    
    createCoreRenderState(ctx) {
        return new _tree_core_CoreRenderState_mjs__WEBPACK_IMPORTED_MODULE_5__["default"](ctx);
    }

    createRenderTexture(w, h, pw, ph) {
        const gl = this.stage.gl;
        const glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pw, ph, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        glTexture.params = {};
        glTexture.params[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        glTexture.params[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        glTexture.params[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;
        glTexture.options = {format: gl.RGBA, internalFormat: gl.RGBA, type: gl.UNSIGNED_BYTE};

        // We need a specific framebuffer for every render texture.
        glTexture.framebuffer = gl.createFramebuffer();
        glTexture.projection = new Float32Array([2/w, 2/h]);

        gl.bindFramebuffer(gl.FRAMEBUFFER, glTexture.framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glTexture, 0);

        return glTexture;
    }
    
    freeRenderTexture(glTexture) {
        let gl = this.stage.gl;
        gl.deleteFramebuffer(glTexture.framebuffer);
        gl.deleteTexture(glTexture);
    }

    uploadTextureSource(textureSource, options) {
        const gl = this.stage.gl;

        const source = options.source;

        const format = {
            premultiplyAlpha: true,
            hasAlpha: true
        };

        if (options && options.hasOwnProperty('premultiplyAlpha')) {
            format.premultiplyAlpha = options.premultiplyAlpha;
        }

        if (options && options.hasOwnProperty('flipBlueRed')) {
            format.flipBlueRed = options.flipBlueRed;
        }

        if (options && options.hasOwnProperty('hasAlpha')) {
            format.hasAlpha = options.hasAlpha;
        }

        if (!format.hasAlpha) {
            format.premultiplyAlpha = false;
        }

        format.texParams = options.texParams || {}
        format.texOptions = options.texOptions || {}

        let glTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, glTexture);

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, format.premultiplyAlpha);

        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
            gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, !!format.flipBlueRed);
        }

        const texParams = format.texParams;
        if (!texParams[gl.TEXTURE_MAG_FILTER]) texParams[gl.TEXTURE_MAG_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_MIN_FILTER]) texParams[gl.TEXTURE_MIN_FILTER] = gl.LINEAR;
        if (!texParams[gl.TEXTURE_WRAP_S]) texParams[gl.TEXTURE_WRAP_S] = gl.CLAMP_TO_EDGE;
        if (!texParams[gl.TEXTURE_WRAP_T]) texParams[gl.TEXTURE_WRAP_T] = gl.CLAMP_TO_EDGE;

        Object.keys(texParams).forEach(key => {
            const value = texParams[key];
            gl.texParameteri(gl.TEXTURE_2D, parseInt(key), value);
        });

        const texOptions = format.texOptions;
        texOptions.format = texOptions.format || (format.hasAlpha ? gl.RGBA : gl.RGB);
        texOptions.type = texOptions.type || gl.UNSIGNED_BYTE;
        texOptions.internalFormat = texOptions.internalFormat || texOptions.format;
        if (options && options.imageRef) {
            texOptions.imageRef = options.imageRef;
        }

        this.stage.platform.uploadGlTexture(gl, textureSource, source, texOptions);

        glTexture.params = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cloneObjShallow(texParams);
        glTexture.options = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].cloneObjShallow(texOptions);

        return glTexture;
    }

    freeTextureSource(textureSource) {
        this.stage.gl.deleteTexture(textureSource.nativeTexture);
    }

    addQuad(renderState, quads, index) {
        let offset = (index * 20);
        const elementCore = quads.quadElements[index];

        let r = elementCore._renderContext;

        let floats = renderState.quads.floats;
        let uints = renderState.quads.uints;
        const mca = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].mergeColorAlpha;

        if (r.tb !== 0 || r.tc !== 0) {
            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUl, r.alpha);
            floats[offset++] = r.px + elementCore._w * r.ta;
            floats[offset++] = r.py + elementCore._w * r.tc;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUr, r.alpha);
            floats[offset++] = r.px + elementCore._w * r.ta + elementCore._h * r.tb;
            floats[offset++] = r.py + elementCore._w * r.tc + elementCore._h * r.td;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._bry;
            uints[offset++] = mca(elementCore._colorBr, r.alpha);
            floats[offset++] = r.px + elementCore._h * r.tb;
            floats[offset++] = r.py + elementCore._h * r.td;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._bry;
            uints[offset] = mca(elementCore._colorBl, r.alpha);
        } else {
            // Simple.
            let cx = r.px + elementCore._w * r.ta;
            let cy = r.py + elementCore._h * r.td;

            floats[offset++] = r.px;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUl, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = r.py;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._uly;
            uints[offset++] = mca(elementCore._colorUr, r.alpha);
            floats[offset++] = cx;
            floats[offset++] = cy;
            floats[offset++] = elementCore._brx;
            floats[offset++] = elementCore._bry;
            uints[offset++] = mca(elementCore._colorBr, r.alpha);
            floats[offset++] = r.px;
            floats[offset++] = cy;
            floats[offset++] = elementCore._ulx;
            floats[offset++] = elementCore._bry;
            uints[offset] = mca(elementCore._colorBl, r.alpha);
        }
    }

    isRenderTextureReusable(renderState, renderTextureInfo) {
        let offset = (renderState._renderTextureInfo.offset * 80) / 4;
        let floats = renderState.quads.floats;
        let uints = renderState.quads.uints;
        return ((floats[offset] === 0) &&
            (floats[offset + 1] === 0) &&
            (floats[offset + 2] === 0) &&
            (floats[offset + 3] === 0) &&
            (uints[offset + 4] === 0xFFFFFFFF) &&
            (floats[offset + 5] === renderTextureInfo.w) &&
            (floats[offset + 6] === 0) &&
            (floats[offset + 7] === 1) &&
            (floats[offset + 8] === 0) &&
            (uints[offset + 9] === 0xFFFFFFFF) &&
            (floats[offset + 10] === renderTextureInfo.w) &&
            (floats[offset + 11] === renderTextureInfo.h) &&
            (floats[offset + 12] === 1) &&
            (floats[offset + 13] === 1) &&
            (uints[offset + 14] === 0xFFFFFFFF) &&
            (floats[offset + 15] === 0) &&
            (floats[offset + 16] === renderTextureInfo.h) &&
            (floats[offset + 17] === 0) &&
            (floats[offset + 18] === 1) &&
            (uints[offset + 19] === 0xFFFFFFFF));
    }

    finishRenderState(renderState) {
        // Set extra shader attribute data.
        let offset = renderState.length * 80;
        for (let i = 0, n = renderState.quadOperations.length; i < n; i++) {
            renderState.quadOperations[i].extraAttribsDataByteOffset = offset;
            let extra = renderState.quadOperations[i].shader.getExtraAttribBytesPerVertex() * 4 * renderState.quadOperations[i].length;
            offset += extra;
            if (extra) {
                renderState.quadOperations[i].shader.setExtraAttribsInBuffer(renderState.quadOperations[i], renderState.quads);
            }
        }
        renderState.quads.dataLength = offset;
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        const gl = this.stage.gl;
        gl.bindTexture(gl.TEXTURE_2D, nativeTexture);
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTexture.framebuffer);
        const precision = renderTexture.precision;
        gl.copyTexSubImage2D(
            gl.TEXTURE_2D,
            0,
            precision * (options.sx || 0),
            precision * (options.sy || 0),
            precision * (options.x || 0),
            precision * (options.y || 0),
            precision * (options.w || renderTexture.ow),
            precision * (options.h || renderTexture.oh));
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLShader)
/* harmony export */ });
/* harmony import */ var _WebGLShaderProgram_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLShaderProgram.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs");
/* harmony import */ var _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../tree/Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class WebGLShader extends _tree_Shader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        const stage = ctx.stage;

        this._program = stage.renderer.shaderPrograms.get(this.constructor);
        if (!this._program) {
            this._program = new _WebGLShaderProgram_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this.constructor.vertexShaderSource, this.constructor.fragmentShaderSource);

            // Let the vbo context perform garbage collection.
            stage.renderer.shaderPrograms.set(this.constructor, this._program);
        }

        this.gl = stage.gl;
    }

    get glProgram() {
        return this._program.glProgram;
    }

    _init() {
        if (!this._initialized) {
            this.initialize();
            this._initialized = true;
        }
    }

    initialize() {
        this._program.compile(this.gl);
    }

    get initialized() {
        return this._initialized;
    }

    _uniform(name) {
        return this._program.getUniformLocation(name);
    }

    _attrib(name) {
        return this._program.getAttribLocation(name);
    }

    _setUniform(name, value, glFunction) {
        this._program.setUniformValue(name, value, glFunction);
    }

    useProgram() {
        this._init();
        this.gl.useProgram(this.glProgram);
        this.beforeUsage();
        this.enableAttribs();
    }

    stopProgram() {
        this.afterUsage();
        this.disableAttribs();
    }

    hasSameProgram(other) {
        // For performance reasons, we first check for identical references.
        return (other && ((other === this) || (other._program === this._program)));
    }

    beforeUsage() {
        // Override to set settings other than the default settings (blend mode etc).
    }

    afterUsage() {
        // All settings changed in beforeUsage should be reset here.
    }

    enableAttribs() {

    }

    disableAttribs() {

    }

    getExtraAttribBytesPerVertex() {
        return 0;
    }

    getVertexAttribPointerOffset(operation) {
        return operation.extraAttribsDataByteOffset - operation.index * 4 * this.getExtraAttribBytesPerVertex();
    }

    setExtraAttribsInBuffer(operation) {
        // Set extra attrib data in in operation.quads.data/floats/uints, starting from
        // operation.extraAttribsBufferByteOffset.
    }

    setupUniforms(operation) {
        // Set all shader-specific uniforms.
        // Notice that all uniforms should be set, even if they have not been changed within this shader instance.
        // The uniforms are shared by all shaders that have the same type (and shader program).
    }

    _getProjection(operation) {
        return operation.getProjection();
    }

    getFlipY(operation) {
        return this._getProjection(operation)[1] < 0;
    }

    beforeDraw(operation) {
    }

    draw(operation) {
    }

    afterDraw(operation) {
    }

    cleanup() {
        this._initialized = false;
        // Program takes little resources, so it is only destroyed when the full stage is destroyed.
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShaderProgram.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebGLShaderProgram)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Base functionality for shader setup/destroy.
 */
class WebGLShaderProgram {

    constructor(vertexShaderSource, fragmentShaderSource) {

        this.vertexShaderSource = vertexShaderSource;
        this.fragmentShaderSource = fragmentShaderSource;

        this._program = null;

        this._uniformLocations = new Map();
        this._attributeLocations = new Map();

        this._currentUniformValues = {};
    }

    compile(gl) {
        if (this._program) return;

        this.gl = gl;

        this._program = gl.createProgram();

        let glVertShader = this._glCompile(gl.VERTEX_SHADER, this.vertexShaderSource);
        let glFragShader = this._glCompile(gl.FRAGMENT_SHADER, this.fragmentShaderSource);

        gl.attachShader(this._program, glVertShader);
        gl.attachShader(this._program, glFragShader);
        gl.linkProgram(this._program);

        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(this._program, gl.LINK_STATUS)) {
            console.error('[Lightning] Error: Could not initialize shader.');
            console.error('[Lightning] gl.VALIDATE_STATUS', gl.getProgramParameter(this._program, gl.VALIDATE_STATUS));
            console.error('[Lightning] gl.getError()', gl.getError());

            // if there is a program info log, log it
            if (gl.getProgramInfoLog(this._program) !== '') {
                console.warn('[Lightning] Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(this._program));
            }

            gl.deleteProgram(this._program);
            this._program = null;
        }

        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
    }

    _glCompile(type, src) {
        let shader = this.gl.createShader(type);

        this.gl.shaderSource(shader, src);
        this.gl.compileShader(shader);

        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error('[Lightning]', this.constructor.name, 'Type: ' + (type === this.gl.VERTEX_SHADER ? 'vertex shader' : 'fragment shader') );
            console.error('[Lightning]', this.gl.getShaderInfoLog(shader));
            let idx = 0;
            console.error('[Lightning]', "========== source ==========\n" + src.split("\n").map(line => "" + (++idx) + ": " + line).join("\n"));
            return null;
        }

        return shader;
    }

    getUniformLocation(name) {
        let location = this._uniformLocations.get(name);
        if (location === undefined) {
            location = this.gl.getUniformLocation(this._program, name);
            this._uniformLocations.set(name, location);
        }

        return location;
    }

    getAttribLocation(name) {
        let location = this._attributeLocations.get(name);
        if (location === undefined) {
            location = this.gl.getAttribLocation(this._program, name);
            this._attributeLocations.set(name, location);
        }

        return location;
    }

    destroy() {
        if (this._program) {
            this.gl.deleteProgram(this._program);
            this._program = null;
        }
    }

    get glProgram() {
        return this._program;
    }

    get compiled() {
        return !!this._program;
    }

    _valueEquals(v1, v2) {
        // Uniform value is either a typed array or a numeric value.
        if (v1.length && v2.length) {
            for (let i = 0, n = v1.length; i < n; i++) {
                if (v1[i] !== v2[i]) return false;
            }
            return true;
        } else {
            return (v1 === v2);
        }
    }

    _valueClone(v) {
        if (v.length) {
            return v.slice(0);
        } else {
            return v;
        }
    }

    setUniformValue(name, value, glFunction) {
        let v = this._currentUniformValues[name];
        if (v === undefined || !this._valueEquals(v, value)) {
            let clonedValue = this._valueClone(value);
            this._currentUniformValues[name] = clonedValue;

            let loc = this.getUniformLocation(name);
            if (loc) {
                let isMatrix = (glFunction === this.gl.uniformMatrix2fv || glFunction === this.gl.uniformMatrix3fv || glFunction === this.gl.uniformMatrix4fv);
                if (isMatrix) {
                    glFunction.call(this.gl, loc, false, clonedValue);
                } else {
                    glFunction.call(this.gl, loc, clonedValue);
                }
            }
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/BoxBlurShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BoxBlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * 4x4 box blur shader which works in conjunction with a 50% rescale.
 */
class BoxBlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const dx = 1.0 / operation.getTextureWidth(0);
        const dy = 1.0 / operation.getTextureHeight(0);
        this._setUniform("stepTextureCoord", new Float32Array([dx, dy]), this.gl.uniform2fv);
    }

}

BoxBlurShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 stepTextureCoord;
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec4 vColor;
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoordUl = aTextureCoord - stepTextureCoord;
        vTextureCoordBr = aTextureCoord + stepTextureCoord;
        vTextureCoordUr = vec2(vTextureCoordBr.x, vTextureCoordUl.y);
        vTextureCoordBl = vec2(vTextureCoordUl.x, vTextureCoordBr.y);
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

BoxBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoordUl;
    varying vec2 vTextureCoordUr;
    varying vec2 vTextureCoordBl;
    varying vec2 vTextureCoordBr;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        vec4 color = 0.25 * (texture2D(uSampler, vTextureCoordUl) + texture2D(uSampler, vTextureCoordUr) + texture2D(uSampler, vTextureCoordBl) + texture2D(uSampler, vTextureCoordBr));
        gl_FragColor = color * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/CircularPushShader.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CircularPushShader)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class CircularPushShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        this._inputValue = 0;

        this._maxDerivative = 0.01;

        this._normalizedValue = 0;

        // The offset between buckets. A value between 0 and 1.
        this._offset = 0;

        this._amount = 0.1;

        this._aspectRatio = 1;

        this._offsetX = 0;

        this._offsetY = 0;

        this.buckets = 100;
    }

    get aspectRatio() {
        return this._aspectRatio;
    }

    set aspectRatio(v) {
        this._aspectRatio = v;
        this.redraw();
    }

    get offsetX() {
        return this._offsetX;
    }

    set offsetX(v) {
        this._offsetX = v;
        this.redraw();
    }

    get offsetY() {
        return this._offsetY;
    }

    set offsetY(v) {
        this._offsetY = v;
        this.redraw();
    }

    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    set inputValue(v) {
        this._inputValue = v;
    }

    get inputValue() {
        return this._inputValue;
    }

    set maxDerivative(v) {
        this._maxDerivative = v;
    }

    get maxDerivative() {
        return this._maxDerivative;
    }

    set buckets(v) {
        if (v > 100) {
            console.warn("[Lightning] CircularPushShader: supports max 100 buckets");
            v = 100;
        }

        // This should be set before starting.
        this._buckets = v;

        // Init values array in the correct length.
        this._values = new Uint8Array(this._getValues(v));

        this.redraw();
    }

    get buckets() {
        return this._buckets;
    }

    _getValues(n) {
        const v = [];
        for (let i = 0; i < n; i++) {
            v.push(this._inputValue);
        }
        return v;
    }

    /**
     * Progresses the shader with the specified (fractional) number of buckets.
     * @param {number} o;
     *   A number from 0 to 1 (1 = all buckets).
     */
    progress(o) {
        this._offset += o * this._buckets;
        const full = Math.floor(this._offset);
        this._offset -= full;
        this._shiftBuckets(full);
        this.redraw();
    }

    _shiftBuckets(n) {
        for (let i = this._buckets - 1; i >= 0; i--) {
            const targetIndex = i - n;
            if (targetIndex < 0) {
                this._normalizedValue = Math.min(this._normalizedValue + this._maxDerivative, Math.max(this._normalizedValue - this._maxDerivative, this._inputValue));
                this._values[i] = 255 * this._normalizedValue;
            } else {
                this._values[i] = this._values[targetIndex];
            }
        }
    }

    set offset(v) {
        this._offset = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("aspectRatio", this._aspectRatio, this.gl.uniform1f);
        this._setUniform("offsetX", this._offsetX, this.gl.uniform1f);
        this._setUniform("offsetY", this._offsetY, this.gl.uniform1f);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
        this._setUniform("offset", this._offset, this.gl.uniform1f);
        this._setUniform("buckets", this._buckets, this.gl.uniform1f);
        this._setUniform("uValueSampler", 1, this.gl.uniform1i);
    }

    useDefault() {
        return this._amount === 0;
    }

    beforeDraw(operation) {
        const gl = this.gl;
        gl.activeTexture(gl.TEXTURE1);
        if (!this._valuesTexture) {
            this._valuesTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
                gl.pixelStorei(gl.UNPACK_FLIP_BLUE_RED, false);
            }
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this._valuesTexture);
        }

        // Upload new values.
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, this._buckets, 1, 0, gl.ALPHA, gl.UNSIGNED_BYTE, this._values);
        gl.activeTexture(gl.TEXTURE0);
    }

    cleanup() {
        if (this._valuesTexture) {
            this.gl.deleteTexture(this._valuesTexture);
        }
    }


}

CircularPushShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    uniform float offsetX;
    uniform float offsetY;
    uniform float aspectRatio;
    varying vec2 vTextureCoord;
    varying vec2 vPos;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vPos = vTextureCoord * 2.0 - 1.0;
        vPos.y = vPos.y * aspectRatio;
        vPos.y = vPos.y + offsetY;
        vPos.x = vPos.x + offsetX;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

CircularPushShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vPos;
    uniform float amount;
    uniform float offset;
    uniform float values[100];
    uniform float buckets;
    uniform sampler2D uSampler;
    uniform sampler2D uValueSampler;
    void main(void){
        float l = length(vPos);
        float m = (l * buckets * 0.678 - offset) / buckets;
        float f = texture2D(uValueSampler, vec2(m, 0.0)).a * amount;
        vec2 unit = vPos / l;
        gl_FragColor = texture2D(uSampler, vTextureCoord - f * unit) * vColor;
    }
`;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DefaultShader)
/* harmony export */ });
/* harmony import */ var _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../WebGLShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class DefaultShader extends _WebGLShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    enableAttribs() {
        // Enables the attribs in the shader program.
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aVertexPosition"), 2, gl.FLOAT, false, 20, 0);
        gl.enableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.vertexAttribPointer(this._attrib("aTextureCoord"), 2, gl.FLOAT, false, 20, 2 * 4);
            gl.enableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            // Some shaders may ignore the color.
            gl.vertexAttribPointer(this._attrib("aColor"), 4, gl.UNSIGNED_BYTE, true, 20, 4 * 4);
            gl.enableVertexAttribArray(this._attrib("aColor"));
        }
    }

    disableAttribs() {
        // Disables the attribs in the shader program.
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aVertexPosition"));

        if (this._attrib("aTextureCoord") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aTextureCoord"));
        }

        if (this._attrib("aColor") !== -1) {
            gl.disableVertexAttribArray(this._attrib("aColor"));
        }
    }

    setupUniforms(operation) {
        this._setUniform("projection", this._getProjection(operation), this.gl.uniform2fv, false);
    }

    draw(operation) {
        let gl = this.gl;

        let length = operation.length;

        if (length) {
            let glTexture = operation.getTexture(0);
            let pos = 0;
            for (let i = 0; i < length; i++) {
                let tx = operation.getTexture(i);
                if (glTexture !== tx) {
                    gl.bindTexture(gl.TEXTURE_2D, glTexture);
                    gl.drawElements(gl.TRIANGLES, 6 * (i - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
                    glTexture = tx;
                    pos = i;
                }
            }
            if (pos < length) {
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.drawElements(gl.TRIANGLES, 6 * (length - pos), gl.UNSIGNED_SHORT, (pos + operation.index) * 6 * 2);
            }
        }
    }

}

DefaultShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

DefaultShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    void main(void){
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DitheringShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DitheringShader)
/* harmony export */ });
/* harmony import */ var _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../textures/NoiseTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * This shader can be used to fix a problem that is known as 'gradient banding'.
 */
class DitheringShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);

        this._noiseTexture = new _textures_NoiseTexture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](ctx.stage);

        this._graining = 1/256;

        this._random = false;
    }

    set graining(v) {
        this._graining = v;
        this.redraw();
    }

    set random(v) {
        this._random = v;
        this.redraw();
    }

    setExtraAttribsInBuffer(operation) {
        // Make sure that the noise texture is uploaded to the GPU.
        this._noiseTexture.load();

        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;

        for (let i = 0; i < length; i++) {

            // Calculate noise texture coordinates so that it spans the full element.
            let brx = operation.getElementWidth(i) / this._noiseTexture.getRenderWidth();
            let bry = operation.getElementHeight(i) / this._noiseTexture.getRenderHeight();

            let ulx = 0;
            let uly = 0;
            if (this._random) {
                ulx = Math.random();
                uly = Math.random();

                brx += ulx;
                bry += uly;

                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = ulx;
                    ulx = brx;
                    brx = t;
                }

                if (Math.random() < 0.5) {
                    // Flip for more randomness.
                    const t = uly;
                    uly = bry;
                    bry = t;
                }
            }

            // Specify all corner points.
            floats[offset] = ulx;
            floats[offset + 1] = uly;

            floats[offset + 2] = brx;
            floats[offset + 3] = uly;

            floats[offset + 4] = brx;
            floats[offset + 5] = bry;

            floats[offset + 6] = ulx;
            floats[offset + 7] = bry;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aNoiseTextureCoord"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));

        let glTexture = this._noiseTexture.source.nativeTexture;
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, glTexture);
        gl.activeTexture(gl.TEXTURE0);
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("uNoiseSampler", 1, this.gl.uniform1i);
        this._setUniform("graining", 2 * this._graining, this.gl.uniform1f);
    }

    enableAttribs() {
        super.enableAttribs();
        let gl = this.gl;
        gl.enableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }

    disableAttribs() {
        super.disableAttribs();
        let gl = this.gl;
        gl.disableVertexAttribArray(this._attrib("aNoiseTextureCoord"));
    }

    useDefault() {
        return this._graining === 0;
    }

    afterDraw(operation) {
        if (this._random) {
            this.redraw();
        }
    }

}

DitheringShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec2 aNoiseTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vNoiseTextureCoord = aNoiseTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

DitheringShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 vNoiseTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform sampler2D uNoiseSampler;
    uniform float graining;
    void main(void){
        vec4 noise = texture2D(uNoiseSampler, vNoiseTextureCoord);
        vec4 color = texture2D(uSampler, vTextureCoord);
        gl_FragColor = (color * vColor) + graining * (noise.r - 0.5);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/FadeOutShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FadeOutShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class FadeOutShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._fade = [0, 0, 0, 0];
    }

    set top(num) {
        this._fade[0] = num;
        this.redraw();
    }

    get top() {
        return this._fade[0];
    }

    set right(num) {
        this._fade[1] = num;
        this.redraw();
    }

    get right() {
        return this._fade[1];
    }

    set bottom(num) {
        this._fade[2] = num;
        this.redraw();
    }

    get bottom() {
        return this._fade[2];
    }

    set left(num) {
        this._fade[3] = num;
        this.redraw();
    }

    get left() {
        return this._fade[3];
    }

    set fade(v) {
        if(Array.isArray(v)) {
            if(v.length === 2) {
                this._fade = [v[0], v[1], v[0], v[1]];
            }
            else if(v.length === 3) {
                this._fade = [v[0], v[1], v[2], this._fade[3]];
            }
            else if (v.length === 4) {
                this._fade = v;
            }
            else {
                this._fade = [v[0], v[0], v[0], v[0]];
            }
        }
        else {
            this._fade = [v, v, v, v];
        }
        this.redraw();
    }

    get fade() {
        return this._fade;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;

        const renderPrecision = this.ctx.stage.getRenderPrecision();
        const fade = this._fade.map((f) => f * renderPrecision);
        this._setUniform('fade',  new Float32Array(fade), this.gl.uniform4fv);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
}

FadeOutShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 fade;
    
    void main() {
        vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 point = vTextureCoord.xy * resolution.xy;
        
        vec2 pos1;
        vec2 pos2;
        vec2 d;
        float c;
        float t = 0.0;
             
        if(fade[0] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x, point.y + fade[0]);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[1] > 0.0) {
            vec2 pos1 = vec2(point.x - resolution.x - fade[1], vTextureCoord.y);
            vec2 pos2 = vec2(point.x - resolution.x, vTextureCoord.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[2] > 0.0) {
            vec2 pos1 = vec2(vTextureCoord.x, point.y - resolution.y - fade[2]);
            vec2 pos2 = vec2(vTextureCoord.x, point.y - resolution.y);
            d = pos1 - pos2;
            c = dot(pos2, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        if(fade[3] > 0.0) {
            pos1 = vec2(point.x, point.y);
            pos2 = vec2(point.x + fade[3], point.y);
            d = pos2 - pos1;
            c = dot(pos1, d) / dot(d, d);
            t = smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0));
            color = mix(vec4(0.0), color, t);
        }
        
        gl_FragColor = color;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/HoleShader.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HoleShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class HoleShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;
        this._radius = 0;
    }

    get x() {
        return this._x;
    }

    set x(v) {
        this._x = v;
        this.redraw();
    }

    get y() {
        return this._y;
    }

    set y(v) {
        this._y = v;
        this.redraw();
    }

    get w() {
        return this._w;
    }

    set w(v) {
        this._w = v;
        this.redraw();
    }

    get h() {
        return this._h;
    }

    set h(v) {
        this._h = v;
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        const owner = operation.shaderOwner;
        const renderPrecision = this.ctx.stage.getRenderPrecision()

        this._setUniform("x", this._x * renderPrecision, this.gl.uniform1f);
        this._setUniform("y", this._y * renderPrecision, this.gl.uniform1f);
        this._setUniform("w", this._w * renderPrecision, this.gl.uniform1f);
        this._setUniform("h", this._h * renderPrecision, this.gl.uniform1f);
        this._setUniform('radius',  (this._radius + .5) * renderPrecision, this.gl.uniform1f);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }

    useDefault() {
        return (this._x === 0 && this._y === 0 && this._w === 0 && this._h === 0)
    }
}

HoleShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

HoleShader.fragmentShaderSource = `
   #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float x;
    uniform float y;
    uniform float w;
    uniform float h;
    uniform vec2 resolution;
    uniform float radius;

    float roundBox(vec2 p, vec2 b, float r) {
        float d = length(max(abs(p)-b+r, 0.1))-r;
        return smoothstep(1.0, 0.0, d);
    }

    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
        vec2 size = vec2(w, h) / 2.0;
        float b = roundBox(pos, size, radius);
        gl_FragColor = mix(color, vec4(0.0), b);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/InversionShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ InversionShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class InversionShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);
        this._amount = 1;
    }

    set amount(v) {
        this._amount = v;
        this.redraw();
    }

    get amount() {
        return this._amount;
    }

    useDefault() {
        return this._amount === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("amount", this._amount, this.gl.uniform1f);
    }

}

InversionShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float amount;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        color.rgb = color.rgb * (1.0 - amount) + amount * (1.0 * color.a - color.rgb); 
        gl_FragColor = color * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/Light3dShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Light3dShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class Light3dShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._strength = 0.5;
        this._ambient = 0.5;
        this._fudge = 0.4;

        this._rx = 0;
        this._ry = 0;

        this._z = 0;
        this._pivotX = NaN;
        this._pivotY = NaN;
        this._pivotZ = 0;

        this._lightY = 0;
        this._lightZ = 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        let vr = operation.shaderOwner;
        let element = vr.element;

        let pivotX = isNaN(this._pivotX) ? element.pivotX * vr.w : this._pivotX;
        let pivotY = isNaN(this._pivotY) ? element.pivotY * vr.h : this._pivotY;
        let coords = vr.getRenderTextureCoords(pivotX, pivotY);

        // Counter normal rotation.

        let rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);

        let gl = this.gl;
        this._setUniform("pivot", new Float32Array([coords[0], coords[1], this._pivotZ]), gl.uniform3fv);
        this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);

        this._setUniform("z", this._z, gl.uniform1f);
        this._setUniform("lightY", this.lightY, gl.uniform1f);
        this._setUniform("lightZ", this.lightZ, gl.uniform1f);
        this._setUniform("strength", this._strength, gl.uniform1f);
        this._setUniform("ambient", this._ambient, gl.uniform1f);
        this._setUniform("fudge", this._fudge, gl.uniform1f);
    }

    set strength(v) {
        this._strength = v;
        this.redraw();
    }

    get strength() {
        return this._strength;
    }

    set ambient(v) {
        this._ambient = v;
        this.redraw();
    }

    get ambient() {
        return this._ambient;
    }

    set fudge(v) {
        this._fudge = v;
        this.redraw();
    }

    get fudge() {
        return this._fudge;
    }

    get rx() {
        return this._rx;
    }

    set rx(v) {
        this._rx = v;
        this.redraw();
    }

    get ry() {
        return this._ry;
    }

    set ry(v) {
        this._ry = v;
        this.redraw();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        this._z = v;
        this.redraw();
    }

    get pivotX() {
        return this._pivotX;
    }

    set pivotX(v) {
        this._pivotX = v + 1;
        this.redraw();
    }

    get pivotY() {
        return this._pivotY;
    }

    set pivotY(v) {
        this._pivotY = v + 1;
        this.redraw();
    }

    get lightY() {
        return this._lightY;
    }

    set lightY(v) {
        this._lightY = v;
        this.redraw();
    }

    get pivotZ() {
        return this._pivotZ;
    }

    set pivotZ(v) {
        this._pivotZ = v;
        this.redraw();
    }

    get lightZ() {
        return this._lightZ;
    }

    set lightZ(v) {
        this._lightZ = v;
        this.redraw();
    }

    useDefault() {
        return (this._rx === 0 && this._ry === 0 && this._z === 0 && this._strength === 0 && this._ambient === 1);
    }

}

Light3dShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float fudge;
    uniform float strength;
    uniform float ambient;
    uniform float z;
    uniform float lightY;
    uniform float lightZ;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Set depth perspective
        float perspective = 1.0 + fudge * pos.z;

        pos.z += lightZ * projection.x;

        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, perspective);

        // Correct light source position.
        pos.y += lightY * abs(projection.y);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

Light3dShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec3 pos;
    uniform sampler2D uSampler;
    uniform float ambient;
    uniform float strength;
    void main(void){
        vec4 rgba = texture2D(uSampler, vTextureCoord);
        float d = length(pos);
        float n = 1.0 / max(0.1, d);
        rgba.rgb = rgba.rgb * (strength * n + ambient);
        gl_FragColor = rgba * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/LinearBlurShader.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LinearBlurShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class LinearBlurShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(context) {
        super(context);

        this._direction = new Float32Array([1, 0]);
        this._kernelRadius = 1;
    }

    get x() {
        return this._direction[0];
    }

    set x(v) {
        this._direction[0] = v;
        this.redraw();
    }

    get y() {
        return this._direction[1];
    }

    set y(v) {
        this._direction[1] = v;
        this.redraw();
    }

    get kernelRadius() {
        return this._kernelRadius;
    }

    set kernelRadius(v) {
        this._kernelRadius = v;
        this.redraw();
    }


    useDefault() {
        return (this._kernelRadius === 0);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        this._setUniform("direction", this._direction, this.gl.uniform2fv);
        this._setUniform("kernelRadius", this._kernelRadius, this.gl.uniform1i);

        const w = operation.getRenderWidth();
        const h = operation.getRenderHeight();
        this._setUniform("resolution", new Float32Array([w, h]), this.gl.uniform2fv);
    }
}

LinearBlurShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    uniform vec2 resolution;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 direction;
    uniform int kernelRadius;
    
    vec4 blur1(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3333333333333333) * direction;
        color += texture2D(image, uv) * 0.29411764705882354;
        color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;
        color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;
        return color; 
    }
    
    vec4 blur2(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.3846153846) * direction;
        vec2 off2 = vec2(3.2307692308) * direction;
        color += texture2D(image, uv) * 0.2270270270;
        color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;
        color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;
        color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;
        return color;
    }
    
    vec4 blur3(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {
        vec4 color = vec4(0.0);
        vec2 off1 = vec2(1.411764705882353) * direction;
        vec2 off2 = vec2(3.2941176470588234) * direction;
        vec2 off3 = vec2(5.176470588235294) * direction;
        color += texture2D(image, uv) * 0.1964825501511404;
        color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;
        color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;
        color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;
        color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;
        return color;
    }    

    void main(void){
        if (kernelRadius == 1) {
            gl_FragColor = blur1(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else if (kernelRadius == 2) {
            gl_FragColor = blur2(uSampler, vTextureCoord, resolution, direction) * vColor;
        } else {
            gl_FragColor = blur3(uSampler, vTextureCoord, resolution, direction) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/MagnifierShader.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MagnifierShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class MagnifierShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
	constructor(context) {
	  super(context);
	  this._x = 0;
	  this._y = 0;
	  this._w = 0;
	  this._h = 0;
	  this._radius = 0;
	  this._magnification = 0.6;
	}
  
	get x() {
	  return this._x;
	}
  
	set x(v) {
	  this._x = v;
	  this.redraw();
	}
  
	get y() {
	  return this._y;
	}
  
	set y(v) {
	  this._y = v;
	  this.redraw();
	}
  
	get w() {
	  return this._w;
	}
  
	set w(v) {
	  this._w = v;
	  this.redraw();
	}
  
	get h() {
	  return this._h;
	}
  
	set h(v) {
	  this._h = v;
	  this.redraw();
	}
  
	get magnification() {
	  return this._magnification;
	}
  
	set magnification(v) {
	  this._magnification = v;
	  this.redraw();
	}
  
	get radius() {
	  return this._radius;
	}
  
	set radius(v) {
	  this._radius = v;
	  this.redraw();
	}
  
	setupUniforms(operation) {
	  super.setupUniforms(operation);
  
	  const owner = operation.shaderOwner;
	  const renderPrecision = this.ctx.stage.getRenderPrecision();
	  this._setUniform('x', this._x * renderPrecision, this.gl.uniform1f);
	  this._setUniform('y', this._y * renderPrecision, this.gl.uniform1f);
	  this._setUniform('w', this._w * renderPrecision, this.gl.uniform1f);
	  this._setUniform('h', this._h * renderPrecision, this.gl.uniform1f);
	  this._setUniform('magnification', this._magnification, this.gl.uniform1f);
	  this._setUniform(
		'radius',
		(this._radius + 0.5) * renderPrecision,
		this.gl.uniform1f
	  );
	  this._setUniform(
		'resolution',
		new Float32Array([
		  owner._w * renderPrecision,
		  owner._h * renderPrecision
		]),
		this.gl.uniform2fv
	  );
	}
 
	useDefault() {
	  return this._w === 0 && this._h === 0;
	}
  }
  
  MagnifierShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;
  
  MagnifierShader.fragmentShaderSource = `
	  #ifdef GL_ES
		# ifdef GL_FRAGMENT_PRECISION_HIGH
		precision highp float;
		# else
		precision lowp float;
		# endif
	  #endif

	  varying vec2 vTextureCoord;
	  varying vec4 vColor;
	  uniform sampler2D uSampler;
	  uniform float x;
	  uniform float y;
	  uniform float w;
	  uniform float h;
	  uniform vec2 resolution;
	  uniform float radius;
	  uniform float magnification;
  
	  float roundBox(vec2 p, vec2 b, float r) {
		  float d = length(max(abs(p)-b+r, 0.1))-r;
		  return smoothstep(1.0, 0.0, d);
	  }

	  float inside(vec2 v) {
		vec2 s = step(vec2(0.0, 0.0), v) - step(vec2(1.0, 1.0), v);
		return s.x * s.y;   
      }
  
	  void main(void) {
		vec4 color = texture2D(uSampler, vTextureCoord);
		vec2 pos = vTextureCoord.xy * resolution - vec2(x, y) - vec2(w, h) / 2.0;
		vec2 size = vec2(w, h) / 2.0;
		float b = roundBox(pos, size, radius);
		vec2 pos2 = (vTextureCoord.xy * magnification * resolution + vec2(x, y) * magnification) / resolution;
		gl_FragColor = mix(color, texture2D(uSampler, pos2) * inside(pos2), b) * vColor;
	  }
  `;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/OutlineShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OutlineShader)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class OutlineShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_1__["default"] {

    constructor(ctx) {
        super(ctx);
        this._width = 5;
        this._col = 0xFFFFFFFF;
        this._color = [1,1,1,1];
    }

    set width(v) {
        this._width = v;
        this.redraw();
    }

    get color() {
        return this._col;
    }

    set color(v) {
        if (this._col !== v) {
            const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaComponentsNormalized(v);
            col[0] = col[0] * col[3];
            col[1] = col[1] * col[3];
            col[2] = col[2] * col[3];

            this._color = col;

            this.redraw();

            this._col = v;
        }
    }

    useDefault() {
        return (this._width === 0 || this._col[3] === 0);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        let gl = this.gl;
        this._setUniform("color", new Float32Array(this._color), gl.uniform4fv);
    }

    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aCorner"));
    }

    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aCorner"));
    }

    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;

        for (let i = 0; i < length; i++) {

            const elementCore = operation.getElementCore(i);

            // We are setting attributes such that if the value is < 0 or > 1, a border should be drawn.
            const ddw = this._width / elementCore.w;
            const dw = ddw / (1 - 2 * ddw);
            const ddh = this._width / elementCore.h;
            const dh = ddh / (1 - 2 * ddh);

            // Specify all corner points.
            floats[offset] = -dw;
            floats[offset + 1] = -dh;

            floats[offset + 2] = 1 + dw;
            floats[offset + 3] = -dh;

            floats[offset + 4] = 1 + dw;
            floats[offset + 5] = 1 + dh;

            floats[offset + 6] = -dw;
            floats[offset + 7] = 1 + dh;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aCorner"), 2, gl.FLOAT, false, 8, this.getVertexAttribPointerOffset(operation));
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

}

OutlineShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aCorner;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec2 vCorner;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vCorner = aCorner;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

OutlineShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vCorner;
    uniform vec4 color;
    uniform sampler2D uSampler;
    void main(void){
        vec2 m = min(vCorner, 1.0 - vCorner);
        float value = step(0.0, min(m.x, m.y));
        gl_FragColor = mix(color, texture2D(uSampler, vTextureCoord) * vColor, value);
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PerspectiveShader.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PerspectiveShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class PerspectiveShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._fudge = 0.2;
        this._rx = 0;
        this._ry = 0;
        this._z = 1.0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        const vr = operation.shaderOwner;
        const element = vr.element;

        const pivotX = element.pivotX * vr.w;
        const pivotY = element.pivotY * vr.h;
        const coords = vr.getRenderTextureCoords(pivotX, pivotY);

        // Counter normal rotation.
        const rz = -Math.atan2(vr._renderContext.tc, vr._renderContext.ta);

        const gl = this.gl;
        this._setUniform("pivot", new Float32Array([coords[0], coords[1], 0]), gl.uniform3fv);
        this._setUniform("rot", new Float32Array([this._rx, this._ry, rz]), gl.uniform3fv);
        this._setUniform("z", this._z, gl.uniform1f);
        this._setUniform("fudge", this._fudge, gl.uniform1f);
    }

    set fudge(v) {
        this._fudge = v;
        this.redraw();
    }

    get fudge() {
        return this._fudge;
    }

    get rx() {
        return this._rx;
    }

    set rx(v) {
        this._rx = v;
        this.redraw();
    }

    get ry() {
        return this._ry;
    }

    set ry(v) {
        this._ry = v;
        this.redraw();
    }

    get z() {
        return this._z;
    }

    set z(v) {
        this._z = v;
        this.redraw();
    }

    useDefault() {
        return (this._rx === 0 && this._ry === 0 && this._z === 0);
    }

}

PerspectiveShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform float z;
    uniform vec3 pivot;
    uniform vec3 rot;
    varying vec3 pos;

    void main(void) {
        pos = vec3(aVertexPosition.xy, z);
        
        pos -= pivot;
        
        // Undo XY rotation
        mat2 iRotXy = mat2( cos(rot.z), sin(rot.z), 
                           -sin(rot.z), cos(rot.z));
        pos.xy = iRotXy * pos.xy;
        
        // Perform 3d rotations
        gl_Position.x = cos(rot.x) * pos.x - sin(rot.x) * pos.z;
        gl_Position.y = pos.y;
        gl_Position.z = sin(rot.x) * pos.x + cos(rot.x) * pos.z;
        
        pos.x = gl_Position.x;
        pos.y = cos(rot.y) * gl_Position.y - sin(rot.y) * gl_Position.z;
        pos.z = sin(rot.y) * gl_Position.y + cos(rot.y) * gl_Position.z;
        
        // Redo XY rotation
        iRotXy[0][1] = -iRotXy[0][1];
        iRotXy[1][0] = -iRotXy[1][0];
        pos.xy = iRotXy * pos.xy; 

        // Undo translate to pivot position
        pos.xyz += pivot;

        pos = vec3(pos.x * projection.x - 1.0, pos.y * -abs(projection.y) + 1.0, pos.z * projection.x);
        
        // Map coords to gl coordinate space.
        // Set z to 0 because we don't want to perform z-clipping
        gl_Position = vec4(pos.xy, 0.0, z);

        vTextureCoord = aTextureCoord;
        vColor = aColor;
        
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

PerspectiveShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform vec3 rot;
    uniform float fudge;

    void main(void) {
        vec2 coords = vTextureCoord;

        coords.xy -= vec2(0.5);
        coords.y = coords.y + (sign(rot[0]) * 0.5 - coords.x) * sin(rot[0]) * fudge * coords.y;
        coords.x = coords.x + (sign(rot[1]) * 0.5 - coords.y) * sin(rot[1]) * fudge * coords.x;
        coords.xy += vec2(0.5);

        if (coords.x < 0.0 || coords.x > 1.0 || coords.y < 0.0 || coords.y > 1.0) {
            gl_FragColor = vec4(0.0);
        } else {
            gl_FragColor = texture2D(uSampler, coords) * vColor;
        }
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/PixelateShader.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PixelateShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @see https://github.com/pixijs/pixi-filters/tree/master/filters/pixelate/src
 */
class PixelateShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);

        this._size = new Float32Array([4, 4]);
    }

    get x() {
        return this._size[0];
    }

    set x(v) {
        this._size[0] = v;
        this.redraw();
    }

    get y() {
        return this._size[1];
    }

    set y(v) {
        this._size[1] = v;
        this.redraw();
    }

    get size() {
        return this._size[0];
    }

    set size(v) {
        this._size[0] = v;
        this._size[1] = v;
        this.redraw();
    }

    useDefault() {
        return ((this._size[0] === 0) && (this._size[1] === 0));
    }

    static getWebGLImpl() {
        return WebGLPixelateShaderImpl;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        let gl = this.gl;
        this._setUniform("size", new Float32Array(this._size), gl.uniform2fv);
    }

    getExtraAttribBytesPerVertex() {
        return 8;
    }

    enableAttribs() {
        super.enableAttribs();
        this.gl.enableVertexAttribArray(this._attrib("aTextureRes"));
    }

    disableAttribs() {
        super.disableAttribs();
        this.gl.disableVertexAttribArray(this._attrib("aTextureRes"));
    }

    setExtraAttribsInBuffer(operation) {
        let offset = operation.extraAttribsDataByteOffset / 4;
        let floats = operation.quads.floats;

        let length = operation.length;
        for (let i = 0; i < length; i++) {
            let w = operation.quads.getTextureWidth(operation.index + i);
            let h = operation.quads.getTextureHeight(operation.index + i);

            floats[offset] = w;
            floats[offset + 1] = h;
            floats[offset + 2] = w;
            floats[offset + 3] = h;
            floats[offset + 4] = w;
            floats[offset + 5] = h;
            floats[offset + 6] = w;
            floats[offset + 7] = h;

            offset += 8;
        }
    }

    beforeDraw(operation) {
        let gl = this.gl;
        gl.vertexAttribPointer(this._attrib("aTextureRes"), 2, gl.FLOAT, false, this.getExtraAttribBytesPerVertex(), this.getVertexAttribPointerOffset(operation));
    }
}

PixelateShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    attribute vec2 aTextureRes;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        vTextureRes = aTextureRes;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

PixelateShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    varying vec2 vTextureRes;

    uniform vec2 size;
    uniform sampler2D uSampler;
    
    vec2 mapCoord( vec2 coord )
    {
        coord *= vTextureRes.xy;
        return coord;
    }
    
    vec2 unmapCoord( vec2 coord )
    {
        coord /= vTextureRes.xy;
        return coord;
    }
    
    vec2 pixelate(vec2 coord, vec2 size)
    {
        return floor( coord / size ) * size;
    }
    
    void main(void)
    {
        vec2 coord = mapCoord(vTextureCoord);
        coord = pixelate(coord, size);
        coord = unmapCoord(coord);
        gl_FragColor = texture2D(uSampler, coord) * vColor;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs":
/*!******************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialFilterShader.mjs ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialFilterShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RadialFilterShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._radius = 0;
        this._cutoff = 1;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set cutoff(v) {
        this._cutoff = v;
        this.redraw();
    }

    get cutoff() {
        return this._cutoff;
    }
    
    useDefault() {
        return this._radius === 0;
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        // We substract half a pixel to get a better cutoff effect.
        this._setUniform("radius", 2 * (this._radius - 0.5) / operation.getRenderWidth(), this.gl.uniform1f);
        this._setUniform("cutoff", 0.5 * operation.getRenderWidth() / this._cutoff, this.gl.uniform1f);
    }

}

RadialFilterShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;
    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 pos;
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
        pos = gl_Position.xy;
    }
`;

RadialFilterShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec2 pos;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform float radius;
    uniform float cutoff;
    void main(void){
        vec4 color = texture2D(uSampler, vTextureCoord);
        float f = max(0.0, min(1.0, 1.0 - (length(pos) - radius) * cutoff));
        gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor * f;
    }
`;



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RadialGradientShader.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RadialGradientShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RadialGradientShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._pivot = [0, 0];
        this._ic = 0xffffffff;
        this._normalizedIC = this._getNormalizedColor(this._ic);
        this._oc = 0x00ffffff;
        this._normalizedOC = this._getNormalizedColor(this._oc);
        this._radius = 0;
    }

    set radiusX(v) {
        this.radius = v;
    }

    get radiusX() {
        return this._radius;
    }

    set radiusY(v) {
        this._radiusY = v;
        this.redraw();
    }

    get radiusY() {
        return this._radiusY;
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    set innerColor(argb) {
        this._ic = argb;
        this._normalizedIC = this._getNormalizedColor(argb);
        this.redraw();
    }

    get innerColor() {
        return this._ic;
    }

    set outerColor(argb) {
        this._oc = argb;
        this._normalizedOC = this._getNormalizedColor(argb);
        this.redraw();
    }

    set color(argb) {
        this.innerColor = argb;
    }

    get color() {
        return this.innerColor;
    }

    get outerColor() {
        return this._ic;
    }

    set x(f) {
        this._x = f;
        this.redraw();
    }

    set y(f) {
        this._y = f;
        this.redraw();
    }

    set pivot(v) {
        if(Array.isArray(v) && v.length === 2) {
            this._pivot = v;
        }
        else if(Array.isArray(v)) {
            this._pivot = [v[0], v[1] || v[0]];
        }
        else {
            this._pivot = [v, v];
        }
        this.redraw();
    }

    get pivot() {
        return this._pivot[0];
    }

    set pivotY(f) {
        this._pivot[1] = f;
        this.redraw();
    }

    get pivotY() {
        return this._pivot[1];
    }

    set pivotX(f) {
        this._pivot[0] = f;
        this.redraw();
    }

    get pivotX() {
        return this._pivot[0];
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;

        if(this._x) {
            this._pivot[0] = this._x / owner.w;
        }
        if(this._y) {
            this._pivot[1] = this._y / owner.h;
        }

        if(this._radius === 0) {
            this._radius = owner.w * 0.5;
        }

        this._setUniform('innerColor', this._normalizedIC, this.gl.uniform4fv);
        this._setUniform('fill', _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._oc)[3], this.gl.uniform1f);
        this._setUniform('outerColor', this._normalizedOC, this.gl.uniform4fv);
        this._setUniform('pivot', new Float32Array(this._pivot),  this.gl.uniform2fv);
        this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
        this._setUniform('radius',  this._radius, this.gl.uniform1f);
        this._setUniform('radiusY',  (this._radiusY || this._radius), this.gl.uniform1f);
    }
}

RadialGradientShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec2 pivot;
    uniform vec4 innerColor;
    uniform vec4 outerColor;
    uniform float radius;
    uniform float radiusY;
    uniform float alpha;
    uniform float fill;
    uniform float aspectRatio;
    
    void main() {
        vec2 point = vTextureCoord.xy * resolution;
        vec2 projection = vec2(pivot.x * resolution.x, pivot.y * resolution.y);
        float d = length((point - projection) / vec2(radius * 2.0, radiusY * 2.0));
        vec4 color = mix(texture2D(uSampler, vTextureCoord) * vColor, outerColor * alpha, fill);
        gl_FragColor = mix(innerColor * alpha, color, smoothstep(0.0, 1.0, d));
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/RoundedRectangleShader.mjs ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RoundedRectangleShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class RoundedRectangleShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._blend = 0;
        this._radius = [1, 1, 1, 1];
        this._stroke = 0;
        this._fc = 0x00ffffff;
        this._fillColor = this._getNormalizedColor(0xffffffff);
        this._strokeColor = this._getNormalizedColor(0x00ffffff);
    }

    set blend(p) {
        this._blend = Math.min(Math.max(p, 0), 1);
    }

    set radius(v) {
        if(Array.isArray(v)) {
            if(v.length === 2) {
                this._radius = [v[0], v[1], v[0], v[1]];
            }
            else if(v.length === 3) {
                this._radius = [v[0], v[1], v[2], this._radius[3]];
            }
            else if (v.length === 4) {
                this._radius = v;
            }
            else {
                this._radius = [v[0], v[0], v[0], v[0]];
            }
        }
        else {
            this._radius = [v, v, v, v];
        }
        this.redraw();
    }

    get radius() {
        return this._radius;
    }

    set topLeft(num) {
        this._radius[0] = num;
        this.redraw();
    }

    get topLeft() {
        return this._radius[0];
    }

    set topRight(num) {
        this._radius[1] = num;
        this.redraw();
    }

    get topRight() {
        return this._radius[1];
    }

    set bottomRight(num) {
        this._radius[2] = num;
        this.redraw();
    }

    get bottomRight() {
        return this._radius[2];
    }

    set bottomLeft(num) {
        this._radius[3] = num;
        this.redraw();
    }

    get bottomLeft() {
        return this._radius[4];
    }

    set strokeColor(argb) {
        this._sc = argb;
        this._strokeColor = this._getNormalizedColor(argb);
        this.redraw();
    }

    get strokeColor() {
        return this._sc;
    }

    set fillColor(argb) {
        this._fc = argb;
        this._fillColor = this._getNormalizedColor(argb);
        this.redraw();
    }

    get fillColor() {
        return this._fc;
    }

    set stroke(num) {
        this._stroke = num;
        this.redraw();
    }

    get stroke() {
        return this._stroke;
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;
        const renderPrecision = this.ctx.stage.getRenderPrecision();
        const _radius = this._radius.map((r) => (r + 0.5) * renderPrecision)
        this._setUniform('radius', new Float32Array(_radius), this.gl.uniform4fv);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);
        this._setUniform('blend', this._blend, this.gl.uniform1f);
        this._setUniform('strokeColor', this._strokeColor, this.gl.uniform4fv);
        this._setUniform('fillColor', this._fillColor, this.gl.uniform4fv);
        this._setUniform('stroke',  this._stroke * renderPrecision, this.gl.uniform1f);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv);
    }
}

RoundedRectangleShader.vertexShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    attribute vec2 aVertexPosition;
    attribute vec2 aTextureCoord;

    attribute vec4 aColor;
    uniform vec2 projection;
    varying vec2 vTextureCoord;
    varying vec4 vColor;

    void main(void){
        gl_Position = vec4(aVertexPosition.x * projection.x - 1.0, aVertexPosition.y * -abs(projection.y) + 1.0, 0.0, 1.0);
        vTextureCoord = aTextureCoord;
        vColor = aColor;
        gl_Position.y = -sign(projection.y) * gl_Position.y;
    }
`;

RoundedRectangleShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif

    #define PI 3.14159265359

    varying vec2 vTextureCoord;
    varying vec4 vColor;

    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 radius;
    uniform float stroke;
    uniform vec4 strokeColor;
    uniform vec4 fillColor;
    uniform float alpha;
    uniform float fill;
    uniform float blend;
    
    float boxDist(vec2 p, vec2 size, float radius){
        size -= vec2(radius);
        vec2 d = abs(p) - size;
        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    float innerBorderMask(float dist, float width){
        float alpha1 = clamp(dist + width, 0.0, 1.0);
        float alpha2 = clamp(dist, 0.0, 1.0);
        return alpha1 - alpha2;
    }

    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        float r = 0.0;
        if (vTextureCoord.x < 0.5 && vTextureCoord.y < 0.5) {
            r = radius[0];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y < 0.5) {
            r = radius[1];
        } else if (vTextureCoord.x >= 0.5 && vTextureCoord.y >= 0.5) {
            r = radius[2];
        } else {
            r = radius[3];
        }
        
        float b = boxDist(vTextureCoord.xy * resolution - halfRes, halfRes - 0.005, r);
        vec4 tex = texture2D(uSampler, vTextureCoord) * vColor;
        vec4 blend = mix(vec4(1.0) * alpha, tex, blend);     
        vec4 layer1 = mix(vec4(0.0), tex * fillColor, fillMask(b));
        gl_FragColor = mix(layer1, blend * strokeColor, innerBorderMask(b, stroke));
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpinnerShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SpinnerShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(ctx) {
        super(ctx);
        this._radius = 100;
        this._width = 50;
        this._period = 1;
        this._angle = 0.5;
        this._smooth = 0.005;
        this._color = 0xffffffff;
        this._backgroundColor = 0xff000000;
        this._time = Date.now();
    }

    set radius(v) {
        this._radius = v;
        this.redraw();
    }

    set width(v) {
        this._width = v;
        this.redraw();
    }

    set period(v) {
        this._period = v;
        this.redraw();
    }

    set angle(v) {
        this._angle = v
        this.redraw();
    }

    set smooth(v) {
        this._smooth = v;
        this.redraw();
    }

    set color(v) {
        this._color = v;
        this.redraw();
    }

    set backgroundColor(v) {
        this._backgroundColor = v;
        this.redraw();
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner

        this._setUniform("iTime", Date.now() - this._time, this.gl.uniform1f);

        const renderPrecision = this.ctx.stage.getRenderPrecision();
        this._setUniform('radius', this._radius * renderPrecision, this.gl.uniform1f);
        this._setUniform('width', this._width * renderPrecision, this.gl.uniform1f);
        this._setUniform('period', this._period, this.gl.uniform1f);
        this._setUniform('angle', this._angle, this.gl.uniform1f);
        this._setUniform('smooth', this._smooth, this.gl.uniform1f);
        this._setUniform('color', new Float32Array(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._color)), this.gl.uniform4fv);
        this._setUniform('backgroundColor', new Float32Array(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(this._backgroundColor)), this.gl.uniform4fv);
        this._setUniform('resolution', new Float32Array([owner._w * renderPrecision, owner._h * renderPrecision]), this.gl.uniform2fv)

        this.redraw()
    }
}

SpinnerShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

SpinnerShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float iTime;
    uniform float radius;
    uniform float width;
    uniform float period;
    uniform float angle;
    uniform float smooth;
    uniform vec2 resolution;

    uniform vec4 color;
    uniform vec4 backgroundColor;

    float ratio = resolution.y / resolution.x;

    vec2 transpose_pos(vec2 pos) {
        if (ratio < 1.) {
            float diff = 0.5 - pos.x;
            pos.x = 0.5 - diff / ratio;
        } else {
            float diff = 0.5 - pos.y;
            pos.y = 0.5 - diff * ratio;
        }
        return pos;
    }

    float get_angle(vec2 pos) {
        pos = transpose_pos(pos);
        float a = atan(pos.y - 0.5, pos.x - 0.5);
        a = (1.0+a/3.14159)/2.0;
        
        return a;
    }

    float dist(vec2 pos1, vec2 pos2) {
        pos1 = transpose_pos(pos1);
        return distance(pos1, pos2);
    }

    void main()
    {
        vec2 fragCoord = vTextureCoord;
        vec4 fragColor = vColor;
        
        vec2 st = vTextureCoord;
        float pct = dist(st, vec2(0.5));

        float a = get_angle(st);
        float t = iTime / 1000.0 / period;

        float inner = max((radius - width) / resolution.x, (radius - width) / resolution.y);
        float outer = max(radius / resolution.x, radius / resolution.y);

        float x1 = mod(t, 1.0);
        float x2 = mod(t + angle, 1.0);

        if (x1 < x2) {
            if (a > x1 && a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        } else {
            if (a < x2) {
                float val = (1.0 - (x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else if (a > x1) {
                float val = (1.0 - (1.0 + x2 - a) / angle) * smoothstep(0.0, 3. * smooth, (1.0 + x2 - a));
                fragColor = mix(backgroundColor, color, val);
            } else {
                fragColor = backgroundColor;
            }
        }

        float s = smoothstep(inner, inner + smooth + 0.00001, pct) * (1.0 - smoothstep(outer, outer + smooth + 0.00001, pct));
        gl_FragColor = texture2D(uSampler, fragCoord) * vColor * (1. - s * fragColor.a) + fragColor * s;
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/SpinnerShader2.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SpinnerShader2)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class SpinnerShader2 extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._period = 1;
        this._stroke = 0;
        this._showDot = true;
        this._clockwise = true;
        this._bc = 0xff000000;
        this._normalizedBC = this._getNormalizedColor(this._bc);
        this._c = 0xffffffff;
        this._normalizedC = this._getNormalizedColor(this._c);
    }

    set radius(v) {
        if(v === 0) {
            v = 1;
        }
        this._radius = v;
    }

    set stroke(value) {
        this._stroke = Math.abs(value);
    }

    get stroke() {
        return this._stroke;
    }

    set color(argb) {
        this._c = argb;
        this._normalizedC = this._getNormalizedColor(argb);
    }

    get color() {
        return this._c;
    }

    set backgroundColor(argb) {
        this._bc = argb;
        this._normalizedBC = this._getNormalizedColor(argb);
    }

    get backgroundColor() {
        return this._sc;
    }

    set showDot(bool) {
        this._showDot = bool;
    }

    get showDot() {
        return this._showDot;
    }

    set clockwise(bool) {
        this._clockwise = bool;
    }

    get clockwise() {
        return this._clockwise;
    }

    set period(v) {
        this._period = v;
    }

    get period() {
        return this._period;
    }

    _getNormalizedColor(color) {
        const col = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaComponentsNormalized(color);
        col[0] *= col[3];
        col[1] *= col[3];
        col[2] *= col[3];
        return new Float32Array(col);
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);
        const owner = operation.shaderOwner;
        const radius = this._radius || (owner._w / 2);

        if(this._stroke === 0) {
            this._stroke = radius * 0.33;
        }

        this._setUniform('resolution', new Float32Array([owner._w, owner._h]),  this.gl.uniform2fv);
        this._setUniform('color', this._normalizedC, this.gl.uniform4fv);
        this._setUniform('backgroundColor', this._normalizedBC, this.gl.uniform4fv);
        this._setUniform('stroke',  this._stroke, this.gl.uniform1f);
        this._setUniform('radius',  radius, this.gl.uniform1f);
        this._setUniform('direction',  this._clockwise ? -1 : 1, this.gl.uniform1f);
        this._setUniform('showDot', !!this._showDot, this.gl.uniform1f);
        this._setUniform('time', Date.now() - SpinnerShader2.spinSync, this.gl.uniform1f);
        this._setUniform('period', this._period, this.gl.uniform1f);
        this._setUniform('alpha', operation.getElementCore(0).renderContext.alpha, this.gl.uniform1f);

        if(this._sc !== this._bc || this._stroke !== radius * 0.5) {
            this.redraw();
        }
    }
}

SpinnerShader2.spinSync = Date.now();

SpinnerShader2.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    
    #define PI 3.14159265359
    
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    
    uniform sampler2D uSampler;
    uniform vec2 resolution;
    uniform vec4 color;
    uniform vec4 backgroundColor;
    uniform float direction;
    uniform float radius;
    uniform float time;
    uniform float stroke;
    uniform float showDot;
    uniform float period;
    uniform float alpha;
    
    float circleDist(vec2 p, float radius){
        return length(p) - radius;
    }
    
    float fillMask(float dist){
        return clamp(-dist, 0.0, 1.0);
    }
    
    void main() {
        vec2 halfRes = 0.5 * resolution.xy;
        vec2 center = vTextureCoord.xy * resolution - halfRes;
        
        float c = max(-circleDist(center, radius - stroke), circleDist(center, radius));
        float rot = -(time / 1000.0 / period) * 6.0 * direction;
        center *= mat2(cos(rot), sin(rot), -sin(rot), cos(rot));
        
        float a = direction * atan(center.x, center.y) * PI * 0.05 + 0.45;
        
        float strokeRad = stroke * 0.5;
        a = mix(a, max(a, fillMask(circleDist(vec2(center.x, center.y + (radius - strokeRad)), strokeRad))), showDot);
        vec4 base = mix(vec4(0.0), backgroundColor * alpha, fillMask(c));
        gl_FragColor = mix(base, color * alpha, fillMask(c) * a);
    }
`;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/renderer/webgl/shaders/VignetteShader.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ VignetteShader)
/* harmony export */ });
/* harmony import */ var _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultShader.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/shaders/DefaultShader.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class VignetteShader extends _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(context);
        this._magnitude = 1.3;
        this._intensity = 0.7;
        this._pivot = [0.5, 0.5];
    }

    setupUniforms(operation) {
        super.setupUniforms(operation);

        this._setUniform("magnitude", this._magnitude , this.gl.uniform1f);
        this._setUniform("intensity", this._intensity, this.gl.uniform1f);
        this._setUniform('pivot', new Float32Array(this._pivot), this.gl.uniform2fv);
        this.redraw()
    }

    set pivot(v) {
        if(Array.isArray(v)) {
            this._pivot = v;
        }
        else {
            this._pivot = [v, v];
        }
        this.redraw();
    }

    get pivotX() {
        return this._pivot[0];
    }

    set pivotX(v) {
        this._pivot[0] = v;
        this.redraw();
    }

    get pivotY() {
        return this._pivot[1];
    }

    set pivotY(v) {
        this._pivot[1] = v;
        this.redraw();
    }

    get intensity() {
        return this._intensity;
    }

    set intensity(v) {
        this._intensity = v;
        this.redraw();
    }

    get magnitude() {
        return this._magnitude;

    }

    set magnitude(v) {
        this._magnitude = v;
        this.redraw();
    }
}

VignetteShader.vertexShaderSource = _DefaultShader_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].vertexShaderSource;

VignetteShader.fragmentShaderSource = `
    #ifdef GL_ES
    # ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    # else
    precision lowp float;
    # endif
    #endif
    varying vec2 vTextureCoord;
    varying vec4 vColor;
    uniform sampler2D uSampler;

    uniform float magnitude;
    uniform float intensity;
    uniform vec2 pivot;

    void main() {
        vec2 uv = vTextureCoord.xy - pivot + vec2(0.5);
        uv.x = clamp(uv.x, 0.0, 1.0);
        uv.y = clamp(uv.y, 0.0, 1.0);
   
        uv *=  1.00 - uv.yx;
        float vig = uv.x * uv.y * 25.0 * intensity;
        vig = pow(vig, 0.45 * magnitude);
        vec4 fragColor = vec4(vig) * vColor;
        gl_FragColor = texture2D(uSampler, vTextureCoord) * fragColor;

    }
`


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/HtmlTexture.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HtmlTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class HtmlTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
        this._htmlElement = undefined;
        this._scale = 1;
    }

    set htmlElement(v) {
        this._htmlElement = v;
        this._changed();
    }

    get htmlElement() {
        return this._htmlElement;
    }

    set scale(v) {
        this._scale = v;
        this._changed();
    }

    get scale() {
        return this._scale;
    }

    set html(v) {
        if (!v) {
            this.htmlElement = undefined;
        } else {
            const d = document.createElement('div');
            d.innerHTML = "<div>" + v + "</div>";
            this.htmlElement = d.firstElementChild;
        }
    }

    get html() {
        return this._htmlElement.innerHTML;
    }

    _getIsValid() {
        return this.htmlElement;
    }

    _getLookupId() {
        return this._scale + ":" + this._htmlElement.innerHTML;
    }

    _getSourceLoader() {
        const htmlElement = this._htmlElement;
        const scale = this._scale;
        return function(cb) {
            if (!window.html2canvas) {
                return cb(new Error("Please include html2canvas (https://html2canvas.hertzen.com/)"));
            }

            const area = HtmlTexture.getPreloadArea();
            area.appendChild(htmlElement);

            html2canvas(htmlElement, {backgroundColor: null, scale: scale}).then(function(canvas) {
                area.removeChild(htmlElement);
                if (canvas.height === 0) {
                    return cb(new Error("Canvas height is 0"));
                }
                cb(null, {source: canvas, width: canvas.width, height: canvas.height});
            }).catch(e => {
                console.error('[Lightning]', e);
            });
        }
    }

    static getPreloadArea() {
        if (!this._preloadArea) {
            // Preload area must be included in document body and must be visible to trigger html element rendering.
            this._preloadArea = document.createElement('div');
            if (this._preloadArea.attachShadow) {
                // Use a shadow DOM if possible to prevent styling from interfering.
                this._preloadArea.attachShadow({mode: 'closed'});
            }
            this._preloadArea.style.opacity = 0;
            this._preloadArea.style.pointerEvents = 'none';
            this._preloadArea.style.position = 'fixed';
            this._preloadArea.style.display = 'block';
            this._preloadArea.style.top = '100vh';
            this._preloadArea.style.overflow = 'hidden';
            document.body.appendChild(this._preloadArea);
        }
        return this._preloadArea;
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ImageTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ImageTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._src = undefined;
        this._hasAlpha = false;
    }

    get src() {
        return this._src;
    }

    set src(v) {
        if (this._src !== v) {
            this._src = v;
            this._changed();
        }
    }

    get hasAlpha() {
        return this._hasAlpha;
    }

    set hasAlpha(v) {
        if (this._hasAlpha !== v) {
            this._hasAlpha = v;
            this._changed();
        }
    }

    _getIsValid() {
        return !!this._src;
    }

    _getLookupId() {
        return this._src;
    }

    _getSourceLoader() {
        let src = this._src;
        let hasAlpha = this._hasAlpha;
        if (this.stage.getOption('srcBasePath')) {
            var fc = src.charCodeAt(0);
            if ((src.indexOf("//") === -1) && ((fc >= 65 && fc <= 90) || (fc >= 97 && fc <= 122) || fc == 46)) {
                // Alphabetical or dot: prepend base path.
                src = this.stage.getOption('srcBasePath') + src;
            }
        }

        return (cb) => {
            return this.stage.platform.loadSrcTexture({src: src, hasAlpha: hasAlpha}, cb);
        }
    }

    getNonDefaults() {
        const obj = super.getNonDefaults();
        if (this._src) {
            obj.src = this._src;
        }
        return obj;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/NoiseTexture.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ NoiseTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class NoiseTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    _getLookupId() {
        return '__noise';
    }

    _getSourceLoader() {
        const gl = this.stage.gl;
        return function(cb) {
            const noise = new Uint8Array(128 * 128 * 4);
            for (let i = 0; i < 128 * 128 * 4; i+=4) {
                const v = Math.floor(Math.random() * 256);
                noise[i] = v;
                noise[i+1] = v;
                noise[i+2] = v;
                noise[i+3] = 255;
            }
            const texParams = {}

            if (gl) {
                texParams[gl.TEXTURE_WRAP_S] = gl.REPEAT;
                texParams[gl.TEXTURE_WRAP_T] = gl.REPEAT;
                texParams[gl.TEXTURE_MIN_FILTER] = gl.NEAREST;
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
            }

            cb(null, {source: noise, w: 128, h: 128, texParams: texParams});
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RectangleTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class RectangleTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    _getLookupId() {
        return '__whitepix';
    }

    _getSourceLoader() {
        return function(cb) {
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            cb(null, {source: whitePixel, w: 1, h: 1, permanent: true});
        }
    }

    isAutosizeTexture() {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SourceTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class SourceTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        this._textureSource = undefined;
    }

    get textureSource() {
        return this._textureSource;
    }

    set textureSource(v) {
        if (v !== this._textureSource) {
            if (v.isResultTexture) {
                // In case of a result texture, automatically inherit the precision.
                this._precision = this.stage.getRenderPrecision();
            }
            this._textureSource = v;
            this._changed();
        }
    }

    _getTextureSource() {
        return this._textureSource;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StaticCanvasTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class StaticCanvasTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);
        this._factory = undefined;
        this._lookupId = undefined;
    }

    set content({factory, lookupId = undefined}) {
        this._factory = factory;
        this._lookupId = lookupId;
        this._changed();
    }

    _getIsValid() {
        return !!this._factory;
    }

    _getLookupId() {
        return this._lookupId;
    }

    _getSourceLoader() {
        const f = this._factory;
        return (cb) => {
            return f((err, canvas) => {
                if (err) {
                    return cb(err);
                }
                cb(null, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas));
            }, this.stage);
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/StaticTexture.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StaticTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class StaticTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage, options) {
        super(stage);

        this._options = options;
    }

    set options(v) {
        if (this._options !== v) {
            this._options = v;
            this._changed();
        }
    }

    get options() {
        return this._options;
    }

    _getIsValid() {
        return !!this._options;
    }

    _getSourceLoader() {
        return (cb) => {
            cb(null, this._options);
        }
    }
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs":
/*!*********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTexture.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTexture)
/* harmony export */ });
/* harmony import */ var _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TextTextureRenderer.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs");
/* harmony import */ var _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextTextureRendererAdvanced.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTexture extends _tree_Texture_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(stage) {
        super(stage);

        // We use the stage precision as the default precision in case of a text texture.
        this._precision = this.stage.getOption('precision');
    }

    static renderer(stage, canvas, settings) {
        if (this.advancedRenderer) {
            return new _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](stage, canvas, settings);
        } else {
            return new _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](stage, canvas, settings);
        }
    }

    get text() {
        return this._text;
    }

    set text(v) {
        if (this._text !== v) {
            this._text = "" + v;
            this._changed();
        }
    }

    get w() {
        return this._w;
    }

    set w(v) {
        if (this._w !== v) {
            this._w = v;
            this._changed();
        }
    }

    get h() {
        return this._h;
    }

    set h(v) {
        if (this._h !== v) {
            this._h = v;
            this._changed();
        }
    }

    get fontStyle() {
        return this._fontStyle;
    }

    set fontStyle(v) {
        if (this._fontStyle !== v) {
            this._fontStyle = v;
            this._changed();
        }
    }

    get fontSize() {
        return this._fontSize;
    }

    set fontSize(v) {
        if (this._fontSize !== v) {
            this._fontSize = v;
            this._changed();
        }
    }

    get fontFace() {
        return this._fontFace;
    }

    set fontFace(v) {
        if (this._fontFace !== v) {
            this._fontFace = v;
            this._changed();
        }
    }

    get wordWrap() {
        return this._wordWrap;
    }

    set wordWrap(v) {
        if (this._wordWrap !== v) {
            this._wordWrap = v;
            this._changed();
        }
    }

    get wordWrapWidth() {
        return this._wordWrapWidth;
    }

    set wordWrapWidth(v) {
        if (this._wordWrapWidth !== v) {
            this._wordWrapWidth = v;
            this._changed();
        }
    }

    get wordBreak() {
        return this._wordBreak;
    }

    set wordBreak(v) {
        if (this._wordBreak !== v) {
            this._wordBreak = v;
            this._changed();
        }
    }

    get textOverflow() {
        return this._textOverflow;
    }

    set textOverflow(v) {
        if (v != this._textOverflow) {
            this._textOverflow = v;
            this._changed();
        }
    }

    get lineHeight() {
        return this._lineHeight;
    }

    set lineHeight(v) {
        if (this._lineHeight !== v) {
            this._lineHeight = v;
            this._changed();
        }
    }

    get textBaseline() {
        return this._textBaseline;
    }

    set textBaseline(v) {
        if (this._textBaseline !== v) {
            this._textBaseline = v;
            this._changed();
        }
    }

    get textAlign() {
        return this._textAlign;
    }

    set textAlign(v) {
        if (this._textAlign !== v) {
            this._textAlign = v;
            this._changed();
        }
    }

    get verticalAlign() {
        return this._verticalAlign;
    }

    set verticalAlign(v) {
        if (this._verticalAlign !== v) {
            this._verticalAlign = v;
            this._changed();
        }
    }

    get offsetY() {
        return this._offsetY;
    }

    set offsetY(v) {
        if (this._offsetY !== v) {
            this._offsetY = v;
            this._changed();
        }
    }

    get maxLines() {
        return this._maxLines;
    }

    set maxLines(v) {
        if (this._maxLines !== v) {
            this._maxLines = v;
            this._changed();
        }
    }

    get maxLinesSuffix() {
        return this._maxLinesSuffix;
    }

    set maxLinesSuffix(v) {
        if (this._maxLinesSuffix !== v) {
            this._maxLinesSuffix = v;
            this._changed();
        }
    }

    get textColor() {
        return this._textColor;
    }

    set textColor(v) {
        if (this._textColor !== v) {
            this._textColor = v;
            this._changed();
        }
    }

    get paddingLeft() {
        return this._paddingLeft;
    }

    set paddingLeft(v) {
        if (this._paddingLeft !== v) {
            this._paddingLeft = v;
            this._changed();
        }
    }

    get paddingRight() {
        return this._paddingRight;
    }

    set paddingRight(v) {
        if (this._paddingRight !== v) {
            this._paddingRight = v;
            this._changed();
        }
    }

    get shadow() {
        return this._shadow;
    }

    set shadow(v) {
        if (this._shadow !== v) {
            this._shadow = v;
            this._changed();
        }
    }

    get shadowColor() {
        return this._shadowColor;
    }

    set shadowColor(v) {
        if (this._shadowColor !== v) {
            this._shadowColor = v;
            this._changed();
        }
    }

    get shadowOffsetX() {
        return this._shadowOffsetX;
    }

    set shadowOffsetX(v) {
        if (this._shadowOffsetX !== v) {
            this._shadowOffsetX = v;
            this._changed();
        }
    }

    get shadowOffsetY() {
        return this._shadowOffsetY;
    }

    set shadowOffsetY(v) {
        if (this._shadowOffsetY !== v) {
            this._shadowOffsetY = v;
            this._changed();
        }
    }

    get shadowBlur() {
        return this._shadowBlur;
    }

    set shadowBlur(v) {
        if (this._shadowBlur !== v) {
            this._shadowBlur = v;
            this._changed();
        }
    }

    get highlight() {
        return this._highlight;
    }

    set highlight(v) {
        if (this._highlight !== v) {
            this._highlight = v;
            this._changed();
        }
    }

    get highlightHeight() {
        return this._highlightHeight;
    }

    set highlightHeight(v) {
        if (this._highlightHeight !== v) {
            this._highlightHeight = v;
            this._changed();
        }
    }

    get highlightColor() {
        return this._highlightColor;
    }

    set highlightColor(v) {
        if (this._highlightColor !== v) {
            this._highlightColor = v;
            this._changed();
        }
    }

    get highlightOffset() {
        return this._highlightOffset;
    }

    set highlightOffset(v) {
        if (this._highlightOffset !== v) {
            this._highlightOffset = v;
            this._changed();
        }
    }

    get highlightPaddingLeft() {
        return this._highlightPaddingLeft;
    }

    set highlightPaddingLeft(v) {
        if (this._highlightPaddingLeft !== v) {
            this._highlightPaddingLeft = v;
            this._changed();
        }
    }

    get highlightPaddingRight() {
        return this._highlightPaddingRight;
    }

    set highlightPaddingRight(v) {
        if (this._highlightPaddingRight !== v) {
            this._highlightPaddingRight = v;
            this._changed();
        }
    }

    get cutSx() {
        return this._cutSx;
    }

    set cutSx(v) {
        if (this._cutSx !== v) {
            this._cutSx = v;
            this._changed();
        }
    }

    get cutEx() {
        return this._cutEx;
    }

    set cutEx(v) {
        if (this._cutEx !== v) {
            this._cutEx = v;
            this._changed();
        }
    }

    get cutSy() {
        return this._cutSy;
    }

    set cutSy(v) {
        if (this._cutSy !== v) {
            this._cutSy = v;
            this._changed();
        }
    }

    get cutEy() {
        return this._cutEy;
    }

    set cutEy(v) {
        if (this._cutEy !== v) {
            this._cutEy = v;
            this._changed();
        }
    }

    get advancedRenderer() {
        return this._advancedRenderer;
    }

    set advancedRenderer(v) {
        if (this._advancedRenderer !== v) {
            this._advancedRenderer = v;
            this._changed();
        }
    }

    set letterSpacing(v) {
        if (this._letterSpacing !== v) {
            this._letterSpacing = v;
            this._changed();
        }
    }

    get letterSpacing() {
        return this._letterSpacing;
    }

    set textIndent(v) {
        if (this._textIndent !== v) {
            this._textIndent = v;
            this._changed();
        }
    }

    get textIndent() {
        return this._textIndent;
    }

    get precision() {
        return super.precision;
    }

    set precision(v) {
        // We actually draw differently when the precision changes.
        if (this.precision !== v) {
            super.precision = v;
            this._changed();
        }
    }

    _getIsValid() {
        return !!this.text;
    }

    _getLookupId() {
        let parts = [];

        if (this.w !== 0) parts.push("w " + this.w);
        if (this.h !== 0) parts.push("h " + this.h);
        if (this.fontStyle !== "normal") parts.push("fS" + this.fontStyle);
        if (this.fontSize !== 40) parts.push("fs" + this.fontSize);
        if (this.fontFace !== null) parts.push("ff" + (Array.isArray(this.fontFace) ? this.fontFace.join(",") : this.fontFace));
        if (this.wordWrap !== true) parts.push("wr" + (this.wordWrap ? 1 : 0));
        if (this.wordWrapWidth !== 0) parts.push("ww" + this.wordWrapWidth);
        if (this.wordBreak !== false) parts.push("wb" + this.wordBreak ? 1 : 0);
        if (this.textOverflow != "") parts.push("to" + this.textOverflow);
        if (this.lineHeight !== null) parts.push("lh" + this.lineHeight);
        if (this.textBaseline !== "alphabetic") parts.push("tb" + this.textBaseline);
        if (this.textAlign !== "left") parts.push("ta" + this.textAlign);
        if (this.verticalAlign !== "top") parts.push("va" + this.verticalAlign);
        if (this.offsetY !== null) parts.push("oy" + this.offsetY);
        if (this.maxLines !== 0) parts.push("ml" + this.maxLines);
        if (this.maxLinesSuffix !== "..") parts.push("ms" + this.maxLinesSuffix);
        parts.push("pc" + this.precision);
        if (this.textColor !== 0xffffffff) parts.push("co" + this.textColor.toString(16));
        if (this.paddingLeft !== 0) parts.push("pl" + this.paddingLeft);
        if (this.paddingRight !== 0) parts.push("pr" + this.paddingRight);
        if (this.shadow !== false) parts.push("sh" + (this.shadow ? 1 : 0));
        if (this.shadowColor !== 0xff000000) parts.push("sc" + this.shadowColor.toString(16));
        if (this.shadowOffsetX !== 0) parts.push("sx" + this.shadowOffsetX);
        if (this.shadowOffsetY !== 0) parts.push("sy" + this.shadowOffsetY);
        if (this.shadowBlur !== 5) parts.push("sb" + this.shadowBlur);
        if (this.highlight !== false) parts.push("hL" + (this.highlight ? 1 : 0));
        if (this.highlightHeight !== 0) parts.push("hh" + this.highlightHeight);
        if (this.highlightColor !== 0xff000000) parts.push("hc" + this.highlightColor.toString(16));
        if (this.highlightOffset !== null) parts.push("ho" + this.highlightOffset);
        if (this.highlightPaddingLeft !== null) parts.push("hl" + this.highlightPaddingLeft);
        if (this.highlightPaddingRight !== null) parts.push("hr" + this.highlightPaddingRight);
        if (this.letterSpacing !== null) parts.push("ls" + this.letterSpacing);
        if (this.textIndent !== null) parts.push("ti" + this.textIndent);

        if (this.cutSx) parts.push("csx" + this.cutSx);
        if (this.cutEx) parts.push("cex" + this.cutEx);
        if (this.cutSy) parts.push("csy" + this.cutSy);
        if (this.cutEy) parts.push("cey" + this.cutEy);

        if (this.advancedRenderer) parts.push("aR" + this.advancedRenderer ? 1 : 0);

        let id = "TX$" + parts.join("|") + ":" + this.text;
        return id;
    }

    _getSourceLoader() {
        const args = this.cloneArgs();

        // Inherit font face from stage.
        if (args.fontFace === null) {
            args.fontFace = this.stage.getOption('defaultFontFace');
        }

        const gl = this.stage.gl;

        return function (cb) {
            const canvas = this.stage.platform.getDrawingCanvas();
            const renderer = (args.advancedRenderer)
              ? new _TextTextureRendererAdvanced_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this.stage, canvas, args)
              : new _TextTextureRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this.stage, canvas, args);
            
            const p = renderer.draw();

            const texParams = {};

            const sharpCfg = this.stage.getOption('fontSharp');
            let sharpen = false;

            // Prevent text blur when text texture is downscaled
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isBoolean(sharpCfg)) {
                sharpen = sharpCfg;
            } else if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isObject(sharpCfg)) {
                const precision = this.stage.getRenderPrecision();
                sharpen = precision <= sharpCfg.precision && args.fontSize <= sharpCfg.fontSize;
            }

            if (gl && sharpen) {
                texParams[gl.TEXTURE_MAG_FILTER] = gl.NEAREST;
            }

            if (p) {
                p.then(() => {
                    /* FIXME: on some platforms (e.g. RPI), throttling text textures cause artifacts */
                    cb(null, Object.assign({
                        renderInfo: renderer.renderInfo,
                        throttle: false,
                        texParams: texParams,
                    }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
                }).catch((err) => {
                    cb(err);
                });
            } else {
                cb(null, Object.assign({
                    renderInfo: renderer.renderInfo,
                    throttle: false,
                    texParams: texParams,
                }, this.stage.platform.getTextureOptionsForDrawingCanvas(canvas)));
            }
        };
    }


    getNonDefaults() {
        const nonDefaults = super.getNonDefaults();
        if (this.text !== "") nonDefaults['text'] = this.text;
        if (this.w !== 0) nonDefaults['w'] = this.w;
        if (this.h !== 0) nonDefaults['h'] = this.h;
        if (this.fontStyle !== "normal") nonDefaults['fontStyle'] = this.fontStyle;
        if (this.fontSize !== 40) nonDefaults["fontSize"] = this.fontSize;
        if (this.fontFace !== null) nonDefaults["fontFace"] = this.fontFace;
        if (this.wordWrap !== true) nonDefaults["wordWrap"] = this.wordWrap;
        if (this.wordWrapWidth !== 0) nonDefaults["wordWrapWidth"] = this.wordWrapWidth;
        if (this.wordBreak !== false) nonDefaults["wordBreak"] = this.wordBreak;
        if (this.textOverflow != "") nonDefaults["textOverflow"] = this.textOverflow;
        if (this.lineHeight !== null) nonDefaults["lineHeight"] = this.lineHeight;
        if (this.textBaseline !== "alphabetic") nonDefaults["textBaseline"] = this.textBaseline;
        if (this.textAlign !== "left") nonDefaults["textAlign"] = this.textAlign;
        if (this.verticalAlign !== "top") nonDefaults["verticalAlign"] = this.verticalAlign;
        if (this.offsetY !== null) nonDefaults["offsetY"] = this.offsetY;
        if (this.maxLines !== 0) nonDefaults["maxLines"] = this.maxLines;
        if (this.maxLinesSuffix !== "..") nonDefaults["maxLinesSuffix"] = this.maxLinesSuffix;
        if (this.precision !== this.stage.getOption('precision')) nonDefaults["precision"] = this.precision;
        if (this.textColor !== 0xffffffff) nonDefaults["textColor"] = this.textColor;
        if (this.paddingLeft !== 0) nonDefaults["paddingLeft"] = this.paddingLeft;
        if (this.paddingRight !== 0) nonDefaults["paddingRight"] = this.paddingRight;
        if (this.shadow !== false) nonDefaults["shadow"] = this.shadow;
        if (this.shadowColor !== 0xff000000) nonDefaults["shadowColor"] = this.shadowColor;
        if (this.shadowOffsetX !== 0) nonDefaults["shadowOffsetX"] = this.shadowOffsetX;
        if (this.shadowOffsetY !== 0) nonDefaults["shadowOffsetY"] = this.shadowOffsetY;
        if (this.shadowBlur !== 5) nonDefaults["shadowBlur"] = this.shadowBlur;
        if (this.highlight !== false) nonDefaults["highlight"] = this.highlight;
        if (this.highlightHeight !== 0) nonDefaults["highlightHeight"] = this.highlightHeight;
        if (this.highlightColor !== 0xff000000) nonDefaults["highlightColor"] = this.highlightColor;
        if (this.highlightOffset !== 0) nonDefaults["highlightOffset"] = this.highlightOffset;
        if (this.highlightPaddingLeft !== 0) nonDefaults["highlightPaddingLeft"] = this.highlightPaddingLeft;
        if (this.highlightPaddingRight !== 0) nonDefaults["highlightPaddingRight"] = this.highlightPaddingRight;
        if (this.letterSpacing !== 0) nonDefaults["letterSpacing"] = this.letterSpacing;
        if (this.textIndent !== 0) nonDefaults["textIndent"] = this.textIndent;

        if (this.cutSx) nonDefaults["cutSx"] = this.cutSx;
        if (this.cutEx) nonDefaults["cutEx"] = this.cutEx;
        if (this.cutSy) nonDefaults["cutSy"] = this.cutSy;
        if (this.cutEy) nonDefaults["cutEy"] = this.cutEy;

        if (this.advancedRenderer) nonDefaults["renderer"] = this.advancedRenderer;
        return nonDefaults;
    }

    cloneArgs() {
        let obj = {};
        obj.text = this._text;
        obj.w = this._w;
        obj.h = this._h;
        obj.fontStyle = this._fontStyle;
        obj.fontSize = this._fontSize;
        obj.fontFace = this._fontFace;
        obj.wordWrap = this._wordWrap;
        obj.wordWrapWidth = this._wordWrapWidth;
        obj.wordBreak = this._wordBreak;
        obj.textOverflow = this._textOverflow;
        obj.lineHeight = this._lineHeight;
        obj.textBaseline = this._textBaseline;
        obj.textAlign = this._textAlign;
        obj.verticalAlign = this._verticalAlign;
        obj.offsetY = this._offsetY;
        obj.maxLines = this._maxLines;
        obj.maxLinesSuffix = this._maxLinesSuffix;
        obj.precision = this._precision;
        obj.textColor = this._textColor;
        obj.paddingLeft = this._paddingLeft;
        obj.paddingRight = this._paddingRight;
        obj.shadow = this._shadow;
        obj.shadowColor = this._shadowColor;
        obj.shadowOffsetX = this._shadowOffsetX;
        obj.shadowOffsetY = this._shadowOffsetY;
        obj.shadowBlur = this._shadowBlur;
        obj.highlight = this._highlight;
        obj.highlightHeight = this._highlightHeight;
        obj.highlightColor = this._highlightColor;
        obj.highlightOffset = this._highlightOffset;
        obj.highlightPaddingLeft = this._highlightPaddingLeft;
        obj.highlightPaddingRight = this._highlightPaddingRight;
        obj.letterSpacing = this._letterSpacing;
        obj.textIndent = this._textIndent;
        obj.cutSx = this._cutSx;
        obj.cutEx = this._cutEx;
        obj.cutSy = this._cutSy;
        obj.cutEy = this._cutEy;
        obj.advancedRenderer = this._advancedRenderer;
        return obj;
    }


}

// Because there are so many properties, we prefer to use the prototype for default values.
// This causes a decrease in performance, but also a decrease in memory usage.
let proto = TextTexture.prototype;
proto._text = "";
proto._w = 0;
proto._h = 0;
proto._fontStyle = "normal";
proto._fontSize = 40;
proto._fontFace = null;
proto._wordWrap = true;
proto._wordWrapWidth = 0;
proto._wordBreak = false;
proto._textOverflow = "";
proto._lineHeight = null;
proto._textBaseline = "alphabetic";
proto._textAlign = "left";
proto._verticalAlign = "top";
proto._offsetY = null;
proto._maxLines = 0;
proto._maxLinesSuffix = "..";
proto._textColor = 0xFFFFFFFF;
proto._paddingLeft = 0;
proto._paddingRight = 0;
proto._shadow = false;
proto._shadowColor = 0xFF000000;
proto._shadowOffsetX = 0;
proto._shadowOffsetY = 0;
proto._shadowBlur = 5;
proto._highlight = false;
proto._highlightHeight = 0;
proto._highlightColor = 0xFF000000;
proto._highlightOffset = 0;
proto._highlightPaddingLeft = 0;
proto._highlightPaddingRight = 0;
proto._letterSpacing = 0;
proto._textIndent = 0;
proto._cutSx = 0;
proto._cutEx = 0;
proto._cutSy = 0;
proto._cutEy = 0;
proto._advancedRenderer = false;






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTextureRenderer.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTextureRenderer)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTextureRenderer {

    constructor(stage, canvas, settings) {
        this._stage = stage;
        this._canvas = canvas;
        this._context = this._canvas.getContext('2d');
        this._settings = settings;
    }

    getPrecision() {
        return this._settings.precision;
    };

    setFontProperties() {
        this._context.font = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.getFontSetting(this) : this._getFontSetting();
        this._context.textBaseline = this._settings.textBaseline;
    };

    _getFontSetting() {
        let ff = this._settings.fontFace;

        if (!Array.isArray(ff)) {
            ff = [ff];
        }

        let ffs = [];
        for (let i = 0, n = ff.length; i < n; i++) {
            if (ff[i] === "serif" || ff[i] === "sans-serif") {
                ffs.push(ff[i]);
            } else {
                ffs.push(`"${ff[i]}"`);
            }
        }

        return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`
    }

    _load() {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && document.fonts) {
            const fontSetting = this._getFontSetting();
            try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                        // Just load the fallback font.
                        console.warn('[Lightning] Font load error', err, fontSetting);
                    }).then(() => {
                        if (!document.fonts.check(fontSetting, this._settings.text)) {
                            console.warn('[Lightning] Font not found', fontSetting);
                        }
                    });
                }
            } catch(e) {
                console.warn("[Lightning] Can't check font loading for " + fontSetting);
            }
        }
    }

    draw() {
        // We do not use a promise so that loading is performed syncronous when possible.
        const loadPromise = this._load();
        if (!loadPromise) {
            return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
        } else {
            return loadPromise.then(() => {
                return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
            });
        }
    }

    _calculateRenderInfo() {
        let renderInfo = {};

        const precision = this.getPrecision();

        const paddingLeft = this._settings.paddingLeft * precision;
        const paddingRight = this._settings.paddingRight * precision;
        const fontSize = this._settings.fontSize * precision;
        let offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
        let lineHeight = this._settings.lineHeight * precision;
        const w = this._settings.w * precision;
        const h = this._settings.h * precision;
        let wordWrapWidth = this._settings.wordWrapWidth * precision;
        const cutSx = this._settings.cutSx * precision;
        const cutEx = this._settings.cutEx * precision;
        const cutSy = this._settings.cutSy * precision;
        const cutEy = this._settings.cutEy * precision;
        const letterSpacing = (this._settings.letterSpacing || 0) * precision;
        const textIndent = this._settings.textIndent * precision;

        // Set font properties.
        this.setFontProperties();

        // Total width.
        let width = w || (2048 / this.getPrecision());

        // Inner width.
        let innerWidth = width - (paddingLeft);
        if (innerWidth < 10) {
            width += (10 - innerWidth);
            innerWidth += (10 - innerWidth);
        }

        if (!wordWrapWidth) {
            wordWrapWidth = innerWidth
        }

        // Text overflow
        if (this._settings.textOverflow && !this._settings.wordWrap) {
            let suffix;
            switch (this._settings.textOverflow) {
                case 'clip':
                    suffix = '';
                    break;
                case 'ellipsis':
                    suffix = this._settings.maxLinesSuffix;
                    break;
                default:
                    suffix = this._settings.textOverflow;
            }
            this._settings.text = this.wrapWord(this._settings.text, wordWrapWidth - textIndent, suffix)
        }

        // word wrap
        // preserve original text
        let linesInfo;
        if (this._settings.wordWrap) {
            linesInfo = this.wrapText(this._settings.text, wordWrapWidth, letterSpacing, textIndent);
        } else {
            linesInfo = {l: this._settings.text.split(/(?:\r\n|\r|\n)/), n: []};
            let i, n = linesInfo.l.length;
            for (let i = 0; i < n - 1; i++) {
                linesInfo.n.push(i);
            }
        }
        let lines = linesInfo.l;

        if (this._settings.maxLines && lines.length > this._settings.maxLines) {
            let usedLines = lines.slice(0, this._settings.maxLines);

            let otherLines = null;
            if (this._settings.maxLinesSuffix) {
                // Wrap again with max lines suffix enabled.
                let w = this._settings.maxLinesSuffix ? this.measureText(this._settings.maxLinesSuffix) : 0;
                let al = this.wrapText(usedLines[usedLines.length - 1], wordWrapWidth - w, letterSpacing, textIndent);
                usedLines[usedLines.length - 1] = al.l[0] + this._settings.maxLinesSuffix;
                otherLines = [al.l.length > 1 ? al.l[1] : ''];
            } else {
                otherLines = [''];
            }

            // Re-assemble the remaining text.
            let i, n = lines.length;
            let j = 0;
            let m = linesInfo.n.length;
            for (i = this._settings.maxLines; i < n; i++) {
                otherLines[j] += (otherLines[j] ? " " : "") + lines[i];
                if (i + 1 < m && linesInfo.n[i + 1]) {
                    j++;
                }
            }

            renderInfo.remainingText = otherLines.join("\n");

            renderInfo.moreTextLines = true;

            lines = usedLines;
        } else {
            renderInfo.moreTextLines = false;
            renderInfo.remainingText = "";
        }

        // calculate text width
        let maxLineWidth = 0;
        let lineWidths = [];
        for (let i = 0; i < lines.length; i++) {
            let lineWidth = this.measureText(lines[i], letterSpacing) + (i === 0 ? textIndent : 0);
            lineWidths.push(lineWidth);
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }

        renderInfo.lineWidths = lineWidths;

        if (!w) {
            // Auto-set width to max text length.
            width = maxLineWidth + paddingLeft + paddingRight;
            innerWidth = maxLineWidth;
        }

        // calculate text height
        lineHeight = lineHeight || fontSize;

        let height;
        if (h) {
            height = h;
        } else {
            const baselineOffset = (this._settings.textBaseline != 'bottom') ? 0.5 * fontSize : 0;
            height = lineHeight * (lines.length - 1) + baselineOffset + Math.max(lineHeight, fontSize) + offsetY;
        }

        if (offsetY === null) {
            offsetY = fontSize;
        }

        renderInfo.w = width;
        renderInfo.h = height;
        renderInfo.lines = lines;
        renderInfo.precision = precision;

        if (!width) {
            // To prevent canvas errors.
            width = 1;
        }

        if (!height) {
            // To prevent canvas errors.
            height = 1;
        }

        if (cutSx || cutEx) {
            width = Math.min(width, cutEx - cutSx);
        }

        if (cutSy || cutEy) {
            height = Math.min(height, cutEy - cutSy);
        }

        renderInfo.width = width;
        renderInfo.innerWidth = innerWidth;
        renderInfo.height = height;
        renderInfo.fontSize = fontSize;
        renderInfo.cutSx = cutSx;
        renderInfo.cutSy = cutSy;
        renderInfo.cutEx = cutEx;
        renderInfo.cutEy = cutEy;
        renderInfo.lineHeight = lineHeight;
        renderInfo.lineWidths = lineWidths;
        renderInfo.offsetY = offsetY;
        renderInfo.paddingLeft = paddingLeft;
        renderInfo.paddingRight = paddingRight;
        renderInfo.letterSpacing = letterSpacing;
        renderInfo.textIndent = textIndent;

        return renderInfo;
    }

    _draw() {
        const renderInfo = this._calculateRenderInfo();
        const precision = this.getPrecision();

        // Add extra margin to prevent issue with clipped text when scaling.
        this._canvas.width = Math.ceil(renderInfo.width + this._stage.getOption('textRenderIssueMargin'));
        this._canvas.height = Math.ceil(renderInfo.height);

        // Canvas context has been reset.
        this.setFontProperties();

        if (renderInfo.fontSize >= 128) {
            // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
            this._context.globalAlpha = 0.01;
            this._context.fillRect(0, 0, 0.01, 0.01);
            this._context.globalAlpha = 1.0;
        }

        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
        }

        let linePositionX;
        let linePositionY;

        let drawLines = [];

        // Draw lines line by line.
        for (let i = 0, n = renderInfo.lines.length; i < n; i++) {
            linePositionX = i === 0 ? renderInfo.textIndent : 0;

            // By default, text is aligned to top
            linePositionY = (i * renderInfo.lineHeight) + renderInfo.offsetY;

            if (this._settings.verticalAlign == 'middle') {
                linePositionY += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
            } else if (this._settings.verticalAlign == 'bottom') {
                linePositionY += renderInfo.lineHeight - renderInfo.fontSize;
            }

            if (this._settings.textAlign === 'right') {
                linePositionX += (renderInfo.innerWidth - renderInfo.lineWidths[i]);
            } else if (this._settings.textAlign === 'center') {
                linePositionX += ((renderInfo.innerWidth - renderInfo.lineWidths[i]) / 2);
            }
            linePositionX += renderInfo.paddingLeft;

            drawLines.push({text: renderInfo.lines[i], x: linePositionX, y: linePositionY, w: renderInfo.lineWidths[i]});
        }

        // Highlight.
        if (this._settings.highlight) {
            let color = this._settings.highlightColor || 0x00000000;

            let hlHeight = (this._settings.highlightHeight * precision || renderInfo.fontSize * 1.5);
            const offset = this._settings.highlightOffset * precision;
            const hlPaddingLeft = (this._settings.highlightPaddingLeft !== null ? this._settings.highlightPaddingLeft * precision : renderInfo.paddingLeft);
            const hlPaddingRight = (this._settings.highlightPaddingRight !== null ? this._settings.highlightPaddingRight * precision : renderInfo.paddingRight);

            this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(color);
            for (let i = 0; i < drawLines.length; i++) {
                let drawLine = drawLines[i];
                this._context.fillRect((drawLine.x - hlPaddingLeft), (drawLine.y - renderInfo.offsetY + offset), (drawLine.w + hlPaddingRight + hlPaddingLeft), hlHeight);
            }
        }

        // Text shadow.
        let prevShadowSettings = null;
        if (this._settings.shadow) {
            prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];

            this._context.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.shadowColor);
            this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
            this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
            this._context.shadowBlur = this._settings.shadowBlur * precision;
        }

        this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor);
        for (let i = 0, n = drawLines.length; i < n; i++) {
            let drawLine = drawLines[i];

            if (renderInfo.letterSpacing === 0) {
                this._context.fillText(drawLine.text, drawLine.x, drawLine.y);
            } else {
                const textSplit = drawLine.text.split('');
                let x = drawLine.x;
                for (let i = 0, j = textSplit.length; i < j; i++) {
                    this._context.fillText(textSplit[i], x, drawLine.y);
                    x += this.measureText(textSplit[i], renderInfo.letterSpacing);
                }
            }
        }

        if (prevShadowSettings) {
            this._context.shadowColor = prevShadowSettings[0];
            this._context.shadowOffsetX = prevShadowSettings[1];
            this._context.shadowOffsetY = prevShadowSettings[2];
            this._context.shadowBlur = prevShadowSettings[3];
        }

        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
        }

        this.renderInfo = renderInfo;
    };

    wrapWord(word, wordWrapWidth, suffix) {
        const suffixWidth = this._context.measureText(suffix).width;
        const wordLen = word.length
        const wordWidth = this._context.measureText(word).width;

        /* If word fits wrapWidth, do nothing */
        if (wordWidth <= wordWrapWidth) {
            return word;
        }

        /* Make initial guess for text cuttoff */
        let cutoffIndex = Math.floor((wordWrapWidth * wordLen) / wordWidth);
        let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > wordWrapWidth) {
            while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -=1;
                    break;
                }
            }
        }

        /* If wrapWidth is too short to even contain suffix alone, return empty string */
        return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '');
    }

    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     */
    wrapText(text, wordWrapWidth, letterSpacing, indent = 0) {
        // Greedy wrapping algorithm that will wrap words as the line grows longer.
        // than its horizontal bounds.
        let lines = text.split(/\r?\n/g);
        let allLines = [];
        let realNewlines = [];
        for (let i = 0; i < lines.length; i++) {
            let resultLines = [];
            let result = '';
            let spaceLeft = wordWrapWidth - indent;
            let words = lines[i].split(' ');
            for (let j = 0; j < words.length; j++) {
                const wordWidth = this.measureText(words[j], letterSpacing);
                const wordWidthWithSpace = wordWidth + this.measureText(' ',letterSpacing);
                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                    // Skip printing the newline if it's the first word of the line that is.
                    // greater than the word wrap width.
                    if (j > 0) {
                        resultLines.push(result);
                        result = '';
                    }
                    result += words[j];
                    spaceLeft = wordWrapWidth - wordWidth - (j === 0 ? indent : 0);
                }
                else {
                    spaceLeft -= wordWidthWithSpace;
                    result += ' ' + words[j];
                }
            }

            resultLines.push(result);
            result = '';

            allLines = allLines.concat(resultLines);

            if (i < lines.length - 1) {
                realNewlines.push(allLines.length);
            }
        }

        return {l: allLines, n: realNewlines};
    };

    measureText(word, space = 0) {
        if (!space) {
            return this._context.measureText(word).width;
        }
        return word.split('').reduce((acc, char) => {
            return acc + this._context.measureText(char).width + space;
        }, 0);
    }
    
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs":
/*!*************************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/textures/TextTextureRendererAdvanced.mjs ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextTextureRendererAdvanced)
/* harmony export */ });
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class TextTextureRendererAdvanced {

    constructor(stage, canvas, settings) {
        this._stage = stage;
        this._canvas = canvas;
        this._context = this._canvas.getContext('2d');
        this._settings = settings;
    }

    getPrecision() {
        return this._settings.precision;
    };

    setFontProperties() {
        const font = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.getFontSetting(this) : this._getFontSetting();
        this._context.font = font;
        this._context.textBaseline = this._settings.textBaseline;
        return font;
    };

    _getFontSetting() {
        let ff = this._settings.fontFace;

        if (!Array.isArray(ff)) {
            ff = [ff];
        }

        let ffs = [];
        for (let i = 0, n = ff.length; i < n; i++) {
            if (ff[i] === "serif" || ff[i] === "sans-serif") {
                ffs.push(ff[i]);
            } else {
                ffs.push(`"${ff[i]}"`);
            }
        }

        return `${this._settings.fontStyle} ${this._settings.fontSize * this.getPrecision()}px ${ffs.join(",")}`
    }

    _load() {
        if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && document.fonts) {
            const fontSetting = this._getFontSetting();
            try {
                if (!document.fonts.check(fontSetting, this._settings.text)) {
                    // Use a promise that waits for loading.
                    return document.fonts.load(fontSetting, this._settings.text).catch(err => {
                        // Just load the fallback font.
                        console.warn('Font load error', err, fontSetting);
                    }).then(() => {
                        if (!document.fonts.check(fontSetting, this._settings.text)) {
                            console.warn('Font not found', fontSetting);
                        }
                    });
                }
            } catch(e) {
                console.warn("Can't check font loading for " + fontSetting);
            }
        }
    }

    draw() {
        // We do not use a promise so that loading is performed syncronous when possible.
        const loadPromise = this._load();
        if (!loadPromise) {
            return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
        } else {
            return loadPromise.then(() => {
                return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark ? this._stage.platform.drawText(this) : this._draw();
            });
        }
    }

    _calculateRenderInfo() {
        let renderInfo = {};

        const precision = this.getPrecision();

        const paddingLeft = this._settings.paddingLeft * precision;
        const paddingRight = this._settings.paddingRight * precision;
        const fontSize = this._settings.fontSize * precision;
        // const offsetY = this._settings.offsetY === null ? null : (this._settings.offsetY * precision);
        const lineHeight = this._settings.lineHeight * precision || fontSize;
        const w = this._settings.w != 0 ? this._settings.w * precision : 2048 / precision;
        // const h = this._settings.h * precision;
        const wordWrapWidth = this._settings.wordWrapWidth * precision;
        const cutSx = this._settings.cutSx * precision;
        const cutEx = this._settings.cutEx * precision;
        const cutSy = this._settings.cutSy * precision;
        const cutEy = this._settings.cutEy * precision;
        const letterSpacing = this._settings.letterSpacing || 0;

        // Set font properties.
        renderInfo.baseFont = this.setFontProperties();

        renderInfo.w = w;
        renderInfo.width = w;
        renderInfo.text = this._settings.text;
        renderInfo.precision = precision;
        renderInfo.fontSize = fontSize;
        renderInfo.lineHeight = lineHeight;
        renderInfo.letterSpacing = letterSpacing;
        renderInfo.textAlign = this._settings.textAlign;
        renderInfo.textColor = this._settings.textColor;
        renderInfo.verticalAlign = this._settings.verticalAlign;
        renderInfo.highlight = this._settings.highlight;
        renderInfo.highlightColor = this._settings.highlightColor;
        renderInfo.highlightHeight = this._settings.highlightHeight;
        renderInfo.highlightPaddingLeft = this._settings.highlightPaddingLeft;
        renderInfo.highlightPaddingRight = this._settings.highlightPaddingRight;
        renderInfo.highlightOffset = this._settings.highlightOffset;
        renderInfo.paddingLeft = this._settings.paddingLeft;
        renderInfo.paddingRight = this._settings.paddingRight;
        renderInfo.maxLines = this._settings.maxLines;
        renderInfo.maxLinesSuffix = this._settings.maxLinesSuffix;
        renderInfo.textOverflow = this._settings.textOverflow;
        renderInfo.wordWrap = this._settings.wordWrap;
        renderInfo.wordWrapWidth = wordWrapWidth;
        renderInfo.shadow = this._settings.shadow;
        renderInfo.shadowColor = this._settings.shadowColor;
        renderInfo.shadowOffsetX = this._settings.shadowOffsetX;
        renderInfo.shadowOffsetY = this._settings.shadowOffsetY;
        renderInfo.shadowBlur = this._settings.shadowBlur;
        renderInfo.cutSx = cutSx;
        renderInfo.cutEx = cutEx;
        renderInfo.cutSy = cutSy;
        renderInfo.cutEy = cutEy;
        renderInfo.textIndent = this._settings.textIndent * precision;
        renderInfo.wordBreak = this._settings.wordBreak;

        let text = renderInfo.text;
        let wrapWidth = renderInfo.wordWrap ? (renderInfo.wordWrapWidth || renderInfo.width) : renderInfo.width;

        // Text overflow
        if (renderInfo.textOverflow && !renderInfo.wordWrap) {
            let suffix;
            switch (this._settings.textOverflow) {
                case 'clip':
                    suffix = '';
                    break;
                case 'ellipsis':
                    suffix = this._settings.maxLinesSuffix;
                    break;
                default:
                    suffix = this._settings.textOverflow;
            }
            text = this.wrapWord(text, wordWrapWidth || renderInfo.w, suffix);
        }

        text = this.tokenize(text);
        text = this.parse(text);
        text = this.measure(text, letterSpacing, renderInfo.baseFont);

        if (renderInfo.textIndent) {
            text = this.indent(text, renderInfo.textIndent);
        }

        if (renderInfo.wordBreak) {
            text = text.reduce((acc, t) => acc.concat(this.wordBreak(t, wrapWidth, renderInfo.baseFont)), [])
            this.resetFontStyle()
        }

        // Calculate detailed drawing information
        let x = paddingLeft;
        let lineNo = 0;

        for (const t of text) {
            // Wrap text
            if (renderInfo.wordWrap && x + t.width > wrapWidth || t.text == '\n') {
                x = paddingLeft;
                lineNo += 1;
            }
            t.lineNo = lineNo;

            if (t.text == '\n') {
                continue;
            }

            t.x = x;
            x += t.width;
        }
        renderInfo.lineNum = lineNo + 1;

        // Vertical align
        let vaOffset = 0;
        if (renderInfo.verticalAlign == 'middle') {
            vaOffset += (renderInfo.lineHeight - renderInfo.fontSize) / 2;
        } else if (this._settings.verticalAlign == 'bottom') {
            vaOffset += renderInfo.lineHeight - renderInfo.fontSize;
        }

        // Calculate lines information
        renderInfo.lines = []
        for (let i = 0; i < renderInfo.lineNum; i++) {
            renderInfo.lines[i] = {
                width: 0,
                x: 0,
                y: renderInfo.lineHeight * i + vaOffset,
                text: [],
            }
        }

        for (let t of text) {
            renderInfo.lines[t.lineNo].text.push(t);
        }

        // Filter out white spaces at beginning and end of each line
        for (const l of renderInfo.lines) {
            if (l.text.length == 0) {
                continue;
            }

            const firstWord = l.text[0].text;
            const lastWord = l.text[l.text.length - 1].text;

            if (firstWord == '\n') {
                l.text.shift();
            }
            if (lastWord == ' ' || lastWord == '\n') {
                l.text.pop();
            }
        }


        // Calculate line width
        for (let l of renderInfo.lines) {
            l.width = l.text.reduce((acc, t) => acc + t.width, 0);
        }

        renderInfo.width = this._settings.w != 0 ? this._settings.w * precision : Math.max(...renderInfo.lines.map((l) => l.width)) + paddingRight;
        renderInfo.w = renderInfo.width;

        // Apply maxLinesSuffix
        if (renderInfo.maxLines && renderInfo.lineNum > renderInfo.maxLines && renderInfo.maxLinesSuffix) {
            const index = renderInfo.maxLines - 1;
            let lastLineText = text.filter((t) => t.lineNo == index)
            let suffix = renderInfo.maxLinesSuffix;
            suffix = this.tokenize(suffix);
            suffix = this.parse(suffix);
            suffix = this.measure(suffix, renderInfo.letterSpacing, renderInfo.baseFont)[0];
            suffix.lineNo = index;
            if (lastLineText.length) {
                suffix.x = lastLineText[lastLineText.length - 1].x + lastLineText[lastLineText.length - 1].width;
            } else {
                suffix.x = 0;
            }
            lastLineText.push(suffix)

            let _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
            while (_w > renderInfo.width || lastLineText[lastLineText.length - 2].text == ' ') {
                lastLineText.splice(lastLineText.length - 2, 1);
                _w = lastLineText.reduce((acc, t) => acc + t.width, 0);
                const prev = lastLineText[lastLineText.length - 2] || {x: 0, width: 0}
                suffix.x = prev.x + prev.width;
                if (lastLineText.length < 2) {
                    break;
                }
            }

            renderInfo.lines[index].text = lastLineText;
            renderInfo.lines[index].width = _w;
        }

        if (this._settings.h) {
            renderInfo.h = this._settings.h;
        } else if (renderInfo.maxLines && renderInfo.maxLines < renderInfo.lineNum) {
            renderInfo.h = renderInfo.maxLines * renderInfo.lineHeight + fontSize / 2;
        } else {
            renderInfo.h = renderInfo.lineNum * renderInfo.lineHeight + fontSize / 2;
        }

        // Horizontal alignment offset
        if (renderInfo.textAlign == 'center') {
            for (let l of renderInfo.lines) {
                l.x = (renderInfo.width - l.width - paddingLeft) / 2;
            }
        } else if (renderInfo.textAlign == 'right') {
            for (let l of renderInfo.lines) {
                l.x = renderInfo.width - l.width - paddingLeft;
            }
        }

        return renderInfo;
    }

    _draw() {
        const renderInfo = this._calculateRenderInfo();
        const precision = this.getPrecision();
        const paddingLeft = renderInfo.paddingLeft * precision;

        // Set canvas dimensions
        let canvasWidth = renderInfo.w || renderInfo.width;
        if (renderInfo.cutSx || renderInfo.cutEx) {
            canvasWidth = Math.min(renderInfo.w, renderInfo.cutEx - renderInfo.cutSx);
        }

        let canvasHeight = renderInfo.h;
        if (renderInfo.cutSy || renderInfo.cutEy) {
            canvasHeight = Math.min(renderInfo.h, renderInfo.cutEy - renderInfo.cutSy);
        }

        this._canvas.width = Math.ceil(canvasWidth + this._stage.getOption('textRenderIssueMargin'));
        this._canvas.height = Math.ceil(canvasHeight);

        // Canvas context has been reset.
        this.setFontProperties();

        if (renderInfo.fontSize >= 128) {
            // WpeWebKit bug: must force compositing because cairo-traps-compositor will not work with text first.
            this._context.globalAlpha = 0.01;
            this._context.fillRect(0, 0, 0.01, 0.01);
            this._context.globalAlpha = 1.0;
        }

        // Cut
        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(-renderInfo.cutSx, -renderInfo.cutSy);
        }

        // Highlight
        if (renderInfo.highlight) {
            const hlColor = renderInfo.highlightColor || 0x00000000;
            const hlHeight = renderInfo.highlightHeight ? renderInfo.highlightHeight * precision :  renderInfo.fontSize * 1.5;
            const hlOffset = renderInfo.highlightOffset ? renderInfo.highlightOffset * precision : 0;
            const hlPaddingLeft = (renderInfo.highlightPaddingLeft !== null ? renderInfo.highlightPaddingLeft * precision : renderInfo.paddingLeft);
            const hlPaddingRight = (renderInfo.highlightPaddingRight !== null ? renderInfo.highlightPaddingRight * precision : renderInfo.paddingRight);

            this._context.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(hlColor);
            const lineNum = renderInfo.maxLines ? Math.min(renderInfo.maxLines, renderInfo.lineNum) : renderInfo.lineNum; 
            for (let i = 0; i < lineNum; i++) {
                const l = renderInfo.lines[i];
                this._context.fillRect(l.x - hlPaddingLeft + paddingLeft, l.y + hlOffset, l.width + hlPaddingLeft + hlPaddingRight, hlHeight);
            }
        }

        // Text shadow.
        let prevShadowSettings = null;
        if (this._settings.shadow) {
            prevShadowSettings = [this._context.shadowColor, this._context.shadowOffsetX, this._context.shadowOffsetY, this._context.shadowBlur];

            this._context.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.shadowColor);
            this._context.shadowOffsetX = this._settings.shadowOffsetX * precision;
            this._context.shadowOffsetY = this._settings.shadowOffsetY * precision;
            this._context.shadowBlur = this._settings.shadowBlur * precision;
        }

        // Draw text
        const defaultColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor);
        let currentColor = defaultColor;
        this._context.fillStyle = defaultColor;
        for (const line of renderInfo.lines) {
            for (const t of line.text) {
                let lx = 0;

                if (t.text == '\n') {
                    continue;
                }

                if (renderInfo.maxLines && t.lineNo >= renderInfo.maxLines) {
                    continue;
                }

                if (t.color != currentColor) {
                    currentColor = t.color;
                    this._context.fillStyle = currentColor;
                }

                this._context.font = t.fontStyle;

                // Draw with letter spacing
                if (t.letters) {
                    for (let l of t.letters) {
                        const _x = renderInfo.lines[t.lineNo].x + t.x + lx;
                        this._context.fillText(l.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                        lx += l.width;
                    }
                // Standard drawing
                } else {
                    const _x = renderInfo.lines[t.lineNo].x + t.x;
                    this._context.fillText(t.text, _x, renderInfo.lines[t.lineNo].y + renderInfo.fontSize);
                }
            }
        }

        // Reset text shadow
        if (prevShadowSettings) {
            this._context.shadowColor = prevShadowSettings[0];
            this._context.shadowOffsetX = prevShadowSettings[1];
            this._context.shadowOffsetY = prevShadowSettings[2];
            this._context.shadowBlur = prevShadowSettings[3];
        }

        // Reset cut translation
        if (renderInfo.cutSx || renderInfo.cutSy) {
            this._context.translate(renderInfo.cutSx, renderInfo.cutSy);
        }
 
        // Postprocess renderInfo.lines to be compatible with standard version
        renderInfo.lines = renderInfo.lines.map((l) => l.text.reduce((acc, v) => acc + v.text, ''));
        if (renderInfo.maxLines) {
            renderInfo.lines = renderInfo.lines.slice(0, renderInfo.maxLines);
        }


        this.renderInfo = renderInfo;

    };

    measureText(word, space = 0) {
        if (!space) {
            return this._context.measureText(word).width;
        }
        return word.split('').reduce((acc, char) => {
            return acc + this._context.measureText(char).width + space;
        }, 0);
    }

    tokenize(text) {
        const re =/ |\n|<i>|<\/i>|<b>|<\/b>|<color=0[xX][0-9a-fA-F]{8}>|<\/color>/g
    
        const delimeters = text.match(re) || [];
        const words = text.split(re) || [];
    
        let final = [];
        for (let i = 0; i < words.length; i++) {
            final.push(words[i], delimeters[i])
        }
        final.pop()
        return final.filter((word) => word != '');
    
    }
    
    parse(tokens) {
        let italic = 0;
        let bold = 0;
        let colorStack = [_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(this._settings.textColor)];
        let color = 0;

        const colorRegexp = /<color=(?<color>0[xX][0-9a-fA-F]{8})/;
    
        return tokens.map((t) => {
            if (t == '<i>') {
                italic += 1;
                t = '';
            } else if (t == '</i>' && italic > 0) {
                italic -= 1;
                t = '';
            } else if (t == '<b>') {
                bold += 1;
                t = '';
            } else if (t == '</b>' && bold > 0) {
                bold -= 1;
                t = '';
            } else if (t == '</color>') {
                if (colorStack.length > 1) {
                    color -= 1;
                    colorStack.pop();
                }
                t = '';
            } else if (colorRegexp.test(t)) {
                colorStack.push(_tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].getRgbaString(parseInt(colorRegexp.exec(t).groups['color'])));
                color += 1;
                t = '';
            }

            return {
                text: t,
                italic: italic,
                bold: bold,
                color: colorStack[color],
            }
        })
        .filter((o) => o.text != '');
    }

    applyFontStyle(word, baseFont) {
        let font = baseFont;
        if (word.bold) {
            font = 'bold ' + font;
        }
        if (word.italic) {
            font = 'italic ' + font;
        }
        this._context.font = font
        word.fontStyle = font;
    }

    resetFontStyle(baseFont) {
        this._context.font = baseFont;
    }

    measure(parsed, letterSpacing = 0, baseFont) {
        for (const p of parsed) {
            this.applyFontStyle(p, baseFont);
            p.width = this.measureText(p.text, letterSpacing);

            // Letter by letter detail for letter spacing
            if (letterSpacing > 0) {
                p.letters = p.text.split('').map((l) => {return {text: l}});
                for (let l of p.letters) {
                    l.width = this.measureText(l.text, letterSpacing);
                }
            }

        }
        this.resetFontStyle(baseFont);
        return parsed;
    }

    indent(parsed, textIndent) {
        parsed.splice(0, 0, {text: "", width: textIndent});
        return parsed;
    }

    wrapWord(word, wordWrapWidth, suffix) {
        const suffixWidth = this._context.measureText(suffix).width;
        const wordLen = word.length
        const wordWidth = this._context.measureText(word).width;

        /* If word fits wrapWidth, do nothing */
        if (wordWidth <= wordWrapWidth) {
            return word;
        }

        /* Make initial guess for text cuttoff */
        let cutoffIndex = Math.floor((wordWrapWidth * wordLen) / wordWidth);
        let truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > wordWrapWidth) {
            while (cutoffIndex > 0) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth > wordWrapWidth) {
                    cutoffIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (cutoffIndex < wordLen) {
                truncWordWidth = this._context.measureText(word.substring(0, cutoffIndex)).width + suffixWidth;
                if (truncWordWidth < wordWrapWidth) {
                    cutoffIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    cutoffIndex -=1;
                    break;
                }
            }
        }

        /* If wrapWidth is too short to even contain suffix alone, return empty string */
        return word.substring(0, cutoffIndex) + (wordWrapWidth >= suffixWidth ? suffix : '')
    }

    _getBreakIndex(word, width) {
        const wordLen = word.length;
        const wordWidth = this.measureText(word);

        if (wordWidth <= width) {
            return {breakIndex: word.length, truncWordWidth: wordWidth};
        }

        let breakIndex = Math.floor((width * wordLen) / wordWidth);
        let truncWordWidth = this.measureText(word.substring(0, breakIndex))

        /* In case guess was overestimated, shrink it letter by letter. */
        if (truncWordWidth > width) {
            while (breakIndex > 0) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth > width) {
                    breakIndex -= 1;
                } else {
                    break;
                }
            }

        /* In case guess was underestimated, extend it letter by letter. */
        } else {
            while (breakIndex < wordLen) {
                truncWordWidth = this.measureText(word.substring(0, breakIndex));
                if (truncWordWidth < width) {
                    breakIndex += 1;
                } else {
                    // Finally, when bound is crossed, retract last letter.
                    breakIndex -=1;
                    truncWordWidth = this.measureText(word.substring(0, breakIndex));
                    break;
                }
            }
        }
        return {breakIndex, truncWordWidth};

    }

    wordBreak(word, width, baseFont) {
        if (!word.text) {
            return word
        }
        this.applyFontStyle(word, baseFont)
        const parts = [];
        let text = word.text;
        if (!word.letters) {
            while (true) {
                const {breakIndex, truncWordWidth} = this._getBreakIndex(text, width);
                parts.push({...word});
                parts[parts.length - 1].text = text.slice(0, breakIndex);
                parts[parts.length - 1].width = truncWordWidth;

                if (breakIndex === text.length) {
                    break;
                }

                text = text.slice(breakIndex);
            }
        } else {
            let totalWidth = 0;
            let letters = [];
            let breakIndex = 0;
            for (const l of word.letters) {
                if (totalWidth + l.width >= width) {
                    parts.push({...word});
                    parts[parts.length - 1].text = text.slice(0, breakIndex);
                    parts[parts.length - 1].width = totalWidth;
                    parts[parts.length - 1].letters = letters;
                    text = text.slice(breakIndex);
                    totalWidth = 0;
                    letters = [];
                    breakIndex = 0;

                } else {
                    breakIndex += 1;
                    letters.push(l);
                    totalWidth += l.width;
                }
            }

            if (totalWidth > 0) {
                parts.push({...word});
                parts[parts.length - 1].text = text.slice(0, breakIndex);
                parts[parts.length - 1].width = totalWidth;
                parts[parts.length - 1].letters = letters;
            }
        }

        return parts;
    }
}

/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/MultiSpline.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MultiSpline)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class MultiSpline {

    constructor() {
        this._clear();
    }

    _clear() {
        this._p = [];
        this._pe = [];
        this._idp = [];
        this._f = [];
        this._v = [];
        this._lv = [];
        this._sm = [];
        this._s = [];
        this._ve = [];
        this._sme = [];
        this._se = [];

        this._length = 0;
    }

    parse(rgba, def) {
        let i, n;
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(def)) {
            def = {0: def}
        }

        let defaultSmoothness = 0.5;

        let items = [];
        for (let key in def) {
            if (def.hasOwnProperty(key)) {
                let obj = def[key];
                if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(obj)) {
                    obj = {v: obj}
                }

                let p = parseFloat(key);

                if (key === "sm") {
                    defaultSmoothness = obj.v;
                } else if (!isNaN(p) && p >= 0 && p <= 2) {
                    obj.p = p;

                    obj.f = _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(obj.v);
                    obj.lv = obj.f ? obj.v(0, 0) : obj.v;

                    items.push(obj);
                }
            }
        }

        // Sort by progress value.
        items = items.sort(function(a, b) {return a.p - b.p});

        n = items.length;

        for (i = 0; i < n; i++) {
            let last = (i === n - 1);
            if (!items[i].hasOwnProperty('pe')) {
                // Progress.
                items[i].pe = last ? (items[i].p <= 1 ? 1 : 2 /* support onetotwo stop */) : items[i + 1].p;
            } else {
                // Prevent multiple items at the same time.
                const max = i < n - 1 ? items[i + 1].p : 1;
                if (items[i].pe > max) {
                    items[i].pe = max;
                }
            }
            if (items[i].pe === items[i].p) {
                items[i].idp = 0;
            } else {
                items[i].idp = 1 / (items[i].pe - items[i].p);
            }
        }

        // Color merger: we need to split/combine RGBA components.

        // Calculate bezier helper values.;
        for (i = 0; i < n; i++) {
            if (!items[i].hasOwnProperty('sm')) {
                // Smoothness.;
                items[i].sm = defaultSmoothness;
            }
            if (!items[i].hasOwnProperty('s')) {
                // Slope.;
                if (i === 0 || i === n - 1 || (items[i].p === 1 /* for onetotwo */)) {
                    // Horizontal slope at start and end.;
                    items[i].s = rgba ? [0, 0, 0, 0] : 0;
                } else {
                    const pi = items[i - 1];
                    const ni = items[i + 1];
                    if (pi.p === ni.p) {
                        items[i].s = rgba ? [0, 0, 0, 0] : 0;
                    } else {
                        if (rgba) {
                            const nc = MultiSpline.getRgbaComponents(ni.lv);
                            const pc = MultiSpline.getRgbaComponents(pi.lv);
                            const d = 1 / (ni.p - pi.p);
                            items[i].s = [
                                d * (nc[0] - pc[0]),
                                d * (nc[1] - pc[1]),
                                d * (nc[2] - pc[2]),
                                d * (nc[3] - pc[3])
                            ];
                        } else {
                            items[i].s = (ni.lv - pi.lv) / (ni.p - pi.p);
                        }
                    }
                }
            }
        }

        for (i = 0; i < n - 1; i++) {
            // Calculate value function.;
            if (!items[i].f) {

                let last = (i === n - 1);
                if (!items[i].hasOwnProperty('ve')) {
                    items[i].ve = last ? items[i].lv : items[i + 1].lv;
                }

                // We can only interpolate on numeric values. Non-numeric values are set literally when reached time.
                if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(items[i].v) && _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(items[i].lv)) {
                    if (!items[i].hasOwnProperty('sme')) {
                        items[i].sme = last ? defaultSmoothness : items[i + 1].sm;
                    }
                    if (!items[i].hasOwnProperty('se')) {
                        items[i].se = last ? (rgba ? [0, 0, 0, 0] : 0) : items[i + 1].s;
                    }

                    // Generate spline.;
                    if (rgba) {
                        items[i].v = MultiSpline.getSplineRgbaValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                    } else {
                        items[i].v = MultiSpline.getSplineValueFunction(items[i].v, items[i].ve, items[i].p, items[i].pe, items[i].sm, items[i].sme, items[i].s, items[i].se);
                    }

                    items[i].f = true;
                }
            }
        }

        if (this.length) {
            this._clear();
        }

        for (i = 0, n = items.length; i < n; i++) {
            this._add(items[i]);
        }
    }

    _add(item) {
        this._p.push(item.p || 0);
        this._pe.push(item.pe || 0);
        this._idp.push(item.idp || 0);
        this._f.push(item.f || false);
        this._v.push(item.hasOwnProperty('v') ? item.v : 0 /* v might be false or null */ );
        this._lv.push(item.lv || 0);
        this._sm.push(item.sm || 0);
        this._s.push(item.s || 0);
        this._ve.push(item.ve || 0);
        this._sme.push(item.sme || 0);
        this._se.push(item.se || 0);
        this._length++;
    }

    _getItem(p) {
        const n = this._length;
        if (!n) {
            return -1;
        }

        if (p < this._p[0]) {
            return 0;
        }

        for (let i = 0; i < n; i++) {
            if (this._p[i] <= p && p < this._pe[i]) {
                return i;
            }
        }

        return n - 1;
    }

    getValue(p) {
        const i = this._getItem(p);
        if (i === -1) {
            return undefined;
        } else {
            if (this._f[i]) {
                const o = Math.min(1, Math.max(0, (p - this._p[i]) * this._idp[i]));
                return this._v[i](o);
            } else {
                return this._v[i];
            }
        }
    }

    get length() {
        return this._length;
    }

    static getRgbaComponents(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r, g, b, a];
    };

    static getSplineValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
        // Normalize slopes because we use a spline that goes from 0 to 1.
        let dp = p2 - p1;
        s1 *= dp;
        s2 *= dp;

        let helpers = MultiSpline.getSplineHelpers(v1, v2, o1, i2, s1, s2);
        if (!helpers) {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;

                return v2 * p + v1 * (1 - p);
            };
        } else {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;
                return MultiSpline.calculateSpline(helpers, p);
            };
        }
    };

    static getSplineRgbaValueFunction(v1, v2, p1, p2, o1, i2, s1, s2) {
        // Normalize slopes because we use a spline that goes from 0 to 1.
        let dp = p2 - p1;
        s1[0] *= dp;
        s1[1] *= dp;
        s1[2] *= dp;
        s1[3] *= dp;
        s2[0] *= dp;
        s2[1] *= dp;
        s2[2] *= dp;
        s2[3] *= dp;

        let cv1 = MultiSpline.getRgbaComponents(v1);
        let cv2 = MultiSpline.getRgbaComponents(v2);

        let helpers = [
            MultiSpline.getSplineHelpers(cv1[0], cv2[0], o1, i2, s1[0], s2[0]),
            MultiSpline.getSplineHelpers(cv1[1], cv2[1], o1, i2, s1[1], s2[1]),
            MultiSpline.getSplineHelpers(cv1[2], cv2[2], o1, i2, s1[2], s2[2]),
            MultiSpline.getSplineHelpers(cv1[3], cv2[3], o1, i2, s1[3], s2[3])
        ];

        if (!helpers[0]) {
            return function (p) {
                // Linear.
                if (p === 0) return v1;
                if (p === 1) return v2;

                return MultiSpline.mergeColors(v2, v1, p);
            };
        } else {
            return function (p) {
                if (p === 0) return v1;
                if (p === 1) return v2;

                return MultiSpline.getArgbNumber([
                    Math.min(255, MultiSpline.calculateSpline(helpers[0], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[1], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[2], p)),
                    Math.min(255, MultiSpline.calculateSpline(helpers[3], p))
                ]);
            };
        }

    };

    /**
     * Creates helpers to be used in the spline function.
     * @param {number} v1
     *   From value.
     * @param {number} v2
     *   To value.
     * @param {number} o1
     *   From smoothness (0 = linear, 1 = smooth).
     * @param {number} s1
     *   From slope (0 = horizontal, infinite = vertical).
     * @param {number} i2
     *   To smoothness.
     * @param {number} s2
     *   To slope.
     * @returns {Number[]}
     *   The helper values to be supplied to the spline function.
     *   If the configuration is actually linear, null is returned.
     */
    static getSplineHelpers(v1, v2, o1, i2, s1, s2) {
        if (!o1 && !i2) {
            // Linear.
            return null;
        }

        // Cubic bezier points.
        // http://cubic-bezier.com/
        let csx = o1;
        let csy = v1 + s1 * o1;
        let cex = 1 - i2;
        let cey = v2 - s2 * i2;

        let xa = 3 * csx - 3 * cex + 1;
        let xb = -6 * csx + 3 * cex;
        let xc = 3 * csx;

        let ya = 3 * csy - 3 * cey + v2 - v1;
        let yb = 3 * (cey + v1) - 6 * csy;
        let yc = 3 * (csy - v1);
        let yd = v1;

        return [xa, xb, xc, ya, yb, yc, yd];
    };

    /**
     * Calculates the intermediate spline value based on the specified helpers.
     * @param {number[]} helpers
     *   Obtained from getSplineHelpers.
     * @param {number} p
     * @return {number}
     */
    static calculateSpline(helpers, p) {
        let xa = helpers[0];
        let xb = helpers[1];
        let xc = helpers[2];
        let ya = helpers[3];
        let yb = helpers[4];
        let yc = helpers[5];
        let yd = helpers[6];

        if (xa === -2 && ya === -2 && xc === 0 && yc === 0) {
            // Linear.
            return p;
        }

        // Find t for p.
        let t = 0.5, cbx, dx;

        for (let it = 0; it < 20; it++) {
            // Cubic bezier function: f(t)=t*(t*(t*a+b)+c).
            cbx = t * (t * (t * xa + xb) + xc);

            dx = p - cbx;
            if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
            }

            // Cubic bezier derivative function: f'(t)=t*(t*(3*a)+2*b)+c
            let cbxd = t * (t * (3 * xa) + 2 * xb) + xc;

            if (cbxd > 1e-10 && cbxd < 1e-10) {
                // Problematic. Fall back to binary search method.
                break;
            }

            t += dx / cbxd;
        }

        // Fallback: binary search method. This is more reliable when there are near-0 slopes.
        let minT = 0;
        let maxT = 1;
        for (let it = 0; it < 20; it++) {
            t = 0.5 * (minT + maxT);

            // Cubic bezier function: f(t)=t*(t*(t*a+b)+c)+d.
            cbx = t * (t * (t * xa + xb) + xc);

            dx = p - cbx;
            if (dx > -1e-8 && dx < 1e-8) {
                // Solution found!
                return t * (t * (t * ya + yb) + yc) + yd;
            }

            if (dx < 0) {
                maxT = t;
            } else {
                minT = t;
            }
        }

        return t;
    };

    static mergeColors(c1, c2, p) {
        let r1 = ((c1 / 65536) | 0) % 256;
        let g1 = ((c1 / 256) | 0) % 256;
        let b1 = c1 % 256;
        let a1 = ((c1 / 16777216) | 0);

        let r2 = ((c2 / 65536) | 0) % 256;
        let g2 = ((c2 / 256) | 0) % 256;
        let b2 = c2 % 256;
        let a2 = ((c2 / 16777216) | 0);

        let r = r1 * p + r2 * (1 - p);
        let g = g1 * p + g2 * (1 - p);
        let b = b1 * p + b2 * (1 - p);
        let a = a1 * p + a2 * (1 - p);

        return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
    };

    static getArgbNumber(rgba) {
        rgba[0] = Math.max(0, Math.min(255, rgba[0]));
        rgba[1] = Math.max(0, Math.min(255, rgba[1]));
        rgba[2] = Math.max(0, Math.min(255, rgba[2]));
        rgba[3] = Math.max(0, Math.min(255, rgba[3]));
        let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
        if (v < 0) {
            v = 0xFFFFFFFF + v + 1;
        }
        return v;
    };
}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjMerger.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjMerger)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ObjMerger {

    static isMf(f) {
        return _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(f) && f.__mf;
    }

    static mf(f) {
        // Set as merge function.
        f.__mf = true;
        return f;
    }

    static merge(a, b) {
        const aks = Object.keys(a);
        const bks = Object.keys(b);

        if (!bks.length) {
            return a;
        }

        // Create index array for all elements.
        const ai = {};
        const bi = {};
        for (let i = 0, n = bks.length; i < n; i++) {
            const key = bks[i];
            ai[key] = -1;
            bi[key] = i;
        }
        for (let i = 0, n = aks.length; i < n; i++) {
            const key = aks[i];
            ai[key] = i;
            if (bi[key] === undefined) {
                bi[key] = -1;
            }
        }

        const aksl = aks.length;

        const result = {};
        for (let i = 0, n = bks.length; i < n; i++) {
            const key = bks[i];

            // Prepend all items in a that are not in b - before the now added b attribute.
            const aIndex = ai[key];
            let curIndex = aIndex;
            while(--curIndex >= 0) {
                const akey = aks[curIndex];
                if (bi[akey] !== -1) {
                    // Already found? Stop processing.
                    // Not yet found but exists in b? Also stop processing: wait until we find it in b.
                    break;
                }
            }
            while(++curIndex < aIndex) {
                const akey = aks[curIndex];
                result[akey] = a[akey];
            }

            const bv = b[key];
            const av = a[key];
            let r;
            if (this.isMf(bv)) {
                r = bv(av);
            } else {
                if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(av) || !_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(bv)) {
                    r = bv;
                } else {
                    r = ObjMerger.merge(av, bv);
                }
            }

            // When marked as undefined, property is deleted.
            if (r !== undefined) {
                result[key] = r;
            }
        }

        // Append remaining final items in a.
        let curIndex = aksl;
        while(--curIndex >= 0) {
            const akey = aks[curIndex];
            if (bi[akey] !== -1) {
                break;
            }
        }
        while(++curIndex < aksl) {
            const akey = aks[curIndex];
            result[akey] = a[akey];
        }

        return result;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectListProxy)
/* harmony export */ });
/* harmony import */ var _tree_ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/ObjectList.mjs */ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ObjectListProxy extends _tree_ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(target) {
        super();
        this._target = target;
    }

    onAdd(item, index) {
        this._target.addAt(item, index);
    }

    onRemove(item, index) {
        this._target.removeAt(index);
    }

    onSync(removed, added, order) {
        this._target._setByArray(order);
    }

    onSet(item, index) {
        this._target.setAt(item, index);
    }

    onMove(item, fromIndex, toIndex) {
        this._target.setAt(item, toIndex);
    }

    createItem(object) {
        return this._target.createItem(object);
    }

    isItem(object) {
        return this._target.isItem(object);
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/ObjectListWrapper.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectListWrapper)
/* harmony export */ });
/* harmony import */ var _ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectListProxy.mjs */ "./node_modules/@lightningjs/core/src/tools/ObjectListProxy.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ObjectListWrapper extends _ObjectListProxy_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(target, wrap) {
        super(target);
        this._wrap = wrap;
    }

    wrap(item) {
        let wrapper = this._wrap(item);
        item._wrapper = wrapper;
        return wrapper;
    }

    onAdd(item, index) {
        item = this.wrap(item);
        super.onAdd(item, index);
    }

    onRemove(item, index) {
        super.onRemove(item, index);
    }

    onSync(removed, added, order) {
        added.forEach(a => this.wrap(a));
        order = order.map(a => a._wrapper);
        super.onSync(removed, added, order);
    }

    onSet(item, index) {
        item = this.wrap(item);
        super.onSet(item, index);
    }

    onMove(item, fromIndex, toIndex) {
        super.onMove(item, fromIndex, toIndex);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/Tools.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/Tools.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tools)
/* harmony export */ });
/* harmony import */ var _tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../tree/Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../tree/StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/StaticCanvasTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/StaticCanvasTexture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





class Tools {

    static getCanvasTexture(canvasFactory, lookupId) {
        return {type: _textures_StaticCanvasTexture_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], content: {factory: canvasFactory, lookupId: lookupId}}
    }

    static getRoundRect(w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
        if (!Array.isArray(radius)){
            // upper-left, upper-right, bottom-right, bottom-left.
            radius = [radius, radius, radius, radius];
        }

        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createRoundRect(cb, stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor);
            } else {
                cb(null, this.createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor));
            }
        };
        let id = 'rect' + [w, h, strokeWidth, strokeColor, fill ? 1 : 0, fillColor].concat(radius).join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createRoundRect(stage, w, h, radius, strokeWidth, strokeColor, fill, fillColor) {
        if (fill === undefined) fill = true;
        if (strokeWidth === undefined) strokeWidth = 0;

        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        canvas.width = w + strokeWidth + 2;
        canvas.height = h + strokeWidth + 2;

        ctx.beginPath();
        let x = 0.5 * strokeWidth + 1, y = 0.5 * strokeWidth + 1;

        ctx.moveTo(x + radius[0], y);
        ctx.lineTo(x + w - radius[1], y);
        ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
        ctx.lineTo(x + w, y + h - radius[2]);
        ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
        ctx.lineTo(x + radius[3], y + h);
        ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
        ctx.lineTo(x, y + radius[0]);
        ctx.arcTo(x, y, x + radius[0], y, radius[0]);
        ctx.closePath();

        if (fill) {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(fillColor)) {
                ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(fillColor);
            } else {
                ctx.fillStyle = "white";
            }
            ctx.fill();
        }

        if (strokeWidth) {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNumber(strokeColor)) {
                ctx.strokeStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(strokeColor);
            } else {
                ctx.strokeStyle = "white";
            }
            ctx.lineWidth = strokeWidth;
            ctx.stroke();
        }

        return canvas;
    }

    static getShadowRect(w, h, radius = 0, blur = 5, margin = blur * 2) {
        if (!Array.isArray(radius)){
            // upper-left, upper-right, bottom-right, bottom-left.
            radius = [radius, radius, radius, radius];
        }

        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createShadowRect(cb, stage, w, h, radius, blur, margin);
            } else {
                cb(null, this.createShadowRect(stage, w, h, radius, blur, margin));
            }
        };
        let id = 'shadow' + [w, h, blur, margin].concat(radius).join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createShadowRect(stage, w, h, radius, blur, margin) {
        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        canvas.width = w + margin * 2;
        canvas.height = h + margin * 2;

        // WpeWebKit bug: we experienced problems without this with shadows in noncompositedwebgl mode.
        ctx.globalAlpha = 0.01;
        ctx.fillRect(0, 0, 0.01, 0.01);
        ctx.globalAlpha = 1.0;

        ctx.shadowColor = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(0xFFFFFFFF);
        ctx.fillStyle = _tree_StageUtils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].getRgbaString(0xFFFFFFFF);
        ctx.shadowBlur = blur;
        ctx.shadowOffsetX = (w + 10) + margin;
        ctx.shadowOffsetY = margin;

        ctx.beginPath();
        const x = -(w + 10);
        const y = 0;

        ctx.moveTo(x + radius[0], y);
        ctx.lineTo(x + w - radius[1], y);
        ctx.arcTo(x + w, y, x + w, y + radius[1], radius[1]);
        ctx.lineTo(x + w, y + h - radius[2]);
        ctx.arcTo(x + w, y + h, x + w - radius[2], y + h, radius[2]);
        ctx.lineTo(x + radius[3], y + h);
        ctx.arcTo(x, y + h, x, y + h - radius[3], radius[3]);
        ctx.lineTo(x, y + radius[0]);
        ctx.arcTo(x, y, x + radius[0], y, radius[0]);
        ctx.closePath();
        ctx.fill();

        return canvas;
    }

    static getSvgTexture(url, w, h) {
        let factory = (cb, stage) => {
            if (_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isSpark) {
                stage.platform.createSvg(cb, stage, url, w, h);
            } else {
                this.createSvg(cb, stage, url, w, h);
            }
        };
        let id = 'svg' + [w, h, url].join(",");
        return Tools.getCanvasTexture(factory, id);
    }

    static createSvg(cb, stage, url, w, h) {
        let canvas = stage.platform.getDrawingCanvas();
        let ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = true;

        let img = new Image();
        img.onload = () => {
            canvas.width = w;
            canvas.height = h;
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            cb(null, canvas);
        }
        img.onError = (err) => {
            cb(err);
        }

        // On the PS4 platform setting the `crossOrigin` attribute on images
        // can cause CORS failures.
        if (!_tree_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isPS4) {
            img.crossOrigin = "Anonymous";
        }

        img.src = url;
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Utils {

    static isFunction(value) {
        return typeof value === 'function';
    }

    static isNumber(value) {
        return typeof value === 'number';
    }

    static isInteger(value) {
        return (typeof value === 'number' && (value % 1) === 0);
    }

    static isBoolean(value) {
        return value === true || value === false;
    }

    static isString(value) {
        return typeof value == 'string';
    }

    static isObject(value) {
        let type = typeof value;
        return !!value && (type == 'object' || type == 'function');
    }

    static isPlainObject(value) {
        let type = typeof value;
        return !!value && (type == 'object');
    }

    static isObjectLiteral(value){
        return typeof value === 'object' && value && value.constructor === Object
    }

    static getArrayIndex(index, arr) {
        return Utils.getModuloIndex(index, arr.length);
    }

    static equalValues(v1, v2) {
        if ((typeof v1) !== (typeof v2)) return false
        if (Utils.isObjectLiteral(v1)) {
            return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2)
        } else if (Array.isArray(v1)) {
            return Array.isArray(v2) && Utils.equalArrays(v1, v2)
        } else {
            return v1 === v2
        }
    }

    static equalObjectLiterals(obj1, obj2) {
        let keys1 = Object.keys(obj1);
        let keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false
        }

        for (let i = 0, n = keys1.length; i < n; i++) {
            const k1 = keys1[i];
            const k2 = keys2[i];
            if (k1 !== k2) {
                return false
            }

            const v1 = obj1[k1];
            const v2 = obj2[k2];

            if (!Utils.equalValues(v1, v2)) {
                return false
            }
        }

        return true;
    }

    static equalArrays(v1, v2) {
        if (v1.length !== v2.length) {
            return false
        }
        for (let i = 0, n = v1.length; i < n; i++) {
            if (!this.equalValues(v1[i], v2[i])) {
                return false
            }
        }

        return true
    }

}

/**
 * Maintains the state of a WebGLRenderingContext.
 */
class WebGLState {

    constructor(id, gl) {
        this._id = id;
        this._gl = gl;
        this._program = undefined;
        this._buffers = new Map();
        this._framebuffers = new Map();
        this._renderbuffers = new Map();

        // Contains vertex attribute definition arrays (enabled, size, type, normalized, stride, offset).
        this._vertexAttribs = new Array(16);
        this._nonDefaultFlags = new Set();
        this._settings = new Map();
        this._textures = new Array(8);
        this._maxTexture = 0;
        this._activeTexture = gl.TEXTURE0;
        this._pixelStorei = new Array(5);
    }

    _getDefaultFlag(cap) {
        return (cap === this._gl.DITHER);
    }

    setFlag(cap, v) {
        const def = this._getDefaultFlag(cap);
        if (v === def) {
            return this._nonDefaultFlags.delete(cap);
        } else {
            if (!this._nonDefaultFlags.has(cap)) {
                this._nonDefaultFlags.add(cap);
                return true;
            } else {
                return false;
            }
        }
    }

    setBuffer(target, buffer) {
        const change = this._buffers.get(target) !== buffer;
        this._buffers.set(target, buffer);

        if (change && (target === this._gl.ARRAY_BUFFER)) {
            // When the array buffer is changed all attributes are cleared.
            this._vertexAttribs = [];
        }

        return change;
    }

    setFramebuffer(target, buffer) {
        const change = this._framebuffers.get(target) !== buffer;
        this._framebuffers.set(target, buffer);
        return change;
    }

    setRenderbuffer(target, buffer) {
        const change = this._renderbuffers.get(target) !== buffer;
        this._renderbuffers.set(target, buffer);
        return change;
    }

    setProgram(program) {
        const change = this._program !== program;
        this._program = program;
        return change
    }

    setSetting(func, v) {
        const s = this._settings.get(func);
        const change = !s || !Utils.equalValues(s, v);
        this._settings.set(func, v);
        return change
    }

    disableVertexAttribArray(index) {
        const va = this._vertexAttribs[index];
        if (va && va[5]) {
            va[5] = false;
            return true;
        }
        return false;
    }

    enableVertexAttribArray(index) {
        const va = this._vertexAttribs[index];
        if (va) {
            if (!va[0]) {
                va[0] = true;
                return true;
            }
        } else {
            this._vertexAttribs[index] = [0, 0, 0, 0, 0, true];
            return true;
        }
        return false;
    }

    vertexAttribPointer(index, props) {
        let va = this._vertexAttribs[index];
        let equal = false;
        if (va) {
            equal = va[0] === props[0] &&
                va[1] === props[1] &&
                va[2] === props[2] &&
                va[3] === props[3] &&
                va[4] === props[4];
        }

        if (equal) {
            return false;
        } else {
            props[5] = va ? va[5] : false;
            return true;
        }
    }

    setActiveTexture(texture) {
        const changed = this._activeTexture !== texture;
        this._activeTexture = texture;
        return changed;
    }

    bindTexture(target, texture) {
        const activeIndex = WebGLState._getTextureIndex(this._activeTexture);
        this._maxTexture = Math.max(this._maxTexture, activeIndex + 1);
        const current = this._textures[activeIndex];
        const targetIndex = WebGLState._getTextureTargetIndex(target);
        if (current) {
            if (current[targetIndex] === texture) {
                return false;
            }
            current[targetIndex] = texture;
            return true;
        } else {
            if (texture) {
                this._textures[activeIndex] = [];
                this._textures[activeIndex][targetIndex] = texture;
                return true
            } else {
                return false
            }
        }
    }

    setPixelStorei(pname, param) {
        const i = WebGLState._getPixelStoreiIndex(pname);
        const change = !Utils.equalValues(this._pixelStorei[i], param);
        this._pixelStorei[i] = param;
        return change;
    }

    migrate(s) {
        const t = this;

        // Warning: migrate should call the original prototype methods directly.

        this._migrateFlags(t, s);

        // useProgram
        if (s._program !== t._program) {
            this._gl._useProgram(s._program);
        }

        this._migrateFramebuffers(t, s);
        this._migrateRenderbuffers(t, s);

        const buffersChanged = this._migrateBuffers(t, s);
        this._migrateAttributes(t, s, buffersChanged);

        this._migrateFlags(t, s);

        this._migrateSettings(t, s);

        this._migratePixelStorei(t, s);
        
        this._migrateTextures(t, s);
        
    }

    _migratePixelStorei(t, s) {
        for (let i = 0, n = t._pixelStorei.length; i < n; i++) {
            if (t._pixelStorei[i] !== s._pixelStorei[i]) {
                const value = s._pixelStorei[i] !== undefined ? s._pixelStorei[i] : WebGLState._getDefaultPixelStoreiByIndex(i);
                this._gl._pixelStorei(WebGLState._getPixelStoreiByIndex(i), value);
            }
        }
    }

    _migrateTextures(t, s) {
        const max = Math.max(t._maxTexture, s._maxTexture);

        let activeTexture = t._activeTexture;

        for (let i = 0; i < max; i++) {
            const sTargets = s._textures[i];
            const tTargets = t._textures[i];
            const textureNumb = WebGLState._getTextureByIndex(i);

            const targetMax = Math.max(tTargets ? tTargets.length : 0, sTargets ? sTargets.length : 0);
            for (let j = 0, n = targetMax; j < n; j++) {
                const target = WebGLState._getTextureTargetByIndex(j);
                if (activeTexture !== textureNumb) {
                    this._gl._activeTexture(textureNumb);
                    activeTexture = textureNumb;
                }

                const texture = (sTargets && sTargets[j]) || null;
                this._gl._bindTexture(target, texture);
            }
        }

        if (s._activeTexture !== activeTexture) {
            this._gl._activeTexture(s._activeTexture);
        }
    }

    _migrateBuffers(t, s) {
        s._buffers.forEach((framebuffer, target) => {
            if (t._buffers.get(target) !== framebuffer) {
                this._gl._bindBuffer(target, framebuffer);
            }
        });

        t._buffers.forEach((buffer, target) => {
            const b = s._buffers.get(target);
            if (b === undefined) {
                this._gl._bindBuffer(target, null);
            }
        });
        return (s._buffers.get(this._gl.ARRAY_BUFFER) !== t._buffers.get(this._gl.ARRAY_BUFFER))
    }

    _migrateFramebuffers(t, s) {
        s._framebuffers.forEach((framebuffer, target) => {
            if (t._framebuffers.get(target) !== framebuffer) {
                this._gl._bindFramebuffer(target, framebuffer);
            }
        });

        t._framebuffers.forEach((framebuffer, target) => {
            const fb = s._framebuffers.get(target);
            if (fb === undefined) {
                this._gl._bindFramebuffer(target, null);
            }
        });
    }

    _migrateRenderbuffers(t, s) {
        s._renderbuffers.forEach((renderbuffer, target) => {
            if (t._renderbuffers.get(target) !== renderbuffer) {
                this._gl._bindRenderbuffer(target, renderbuffer);
            }
        });

        t._renderbuffers.forEach((renderbuffer, target) => {
            const fb = s._renderbuffers.get(target);
            if (fb === undefined) {
                this._gl._bindRenderbuffer(target, null);
            }
        });
    }

    _migrateAttributes(t, s, buffersChanged) {

        if (!buffersChanged) {
            t._vertexAttribs.forEach((attrib, index) => {
                if (!s._vertexAttribs[index]) {
                    // We can't 'delete' a vertex attrib so we'll disable it.
                    this._gl._disableVertexAttribArray(index);
                }
            });

            s._vertexAttribs.forEach((attrib, index) => {
                this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[4]);
                if (attrib[5]) {
                    this._gl._enableVertexAttribArray(index);
                } else {
                    this._gl._disableVertexAttribArray(index);
                }
            });
        } else {
            // When buffers are changed, previous attributes were reset automatically.
            s._vertexAttribs.forEach((attrib, index) => {
                if (attrib[0]) {
                    // Do not set vertex attrib pointer when it was just the default value.
                    this._gl._vertexAttribPointer(index, attrib[0], attrib[1], attrib[2], attrib[3], attrib[4]);
                }
                if (attrib[5]) {
                    this._gl._enableVertexAttribArray(index);
                }
            });
        }
    }

    _migrateSettings(t, s) {
        const defaults = this.constructor.getDefaultSettings();
        t._settings.forEach((value, func) => {
            const name = func.name || func.xname;
            if (!s._settings.has(func)) {
                let args = defaults.get(name);
                if (Utils.isFunction(args)) {
                    args = args(this._gl);
                }
                // We are actually setting the setting for optimization purposes.
                s._settings.set(func, args);
                func.apply(this._gl, args);
            }
        });
        s._settings.forEach((value, func) => {
            const tValue = t._settings.get(func);
            if (!tValue || !Utils.equalValues(tValue, value)) {
                func.apply(this._gl, value);
            }
        });
    }

    _migrateFlags(t, s) {
        t._nonDefaultFlags.forEach(setting => {
            if (!s._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                    this._gl._enable(setting);
                } else {
                    this._gl._disable(setting);
                }
            }
        });
        s._nonDefaultFlags.forEach(setting => {
            if (!t._nonDefaultFlags.has(setting)) {
                if (this._getDefaultFlag(setting)) {
                    this._gl._disable(setting);
                } else {
                    this._gl._enable(setting);
                }
            }
        });
    }

    static getDefaultSettings() {
        if (!this._defaultSettings) {
            this._defaultSettings = new Map();
            const d = this._defaultSettings;
            const g = WebGLRenderingContext.prototype;
            d.set("viewport", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
            d.set("scissor", function(gl) {return [0,0,gl.canvas.width, gl.canvas.height]});
            d.set("blendColor", [0, 0, 0, 0]);
            d.set("blendEquation", [g.FUNC_ADD]);
            d.set("blendEquationSeparate", [g.FUNC_ADD, g.FUNC_ADD]);
            d.set("blendFunc", [g.ONE, g.ZERO]);
            d.set("blendFuncSeparate", [g.ONE, g.ZERO, g.ONE, g.ZERO]);
            d.set("clearColor", [0, 0, 0, 0]);
            d.set("clearDepth", [1]);
            d.set("clearStencil", [0]);
            d.set("colorMask", [true, true, true, true]);
            d.set("cullFace", [g.BACK]);
            d.set("depthFunc", [g.LESS]);
            d.set("depthMask", [true]);
            d.set("depthRange", [0, 1]);
            d.set("frontFace", [g.CCW]);
            d.set("lineWidth", [1]);
            d.set("polygonOffset", [0, 0]);
            d.set("sampleCoverage", [1, false]);
            d.set("stencilFunc", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateFront", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateBack", [g.ALWAYS, 0, 1]);
            d.set("_stencilFuncSeparateFrontAndBack", [g.ALWAYS, 0, 1]);
            d.set("stencilMask", [1]);
            d.set("_stencilMaskSeparateFront", [1]);
            d.set("_stencilMaskSeparateBack", [1]);
            d.set("_stencilMaskSeparateFrontAndBack", [1]);
            d.set("stencilOp", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateFront", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateBack", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("_stencilOpSeparateFrontAndBack", [g.KEEP, g.KEEP, g.KEEP]);
            d.set("vertexAttrib1f", []);
            d.set("vertexAttrib1fv", []);
            d.set("vertexAttrib2f", []);
            d.set("vertexAttrib2fv", []);
            d.set("vertexAttrib3f", []);
            d.set("vertexAttrib3fv", []);
            d.set("vertexAttrib4f", []);
            d.set("vertexAttrib4fv", []);
        }
        return this._defaultSettings
    }

    static _getTextureTargetIndex(target) {
        switch(target) {
            case 0x0DE1:
                /* TEXTURE_2D */
                return 0;
            case 0x8513:
                /* TEXTURE_CUBE_MAP */
                return 1;
            default:
                // Shouldn't happen.
                throw new Error('Unknown texture target: ' + target);
        }
    }

    static _getTextureTargetByIndex(index) {
        if (!this._textureTargetIndices) {
            this._textureTargetIndices = [0x0DE1, 0x8513];
        }
        return this._textureTargetIndices[index]
    }

    static _getTextureIndex(index) {
        return index - 0x84C0 /* GL_TEXTURE0 */;
    }

    static _getTextureByIndex(index) {
        return index + 0x84C0;
    }

    static _getPixelStoreiIndex(pname) {
        switch(pname) {
            case 0x0D05:
                /* PACK_ALIGNMENT */
                return 0;
            case 0x0CF5:
                /* UNPACK_ALIGNMENT */
                return 1;
            case 0x9240:
                /* UNPACK_FLIP_Y_WEBGL */
                return 2;
            case 0x9241:
                /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */
                return 3;
            case 0x9243:
                /* UNPACK_COLORSPACE_CONVERSION_WEBGL */
                return 4;
                //@todo: support WebGL2 properties, see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/pixelStorei
            case 0x9245:
                /* UNPACK_FLIP_BLUE_RED */
                return 5;
            default:
                // Shouldn't happen.
                throw new Error('Unknown pixelstorei: ' + pname);
        }
    }

    static _getPixelStoreiByIndex(index) {
        if (!this._pixelStoreiIndices) {
            this._pixelStoreiIndices = [0x0D05, 0x0CF5, 0x9240, 0x9241, 0x9243];
        }
        return this._pixelStoreiIndices[index]
    }

    static _getDefaultPixelStoreiByIndex(index) {
        if (!this._pixelStoreiDefaults) {
            this._pixelStoreiDefaults = [4, 4, false, false, WebGLRenderingContext.prototype.BROWSER_DEFAULT_WEBGL];
        }
        return this._pixelStoreiDefaults[index]
    }
}

class WebGLStateManager {

    _initStateManager(id = "default") {
        this._states = {};
        this._state = this._getState(id);
    }

    _getState(id) {
        if (!this._states[id]) {
            this._states[id] = new WebGLState(id, this);
        }
        return this._states[id];
    }

    switchState(id = "default") {
        if (this._state._id !== id) {
            const newState = this._getState(id);
            this._state.migrate(newState);
            this._state = newState;
        }
    }

    $useProgram(program) {
        if (this._state.setProgram(program))
            this._useProgram(program);
    }

    $bindBuffer(target, fb) {
        if (this._state.setBuffer(target, fb))
            this._bindBuffer(target, fb);
    }

    $bindFramebuffer(target, fb) {
        if (this._state.setFramebuffer(target, fb))
            this._bindFramebuffer(target, fb);
    }

    $bindRenderbuffer(target, fb) {
        if (this._state.setRenderbuffer(target, fb))
            this._bindRenderbuffer(target, fb);
    }

    $enable(cap) {
        if (this._state.setFlag(cap, true))
            this._enable(cap);
    }

    $disable(cap) {
        if (this._state.setFlag(cap, false))
            this._disable(cap);
    }

    $viewport(x, y, w, h) {
        if (this._state.setSetting(this._viewport, [x, y, w, h]))
            this._viewport(x, y, w, h);
    }

    $scissor(x, y, w, h) {
        if (this._state.setSetting(this._scissor, [x, y, w, h]))
            this._scissor(x, y, w, h);
    }

    $disableVertexAttribArray(index) {
        if (this._state.disableVertexAttribArray(index))
            this._disableVertexAttribArray(index);
    }

    $enableVertexAttribArray(index) {
        if (this._state.enableVertexAttribArray(index))
            this._enableVertexAttribArray(index);
    }

    $vertexAttribPointer(index, size, type, normalized, stride, offset) {
        if (this._state.vertexAttribPointer(index, [size, type, normalized, stride, offset]))
            this._vertexAttribPointer(index, size, type, normalized, stride, offset);
    }

    $activeTexture(texture) {
        if (this._state.setActiveTexture(texture))
            this._activeTexture(texture);
    }

    $bindTexture(target, texture) {
        if (this._state.bindTexture(target, texture))
            this._bindTexture(target, texture);
    }

    $pixelStorei(pname, param) {
        if (this._state.setPixelStorei(pname, param)) {
            this._pixelStorei(pname, param);
        }
    }

    $stencilFuncSeparate(face, func, ref, mask) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilFuncSeparateFront;
                break;
            case this.BACK:
                f = this._stencilFuncSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilFuncSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [func, ref, mask]))
            f.apply(this, [func, ref, mask]);
    }

    _stencilFuncSeparateFront(func, ref, mask) {
        this._stencilFuncSeparate(this.FRONT, func, ref, mask);
    }

    _stencilFuncSeparateBack(func, ref, mask) {
        this._stencilFuncSeparate(this.BACK, func, ref, mask);
    }

    _stencilFuncSeparateFrontAndBack(func, ref, mask) {
        this._stencilFuncSeparate(this.FRONT_AND_BACK, func, ref, mask);
    }

    $stencilMaskSeparate(face, mask) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilMaskSeparateFront;
                break;
            case this.BACK:
                f = this._stencilMaskSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilMaskSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [mask]))
            f.apply(this, [mask]);
    }

    _stencilMaskSeparateFront(mask) {
        this._stencilMaskSeparate(this.FRONT, mask);
    }

    _stencilMaskSeparateBack(mask) {
        this._stencilMaskSeparate(this.BACK, mask);
    }

    _stencilMaskSeparateFrontAndBack(mask) {
        this._stencilMaskSeparate(this.FRONT_AND_BACK, mask);
    }

    $stencilOpSeparate(face, fail, zfail, zpass) {
        let f;
        switch(face) {
            case this.FRONT:
                f = this._stencilOpSeparateFront;
                break;
            case this.BACK:
                f = this._stencilOpSeparateBack;
                break;
            case this.FRONT_AND_BACK:
                f = this._stencilOpSeparateFrontAndBack;
                break;
        }

        if (this._state.setSetting(f, [fail, zfail, zpass]))
            f.apply(this, [fail, zfail, zpass]);
    }

    _stencilOpSeparateFront(fail, zfail, zpass) {
        this._stencilOpSeparate(this.FRONT, fail, zfail, zpass);
    }

    _stencilOpSeparateBack(fail, zfail, zpass) {
        this._stencilOpSeparate(this.BACK, fail, zfail, zpass);
    }

    _stencilOpSeparateFrontAndBack(fail, zfail, zpass) {
        this._stencilOpSeparate(this.FRONT_AND_BACK, fail, zfail, zpass);
    }

    $blendColor(red, green, blue, alpha) {
        if (this._state.setSetting(this._blendColor, [red, green, blue, alpha]))
            this._blendColor(red, green, blue, alpha);
    }

    $blendEquation(mode) {
        if (this._state.setSetting(this._blendEquation, [mode]))
            this._blendEquation(mode);
    }

    $blendEquationSeparate(modeRGB, modeAlpha) {
        if (this._state.setSetting(this._blendEquationSeparate, [modeRGB, modeAlpha]))
            this._blendEquationSeparate(modeRGB, modeAlpha);
    }

    $blendFunc(sfactor, dfactor) {
        if (this._state.setSetting(this._blendFunc, [sfactor, dfactor]))
            this._blendFunc(sfactor, dfactor);
    }

    $blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
        if (this._state.setSetting(this._blendFuncSeparate, [srcRGB, dstRGB, srcAlpha, dstAlpha]))
            this._blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
    }

    $clearColor(red, green, blue, alpha) {
        if (this._state.setSetting(this._clearColor, [red, green, blue, alpha]))
            this._clearColor(red, green, blue, alpha);
    }

    $clearDepth(depth) {
        if (this._state.setSetting(this._clearDepth, [depth]))
            this._clearDepth(depth);
    }

    $clearStencil(s) {
        if (this._state.setSetting(this._clearStencil, [s]))
            this._clearStencil(s);
    }

    $colorMask(red, green, blue, alpha) {
        if (this._state.setSetting(this._colorMask, [red, green, blue, alpha]))
            this._colorMask(red, green, blue, alpha);
    }

    $cullFace(mode) {
        if (this._state.setSetting(this._cullFace, [mode]))
            this._cullFace(mode);
    }

    $depthFunc(func) {
        if (this._state.setSetting(this._depthFunc, [func]))
            this._depthFunc(func);
    }

    $depthMask(flag) {
        if (this._state.setSetting(this._depthMask, [flag]))
            this._depthMask(flag);
    }

    $depthRange(zNear, zFar) {
        if (this._state.setSetting(this._depthRange, [zNear, zFar]))
            this._depthRange(zNear, zFar);
    }

    $frontFace(mode) {
        if (this._state.setSetting(this._frontFace, [mode]))
            this._frontFace(mode);
    }

    $lineWidth(width) {
        if (this._state.setSetting(this._lineWidth, [width]))
            this._lineWidth(width);
    }

    $polygonOffset(factor, units) {
        if (this._state.setSetting(this._polygonOffset, [factor, units]))
            this._polygonOffset(factor, units);
    }

    $sampleCoverage(value, invert) {
        if (this._state.setSetting(this._sampleCoverage, [value, invert]))
            this._sampleCoverage(value, invert);
    }

    $stencilFunc(func, ref, mask) {
        if (this._state.setSetting(this._stencilFunc, [func, ref, mask]))
            this._stencilFunc(func, ref, mask);
    }

    $stencilMask(mask) {
        if (this._state.setSetting(this._stencilMask, [mask]))
            this._stencilMask(mask);
    }

    $stencilOp(fail, zfail, zpass) {
        if (this._state.setSetting(this._stencilOp, [fail, zfail, zpass]))
            this._stencilOp(fail, zfail, zpass);
    }

    $vertexAttrib1f(indx, x) {
        if (this._state.setSetting(this._vertexAttrib1f, [indx, x]))
            this._vertexAttrib1f(indx, x);
    }

    $vertexAttrib1fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib1fv, [indx, values]))
            this._vertexAttrib1fv(indx, values);
    }

    $vertexAttrib2f(indx, x, y) {
        if (this._state.setSetting(this._vertexAttrib2f, [indx, x, y]))
            this._vertexAttrib2f(indx, x, y);
    }

    $vertexAttrib2fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib2fv, [indx, values]))
            this._vertexAttrib2fv(indx, values);
    }

    $vertexAttrib3f(indx, x, y, z) {
        if (this._state.setSetting(this._vertexAttrib3f, [indx, x, y, z]))
            this._vertexAttrib3f(indx, x, y, z);
    }

    $vertexAttrib3fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib3fv, [indx, values]))
            this._vertexAttrib3fv(indx, values);
    }

    $vertexAttrib4f(indx, x, y, z, w) {
        if (this._state.setSetting(this._vertexAttrib4f, [indx, x, y, z, w]))
            this._vertexAttrib4f(indx, x, y, z, w);
    }

    $vertexAttrib4fv(indx, values) {
        if (this._state.setSetting(this._vertexAttrib4fv, [indx, values]))
            this._vertexAttrib4fv(indx, values);
    }

    /**
     * Sets up the rendering context for context sharing.
     * @param {WebGLRenderingContext} gl
     * @param {string} id
     */
    static enable(gl, id = "default") {
        const names = Object.getOwnPropertyNames(WebGLStateManager.prototype);
        const WebGLRenderingContextProto = gl.__proto__;
        names.forEach(name => {
            if (name !== "constructor") {
                const method = WebGLStateManager.prototype[name];
                if (name.charAt(0) === "$") {
                    name = name.substr(1);
                }
                if (gl[name] !== method) {
                    if (gl[name]) {
                        if (!gl[name].name) {
                            // We do this for compatibility with the Chrome WebGL Inspector plugin.
                            gl[name].xname = name;
                        }
                        gl['_' + name] = gl[name];
                    }
                    gl[name] = method;
                }
            }
        });

        WebGLStateManager.prototype._initStateManager.call(gl, id);

        return gl;
    }

}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebGLStateManager);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Base.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Base.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Base)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Base {

    static defaultSetter(obj, name, value) {
        obj[name] = value;
    }

    static patchObject(obj, settings) {
        if (!_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            console.error("[Lightning] Settings must be object literal");
        } else {
            let names = Object.keys(settings);
            for (let i = 0, n = names.length; i < n; i++) {
                let name = names[i];

                this.patchObjectProperty(obj, name, settings[name]);
            }
        }
    }

    static patchObjectProperty(obj, name, value) {
        let setter = obj.setSetting || Base.defaultSetter;

        if (name.charAt(0) === "_") {
            // Disallow patching private variables.
            if (name !== "__create") {
                console.error("[Lightning] Patch of private property '" + name + "' is not allowed");
            }
        } else if (name !== "type") {
            // Type is a reserved keyword to specify the class type on creation.
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(value) && value.__local) {
                // Local function (Base.local(s => s.something))
                value = value.__local(obj);
            }

            setter(obj, name, value);
        }
    }

    static local(func) {
        // This function can be used as an object setting, which is called with the target object.
        func.__local = true;
    }


}





/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Element.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Element.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Element)
/* harmony export */ });
/* harmony import */ var _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/ElementCore.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _Shader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _Texture_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Texture.mjs */ "./node_modules/@lightningjs/core/src/tree/Texture.mjs");
/* harmony import */ var _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../textures/ImageTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/ImageTexture.mjs");
/* harmony import */ var _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../textures/TextTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/TextTexture.mjs");
/* harmony import */ var _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../textures/SourceTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/SourceTexture.mjs");
/* harmony import */ var _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../animation/Transition.mjs */ "./node_modules/@lightningjs/core/src/animation/Transition.mjs");
/* harmony import */ var _ElementChildList_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ElementChildList.mjs */ "./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Render tree node.
 */









class Element {

    constructor(stage) {
        this.stage = stage;

        this.__id = Element.id++;

        this.__start();

        // EventEmitter constructor.
        this._hasEventListeners = false;

        this.__core = new _core_ElementCore_mjs__WEBPACK_IMPORTED_MODULE_1__["default"](this);

        /**
         * A reference that can be used while merging trees.
         * @type {string}
         */
        this.__ref = null;

        /**
         * An element is attached if it is a descendant of the stage root.
         * @type {boolean}
         */
        this.__attached = false;

        /**
         * An element is enabled when it is attached and it is visible (worldAlpha > 0).
         * @type {boolean}
         */
        this.__enabled = false;

        /**
         * An element is active when it is enabled and it is within bounds.
         * @type {boolean}
         */
        this.__active = false;

        /**
         * @type {Element}
         */
        this.__parent = null;

        /**
         * The texture that is currently set.
         * @type {Texture}
         */
        this.__texture = null;

        /**
         * The currently displayed texture. While this.texture is loading, this one may be different.
         * @type {Texture}
         */
        this.__displayedTexture = null;

        /**
         * Tags that can be used to identify/search for a specific element.
         * @type {String[]}
         */
        this.__tags = null;

        /**
         * The tree's tags mapping.
         * This contains all elements for all known tags, at all times.
         * @type {Map}
         */
        this.__treeTags = null;

        /**
         * Creates a tag context: tagged elements in this branch will not be reachable from ancestors of this elements.
         * @type {boolean}
         */
        this.__tagRoot = false;

        /**
         * (Lazy-initialised) list of children owned by this elements.
         * @type {ElementChildList}
         */
        this.__childList = null;

        this._w = 0;

        this._h = 0;
    }

    __start() {
    }

    get id() {
        return this.__id;
    }

    set ref(ref) {
        if (this.__ref !== ref) {
            const charcode = ref.charCodeAt(0);
            if (!_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(charcode)) {
                this._throwError("Ref must start with an upper case character: " + ref);
            }
            if (this.__ref !== null) {
                this.removeTag(this.__ref);
                if (this.__parent) {
                    this.__parent.__childList.clearRef(this.__ref);
                }
            }

            this.__ref = ref;

            if (this.__ref) {
                this._addTag(this.__ref);
                if (this.__parent) {
                    this.__parent.__childList.setRef(this.__ref, this);
                }
            }
        }
    }

    get ref() {
        return this.__ref;
    }

    get core() {
        return this.__core;
    }

    setAsRoot() {
        this.__core.setAsRoot();
        this._updateAttachedFlag();
        this._updateEnabledFlag();
    }

    get isRoot() {
        return this.__core.isRoot;
    }

    _setParent(parent) {
        if (this.__parent === parent) return;

        if (this.__parent) {
            this._unsetTagsParent();
        }

        this.__parent = parent;

        if (parent) {
            this._setTagsParent();
        }

        this._updateAttachedFlag();
        this._updateEnabledFlag();
        this._updateCollision();

        if (this.isRoot && parent) {
            this._throwError("Root should not be added as a child! Results are unspecified!");
        }
    };

    getDepth() {
        let depth = 0;

        let p = this.__parent;
        while(p) {
            depth++;
            p = p.__parent;
        }

        return depth;
    };

    getAncestor(l) {
        let p = this;
        while (l > 0 && p.__parent) {
            p = p.__parent;
            l--;
        }
        return p;
    };

    getAncestors() {
        const a = [];
        let p = this;
        while (p) {
            a.push(p);
            p = p.__parent;
        }
        return a;
    }

    getAncestorAtDepth(depth) {
        let levels = this.getDepth() - depth;
        if (levels < 0) {
            return null;
        }
        return this.getAncestor(levels);
    };

    isAncestorOf(c) {
        let p = c;
        while(p = p.parent) {
            if (this === p) {
                return true;
            }
        }
        return false;
    };

    getSharedAncestor(c) {
        let o1 = this;
        let o2 = c;
        let l1 = o1.getDepth();
        let l2 = o2.getDepth();
        if (l1 > l2) {
            o1 = o1.getAncestor(l1 - l2);
        } else if (l2 > l1) {
            o2 = o2.getAncestor(l2 - l1);
        }

        do {
            if (o1 === o2) {
                return o1;
            }

            o1 = o1.__parent;
            o2 = o2.__parent;
        } while (o1 && o2);

        return null;
    };

    get attached() {
        return this.__attached;
    }

    get enabled() {
        return this.__enabled;
    }

    get active() {
        return this.__active;
    }

    _isAttached() {
        return (this.__parent ? this.__parent.__attached : (this.stage.root === this));
    };

    _isEnabled() {
        return this.__core.visible && (this.__core.alpha > 0) && (this.__parent ? this.__parent.__enabled : (this.stage.root === this));
    };

    _isActive() {
        return this._isEnabled() && this.withinBoundsMargin;
    };

    /**
     * Updates the 'attached' flag for this branch.
     */
    _updateAttachedFlag() {
        let newAttached = this._isAttached();
        if (this.__attached !== newAttached) {
            this.__attached = newAttached;

            if (newAttached) {
                this._onSetup();
            }

            let children = this._children.get();
            if (children) {
                let m = children.length;
                if (m > 0) {
                    for (let i = 0; i < m; i++) {
                        children[i]._updateAttachedFlag();
                    }
                }
            }

            if (newAttached) {
                this._onAttach();
            } else {
                this._onDetach();
            }
        }
    };

    /**
     * Updates the 'enabled' flag for this branch.
     */
    _updateEnabledFlag() {
        let newEnabled = this._isEnabled();
        if (this.__enabled !== newEnabled) {
            if (newEnabled) {
                this._onEnabled();
                this._setEnabledFlag();
            } else {
                this._onDisabled();
                this._unsetEnabledFlag();
            }

            let children = this._children.get();
            if (children) {
                let m = children.length;
                if (m > 0) {
                    for (let i = 0; i < m; i++) {
                        children[i]._updateEnabledFlag();
                    }
                }
            }
        }
    };

    _setEnabledFlag() {
        this.__enabled = true;

        // Force re-check of texture because dimensions might have changed (cutting).
        this._updateDimensions();
        this._updateTextureCoords();

        if (this.__texture) {
            this.__texture.addElement(this);
        }

        if (this.withinBoundsMargin) {
            this._setActiveFlag();
        }

        if (this.__core.shader) {
            this.__core.shader.addElement(this.__core);
        }

    }

    _unsetEnabledFlag() {
        if (this.__active) {
            this._unsetActiveFlag();
        }

        if (this.__texture) {
            this.__texture.removeElement(this);
        }

        if (this.__core.shader) {
            this.__core.shader.removeElement(this.__core);
        }

        if (this._texturizer) {
            this.texturizer.filters.forEach(filter => filter.removeElement(this.__core));
        }

        this.__enabled = false;
    }

    _setActiveFlag() {
        this.__active = true;

        // This must happen before enabling the texture, because it may already be loaded or load directly.
        if (this.__texture) {
            this.__texture.incActiveCount();
        }

        if (this.__texture) {
            this._enableTexture();
        }
        this._onActive();
    }

    _unsetActiveFlag() {
        if (this.__texture) {
            this.__texture.decActiveCount();
        }

        this.__active = false;
        if (this.__texture) {
            this._disableTexture();
        }

        if (this._hasTexturizer()) {
            this.texturizer.deactivate();
        }

        this._onInactive();
    }

    _onSetup() {
    }

    _onAttach() {
    }

    _onDetach() {
    }

    _onEnabled() {
    }

    _onDisabled() {
    }

    _onActive() {
    }

    _onInactive() {
    }

    _onResize() {
    }

    _getRenderWidth() {
        if (this._w) {
            return this._w;
        } else if (this.__displayedTexture) {
            return this.__displayedTexture.getRenderWidth();
        } else if (this.__texture) {
            // Texture already loaded, but not yet updated (probably because this element is not active).
            return this.__texture.getRenderWidth();
        } else {
            return 0;
        }
    };

    _getRenderHeight() {
        if (this._h) {
            return this._h;
        } else if (this.__displayedTexture) {
            return this.__displayedTexture.getRenderHeight();
        } else if (this.__texture) {
            // Texture already loaded, but not yet updated (probably because this element is not active).
            return this.__texture.getRenderHeight();
        } else {
            return 0;
        }
    };

    get renderWidth() {
        if (this.__enabled) {
            // Render width is only maintained if this element is enabled.
            return this.__core.getRenderWidth();
        } else {
            return this._getRenderWidth();
        }
    }

    get renderHeight() {
        if (this.__enabled) {
            return this.__core.getRenderHeight();
        } else {
            return this._getRenderHeight();
        }
    }

    get finalX() {
        return this.__core.x;
    }

    get finalY() {
        return this.__core.y;
    }

    get finalW() {
        return this.__core.w;
    }

    get finalH() {
        return this.__core.h;
    }

    textureIsLoaded() {
        return this.__texture && this.__texture.isLoaded();
    }

    loadTexture() {
        if (this.__texture) {
            this.__texture.load();

            if (!this.__texture.isUsed() || !this._isEnabled()) {
                // Loading the texture will have no effect on the dimensions of this element.
                // Manually update them, so that calcs can be performed immediately in userland.
                this._updateDimensions();
            }
        }
    }

    _enableTextureError() {
        // txError event should automatically be re-triggered when a element becomes active.
        const loadError = this.__texture.loadError;
        if (loadError) {
            this.emit('txError', loadError, this.__texture._source);
        }
    }

    _enableTexture() {
        if (this.__texture.isLoaded()) {
            this._setDisplayedTexture(this.__texture);
        } else {
            // We don't want to retain the old 'ghost' image as it wasn't visible anyway.
            this._setDisplayedTexture(null);

            this._enableTextureError();
        }
    }

    _disableTexture() {
        // We disable the displayed texture because, when the texture changes while invisible, we should use that w, h,
        // mw, mh for checking within bounds.
        this._setDisplayedTexture(null);
    }

    get texture() {
        return this.__texture;
    }

    set texture(v) {
        let texture;
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
            if (v.type) {
                texture = new v.type(this.stage);
            } else {
                texture = this.texture;
            }

            if (texture) {
                _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(texture, v);
            }
        } else if (!v) {
            texture = null;
        } else {
            if (v.isTexture) {
                texture = v;
            } else if (v.isTextureSource) {
                texture = new _textures_SourceTexture_mjs__WEBPACK_IMPORTED_MODULE_6__["default"](this.stage);
                texture.textureSource = v;
            } else {
                console.error("[Lightning] Please specify a texture type.");
                return;
            }
        }

        const prevTexture = this.__texture;
        if (texture !== prevTexture) {
            this.__texture = texture;

            if (this.__texture) {
                if (this.__enabled) {
                    this.__texture.addElement(this);

                    if (this.withinBoundsMargin) {
                        if (this.__texture.isLoaded()) {
                            this._setDisplayedTexture(this.__texture);
                        } else {
                            this._enableTextureError();
                        }
                    }
                }
            } else {
                // Make sure that current texture is cleared when the texture is explicitly set to null.
                this._setDisplayedTexture(null);
            }

            if (prevTexture && prevTexture !== this.__displayedTexture) {
                prevTexture.removeElement(this);
            }

            this._updateDimensions();
        }
    }

    get displayedTexture() {
        return this.__displayedTexture;
    }

    _setDisplayedTexture(v) {
        let prevTexture = this.__displayedTexture;

        if (prevTexture && (v !== prevTexture)) {
            if (this.__texture !== prevTexture) {
                // The old displayed texture is deprecated.
                prevTexture.removeElement(this);
            }
        }

        const prevSource = this.__core.displayedTextureSource ? this.__core.displayedTextureSource._source : null;
        const sourceChanged = (v ? v._source : null) !== prevSource;

        this.__displayedTexture = v;
        this._updateDimensions();

        if (this.__displayedTexture) {
            if (sourceChanged) {
                // We don't need to reference the displayed texture because it was already referenced (this.texture === this.displayedTexture).
                this._updateTextureCoords();
                this.__core.setDisplayedTextureSource(this.__displayedTexture._source);
            }
        } else {
            this.__core.setDisplayedTextureSource(null);
        }

        if (sourceChanged) {
            if (this.__displayedTexture) {
                this.emit('txLoaded', this.__displayedTexture);
            } else {
                this.emit('txUnloaded', this.__displayedTexture);
            }
        }
    }

    onTextureSourceLoaded() {
        // This function is called when element is enabled, but we only want to set displayed texture for active elements.
        if (this.active) {
            // We may be dealing with a texture reloading, so we must force update.
            this._setDisplayedTexture(this.__texture);
        }
    };

    onTextureSourceLoadError(e) {
        this.emit('txError', e, this.__texture._source);
    };

    forceRenderUpdate() {
        this.__core.setHasRenderUpdates(3);
    }

    onDisplayedTextureClippingChanged() {
        this._updateDimensions();
        this._updateTextureCoords();
    };

    onPrecisionChanged() {
        this._updateDimensions();
    };

    onDimensionsChanged(w, h) {
        if (this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"]) {
            this.texture.w = w;
            this.texture.h = h;
            this.w = w;
            this.h = h;
        }
    }

    _updateDimensions() {
        let w = this._getRenderWidth();
        let h = this._getRenderHeight();

        let unknownSize = false;
        if (!w || !h) {
            if (!this.__displayedTexture && this.__texture) {
                // We use a 'max width' replacement instead in the ElementCore calcs.
                // This makes sure that it is able to determine withinBounds.
                w = w || this.__texture.mw;
                h = h || this.__texture.mh;

                if ((!w || !h) && this.__texture.isAutosizeTexture()) {
                    unknownSize = true;
                }
            }
        }

        if (this.__core.setDimensions(w, h, unknownSize)) {
            this._onResize();
        }
    }

    _updateTextureCoords() {
        if (this.displayedTexture && this.displayedTexture._source) {
            let displayedTexture = this.displayedTexture;
            let displayedTextureSource = this.displayedTexture._source;

            let tx1 = 0, ty1 = 0, tx2 = 1.0, ty2 = 1.0;
            if (displayedTexture.clipping) {
                // Apply texture clipping.
                let w = displayedTextureSource.getRenderWidth();
                let h = displayedTextureSource.getRenderHeight();
                let iw, ih, rw, rh;
                iw = 1 / w;
                ih = 1 / h;

                if (displayedTexture.pw) {
                    rw = (displayedTexture.pw) * iw;
                } else {
                    rw = (w - displayedTexture.px) * iw;
                }

                if (displayedTexture.ph) {
                    rh = displayedTexture.ph * ih;
                } else {
                    rh = (h - displayedTexture.py) * ih;
                }

                iw *= (displayedTexture.px);
                ih *= (displayedTexture.py);

                tx1 = iw;
                ty1 = ih;
                tx2 = tx2 * rw + iw;
                ty2 = ty2 * rh + ih;

                tx1 = Math.max(0, tx1);
                ty1 = Math.max(0, ty1);
                tx2 = Math.min(1, tx2);
                ty2 = Math.min(1, ty2);
            }

            if (displayedTextureSource._flipTextureY) {
                let tempty = ty2;
                ty2 = ty1;
                ty1 = tempty;
            }
            this.__core.setTextureCoords(tx1, ty1, tx2, ty2);
        }
    }

    getCornerPoints() {
        return this.__core.getCornerPoints();
    }

    _unsetTagsParent() {
        if (this.__tags) {
            this.__tags.forEach((tag) => {
                // Remove from treeTags.
                let p = this;
                while (p = p.__parent) {
                    let parentTreeTags = p.__treeTags.get(tag);
                    parentTreeTags.delete(this);

                    if (p.__tagRoot) {
                        break;
                    }
                }
            });
        }

        let tags = null;
        let n = 0;
        if (this.__treeTags) {
            if (!this.__tagRoot) {
                tags = _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].iteratorToArray(this.__treeTags.keys());
                n = tags.length;

                if (n > 0) {
                    for (let i = 0; i < n; i++) {
                        let tagSet = this.__treeTags.get(tags[i]);

                        // Remove from treeTags.
                        let p = this;
                        while ((p = p.__parent)) {
                            let parentTreeTags = p.__treeTags.get(tags[i]);

                            tagSet.forEach(function (comp) {
                                parentTreeTags.delete(comp);
                            });

                            if (p.__tagRoot) {
                                break;
                            }
                        }
                    }
                }
            }
        }
    };

    _setTagsParent() {
        // Just copy over the 'local' tags.
        if (this.__tags) {
            this.__tags.forEach((tag) => {
                let p = this;
                while (p = p.__parent) {
                    if (!p.__treeTags) {
                        p.__treeTags = new Map();
                    }

                    let s = p.__treeTags.get(tag);
                    if (!s) {
                        s = new Set();
                        p.__treeTags.set(tag, s);
                    }

                    s.add(this);

                    if (p.__tagRoot) {
                        break;
                    }
                }
            });
        }

        if (this.__treeTags && this.__treeTags.size) {
            if (!this.__tagRoot) {
                this.__treeTags.forEach((tagSet, tag) => {
                    let p = this;
                    while (!p.__tagRoot && (p = p.__parent)) {
                        if (p.__tagRoot) {
                            // Do not copy all subs.
                        }
                        if (!p.__treeTags) {
                            p.__treeTags = new Map();
                        }

                        let s = p.__treeTags.get(tag);
                        if (!s) {
                            s = new Set();
                            p.__treeTags.set(tag, s);
                        }

                        tagSet.forEach(function (comp) {
                            s.add(comp);
                        });
                    }
                });
            }
        }
    };


    _getByTag(tag) {
        if (!this.__treeTags) {
            return [];
        }
        let t = this.__treeTags.get(tag);
        return t ? _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].setToArray(t) : [];
    };

    getTags() {
        return this.__tags ? this.__tags : [];
    };

    setTags(tags) {
        tags = tags.reduce((acc, tag) => {
            return acc.concat(tag.split(' '));
        }, []);

        if (this.__ref) {
            tags.push(this.__ref);
        }

        let i, n = tags.length;
        let removes = [];
        let adds = [];
        for (i = 0; i < n; i++) {
            if (!this.hasTag(tags[i])) {
                adds.push(tags[i]);
            }
        }

        let currentTags = this.tags || [];
        n = currentTags.length;
        for (i = 0; i < n; i++) {
            if (tags.indexOf(currentTags[i]) == -1) {
                removes.push(currentTags[i]);
            }
        }

        for (i = 0; i < removes.length; i++) {
            this.removeTag(removes[i]);
        }

        for (i = 0; i < adds.length; i++) {
            this.addTag(adds[i]);
        }
    }

    addTag(tag) {
        if (tag.indexOf(' ') === -1) {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(tag.charCodeAt(0))) {
                this._throwError("Tag may not start with an upper case character.");
            }

            this._addTag(tag);
        } else {
            const tags = tag.split(' ');
            for (let i = 0, m = tags.length; i < m; i++) {
                const tag = tags[i];

                if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(tag.charCodeAt(0))) {
                    this._throwError("Tag may not start with an upper case character.");
                }

                this._addTag(tag);
            }
        }
    }

    _addTag(tag) {
        if (!this.__tags) {
            this.__tags = [];
        }
        if (this.__tags.indexOf(tag) === -1) {
            this.__tags.push(tag);

            // Add to treeTags hierarchy.
            let p = this.__parent;
            if (p) {
                do {
                    if (!p.__treeTags) {
                        p.__treeTags = new Map();
                    }

                    let s = p.__treeTags.get(tag);
                    if (!s) {
                        s = new Set();
                        p.__treeTags.set(tag, s);
                    }

                    s.add(this);

                } while (!p.__tagRoot && (p = p.__parent));
            }
        }
    }

    removeTag(tag) {
        let i = this.__tags.indexOf(tag);
        if (i !== -1) {
            this.__tags.splice(i, 1);

            // Remove from treeTags hierarchy.
            let p = this.__parent;
            if (p) {
                do {
                    let list = p.__treeTags.get(tag);
                    if (list) {
                        list.delete(this);
                    }
                } while (!p.__tagRoot && (p = p.__parent));
            }
        }
    }

    hasTag(tag) {
        return (this.__tags && (this.__tags.indexOf(tag) !== -1));
    }

    /**
     * Returns one of the elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element}
     */
    _tag(tag) {
        if (tag.indexOf(".") !== -1) {
            return this.mtag(tag)[0];
        } else {
            if (this.__treeTags) {
                let t = this.__treeTags.get(tag);
                if (t) {
                    const item = t.values().next();
                    return item ? item.value : undefined;
                }
            }
        }
    };

    get tag() {
        return this._tag;
    }

    set tag(t) {
        this.tags = t;
    }

    /**
     * Returns all elements from the subtree that have this tag.
     * @param {string} tag
     * @returns {Element[]}
     */
    mtag(tag) {
        let idx = tag.indexOf(".");
        if (idx >= 0) {
            let parts = tag.split('.');
            let res = this._getByTag(parts[0]);
            let level = 1;
            let c = parts.length;
            while (res.length && level < c) {
                let resn = [];
                for (let j = 0, n = res.length; j < n; j++) {
                    resn = resn.concat(res[j]._getByTag(parts[level]));
                }

                res = resn;
                level++;
            }
            return res;
        } else {
            return this._getByTag(tag);
        }
    };

    stag(tag, settings) {
        let t = this.mtag(tag);
        let n = t.length;
        for (let i = 0; i < n; i++) {
            _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObject(t[i], settings);
        }
    }

    get tagRoot() {
        return this.__tagRoot;
    }

    set tagRoot(v) {
        if (this.__tagRoot !== v) {
            if (!v) {
                this._setTagsParent();
            } else {
                this._unsetTagsParent();
            }

            this.__tagRoot = v;
        }
    }

    sel(path) {
        const results = this.select(path);
        if (results.length) {
            return results[0];
        } else {
            return undefined;
        }
    }

    select(path) {
        if (path.indexOf(",") !== -1) {
            let selectors = path.split(',');
            let res = [];
            for (let i = 0; i < selectors.length; i++) {
                res = res.concat(this._select(selectors[i]));
            }
            return res;
        } else {
            return this._select(path);
        }
    }

    _select(path) {
        if (path === "") return [this];


        let pointIdx = path.indexOf(".");
        let arrowIdx = path.indexOf(">");
        if (pointIdx === -1 && arrowIdx === -1) {
            // Quick case.
            return this.mtag(path);
        }

        // Detect by first char.
        let isRef;
        if (arrowIdx === 0) {
            isRef = true;
            path = path.substr(1);
        } else if (pointIdx === 0) {
            isRef = false;
            path = path.substr(1);
        } else {
            isRef = false;
        }

        return this._selectChilds(path, isRef);
    }

    _selectChilds(path, isRef) {
        const pointIdx = path.indexOf(".");
        const arrowIdx = path.indexOf(">");

        if (pointIdx === -1 && arrowIdx === -1) {
            if (isRef) {
                const ref = this.getByRef(path);
                return ref ? [ref] : [];
            } else {
                return this.mtag(path);
            }
        }

        if ((arrowIdx === -1) || (pointIdx !== -1 && pointIdx < arrowIdx)) {
            let next;
            const str = path.substr(0, pointIdx);
            if (isRef) {
                const ref = this.getByRef(str);
                next = ref ? [ref] : [];
            } else {
                next = this.mtag(str);
            }
            let total = [];
            const subPath = path.substr(pointIdx + 1);
            for (let i = 0, n = next.length; i < n; i++) {
                total = total.concat(next[i]._selectChilds(subPath, false));
            }
            return total;
        } else {
            let next;
            const str = path.substr(0, arrowIdx);
            if (isRef) {
                const ref = this.getByRef(str);
                next = ref ? [ref] : [];
            } else {
                next = this.mtag(str);
            }
            let total = [];
            const subPath = path.substr(arrowIdx + 1);
            for (let i = 0, n = next.length; i < n; i++) {
                total = total.concat(next[i]._selectChilds(subPath, true));
            }
            return total;
        }
    }

    getByRef(ref) {
        return this.childList.getByRef(ref);
    }

    getLocationString() {
        let i;
        i = this.__parent ? this.__parent._children.getIndex(this) : "R";
        let localTags = this.getTags();
        let str = this.__parent ? this.__parent.getLocationString(): "";
        if (this.ref) {
            str += ":[" + i + "]" + this.ref;
        } else if (localTags.length) {
            str += ":[" + i + "]" + localTags.join(",");
        } else {
            str += ":[" + i + "]#" + this.id;
        }
        return str;
    }

    toString() {
        let obj = this.getSettings();
        return Element.getPrettyString(obj, "");
    };

    static getPrettyString(obj, indent) {
        let children = obj.children;
        delete obj.children;


        // Convert singular json settings object.
        let colorKeys = ["color", "colorUl", "colorUr", "colorBl", "colorBr"];
        let str = JSON.stringify(obj, function (k, v) {
            if (colorKeys.indexOf(k) !== -1) {
                return "COLOR[" + v.toString(16) + "]";
            }
            return v;
        });
        str = str.replace(/"COLOR\[([a-f0-9]{1,8})\]"/g, "0x$1");

        if (children) {
            let childStr = "";
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(children)) {
                let refs = Object.keys(children);
                childStr = "";
                for (let i = 0, n = refs.length; i < n; i++) {
                    childStr += `\n${indent}  "${refs[i]}":`
                    delete children[refs[i]].ref;
                    childStr += Element.getPrettyString(children[refs[i]], indent + "  ") + (i < n - 1 ? "," : "");
                }
                let isEmpty = (str === "{}");
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + childStr + "\n" + indent + "}";
            } else {
                let n = children.length;
                childStr = "[";
                for (let i = 0; i < n; i++) {
                    childStr += Element.getPrettyString(children[i], indent + "  ") + (i < n - 1 ? "," : "") + "\n";
                }
                childStr += indent + "]}";
                let isEmpty = (str === "{}");
                str = str.substr(0, str.length - 1) + (isEmpty ? "" : ",") + "\"children\":\n" + indent + childStr + "}";
            }

        }

        return str;
    }

    getSettings() {
        let settings = this.getNonDefaults();

        let children = this._children.get();
        if (children) {
            let n = children.length;
            if (n) {
                const childArray = [];
                let missing = false;
                for (let i = 0; i < n; i++) {
                    childArray.push(children[i].getSettings());
                    missing = missing || !children[i].ref;
                }

                if (!missing) {
                    settings.children = {}
                    childArray.forEach(child => {
                        settings.children[child.ref] = child;
                    });
                } else {
                    settings.children = childArray;
                }
            }
        }

        settings.id = this.id;

        return settings;
    }

    getNonDefaults() {
        let settings = {};

        if (this.constructor !== Element) {
            settings.type = this.constructor.name;
        }

        if (this.__ref) {
            settings.ref = this.__ref;
        }

        if (this.__tags && this.__tags.length) {
            settings.tags = this.__tags;
        }

        if (this.x !== 0) settings.x = this.x;
        if (this.y !== 0) settings.y = this.y;
        if (this.w !== 0) settings.w = this.w;
        if (this.h !== 0) settings.h = this.h;

        if (this.scaleX === this.scaleY) {
            if (this.scaleX !== 1) settings.scale = this.scaleX;
        } else {
            if (this.scaleX !== 1) settings.scaleX = this.scaleX;
            if (this.scaleY !== 1) settings.scaleY = this.scaleY;
        }

        if (this.pivotX === this.pivotY) {
            if (this.pivotX !== 0.5) settings.pivot = this.pivotX;
        } else {
            if (this.pivotX !== 0.5) settings.pivotX = this.pivotX;
            if (this.pivotY !== 0.5) settings.pivotY = this.pivotY;
        }

        if (this.mountX === this.mountY) {
            if (this.mountX !== 0) settings.mount = this.mountX;
        } else {
            if (this.mountX !== 0) settings.mountX = this.mountX;
            if (this.mountY !== 0) settings.mountY = this.mountY;
        }

        if (this.alpha !== 1) settings.alpha = this.alpha;

        if (!this.visible) settings.visible = false;

        if (this.rotation !== 0) settings.rotation = this.rotation;

        if (this.colorUl === this.colorUr && this.colorBl === this.colorBr && this.colorUl === this.colorBl) {
            if (this.colorUl !== 0xFFFFFFFF) settings.color = this.colorUl.toString(16);
        } else {
            if (this.colorUl !== 0xFFFFFFFF) settings.colorUl = this.colorUl.toString(16);
            if (this.colorUr !== 0xFFFFFFFF) settings.colorUr = this.colorUr.toString(16);
            if (this.colorBl !== 0xFFFFFFFF) settings.colorBl = this.colorBl.toString(16);
            if (this.colorBr !== 0xFFFFFFFF) settings.colorBr = this.colorBr.toString(16);
        }

        if (this.zIndex) settings.zIndex = this.zIndex;

        if (this.forceZIndexContext) settings.forceZIndexContext = true;

        if (this.clipping) settings.clipping = this.clipping;

        if (!this.clipbox) settings.clipbox = this.clipbox;

        if (this.__texture) {
            let tnd = this.__texture.getNonDefaults();
            if (Object.keys(tnd).length) {
                settings.texture = tnd;
            }
        }

        if (this.shader && _Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(this.shader.getNonDefaults)) {
            let tnd = this.shader.getNonDefaults();
            if (Object.keys(tnd).length) {
                settings.shader = tnd;
            }
        }

        if (this._hasTexturizer()) {
            if (this.texturizer.enabled) {
                settings.renderToTexture = this.texturizer.enabled;
            }
            if (this.texturizer.lazy) {
                settings.renderToTextureLazy = this.texturizer.lazy;
            }
            if (this.texturizer.colorize) {
                settings.colorizeResultTexture = this.texturizer.colorize;
            }
            if (this.texturizer.renderOffscreen) {
                settings.renderOffscreen = this.texturizer.renderOffscreen;
            }
        }

        return settings;
    };

    static getGetter(propertyPath) {
        let getter = Element.PROP_GETTERS.get(propertyPath);
        if (!getter) {
            getter = new Function('obj', 'return obj.' + propertyPath);
            Element.PROP_GETTERS.set(propertyPath, getter);
        }
        return getter;
    }

    static getSetter(propertyPath) {
        let setter = Element.PROP_SETTERS.get(propertyPath);
        if (!setter) {
            setter = new Function('obj', 'v', 'obj.' + propertyPath + ' = v');
            Element.PROP_SETTERS.set(propertyPath, setter);
        }
        return setter;
    }

    get withinBoundsMargin() {
        return this.__core._withinBoundsMargin;
    }

    _enableWithinBoundsMargin() {
        // Iff enabled, this toggles the active flag.
        if (this.__enabled) {
            this._setActiveFlag();
        }
    }

    _disableWithinBoundsMargin() {
        // Iff active, this toggles the active flag.
        if (this.__active) {
            this._unsetActiveFlag();
        }
    }

    set boundsMargin(v) {
        if (!Array.isArray(v) && v !== null) {
            throw new Error("boundsMargin should be an array of left-top-right-bottom values or null (inherit margin)");
        }
        this.__core.boundsMargin = v;
    }

    get boundsMargin() {
        return this.__core.boundsMargin;
    }

    get x() {
        return this.__core.offsetX;
    }

    set x(v) {
        this.__core.offsetX = v;
    }

    get y() {
        return this.__core.offsetY;
    }

    set y(v) {
        this.__core.offsetY = v;
    }

    get w() {
        return this._w;
    }

    set w(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(v)) {
            this._w = 0;
            this.__core.funcW = v;
        } else {
            v = Math.max(v, 0);
            if (this._w !== v) {
                this.__core.disableFuncW();
                this._w = v;
                this._updateDimensions();
            }
        }
    }

    get h() {
        return this._h;
    }

    set h(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(v)) {
            this._h = 0;
            this.__core.funcH = v;
        } else {
            v = Math.max(v, 0);
            if (this._h !== v) {
                this.__core.disableFuncH();
                this._h = v;
                this._updateDimensions();
            }
        }
    }

    get collision() {
        return this._collision;
    }

    set collision(v) {
        this._collision = v;
    }

    _updateCollision() {
        if (this.collision && this.__parent && this.__parent.collision === undefined) {
            /**
             * Mark collision as 2 to indicate atleast one descendant has collision enabled.
             * This narrows down the search for elements with active collision.
            */
            this.__parent.collision = 2;
        }
    }

    get scaleX() {
        return this.__core.scaleX;
    }

    set scaleX(v) {
        this.__core.scaleX = v;
    }

    get scaleY() {
        return this.__core.scaleY;
    }

    set scaleY(v) {
        this.__core.scaleY = v;
    }

    get scale() {
        return this.__core.scale;
    }

    set scale(v) {
        this.__core.scale = v;
    }

    get pivotX() {
        return this.__core.pivotX;
    }

    set pivotX(v) {
        this.__core.pivotX = v;
    }

    get pivotY() {
        return this.__core.pivotY;
    }

    set pivotY(v) {
        this.__core.pivotY = v;
    }

    get pivot() {
        return this.__core.pivot;
    }

    set pivot(v) {
        this.__core.pivot = v;
    }

    get mountX() {
        return this.__core.mountX;
    }

    set mountX(v) {
        this.__core.mountX = v;
    }

    get mountY() {
        return this.__core.mountY;
    }

    set mountY(v) {
        this.__core.mountY = v;
    }

    get mount() {
        return this.__core.mount;
    }

    set mount(v) {
        this.__core.mount = v;
    }

    get rotation() {
        return this.__core.rotation;
    }

    set rotation(v) {
        this.__core.rotation = v;
    }

    get alpha() {
        return this.__core.alpha;
    }

    set alpha(v) {
        this.__core.alpha = v;
    }

    get visible() {
        return this.__core.visible;
    }

    set visible(v) {
        this.__core.visible = v;
    }
    
    get colorUl() {
        return this.__core.colorUl;
    }

    set colorUl(v) {
        this.__core.colorUl = v;
    }

    get colorUr() {
        return this.__core.colorUr;
    }

    set colorUr(v) {
        this.__core.colorUr = v;
    }

    get colorBl() {
        return this.__core.colorBl;
    }

    set colorBl(v) {
        this.__core.colorBl = v;
    }

    get colorBr() {
        return this.__core.colorBr;
    }

    set colorBr(v) {
        this.__core.colorBr = v;
    }

    get color() {
        return this.__core.colorUl;
    }

    set color(v) {
        if (this.colorUl !== v || this.colorUr !== v || this.colorBl !== v || this.colorBr !== v) {
            this.colorUl = v;
            this.colorUr = v;
            this.colorBl = v;
            this.colorBr = v;
        }
    }

    get colorTop() {
        return this.colorUl;
    }

    set colorTop(v) {
        if (this.colorUl !== v || this.colorUr !== v) {
            this.colorUl = v;
            this.colorUr = v;
        }
    }

    get colorBottom() {
        return this.colorBl;
    }

    set colorBottom(v) {
        if (this.colorBl !== v || this.colorBr !== v) {
            this.colorBl = v;
            this.colorBr = v;
        }
    }

    get colorLeft() {
        return this.colorUl;
    }

    set colorLeft(v) {
        if (this.colorUl !== v || this.colorBl !== v) {
            this.colorUl = v;
            this.colorBl = v;
        }
    }

    get colorRight() {
        return this.colorUr;
    }

    set colorRight(v) {
        if (this.colorUr !== v || this.colorBr !== v) {
            this.colorUr = v;
            this.colorBr = v;
        }
    }

    get zIndex() {return this.__core.zIndex}
    set zIndex(v) {
        this.__core.zIndex = v;
    }

    get forceZIndexContext() {return this.__core.forceZIndexContext}
    set forceZIndexContext(v) {
        this.__core.forceZIndexContext = v;
    }

    get clipping() {return this.__core.clipping}
    set clipping(v) {
        this.__core.clipping = v;
    }

    get clipbox() {return this.__core.clipbox}
    set clipbox(v) {
        this.__core.clipbox = v;
    }

    get tags() {
        return this.getTags();
    }

    set tags(v) {
        if (!Array.isArray(v)) v = [v];
        this.setTags(v);
    }

    set t(v) {
        this.tags = v;
    }

    get _children() {
        if (!this.__childList) {
            this.__childList = new _ElementChildList_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this, false);
        }
        return this.__childList;
    }

    get childList() {
        if (!this._allowChildrenAccess()) {
            this._throwError("Direct access to children is not allowed in " + this.getLocationString());
        }
        return this._children;
    }

    hasChildren() {
        return this._allowChildrenAccess() && this.__childList && (this.__childList.length > 0);
    }

    _allowChildrenAccess() {
        return true;
    }

    get children() {
        return this.childList.get();
    }

    set children(children) {
        this.childList.patch(children);
    }

    add(o) {
        return this.childList.a(o);
    }

    get p() {
        return this.__parent;
    }

    get parent() {
        return this.__parent;
    }

    get src() {
        if (this.texture && this.texture instanceof _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__["default"]) {
            return this.texture._src;
        } else {
            return undefined;
        }
    }

    set src(v) {
        const texture = new _textures_ImageTexture_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](this.stage);
        texture.src = v;
        this.texture = texture;
    }

    set mw(v) {
        if (this.texture) {
            this.texture.mw = v;
            this._updateDimensions();
        } else {
            this._throwError('Please set mw after setting a texture.');
        }
    }

    set mh(v) {
        if (this.texture) {
            this.texture.mh = v;
            this._updateDimensions();
        } else {
            this._throwError('Please set mh after setting a texture.');
        }
    }

    get rect() {
        return (this.texture === this.stage.rectangleTexture);
    }

    set rect(v) {
        if (v) {
            this.texture = this.stage.rectangleTexture;
        } else {
            this.texture = null;
        }
    }

    enableTextTexture() {
        if (!this.texture || !(this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            this.texture = new _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"](this.stage);

            if (!this.texture.w && !this.texture.h) {
                // Inherit dimensions from element.
                // This allows userland to set dimensions of the Element and then later specify the text.
                this.texture.w = this.w;
                this.texture.h = this.h;
            }
        }
        return this.texture;
    }

    get text() {
        if (this.texture && (this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            return this.texture;
        } else {
            return null;
        }
    }

    set text(v) {
        if (!this.texture || !(this.texture instanceof _textures_TextTexture_mjs__WEBPACK_IMPORTED_MODULE_7__["default"])) {
            this.enableTextTexture();
        }
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isString(v)) {
            this.texture.text = v;
        } else {
            this.texture.patch(v);
        }
    }

    set onUpdate(f) {
        this.__core.onUpdate = f;
    }

    set onAfterCalcs(f) {
        this.__core.onAfterCalcs = f;
    }

    set onAfterUpdate(f) {
        this.__core.onAfterUpdate = f;
    }

    forceUpdate() {
        // Make sure that the update loop is run.
        this.__core._setHasUpdates();
    }

    get shader() {
        return this.__core.shader;
    }

    set shader(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v) && !v.type) {
            // Setting properties on an existing shader.
            if (this.shader) {
                this.shader.patch(v);
            }
        } else {
            const shader = _Shader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].create(this.stage, v);

            if (this.__enabled && this.__core.shader) {
                this.__core.shader.removeElement(this.__core);
            }

            this.__core.shader = shader;

            if (this.__enabled && this.__core.shader) {
                this.__core.shader.addElement(this.__core);
            }
        }
    }

    _hasTexturizer() {
        return !!this.__core._texturizer;
    }

    get renderToTexture() {
        return this.rtt
    }

    set renderToTexture(v) {
        this.rtt = v
    }

    get rtt() {
        return this._hasTexturizer() && this.texturizer.enabled;
    }

    set rtt(v) {
        this.texturizer.enabled = v;
    }

    get rttLazy() {
        return this._hasTexturizer() && this.texturizer.lazy;
    }

    set rttLazy(v) {
        this.texturizer.lazy = v;
    }

    get renderOffscreen() {
        return this._hasTexturizer() && this.texturizer.renderOffscreen;
    }

    set renderOffscreen(v) {
        this.texturizer.renderOffscreen = v;
    }

    get colorizeResultTexture() {
        return this._hasTexturizer() && this.texturizer.colorize;
    }

    set colorizeResultTexture(v) {
        this.texturizer.colorize = v;
    }

    getTexture() {
        return this.texturizer._getTextureSource();
    }

    get texturizer() {
        return this.__core.texturizer;
    }

    patch(settings) {
        let paths = Object.keys(settings);

        for (let i = 0, n = paths.length; i < n; i++) {
            let path = paths[i];
            const v = settings[path];

            const firstCharCode = path.charCodeAt(0);
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isUcChar(firstCharCode)) {
                // Ref.
                const child = this.getByRef(path);
                if (!child) {
                    if (v !== undefined) {
                        // Add to list immediately.
                        let c;
                        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
                            // Catch this case to capture createMode flag.
                            c = this.childList.createItem(v);
                            c.patch(v);
                        } else if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObject(v)) {
                            c = v;
                        }
                        if (c.isElement) {
                            c.ref = path;
                        }

                        this.childList.a(c);
                    }
                } else {
                    if (v === undefined) {
                        if (child.parent) {
                            child.parent.childList.remove(child);
                        }
                    } else if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(v)) {
                        child.patch(v);
                    } else if (v.isElement) {
                        // Replace element by new element.
                        v.ref = path;
                        this.childList.replace(v, child);
                    } else {
                        this._throwError("Unexpected value for path: " + path);
                    }
                }
            } else {
                // Property.
                _Base_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].patchObjectProperty(this, path, v);
            }
        }
    }

    _throwError(message) {
        throw new Error(this.constructor.name + " (" + this.getLocationString() + "): " + message);
    }

    animation(settings) {
        return this.stage.animations.createAnimation(this, settings);
    }

    transition(property, settings = null) {
        if (settings === null) {
            return this._getTransition(property);
        } else {
            this._setTransition(property, settings);
            // We do not create/return the transition, because it would undo the 'lazy transition creation' optimization.
            return null;
        }
    }

    set transitions(object) {
        let keys = Object.keys(object);
        keys.forEach(property => {
            this.transition(property, object[property]);
        });
    }

    set smooth(object) {
        let keys = Object.keys(object);
        keys.forEach(property => {
            let value = object[property];
            if (Array.isArray(value)) {
                this.setSmooth(property, value[0], value[1]);
            } else {
                this.setSmooth(property, value);
            }
        });
    }

    fastForward(property) {
        if (this._transitions) {
            let t = this._transitions[property];
            if (t && t.isTransition) {
                t.finish();
            }
        }
    }

    _getTransition(property) {
        if (!this._transitions) {
            this._transitions = {};
        }
        let t = this._transitions[property];
        if (!t) {
            // Create default transition.
            t = new _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](this.stage.transitions, this.stage.transitions.defaultTransitionSettings, this, property);
        } else if (t.isTransitionSettings) {
            // Upgrade to 'real' transition.
            t = new _animation_Transition_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](
                this.stage.transitions,
                t,
                this,
                property
            );
        }
        this._transitions[property] = t;
        return t;
    }

    _setTransition(property, settings) {
        if (!settings) {
            this._removeTransition(property);
        } else {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_3__["default"].isObjectLiteral(settings)) {
                // Convert plain object to proper settings object.
                settings = this.stage.transitions.createSettings(settings);
            }

            if (!this._transitions) {
                this._transitions = {};
            }

            let current = this._transitions[property];
            if (current && current.isTransition) {
                // Runtime settings change.
                current.settings = settings;
                return current;
            } else {
                // Initially, only set the settings and upgrade to a 'real' transition when it is used.
                this._transitions[property] = settings;
            }
        }
    }

    _removeTransition(property) {
        if (this._transitions) {
            delete this._transitions[property];
        }
    }

    getSmooth(property, v) {
        let t = this._getTransition(property);
        if (t && t.isAttached()) {
            return t.targetValue;
        } else {
            return v;
        }
    }

    setSmooth(property, v, settings) {
        if (settings) {
            this._setTransition(property, settings);
        }
        let t = this._getTransition(property);
        t.start(v);
        return t;
    }

    get flex() {
        return this.__core.flex;
    }

    set flex(v) {
        this.__core.flex = v;
    }

    get flexItem() {
        return this.__core.flexItem;
    }

    set flexItem(v) {
        this.__core.flexItem = v;
    }

    static isColorProperty(property) {
        return property.toLowerCase().indexOf("color") >= 0;
    }

    static getMerger(property) {
        if (Element.isColorProperty(property)) {
            return _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].mergeColors;
        } else {
            return _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].mergeNumbers;
        }
    }

    toJSON() {
        const ref = [`${this.constructor.name}`];
        const tree = {};
        tree[ref] = {};

        if (this.hasChildren()) {
            Element.collectChildren(tree[ref], this.__childList);
        } else {
            tree[ref] = {...Element.getProperties(this)};
        }
        return tree;
    }

    static collectChildren(tree, children) {
        const childList = children;
        for (let i = 0, j = childList.length; i < j; i++) {
            const element = childList.getAt(i);
            const ref = `${element.__ref || `Element-${element.id}`}`;
            const properties = this.getProperties(element);

            tree[ref] = {...properties};

            if (element.hasChildren()) {
                tree[ref].children = {};
                this.collectChildren(
                    tree[ref].children, element.__childList
                );
            }
        }
    }

    static getProperties(element) {
        const props = {};
        const list = [
            "alpha", "active", "attached", "boundsMargin", "color", "clipping", "enabled", "h", "id", "isComponent",
            "mount", "mountY", "mountX", "pivot", "pivotX", "pivotY", "ref", "renderOfScreen", "renderToTexture", "scale",
            "scaleX", "scaleY", "state", "tag", "visible", "w", "x", "y", "zIndex",
            "!!flex", "!!flexItem", "hasFocus()", "hasFinalFocus()"
        ];
        let n = list.length;

        while (n--) {
            let key = list[n];
            const getBoolean = /^!{2}/;
            const isFunction = /\(\)$/;

            if (getBoolean.test(key)) {
                key = key.substring(2, key.length);
                props[key] = !!element[key];
            } else if (isFunction.test(key)) {
                key = key.substring(0, key.length - 2);
                if (typeof element[key] === "function") {
                    props[key] = element[key]();
                }
            } else {
                props[key] = element[key];
            }
        }
        return {...props, ...element.getNonDefaults()};
    }
}

// This gives a slight performance benefit compared to extending EventEmitter.
_EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_4__["default"].addAsMixin(Element);

Element.prototype.isElement = 1;

Element.id = 1;

// Getters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
Element.PROP_GETTERS = new Map();

// Setters reused when referencing element (subobject) properties by a property path, as used in a transition or animation ('x', 'texture.x', etc).
Element.PROP_SETTERS = new Map();









/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/ElementChildList.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementChildList)
/* harmony export */ });
/* harmony import */ var _ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ObjectList.mjs */ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages the list of children for an element.
 */



class ElementChildList extends _ObjectList_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(element) {
        super();
        this._element = element;
    }

    _connectParent(item) {
        const prevParent = item.parent;
        if (prevParent && prevParent !== this._element) {
            // Cleanup in previous child list, without
            const prevChildList = item.parent.childList;
            const index = prevChildList.getIndex(item);

            if (item.ref) {
                prevChildList._refs[item.ref] = undefined;
            }
            prevChildList._items.splice(index, 1);

            // Also clean up element core.
            prevParent.core.removeChildAt(index);

        }

        item._setParent(this._element);

        // We are expecting the caller to sync it to the core.
    }

    onAdd(item, index) {
        this._connectParent(item);
        this._element.core.addChildAt(index, item.core);
    }

    onRemove(item, index) {
        item._setParent(null);
        this._element.core.removeChildAt(index);
    }

    onSync(removed, added, order) {
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i]._setParent(null);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            this._connectParent(added[i]);
        }
        let gc = i => i.core;
        this._element.core.syncChildren(removed.map(gc), added.map(gc), order.map(gc));
    }

    onSet(item, index, prevItem) {
        prevItem._setParent(null);

        this._connectParent(item);
        this._element.core.setChildAt(index, item.core);
    }

    onMove(item, fromIndex, toIndex) {
        this._element.core.moveChild(fromIndex, toIndex);
    }

    createItem(object) {
        if (object.type) {
            return new object.type(this._element.stage);
        } else {
            return this._element.stage.createElement();
        }
    }

    isItem(object) {
        return object.isElement;
    }

}




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/ObjectList.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/ObjectList.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectList)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Manages a list of objects.
 * Objects may be patched. Then, they can be referenced using the 'ref' (string) property.
 */
class ObjectList {

    constructor() {
        this._items = [];
        this._refs = {}
    }

    get() {
        return this._items;
    }

    get first() {
        return this._items[0];
    }

    get last() {
        return this._items.length ? this._items[this._items.length - 1] : undefined;
    }

    add(item) {
        this.addAt(item, this._items.length);
    }

    addAt(item, index) {
        if (index >= 0 && index <= this._items.length) {
            let currentIndex = this._items.indexOf(item);
            if (currentIndex === index) {
                return item;
            }

            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(item)) {
                const o = item;
                item = this.createItem(o);
                item.patch(o);
            }

            if (currentIndex != -1) {
                this.setAt(item, index);
            } else {
                if (item.ref) {
                    this._refs[item.ref] = item;
                }
                this._items.splice(index, 0, item);
                this.onAdd(item, index);
            }
        } else {
            throw new Error('addAt: The index ' + index + ' is out of bounds ' + this._items.length);
        }
    }

    replaceByRef(item) {
        if (item.ref) {
            const existingItem = this.getByRef(item.ref);
            if (!existingItem) {
                throw new Error('replaceByRef: no item found with reference: ' + item.ref);
            }
            this.replace(item, existingItem);
        } else {
            throw new Error('replaceByRef: no ref specified in item');
        }
        this.addAt(item, this._items.length);

    }

    replace(item, prevItem) {
        const index = this.getIndex(prevItem);
        if (index === -1) {
            throw new Error('replace: The previous item does not exist');
        }
        this.setAt(item, index);
    }

    setAt(item, index) {
        if (index >= 0 && index < this._items.length) {

            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(item)) {
                const o = item;
                item = this.createItem(o);
                item.patch(o);
            }

            let currentIndex = this._items.indexOf(item);
            if (currentIndex != -1) {
                if (currentIndex !== index) {
                    const fromIndex = currentIndex;
                    if (fromIndex !== index) {
                        this._items.splice(fromIndex, 1);
                        this._items.splice(index, 0, item);
                        this.onMove(item, fromIndex, index);
                    }
                }
            } else {
                if (index < this._items.length) {
                    if (this._items[index].ref) {
                        this._refs[this._items[index].ref] = undefined;
                    }
                }

                const prevItem = this._items[index];

                // Doesn't exist yet: overwrite current.
                this._items[index] = item;

                if (item.ref) {
                    this._refs[item.ref] = item;
                }

                this.onSet(item, index, prevItem);
            }
        } else {
            throw new Error('setAt: The index ' + index + ' is out of bounds ' + this._items.length);
        }
    }

    getAt(index) {
        return this._items[index];
    }

    getIndex(item) {
        return this._items.indexOf(item);
    }

    remove(item) {
        let index = this._items.indexOf(item);

        if (index !== -1) {
            this.removeAt(index);
        }
    };

    removeAt(index) {
        if (index >= 0 && index < this._items.length) {
            const item = this._items[index];

            if (item.ref) {
                this._refs[item.ref] = undefined;
            }

            this._items.splice(index, 1);

            this.onRemove(item, index);

            return item;
        } else {
            throw new Error(`removeAt: The index ${index} is out of bounds ${this._items.length - 1}`);
        }
    };

    clear() {
        let n = this._items.length;
        if (n) {
            let prev = this._items;
            this._items = [];
            this._refs = {}
            this.onSync(prev, [], []);
        }
    };

    a(o) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(o)) {
            let c = this.createItem(o);
            c.patch(o);
            this.add(c);
            return c;
        } else if (Array.isArray(o)) {
            for (let i = 0, n = o.length; i < n; i++) {
                this.a(o[i]);
            }
            return null;
        } else if (this.isItem(o)) {
            this.add(o);
            return o;
        }
    };

    get length() {
        return this._items.length;
    }

    _getRefs() {
        return this._refs;
    }

    getByRef(ref) {
        return this._refs[ref];
    }

    clearRef(ref) {
        delete this._refs[ref];
    }

    setRef(ref, child) {
        this._refs[ref] = child;
    }

    patch(settings) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(settings)) {
            this._setByObject(settings);
        } else if (Array.isArray(settings)) {
            this._setByArray(settings);
        }
    }

    _setByObject(settings) {
        // Overrule settings of known referenced items.
        let refs = this._getRefs();
        let crefs = Object.keys(settings);
        for (let i = 0, n = crefs.length; i < n; i++) {
            let cref = crefs[i];
            let s = settings[cref];

            let c = refs[cref];
            if (!c) {
                if (this.isItem(s)) {
                    // Replace previous item;
                    s.ref = cref;
                    this.add(s);
                } else {
                    // Create new item.
                    c = this.createItem(s);
                    c.ref = cref;
                    c.patch(s);
                    this.add(c);
                }
            } else {
                if (this.isItem(s)) {
                    if (c !== s) {
                        // Replace previous item;
                        let idx = this.getIndex(c);
                        s.ref = cref;
                        this.setAt(s, idx);
                    }
                } else {
                    c.patch(s);
                }
            }
        }
    }

    _equalsArray(array) {
        let same = true;
        if (array.length === this._items.length) {
            for (let i = 0, n = this._items.length; (i < n) && same; i++) {
                same = same && (this._items[i] === array[i]);
            }
        } else {
            same = false;
        }
        return same;
    }

    _setByArray(array) {
        // For performance reasons, first check if the arrays match exactly and bail out if they do.
        if (this._equalsArray(array)) {
            return;
        }

        for (let i = 0, n = this._items.length; i < n; i++) {
            this._items[i].marker = true;
        }

        let refs;
        let newItems = [];
        for (let i = 0, n = array.length; i < n; i++) {
            let s = array[i];
            if (this.isItem(s)) {
                s.marker = false;
                newItems.push(s);
            } else {
                let cref = s.ref;
                let c;
                if (cref) {
                    if (!refs) refs = this._getRefs();
                    c = refs[cref];
                }

                if (!c) {
                    // Create new item.
                    c = this.createItem(s);
                } else {
                    c.marker = false;
                }

                if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(s)) {
                    c.patch(s);
                }

                newItems.push(c);
            }
        }

        this._setItems(newItems);
    }

    _setItems(newItems) {
        let prevItems = this._items;
        this._items = newItems;

        // Remove the items.
        let removed = prevItems.filter(item => {let m = item.marker; delete item.marker; return m});
        let added = newItems.filter(item => (prevItems.indexOf(item) === -1));

        if (removed.length || added.length) {
            // Recalculate refs.
            this._refs = {}
            for (let i = 0, n = this._items.length; i < n; i++) {
                let ref = this._items[i].ref;
                if (ref) {
                    this._refs[ref] = this._items[i];
                }
            }
        }

        this.onSync(removed, added, newItems);
    }

    sort(f) {
        const items = this._items.slice();
        items.sort(f);
        this._setByArray(items);
    }

    onAdd(item, index) {
    }

    onRemove(item, index) {
    }

    onSync(removed, added, order) {
    }

    onSet(item, index, prevItem) {
    }

    onMove(item, fromIndex, toIndex) {
    }

    createItem(object) {
        throw new Error("ObjectList.createItem must create and return a new object");
    }

    isItem(object) {
        return false;
    }

    forEach(f) {
        this.get().forEach(f);
    }

}






/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Shader.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Shader.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Shader)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class Shader {

    constructor(coreContext) {
        this._initialized = false;

        this.ctx = coreContext;

        /**
         * The (enabled) elements that use this shader.
         * @type {Set<ElementCore>}
         */
        this._elements = new Set();
    }

    static create(stage, v) {
        let shader;
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isObjectLiteral(v)) {
            if (v.type) {
                shader = stage.renderer.createShader(stage.ctx, v);
            } else {
                shader = this.shader;
            }

            if (shader) {
                _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(shader, v);
            }
        } else if (v === null) {
            shader = stage.ctx.renderState.defaultShader;
        } else if (v === undefined) {
            shader = null;
        } else {
            if (v.isShader) {
                if (!stage.renderer.isValidShaderType(v.constructor)) {
                    console.error("[Lightning] Invalid shader type");
                    v = null;
                }
                shader = v;
            } else {
                console.error("[Lightning] Please specify a shader type.");
                return;
            }
        }

        return shader;
    }

    static getWebGL() {
        return undefined;
    }

    static getC2d() {
        return undefined;
    }

    addElement(elementCore) {
        this._elements.add(elementCore);
    }

    removeElement(elementCore) {
        this._elements.delete(elementCore);
        if (!this._elements) {
            this.cleanup();
        }
    }

    redraw() {
        this._elements.forEach(elementCore => {
            elementCore.setHasRenderUpdates(2);
        });
    }

    patch(settings) {
        _Base_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].patchObject(this, settings);
    }

    useDefault() {
        // Should return true if this shader is configured (using it's properties) to not have any effect.
        // This may allow the render engine to avoid unnecessary shader program switches or even texture copies.
        return false;
    }

    addEmpty() {
        // Draws this shader even if there are no quads to be added.
        // This is handy for custom shaders.
        return false;
    }

    cleanup() {
        // Called when no more enabled elements have this shader.
    }

    get isShader() {
        return true;
    }
}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Stage.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Stage.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Stage)
/* harmony export */ });
/* harmony import */ var _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../EventEmitter.mjs */ "./node_modules/@lightningjs/core/src/EventEmitter.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/* harmony import */ var _renderer_webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/webgl/WebGLRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/webgl/WebGLRenderer.mjs");
/* harmony import */ var _renderer_c2d_C2dRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/c2d/C2dRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/c2d/C2dRenderer.mjs");
/* harmony import */ var _renderer_spark_SparkRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/spark/SparkRenderer.mjs */ "./node_modules/@lightningjs/core/src/renderer/spark/SparkRenderer.mjs");
/* harmony import */ var _platforms_PlatformLoader_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platforms/PlatformLoader.mjs */ "./node_modules/@lightningjs/core/src/platforms/PlatformLoader.mjs");
/* harmony import */ var _tools_WebGLStateManager_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../tools/WebGLStateManager.mjs */ "./node_modules/@lightningjs/core/src/tools/WebGLStateManager.mjs");
/* harmony import */ var _Shader_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Shader.mjs */ "./node_modules/@lightningjs/core/src/tree/Shader.mjs");
/* harmony import */ var _Element_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Element.mjs */ "./node_modules/@lightningjs/core/src/tree/Element.mjs");
/* harmony import */ var _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./StageUtils.mjs */ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs");
/* harmony import */ var _TextureManager_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./TextureManager.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureManager.mjs");
/* harmony import */ var _TextureThrottler_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./TextureThrottler.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs");
/* harmony import */ var _core_CoreContext_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/CoreContext.mjs */ "./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs");
/* harmony import */ var _animation_TransitionManager_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../animation/TransitionManager.mjs */ "./node_modules/@lightningjs/core/src/animation/TransitionManager.mjs");
/* harmony import */ var _animation_AnimationManager_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../animation/AnimationManager.mjs */ "./node_modules/@lightningjs/core/src/animation/AnimationManager.mjs");
/* harmony import */ var _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../textures/RectangleTexture.mjs */ "./node_modules/@lightningjs/core/src/textures/RectangleTexture.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Application render tree.
 */










class Stage extends _EventEmitter_mjs__WEBPACK_IMPORTED_MODULE_0__["default"] {

    constructor(options = {}) {
        super();
        this._setOptions(options);

        this._usedMemory = 0;
        this._lastGcFrame = 0;

        const platformType = Stage.platform ? Stage.platform : _platforms_PlatformLoader_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].load(options);
        this.platform = new platformType();

        if (this.platform.init) {
            this.platform.init(this);
        }

        this.gl = null;
        this.c2d = null;

        const context = this.getOption('context');
        if (context) {
            if (context.useProgram) {
                this.gl = context;
            } else {
                this.c2d = context;
            }
        } else {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isWeb && (!Stage.isWebglSupported() || this.getOption('canvas2d'))) {
                this.c2d = this.platform.createCanvasContext(this.getOption('w'), this.getOption('h'));
            } else {
                this.gl = this.platform.createWebGLContext(this.getOption('w'), this.getOption('h'));
            }
        }

        if (this.gl) {
            // Wrap in WebGLStateManager.
            // This prevents unnecessary double WebGL commands from being executed, and allows context switching.
            // Context switching is necessary when reusing the same context for Three.js.
            // Note that the user must make sure that the WebGL context is untouched before creating the application,
            //  when manually passing over a canvas or context in the options.
            _tools_WebGLStateManager_mjs__WEBPACK_IMPORTED_MODULE_6__["default"].enable(this.gl, "lightning")
        }

        this._mode = this.gl ? 0 : 1;

        // Override width and height.
        if (this.getCanvas()) {
            this._options.w = this.getCanvas().width;
            this._options.h = this.getCanvas().height;
        }

        if (this._mode === 0) {
            if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark) {
                this._renderer = new _renderer_spark_SparkRenderer_mjs__WEBPACK_IMPORTED_MODULE_4__["default"](this);
            } else {
                this._renderer = new _renderer_webgl_WebGLRenderer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
            }
        } else {
            this._renderer = new _renderer_c2d_C2dRenderer_mjs__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        }

        this.setClearColor(this.getOption('clearColor'));

        this.frameCounter = 0;

        this.transitions = new _animation_TransitionManager_mjs__WEBPACK_IMPORTED_MODULE_8__["default"](this);
        this.animations = new _animation_AnimationManager_mjs__WEBPACK_IMPORTED_MODULE_9__["default"](this);

        this.textureManager = new _TextureManager_mjs__WEBPACK_IMPORTED_MODULE_10__["default"](this);
        this.textureThrottler = new _TextureThrottler_mjs__WEBPACK_IMPORTED_MODULE_11__["default"](this);

        this.startTime = 0;
        this.currentTime = 0;
        this.dt = 0;

        // Preload rectangle texture, so that we can skip some border checks for loading textures.
        this.rectangleTexture = new _textures_RectangleTexture_mjs__WEBPACK_IMPORTED_MODULE_12__["default"](this);
        this.rectangleTexture.load();

        // Never clean up because we use it all the time.
        this.rectangleTexture.source.permanent = true;

        this.ctx = new _core_CoreContext_mjs__WEBPACK_IMPORTED_MODULE_13__["default"](this);

        this._updateSourceTextures = new Set();
    }

    get renderer() {
        return this._renderer;
    }

    static isWebglSupported() {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isNode) {
            return true;
        }

        try {
            return !!window.WebGLRenderingContext;
        } catch(e) {
            return false;
        }
    }

    /**
     * Returns the rendering mode.
     * @returns {number}
     *  0: WebGL
     *  1: Canvas2d
     */
    get mode() {
        return this._mode;
    }

    isWebgl() {
        return this.mode === 0;
    }

    isC2d() {
        return this.mode === 1;
    }

    getOption(name) {
        return this._options[name];
    }

    _setOptions(o) {
        this._options = {};

        let opt = (name, def) => {
            let value = o[name];

            if (value === undefined) {
                this._options[name] = def;
            } else {
                this._options[name] = value;
            }
        }

        opt('canvas', null);
        opt('context', null);
        opt('w', 1920);
        opt('h', 1080);
        opt('srcBasePath', null);
        opt('memoryPressure', 24e6);
        opt('bufferMemory', 2e6);
        opt('textRenderIssueMargin', 0);
        opt('fontSharp',{precision:0.6666666667, fontSize: 24})
        opt('clearColor', [0, 0, 0, 0]);
        opt('defaultFontFace', 'sans-serif');
        opt('fixedDt', 0);
        opt('useImageWorker', true);
        opt('autostart', true);
        opt('precision', 1);
        opt('canvas2d', false);
        opt('platform', null);
        opt('readPixelsBeforeDraw', false);
    }

    setApplication(app) {
        this.application = app;
    }

    init() {

        if (this.application.getOption('debug') && this.platform._imageWorker) {
            console.log('[Lightning] Using image worker!');
        }

        if (this.application.getOption('debug') && this.c2d) {
            console.log('[Lightning] Using canvas2d renderer');
        }

        this.application.setAsRoot();
        if (this.getOption('autostart')) {
            this.platform.startLoop();
        }
    }

    destroy() {
        this.platform.stopLoop();
        this.platform.destroy();
        this.ctx.destroy();
        this.textureManager.destroy();
        this._renderer.destroy();
    }

    stop() {
        this.platform.stopLoop();
    }

    resume() {
        this.platform.startLoop();
    }

    get root() {
        return this.application;
    }

    getCanvas() {
        return this._mode ? this.c2d.canvas : this.gl.canvas;
    }

    getRenderPrecision() {
        return this._options.precision;
    }

    /**
     * Marks a texture for updating it's source upon the next drawFrame.
     * @param texture
     */
    addUpdateSourceTexture(texture) {
        if (this._updatingFrame) {
            // When called from the upload loop, we must immediately load the texture in order to avoid a 'flash'.
            texture._performUpdateSource();
        } else {
            this._updateSourceTextures.add(texture);
        }
    }

    removeUpdateSourceTexture(texture) {
        if (this._updateSourceTextures) {
            this._updateSourceTextures.delete(texture);
        }
    }

    hasUpdateSourceTexture(texture) {
        return (this._updateSourceTextures && this._updateSourceTextures.has(texture));
    }

    drawFrame() {
        this.startTime = this.currentTime;
        this.currentTime = this.platform.getHrTime();

        if (this._options.fixedDt) {
            this.dt = this._options.fixedDt;
        } else {
            this.dt = (!this.startTime) ? .02 : .001 * (this.currentTime - this.startTime);
        }

        this.emit('frameStart');

        if (this._updateSourceTextures.size) {
            this._updateSourceTextures.forEach(texture => {
                texture._performUpdateSource();
            });
            this._updateSourceTextures = new Set();
        }

        this.emit('update');

        const changes = this.ctx.hasRenderUpdates();

        // Update may cause textures to be loaded in sync, so by processing them here we may be able to show them
        // during the current frame already.
        this.textureThrottler.processSome();

        if (changes) {
            this._updatingFrame = true;
            this.ctx.update();
            this.ctx.render();
            this._updatingFrame = false;
        }

        this.platform.nextFrame(changes);

        this.emit('frameEnd');

        this.frameCounter++;
    }

    isUpdatingFrame() {
        return this._updatingFrame;
    }

    renderFrame() {
        this.ctx.frame();
    }

    forceRenderUpdate() {
        // Enforce re-rendering.
        if (this.root) {
            this.root.core._parent.setHasRenderUpdates(1);
        }
    }

    setClearColor(clearColor) {
        this.forceRenderUpdate();
        if (clearColor === null) {
            // Do not clear.
            this._clearColor = null;
        } else if (Array.isArray(clearColor)) {
            this._clearColor = clearColor;
        } else {
            this._clearColor = _StageUtils_mjs__WEBPACK_IMPORTED_MODULE_14__["default"].getRgbaComponentsNormalized(clearColor);
        }
    }

    getClearColor() {
        return this._clearColor;
    }

    createElement(settings) {
        if (settings) {
            return this.element(settings);
        } else {
            return new _Element_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](this);
        }
    }

    createShader(settings) {
        return _Shader_mjs__WEBPACK_IMPORTED_MODULE_7__["default"].create(this, settings);
    }

    element(settings) {
        if (settings.isElement) return settings;

        let element;
        if (settings.type) {
            element = new settings.type(this);
        } else {
            element = new _Element_mjs__WEBPACK_IMPORTED_MODULE_15__["default"](this);
        }

        element.patch(settings);

        return element;
    }

    c(settings) {
        return this.element(settings);
    }

    get w() {
        return this._options.w;
    }

    get h() {
        return this._options.h;
    }

    get coordsWidth() {
        return this.w / this._options.precision;
    }

    get coordsHeight() {
        return this.h / this._options.precision;
    }

    addMemoryUsage(delta) {
        this._usedMemory += delta;
        if (this._lastGcFrame !== this.frameCounter) {
            if (this._usedMemory > this.getOption('memoryPressure')) {
                this.gc(false);
                if (this._usedMemory > this.getOption('memoryPressure') - 2e6) {
                    // Too few released. Aggressive cleanup.
                    this.gc(true);
                }
            }
        }
    }

    get usedMemory() {
        return this._usedMemory;
    }

    gc(aggressive) {
        if (this._lastGcFrame !== this.frameCounter) {
            this._lastGcFrame = this.frameCounter;
            const memoryUsageBefore = this._usedMemory;
            this.gcTextureMemory(aggressive);
            this.gcRenderTextureMemory(aggressive);
            this.renderer.gc(aggressive);

            if (this.application.getOption('debug')) {
                console.log(`[Lightning] GC${aggressive ? "[aggressive]" : ""}! Frame ${this._lastGcFrame} Freed ${((memoryUsageBefore - this._usedMemory) / 1e6).toFixed(2)}MP from GPU memory. Remaining: ${(this._usedMemory / 1e6).toFixed(2)}MP`);
                const other = this._usedMemory - this.textureManager.usedMemory - this.ctx.usedMemory;
                console.log(`[Lightning] Textures: ${(this.textureManager.usedMemory / 1e6).toFixed(2)}MP, Render Textures: ${(this.ctx.usedMemory / 1e6).toFixed(2)}MP, Renderer caches: ${(other / 1e6).toFixed(2)}MP`);
            }
        }
    }

    gcTextureMemory(aggressive = false) {
        if (aggressive && this.ctx.root.visible) {
            // Make sure that ALL textures are cleaned;
            this.ctx.root.visible = false;
            this.textureManager.gc();
            this.ctx.root.visible = true;
        } else {
            this.textureManager.gc();
        }
    }

    gcRenderTextureMemory(aggressive = false) {
        if (aggressive && this.root.visible) {
            // Make sure that ALL render textures are cleaned;
            this.root.visible = false;
            this.ctx.freeUnusedRenderTextures(0);
            this.root.visible = true;
        } else {
            this.ctx.freeUnusedRenderTextures(0);
        }
    }

    getDrawingCanvas() {
        return this.platform.getDrawingCanvas();
    }

    update() {
        this.ctx.update()
    }

    addServiceProvider(serviceprovider) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isSpark) {
            this.platform.addServiceProvider(serviceprovider);
        }
    }

    getChildrenByPosition(x, y){
        const children = [];
        this.root.core.update();
        this.root.core.collectAtCoord(x,y,children);

        return children;
    }
}











/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/StageUtils.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/StageUtils.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StageUtils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class StageUtils {

    static mergeNumbers(v1, v2, p) {
        return v1 * p + v2 * (1 - p);
    };

    static rgb(r, g, b) {
        return (r << 16) + (g << 8) + b + (255 * 16777216);
    };

    static rgba(r, g, b, a) {
        return (r << 16) + (g << 8) + b + (((a * 255) | 0) * 16777216);
    };

    static getRgbString(color) {
        let r = ((color / 65536) | 0) % 256;
        let g = ((color / 256) | 0) % 256;
        let b = color % 256;
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    };

    static getRgbaString(color) {
        let r = ((color / 65536) | 0) % 256;
        let g = ((color / 256) | 0) % 256;
        let b = color % 256;
        let a = ((color / 16777216) | 0) / 255;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
    };

    static getRgbaStringFromArray(color) {
        let r = Math.floor(color[0] * 255);
        let g = Math.floor(color[1] * 255);
        let b = Math.floor(color[2] * 255);
        let a = Math.floor(color[3] * 255) / 255;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a.toFixed(4) + ')';
    };

    static getRgbaComponentsNormalized(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r / 255, g / 255, b / 255, a / 255];
    };

    static getRgbComponentsNormalized(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        return [r / 255, g / 255, b / 255];
    };

    static getRgbaComponents(argb) {
        let r = ((argb / 65536) | 0) % 256;
        let g = ((argb / 256) | 0) % 256;
        let b = argb % 256;
        let a = ((argb / 16777216) | 0);
        return [r, g, b, a];
    };

    static getArgbNumber(rgba) {
        rgba[0] = Math.max(0, Math.min(255, rgba[0]));
        rgba[1] = Math.max(0, Math.min(255, rgba[1]));
        rgba[2] = Math.max(0, Math.min(255, rgba[2]));
        rgba[3] = Math.max(0, Math.min(255, rgba[3]));
        let v = ((rgba[3] | 0) << 24) + ((rgba[0] | 0) << 16) + ((rgba[1] | 0) << 8) + (rgba[2] | 0);
        if (v < 0) {
            v = 0xFFFFFFFF + v + 1;
        }
        return v;
    };

    static mergeColors(c1, c2, p) {
        let r1 = ((c1 / 65536) | 0) % 256;
        let g1 = ((c1 / 256) | 0) % 256;
        let b1 = c1 % 256;
        let a1 = ((c1 / 16777216) | 0);

        let r2 = ((c2 / 65536) | 0) % 256;
        let g2 = ((c2 / 256) | 0) % 256;
        let b2 = c2 % 256;
        let a2 = ((c2 / 16777216) | 0);

        let r = r1 * p + r2 * (1 - p);
        let g = g1 * p + g2 * (1 - p);
        let b = b1 * p + b2 * (1 - p);
        let a = a1 * p + a2 * (1 - p);

        return Math.round(a) * 16777216 + Math.round(r) * 65536 + Math.round(g) * 256 + Math.round(b);
    };

    static mergeMultiColors(c, p) {
        let r = 0, g = 0, b = 0, a = 0, t = 0;
        let n = c.length;
        for (let i = 0; i < n; i++) {
            let r1 = ((c[i] / 65536) | 0) % 256;
            let g1 = ((c[i] / 256) | 0) % 256;
            let b1 = c[i] % 256;
            let a1 = ((c[i] / 16777216) | 0);
            r += r1 * p[i];
            g += g1 * p[i];
            b += b1 * p[i];
            a += a1 * p[i];
            t += p[i];
        }

        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    };

    static mergeMultiColorsEqual(c) {
        let r = 0, g = 0, b = 0, a = 0, t = 0;
        let n = c.length;
        for (let i = 0; i < n; i++) {
            let r1 = ((c[i] / 65536) | 0) % 256;
            let g1 = ((c[i] / 256) | 0) % 256;
            let b1 = c[i] % 256;
            let a1 = ((c[i] / 16777216) | 0);
            r += r1;
            g += g1;
            b += b1;
            a += a1;
            t += 1.0;
        }

        t = 1 / t;
        return Math.round(a * t) * 16777216 + Math.round(r * t) * 65536 + Math.round(g * t) * 256 + Math.round(b * t);
    };

    static mergeColorAlpha(c, alpha) {
        let a = ((c / 16777216 | 0) * alpha) | 0;
        return (((((c >> 16) & 0xff) * a) / 255) & 0xff) +
            ((((c & 0xff00) * a) / 255) & 0xff00) +
            (((((c & 0xff) << 16) * a) / 255) & 0xff0000) +
            (a << 24);
    };

    static rad(deg) {
        return deg * (Math.PI / 180);
    };

    static getTimingBezier(a, b, c, d) {
        let xc = 3.0 * a;
        let xb = 3.0 * (c - a) - xc;
        let xa = 1.0 - xc - xb;
        let yc = 3.0 * b;
        let yb = 3.0 * (d - b) - yc;
        let ya = 1.0 - yc - yb;

        return function (time) {
            if (time >= 1.0) {
                return 1;
            }
            if (time <= 0) {
                return 0;
            }

            let t = 0.5, cbx, cbxd, dx;

            for (let it = 0; it < 20; it++) {
                cbx = t * (t * (t * xa + xb) + xc);
                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                    return t * (t * (t * ya + yb) + yc);
                }

                // Cubic bezier derivative.
                cbxd = t * (t * (3 * xa) + 2 * xb) + xc;

                if (cbxd > 1e-10 && cbxd < 1e-10) {
                    // Problematic. Fall back to binary search method.
                    break;
                }

                t += dx / cbxd;
            }

            // Fallback: binary search method. This is more reliable when there are near-0 slopes.
            let minT = 0;
            let maxT = 1;
            for (let it = 0; it < 20; it++) {
                t = 0.5 * (minT + maxT);

                cbx = t * (t * (t * xa + xb) + xc);

                dx = time - cbx;
                if (dx > -1e-8 && dx < 1e-8) {
                    // Solution found!
                    return t * (t * (t * ya + yb) + yc);
                }

                if (dx < 0) {
                    maxT = t;
                } else {
                    minT = t;
                }
            }

        };
    };

    static getTimingFunction(str) {
        switch (str) {
            case "linear":
                return function (time) {
                    return time
                };
            case "ease":
                return StageUtils.getTimingBezier(0.25, 0.1, 0.25, 1.0);
            case "ease-in":
                return StageUtils.getTimingBezier(0.42, 0, 1.0, 1.0);
            case "ease-out":
                return StageUtils.getTimingBezier(0, 0, 0.58, 1.0);
            case "ease-in-out":
                return StageUtils.getTimingBezier(0.42, 0, 0.58, 1.0);
            case "step-start":
                return function () {
                    return 1
                };
            case "step-end":
                return function (time) {
                    return time === 1 ? 1 : 0;
                };
            default:
                let s = "cubic-bezier(";
                if (str && str.indexOf(s) === 0) {
                    let parts = str.substr(s.length, str.length - s.length - 1).split(",");
                    if (parts.length !== 4) {
                        console.warn("[Lightning] Unknown timing function: " + str);

                        // Fallback: use linear.
                        return function (time) {
                            return time
                        };
                    }
                    let a = parseFloat(parts[0]);
                    let b = parseFloat(parts[1]);
                    let c = parseFloat(parts[2]);
                    let d = parseFloat(parts[3]);
                    if (isNaN(a) || isNaN(b) || isNaN(c) || isNaN(d)) {
                        console.warn("[Lightning] Unknown timing function: " + str);
                        // Fallback: use linear.
                        return function (time) {
                            return time
                        };
                    }

                    return StageUtils.getTimingBezier(a, b, c, d);
                } else {
                    console.warn("[Lightning] Unknown timing function: " + str);
                    // Fallback: use linear.
                    return function (time) {
                        return time
                    };
                }
        }
    };

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Texture.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Texture.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var _Base_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base.mjs */ "./node_modules/@lightningjs/core/src/tree/Base.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Texture {

    /**
     * @param {Stage} stage
     */
    constructor(stage) {
        this.stage = stage;

        this.manager = this.stage.textureManager;

        this.id = Texture.id++;

        /**
         * All enabled elements that use this texture object (either as texture or displayedTexture).
         * @type {Set<Element>}
         */
        this.elements = new Set();

        /**
         * The number of enabled elements that are active.
         * @type {number}
         */
        this._activeCount = 0;

        /**
         * The associated texture source.
         * Should not be changed.
         * @type {TextureSource}
         */
        this._source = null;

        /**
         * A resize mode can be set to cover or contain a certain area.
         * It will reset the texture clipping settings.
         * When manual texture clipping is performed, the resizeMode is reset.
         * @type {{type: string, width: number, height: number}}
         * @private
         */
        this._resizeMode = null;

        /**
         * The texture clipping x-offset.
         * @type {number}
         */
        this._x = 0;

        /**
         * The texture clipping y-offset.
         * @type {number}
         */
        this._y = 0;

        /**
         * The texture clipping width. If 0 then full width.
         * @type {number}
         */
        this._w = 0;

        /**
         * The texture clipping height. If 0 then full height.
         * @type {number}
         */
        this._h = 0;

        /**
         * Render precision (0.5 = fuzzy, 1 = normal, 2 = sharp even when scaled twice, etc.).
         * @type {number}
         * @private
         */
        this._precision = 1;

        /**
         * The (maximum) expected texture source width. Used for within bounds determination while texture is not yet loaded.
         * If not set, 2048 is used by ElementCore.update.
         * @type {number}
         */
        this.mw = 0;

        /**
         * The (maximum) expected texture source height. Used for within bounds determination while texture is not yet loaded.
         * If not set, 2048 is used by ElementCore.update.
         * @type {number}
         */
        this.mh = 0;

        /**
         * Indicates if Texture.prototype.texture uses clipping.
         * @type {boolean}
         */
        this.clipping = false;

        /**
         * Indicates whether this texture must update (when it becomes used again).
         * @type {boolean}
         * @private
         */
        this._mustUpdate = true;

    }

    get source() {
        if (this._mustUpdate || this.stage.hasUpdateSourceTexture(this)) {
            this._performUpdateSource(true);
            this.stage.removeUpdateSourceTexture(this);
        }
        return this._source;
    }

    addElement(v) {
        if (!this.elements.has(v)) {
            this.elements.add(v);

            if (this.elements.size === 1) {
                if (this._source) {
                    this._source.addTexture(this);
                }
            }

            if (v.active) {
                this.incActiveCount();
            }
        }
    }

    removeElement(v) {
        if (this.elements.delete(v)) {
            if (this.elements.size === 0) {
                if (this._source) {
                    this._source.removeTexture(this);
                }
            }

            if (v.active) {
                this.decActiveCount();
            }
        }
    }

    incActiveCount() {
        // Ensure that texture source's activeCount has transferred ownership.
        const source = this.source;

        if (source) {
            this._checkForNewerReusableTextureSource();
        }

        this._activeCount++;
        if (this._activeCount === 1) {
            this.becomesUsed();
        }
    }

    decActiveCount() {
        const source = this.source; // Force updating the source.
        this._activeCount--;
        if (!this._activeCount) {
            this.becomesUnused();
        }
    }

    becomesUsed() {
        if (this.source) {
            this.source.incActiveTextureCount();
        }
    }

    onLoad() {
        if (this._resizeMode) {
            this._applyResizeMode();
        }

        this.elements.forEach(element => {
            if (element.active) {
                element.onTextureSourceLoaded();
            }
        });
    }

    _checkForNewerReusableTextureSource() {
        // When this source became unused and cleaned up, it may have disappeared from the reusable texture map.
        // In the meantime another texture may have been generated loaded with the same lookup id.
        // If this is the case, use that one instead to make sure only one active texture source per lookup id exists.
        const source = this.source;
        if (!source.isLoaded()) {
            const reusable = this._getReusableTextureSource();
            if (reusable && reusable.isLoaded() && (reusable !== source)) {
                this._replaceTextureSource(reusable);
            }
        } else {
            if (this._resizeMode) {
                this._applyResizeMode();
            }
        }
    }

    becomesUnused() {
        if (this.source) {
            this.source.decActiveTextureCount();
        }
    }

    isUsed() {
        return this._activeCount > 0;
    }

    /**
     * Returns the lookup id for the current texture settings, to be able to reuse it.
     * @returns {string|null}
     */
    _getLookupId() {
        // Default: do not reuse texture.
        return null;
    }

    /**
     * Generates a loader function that is able to generate the texture for the current settings of this texture.
     * It should return a function that receives a single callback argument.
     * That callback should be called with the following arguments:
     *   - err
     *   - options: object
     *     - source: ArrayBuffer|WebGlTexture|ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|ImageBitmap
     *     - w: Number
     *     - h: Number
     *     - permanent: Boolean
     *     - hasAlpha: boolean
     *     - permultiplyAlpha: boolean
     *     - flipBlueRed: boolean
     *     - renderInfo: object
     * The loader itself may return a Function that is called when loading of the texture is cancelled. This can be used
     * to stop fetching an image when it is no longer in element, for example.
     */
    _getSourceLoader() {
        throw new Error("Texture.generate must be implemented.");
    }

    get isValid() {
        return this._getIsValid();
    }

    /**
     * If texture is not 'valid', no source can be created for it.
     * @returns {boolean}
     */
    _getIsValid() {
        return true;
    }

    /**
     * This must be called when the texture source must be re-generated.
     */
    _changed() {
        // If no element is actively using this texture, ignore it altogether.
        if (this.isUsed()) {
            this._updateSource();
        } else {
            this._mustUpdate = true;
        }
    }

    _updateSource() {
        // We delay all updateSource calls to the next drawFrame, so that we can bundle them.
        // Otherwise we may reload a texture more often than necessary, when, for example, patching multiple text
        // properties.
        this.stage.addUpdateSourceTexture(this);
    }

    _performUpdateSource(force = false) {
        // If, in the meantime, the texture was no longer used, just remember that it must update until it becomes used
        // again.
        if (force || this.isUsed()) {
            this._mustUpdate = false;
            let source = this._getTextureSource();
            this._replaceTextureSource(source);
        }
    }

    _getTextureSource() {
        let source = null;
        if (this._getIsValid()) {
            const lookupId = this._getLookupId();
            source = this._getReusableTextureSource(lookupId);
            if (!source) {
                source = this.manager.getTextureSource(this._getSourceLoader(), lookupId);
            }
        }
        return source;
    }

    _getReusableTextureSource(lookupId = this._getLookupId()) {
        if (this._getIsValid()) {
            if (lookupId) {
                return this.manager.getReusableTextureSource(lookupId);
            }
        }
        return null;
    }

    _replaceTextureSource(newSource = null) {
        let oldSource = this._source;

        this._source = newSource;

        if (this.elements.size) {
            if (oldSource) {
                if (this._activeCount) {
                    oldSource.decActiveTextureCount();
                }

                oldSource.removeTexture(this);
            }

            if (newSource) {
                // Must happen before setDisplayedTexture to ensure sprite map texcoords are used.
                newSource.addTexture(this);
                if (this._activeCount) {
                    newSource.incActiveTextureCount();
                }
            }
        }

        if (this.isUsed()) {
            if (newSource) {
                if (newSource.isLoaded()) {

                    // Apply resizeMode
                    if (this._resizeMode) {
                        this._applyResizeMode();
                    }

                    this.elements.forEach(element => {
                        if (element.active) {
                            element._setDisplayedTexture(this);
                        }
                    });
                } else {
                    const loadError = newSource.loadError;
                    if (loadError) {
                        this.elements.forEach(element => {
                            if (element.active) {
                                element.onTextureSourceLoadError(loadError);
                            }
                        });
                    }
                }
            } else {
                this.elements.forEach(element => {
                    if (element.active) {
                        element._setDisplayedTexture(null);
                    }
                });
            }
        }
    }

    load() {
        // Make sure that source is up to date.
        if (this.source) {
            if (!this.isLoaded()) {
                this.source.load(true);
            }
        }
    }

    isLoaded() {
        return this._source && this._source.isLoaded();
    }

    get loadError() {
        return this._source && this._source.loadError;
    }

    free() {
        if (this._source) {
            this._source.free();
        }
    }

    set resizeMode({type = "cover", w = 0, h = 0, clipX = 0.5, clipY = 0.5}) {
        this._resizeMode = {type, w, h, clipX, clipY};
        if (this.isLoaded()) {
            this._applyResizeMode();
        }
    }

    get resizeMode() {
        return this._resizeMode;
    }

    _clearResizeMode() {
        this._resizeMode = null;
    }

    _applyResizeMode() {
        if (this._resizeMode.type === "cover") {
            this._applyResizeCover();
        } else if (this._resizeMode.type === "contain") {
            this._applyResizeContain();
        }
        this._updatePrecision();
        this._updateClipping();
    }

    _applyResizeCover() {
        const scaleX = this._resizeMode.w / this._source.w;
        const scaleY = this._resizeMode.h / this._source.h;
        let scale = Math.max(scaleX, scaleY);
        if (!scale) return;
        this._precision = 1/scale;
        if (scaleX && scaleX < scale) {
            const desiredSize = this._precision * this._resizeMode.w;
            const choppedOffPixels = this._source.w - desiredSize;
            this._x = choppedOffPixels * this._resizeMode.clipX;
            this._w = this._source.w - choppedOffPixels;
        }
        if (scaleY && scaleY < scale) {
            const desiredSize = this._precision * this._resizeMode.h;
            const choppedOffPixels = this._source.h - desiredSize;
            this._y = choppedOffPixels * this._resizeMode.clipY;
            this._h = this._source.h - choppedOffPixels;
        }
    }

    _applyResizeContain() {
        const scaleX = this._resizeMode.w / this._source.w;
        const scaleY = this._resizeMode.h / this._source.h;
        let scale = scaleX;
        if (!scale || scaleY < scale) {
            scale = scaleY;
        }
        if (!scale) return;
        this._precision = 1/scale;
    }

    enableClipping(x, y, w, h) {
        this._clearResizeMode();

        x *= this._precision;
        y *= this._precision;
        w *= this._precision;
        h *= this._precision;
        if (this._x !== x || this._y !== y || this._w !== w || this._h !== h) {
            this._x = x;
            this._y = y;
            this._w = w;
            this._h = h;

            this._updateClipping(true);
        }
    }

    disableClipping() {
        this._clearResizeMode();

        if (this._x || this._y || this._w || this._h) {
            this._x = 0;
            this._y = 0;
            this._w = 0;
            this._h = 0;

            this._updateClipping();
        }
    }

    _updateClipping() {
        this.clipping = !!(this._x || this._y || this._w || this._h);

        let self = this;
        this.elements.forEach(function(element) {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === self) {
                element.onDisplayedTextureClippingChanged();
            }
        });
    }

    _updatePrecision() {
        let self = this;
        this.elements.forEach(function(element) {
            // Ignore if not the currently displayed texture.
            if (element.displayedTexture === self) {
                element.onPrecisionChanged();
            }
        });
    }

    getNonDefaults() {
        let nonDefaults = {};
        nonDefaults['type'] = this.constructor.name;
        if (this.x !== 0) nonDefaults['x'] = this.x;
        if (this.y !== 0) nonDefaults['y'] = this.y;
        if (this.w !== 0) nonDefaults['w'] = this.w;
        if (this.h !== 0) nonDefaults['h'] = this.h;
        if (this.precision !== 1) nonDefaults['precision'] = this.precision;
        return nonDefaults;
    }

    get px() {
        return this._x;
    }

    get py() {
        return this._y;
    }

    get pw() {
        return this._w;
    }

    get ph() {
        return this._h;
    }

    get x() {
        return this._x / this._precision;
    }
    set x(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._x !== v) {
            this._x = v;
            this._updateClipping();
        }
    }

    get y() {
        return this._y / this._precision;
    }
    set y(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._y !== v) {
            this._y = v;
            this._updateClipping();
        }
    }

    get w() {
        return this._w / this._precision;
    }

    set w(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._w !== v) {
            this._w = v;
            this._updateClipping();
        }
    }

    get h() {
        return this._h / this._precision;
    }

    set h(v) {
        this._clearResizeMode();
        v = v * this._precision;
        if (this._h !== v) {
            this._h = v;
            this._updateClipping();
        }
    }

    get precision() {
        return this._precision;
    }

    set precision(v) {
        this._clearResizeMode();
        if (this._precision !== v) {
            this._precision = v;
            this._updatePrecision();
        }
    }

    isAutosizeTexture() {
        return true;
    }

    getRenderWidth() {
        if (!this.isAutosizeTexture()) {
            // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
            return 0;
        }

        // If dimensions are unknown (texture not yet loaded), use maximum width as a fallback as render width to allow proper bounds checking.
        return (this._w || (this._source ? this._source.getRenderWidth() - this._x : 0)) / this._precision;
    }

    getRenderHeight() {
        if (!this.isAutosizeTexture()) {
            // In case of the rectangle texture, we'd prefer to not cause a 1x1 w,h as it would interfere with flex layout fit-to-contents.
            return 0;
        }

        return (this._h || (this._source ? this._source.getRenderHeight() - this._y : 0)) / this._precision;
    }

    patch(settings) {
        _Base_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].patchObject(this, settings);
    }

}

Texture.prototype.isTexture = true;

Texture.id = 0;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureManager.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureManager.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureManager)
/* harmony export */ });
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextureSource.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class TextureManager {

    constructor(stage) {
        this.stage = stage;

        /**
         * The currently used amount of texture memory.
         * @type {number}
         */
        this._usedMemory = 0;

        /**
         * All uploaded texture sources.
         * @type {TextureSource[]}
         */
        this._uploadedTextureSources = [];

        /**
         * The texture source lookup id to texture source hashmap.
         * @type {Map<String, TextureSource>}
         */
        this.textureSourceHashmap = new Map();

    }

    get usedMemory() {
        return this._usedMemory;
    }

    destroy() {
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            this._nativeFreeTextureSource(this._uploadedTextureSources[i]);
        }
        
        this.textureSourceHashmap.clear();
        this._usedMemory = 0;
    }

    getReusableTextureSource(id) {
        return this.textureSourceHashmap.get(id);
    }

    getTextureSource(func, id) {
        // Check if texture source is already known.
        let textureSource = id ? this.textureSourceHashmap.get(id) : null;
        if (!textureSource) {
            // Create new texture source.
            textureSource = new _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this, func);

            if (id) {
                textureSource.lookupId = id;
                this.textureSourceHashmap.set(id, textureSource);
            }
        }

        return textureSource;
    }

    uploadTextureSource(textureSource, options) {
        if (textureSource.isLoaded()) return;

        this._addMemoryUsage(textureSource.w * textureSource.h);

        // Load texture.
        const nativeTexture = this._nativeUploadTextureSource(textureSource, options);

        textureSource._nativeTexture = nativeTexture;

        // We attach w and h to native texture (we need it in CoreRenderState._isRenderTextureReusable).
        nativeTexture.w = textureSource.w;
        nativeTexture.h = textureSource.h;

        nativeTexture.update = this.stage.frameCounter;

        this._uploadedTextureSources.push(textureSource);
        
        this.addToLookupMap(textureSource);
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }
    
    addToLookupMap(textureSource) {
        const lookupId = textureSource.lookupId;
        if (lookupId) {
            if (!this.textureSourceHashmap.has(lookupId)) {
                this.textureSourceHashmap.set(lookupId, textureSource);
            }
        }
    }

    gc() {
        this.freeUnusedTextureSources();
        this._cleanupLookupMap();
    }
    
    freeUnusedTextureSources() {
        let remainingTextureSources = [];
        for (let i = 0, n = this._uploadedTextureSources.length; i < n; i++) {
            let ts = this._uploadedTextureSources[i];
            if (ts.allowCleanup()) {
                this._freeManagedTextureSource(ts);
            } else {
                remainingTextureSources.push(ts);
            }
        }

        this._uploadedTextureSources = remainingTextureSources;

        this._cleanupLookupMap();
    }

    _freeManagedTextureSource(textureSource) {
        if (textureSource.isLoaded()) {
            this._nativeFreeTextureSource(textureSource);
            this._addMemoryUsage(-textureSource.w * textureSource.h);
        }

        // Should be reloaded.
        textureSource.loadingSince = null;
    }

    _cleanupLookupMap() {
        // We keep those that still have value (are being loaded or already loaded, or are likely to be reused).
        this.textureSourceHashmap.forEach((textureSource, lookupId) => {
            if (!(textureSource.isLoaded() || textureSource.isLoading()) && !textureSource.isUsed()) {
                this.textureSourceHashmap.delete(lookupId);
            }
        });
    }

    /**
     * Externally free texture source.
     * @param textureSource
     */
    freeTextureSource(textureSource) {
        const index = this._uploadedTextureSources.indexOf(textureSource);
        const managed = (index !== -1);

        if (textureSource.isLoaded()) {
            if (managed) {
                this._addMemoryUsage(-textureSource.w * textureSource.h);
                this._uploadedTextureSources.splice(index, 1);
            }
            this._nativeFreeTextureSource(textureSource);
        }

        // Should be reloaded.
        textureSource.loadingSince = null;
    }

    _nativeUploadTextureSource(textureSource, options) {
        return this.stage.renderer.uploadTextureSource(textureSource, options);
    }

    _nativeFreeTextureSource(textureSource) {
        this.stage.renderer.freeTextureSource(textureSource);
        textureSource.clearNativeTexture();
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureSource.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureSource)
/* harmony export */ });
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class TextureSource {

    constructor(manager, loader = null) {
        this.id = TextureSource.id++;

        this.manager = manager;

        this.stage = manager.stage;

        /**
         * All enabled textures (textures that are used by visible elements).
         * @type {Set<Texture>}
         */
        this.textures = new Set();

        /**
         * The number of active textures (textures that have at least one active element).
         * @type {number}
         * @private
         */
        this._activeTextureCount = 0;

        /**
         * The factory for the source of this texture.
         * @type {Function}
         */
        this.loader = loader;

        /**
         * Identifier for reuse.
         * @type {String}
         */
        this.lookupId = null;

        /**
         * If set, this.is called when the texture source is no longer displayed (this.components.size becomes 0).
         * @type {Function}
         */
        this._cancelCb = null;

        /**
         * Loading since timestamp in millis.
         * @type {number}
         */
        this.loadingSince = 0;

        this.w = 0;
        this.h = 0;

        this._nativeTexture = null;

        /**
         * If true, then this.texture source is never freed from memory during garbage collection.
         * @type {boolean}
         */
        this.permanent = false;

        /**
         * Sub-object with texture-specific rendering information.
         * For images, contains the src property, for texts, contains handy rendering information.
         * @type {Object}
         */
        this.renderInfo = null;

        /**
         * Generated for 'renderToTexture'.
         * @type {boolean}
         * @private
         */
        this._isResultTexture = !this.loader;

        /**
         * Contains the load error, if the texture source could previously not be loaded.
         * @type {object}
         * @private
         */
        this._loadError = null;

        /**
         *  Hold a reference to the javascript variable which contains the texture, this is not required for WebGL in WebBrowsers but is required for Spark runtime.
         * @type {object}
         * @private
         */
        this._imageRef = null;

    }

    get loadError() {
        return this._loadError;
    }

    addTexture(v) {
        if (!this.textures.has(v)) {
            this.textures.add(v);
        }
    }

    removeTexture(v) {
        this.textures.delete(v);
    }

    incActiveTextureCount() {
        this._activeTextureCount++;
        if (this._activeTextureCount === 1) {
            this.becomesUsed();
        }
    }

    decActiveTextureCount() {
        this._activeTextureCount--;
        if (this._activeTextureCount === 0) {
            this.becomesUnused();
        }
    }

    get isResultTexture() {
        return this._isResultTexture;
    }

    set isResultTexture(v) {
        this._isResultTexture = v;
    }

    forEachEnabledElement(cb) {
        this.textures.forEach(texture => {
            texture.elements.forEach(cb);
        });
    }

    hasEnabledElements() {
        return this.textures.size > 0;
    }

    forEachActiveElement(cb) {
        this.textures.forEach(texture => {
            texture.elements.forEach(element => {
                if (element.active) {
                    cb(element);
                }
            });
        });
    }

    getRenderWidth() {
        return this.w;
    }

    getRenderHeight() {
        return this.h;
    }

    allowCleanup() {
        return !this.permanent && !this.isUsed();
    }

    becomesUsed() {
        // Even while the texture is being loaded, make sure it is on the lookup map so that others can reuse it.
        this.load();
    }

    becomesUnused() {
        this.cancel();
    }

    cancel() {
        if (this.isLoading()) {
            if (this._cancelCb) {
                this._cancelCb(this);

                // Clear callback to avoid memory leaks.
                this._cancelCb = null;
            }
            this.loadingSince = 0;
        }
    }

    isLoaded() {
        return !!this._nativeTexture;
    }

    isLoading() {
        return (this.loadingSince > 0);
    }

    isError() {
        return !!this._loadError;
    }

    reload() {
        this.free();
        if (this.isUsed()) {
            this.load();
        }
    }

    load(forceSync = false) {
        // From the moment of loading (when a texture source becomes used by active elements)
        if (this.isResultTexture) {
            // Element result texture source, for which the loading is managed by the core.
            return;
        }

        if (!this._nativeTexture && !this.isLoading()) {
            this.loadingSince = (new Date()).getTime();
            this._cancelCb = this.loader((err, options) => {
                // Ignore loads that come in after a cancel.
                if (this.isLoading()) {
                    // Clear callback to avoid memory leaks.
                    this._cancelCb = null;

                    if (this.manager.stage.destroyed) {
                        // Ignore async load when stage is destroyed.
                        return;
                    }
                    if (err) {
                        // Emit txError.
                        this.onError(err);
                    } else if (options && options.source) {
                        if (!this.stage.isUpdatingFrame() && !forceSync && (options.throttle !== false)) {
                            const textureThrottler = this.stage.textureThrottler;
                            this._cancelCb = textureThrottler.genericCancelCb;
                            textureThrottler.add(this, options);
                        } else {
                            this.processLoadedSource(options);
                        }
                    }
                }
            }, this);
        }
    }

    processLoadedSource(options) {
        this.loadingSince = 0;
        this.setSource(options);
    }

    setSource(options) {
        const source = options.source;

        this.w = source.width || (options && options.w) || 0;
        this.h = source.height || (options && options.h) || 0;

        if (options && options.renderInfo) {
            // Assign to id in cache so that it can be reused.
            this.renderInfo = options.renderInfo;
        }

        this.permanent = !!options.permanent;

        if (options && options.imageRef)
            this._imageRef = options.imageRef;
        if (options && options.flipTextureY) {
            this._flipTextureY = options.flipTextureY;
        } else {
            this._flipTextureY = false;
        }

        if (this._isNativeTexture(source)) {
            // Texture managed by caller.
            this._nativeTexture = source;

            this.w = this.w || source.w;
            this.h = this.h || source.h;

            // WebGLTexture objects are by default;
            this.permanent = options.hasOwnProperty('permanent') ? options.permanent : true;
        } else {
            this.manager.uploadTextureSource(this, options);
        }

        // Must be cleared when reload is succesful.
        this._loadError = null;

        this.onLoad();
    }

    isUsed() {
        return this._activeTextureCount > 0;
    }

    onLoad() {
        if (this.isUsed()) {
            this.textures.forEach(texture => {
                texture.onLoad();
            });
        }
    }

    forceRenderUpdate() {
        // Userland should call this method after changing the nativeTexture manually outside of the framework
        //  (using tex[Sub]Image2d for example).

        if (this._nativeTexture) {
            // Change 'update' flag. This is currently not used by the framework but is handy in userland.
            this._nativeTexture.update = this.stage.frameCounter;
        }

        this.forEachActiveElement(function (element) {
            element.forceRenderUpdate();
        });

    }

    forceUpdateRenderCoords() {
        this.forEachActiveElement(function (element) {
            element._updateTextureCoords();
        });
    }

    get nativeTexture() {
        return this._nativeTexture;
    }

    clearNativeTexture() {
        this._nativeTexture = null;
        //also clear the reference to the texture variable.
        this._imageRef = null;
    }

    /**
     * Used for result textures.
     */
    replaceNativeTexture(newNativeTexture, w, h) {
        let prevNativeTexture = this._nativeTexture;
        // Loaded by core.
        this._nativeTexture = newNativeTexture;
        this.w = w;
        this.h = h;

        if (!prevNativeTexture && this._nativeTexture) {
            this.forEachActiveElement(element => element.onTextureSourceLoaded());
        }

        if (!this._nativeTexture) {
            this.forEachActiveElement(element => element._setDisplayedTexture(null));
        }

        // Dimensions must be updated also on enabled elements, as it may force it to go within bounds.
        this.forEachEnabledElement(element => element._updateDimensions());

        // Notice that the sprite map must never contain render textures.
    }

    onError(e) {
        this._loadError = e;
        this.loadingSince = 0;
        console.error('[Lightning] texture load error', e, this.lookupId);
        this.forEachActiveElement(element => element.onTextureSourceLoadError(e));
    }

    free() {
        if (this.isLoaded()) {
            this.manager.freeTextureSource(this);
        }
    }

    _isNativeTexture(source) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].isNode) {
            return source.constructor.name === "WebGLTexture";
        }

        if ('WebGLTexture' in window) {
            return source instanceof WebGLTexture;
        }

        return false;
    }

}

TextureSource.prototype.isTextureSource = true;

TextureSource.id = 1;




/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/TextureThrottler.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureThrottler)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Allows throttling of loading texture sources, keeping the app responsive.
 */
class TextureThrottler {

    constructor(stage) {
        this.stage = stage;

        this.genericCancelCb = (textureSource) => {
            this._remove(textureSource);
        };

        this._sources = [];
        this._data = [];
    }

    destroy() {
        this._sources = [];
        this._data = [];
    }

    processSome() {
        if (this._sources.length) {
            const start = Date.now();
            do {
                this._processItem();
            } while(this._sources.length && (Date.now() - start < TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME));
        }
    }

    _processItem() {
        const source = this._sources.pop();
        const data = this._data.pop();
        if (source.isLoading()) {
            source.processLoadedSource(data);
        }
    }

    add(textureSource, data) {
        this._sources.push(textureSource);
        this._data.push(data);
    }

    _remove(textureSource) {
        const index = this._sources.indexOf(textureSource);
        if (index >= 0) {
            this._sources.splice(index, 1);
            this._data.splice(index, 1);
        }
    }

}

TextureThrottler.MAX_UPLOAD_TIME_PER_FRAME = 10;


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/Utils.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/Utils.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Utils)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class Utils {

    static isFunction(value) {
        return typeof value === 'function';
    }

    static isNumber(value) {
        return typeof value === 'number';
    }

    static isInteger(value) {
        return (typeof value === 'number' && (value % 1) === 0);
    }

    static isBoolean(value) {
        return value === true || value === false;
    }

    static isString(value) {
        return typeof value === 'string';
    }

    static clone(v) {
        if (Utils.isObjectLiteral(v) || Array.isArray(v)) {
            return Utils.getDeepClone(v);
        } else {
            // Copy by value.
            return v;
        }
    }

    static cloneObjShallow(obj) {
        let keys = Object.keys(obj);
        let clone = {}
        for (let i = 0; i < keys.length; i++) {
            clone[keys[i]] = obj[keys[i]];
        }
        return clone;
    }

    static merge(obj1, obj2) {
        let keys = Object.keys(obj2);
        for (let i = 0; i < keys.length; i++) {
            obj1[keys[i]] = obj2[keys[i]];
        }
        return obj1;
    }

    static isObject(value) {
        let type = typeof value;
        return !!value && (type === 'object' || type === 'function');
    }

    static isPlainObject(value) {
        let type = typeof value;
        return !!value && (type === 'object');
    }

    static isObjectLiteral(value){
        return typeof value === 'object' && value && value.constructor === Object;
    }

    static getArrayIndex(index, arr) {
        return Utils.getModuloIndex(index, arr.length);
    }

    static getModuloIndex(index, len) {
        if (len === 0) return index;
        while (index < 0) {
            index += Math.ceil(-index / len) * len;
        }
        index = index % len;
        return index;
    }

    static getDeepClone(obj) {
        let i, c;
        if (Utils.isFunction(obj)) {
            // Copy functions by reference.
            return obj;
        }
        if (Array.isArray(obj)) {
            c = [];
            let keys = Object.keys(obj);
            for (i = 0; i < keys.length; i++) {
                c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
            }
            return c;
        } else if (Utils.isObject(obj)) {
            c = {}
            let keys = Object.keys(obj);
            for (i = 0; i < keys.length; i++) {
                c[keys[i]] = Utils.getDeepClone(obj[keys[i]]);
            }
            return c;
        } else {
            return obj;
        }
    }

    static equalValues(v1, v2) {
        if ((typeof v1) !== (typeof v2)) return false;
        if (Utils.isObjectLiteral(v1)) {
            return Utils.isObjectLiteral(v2) && Utils.equalObjectLiterals(v1, v2);
        } else if (Array.isArray(v1)) {
            return Array.isArray(v2) && Utils.equalArrays(v1, v2);
        } else {
            return v1 === v2;
        }
    }

    static equalObjectLiterals(obj1, obj2) {
        let keys1 = Object.keys(obj1);
        let keys2 = Object.keys(obj2);
        if (keys1.length !== keys2.length) {
            return false;
        }

        for (let i = 0, n = keys1.length; i < n; i++) {
            const k1 = keys1[i];
            const k2 = keys2[i];
            if (k1 !== k2) {
                return false;
            }

            const v1 = obj1[k1];
            const v2 = obj2[k2];

            if (!Utils.equalValues(v1, v2)) {
                return false;
            }
        }

        return true;
    }

    static equalArrays(v1, v2) {
        if (v1.length !== v2.length) {
            return false;
        }
        for (let i = 0, n = v1.length; i < n; i++) {
            if (!this.equalValues(v1[i], v2[i])) {
                return false;
            }
        }

        return true;
    }

    static setToArray(s) {
        let result = [];
        s.forEach(function (value) {
            result.push(value);
        });
        return result;
    }

    static iteratorToArray(iterator) {
        let result = [];
        let iteratorResult = iterator.next();
        while (!iteratorResult.done) {
            result.push(iteratorResult.value);
            iteratorResult = iterator.next();
        }
        return result;
    }

    static isUcChar(charcode) {
        return charcode >= 65 && charcode <= 90;
    }

}

Utils.isWeb = (typeof window !== "undefined") && (typeof sparkscene === "undefined");
Utils.isWPE = Utils.isWeb && (navigator.userAgent.indexOf("WPE") !== -1);
Utils.isSpark = (typeof sparkscene !== "undefined");
Utils.isNode = (typeof window === "undefined") || Utils.isSpark;
Utils.isPS4 = Utils.isWeb && (navigator.userAgent.indexOf("PlayStation 4") !== -1);


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreContext.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreContext)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreContext {

    constructor(stage) {
        this.stage = stage;

        this.root = null;

        this.updateTreeOrder = 0;

        this.renderState = this.stage.renderer.createCoreRenderState(this);

        this.renderExec = this.stage.renderer.createCoreRenderExecutor(this);
        this.renderExec.init();

        this._usedMemory = 0;
        this._renderTexturePool = [];

        this._renderTextureId = 1;

        this._zSorts = [];
    }

    get usedMemory() {
        return this._usedMemory;
    }

    destroy() {
        this._renderTexturePool.forEach(texture => this._freeRenderTexture(texture));
        this._usedMemory = 0;
    }

    hasRenderUpdates() {
        return !!this.root._parent._hasRenderUpdates;
    }

    render() {
        // Clear flag to identify if anything changes before the next frame.
        this.root._parent._hasRenderUpdates = 0;

        this._render();
    }

    update() {
        this._update();

        // Due to the boundsVisibility flag feature (and onAfterUpdate hook), it is possible that other elements were
        // changed during the update loop (for example due to the txLoaded event). We process these changes immediately
        // (but not recursively to prevent infinite loops).
        if (this.root._hasUpdates) {
            this._update();
        }

        this._performForcedZSorts();
    }

    /**
     * Certain ElementCore items may be forced to zSort to strip out references to prevent memleaks..
     */
    _performForcedZSorts() {
        const n = this._zSorts.length;
        if (n) {
            // Forced z-sorts (ElementCore may force a z-sort in order to free memory/prevent memory leaks).
            for (let i = 0, n = this._zSorts.length; i < n; i++) {
                if (this._zSorts[i].zSort) {
                    this._zSorts[i].sortZIndexedChildren();
                }
            }
            this._zSorts = [];
        }
    }

    _update() {
        this.updateTreeOrder = 0;

        this.root.update();
    }

    _render() {
        // Obtain a sequence of the quad operations.
        this._fillRenderState();

        if (this.stage.getOption('readPixelsBeforeDraw')) {
            const pixels = new Uint8Array(4);
            const gl = this.stage.gl;
            gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        }

        // Now run them with the render executor.
        this._performRender();
    }

    _fillRenderState() {
        this.renderState.reset();
        this.root.render();
        this.renderState.finish();
    }

    _performRender() {
        this.renderExec.execute();
    }

    _addMemoryUsage(delta) {
        this._usedMemory += delta;
        this.stage.addMemoryUsage(delta);
    }

    allocateRenderTexture(w, h) {
        let prec = this.stage.getRenderPrecision();
        let pw = Math.max(1, Math.round(w * prec));
        let ph = Math.max(1, Math.round(h * prec));

        // Search last item first, so that last released render texture is preferred (may cause memory cache benefits).
        const n = this._renderTexturePool.length;
        for (let i = n - 1; i >= 0; i--) {
            const texture = this._renderTexturePool[i];
            // We don't want to reuse the same render textures within the same frame because that will create gpu stalls.
            if (texture.w === pw && texture.h === ph && (texture.update !== this.stage.frameCounter)) {
                texture.f = this.stage.frameCounter;
                this._renderTexturePool.splice(i, 1);
                return texture;
            }
        }

        const texture = this._createRenderTexture(w, h, pw, ph);
        texture.precision = prec;
        return texture;
    }

    releaseRenderTexture(texture) {
        this._renderTexturePool.push(texture);
    }

    freeUnusedRenderTextures(maxAge = 60) {
        // Clean up all textures that are no longer used.
        // This cache is short-lived because it is really just meant to supply running shaders that are
        // updated during a number of frames.
        let limit = this.stage.frameCounter - maxAge;

        this._renderTexturePool = this._renderTexturePool.filter(texture => {
            if (texture.f <= limit) {
                this._freeRenderTexture(texture);
                return false;
            }
            return true;
        });
    }

    _createRenderTexture(w, h, pw, ph) {
        this._addMemoryUsage(pw * ph);

        const texture = this.stage.renderer.createRenderTexture(w, h, pw, ph);
        texture.id = this._renderTextureId++;
        texture.f = this.stage.frameCounter;
        texture.ow = w;
        texture.oh = h;
        texture.w = pw;
        texture.h = ph;

        return texture;
    }

    _freeRenderTexture(nativeTexture) {
        this.stage.renderer.freeRenderTexture(nativeTexture);
        this._addMemoryUsage(-nativeTexture.w * nativeTexture.h);
    }

    copyRenderTexture(renderTexture, nativeTexture, options) {
        this.stage.renderer.copyRenderTexture(renderTexture, nativeTexture, options);
    }

    forceZSort(elementCore) {
        this._zSorts.push(elementCore);
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreQuadList.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreQuadList)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class CoreQuadList {

    constructor(ctx) {

        this.ctx = ctx;

        this.quadTextures = [];

        this.quadElements = [];
    }

    get length() {
        return this.quadTextures.length;
    }

    reset() {
        this.quadTextures = [];
        this.quadElements = [];
        this.dataLength = 0;
    }

    getElement(index) {
        return this.quadElements[index]._element;
    }

    getElementCore(index) {
        return this.quadElements[index];
    }

    getTexture(index) {
        return this.quadTextures[index];
    }

    getTextureWidth(index) {
        let nativeTexture = this.quadTextures[index];
        if (nativeTexture.w) {
            // Render texture;
            return nativeTexture.w;
        } else {
            return this.quadElements[index]._displayedTextureSource.w;
        }
    }

    getTextureHeight(index) {
        let nativeTexture = this.quadTextures[index];
        if (nativeTexture.h) {
            // Render texture;
            return nativeTexture.h;
        } else {
            return this.quadElements[index]._displayedTextureSource.h;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreQuadOperation.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreQuadOperation)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreQuadOperation {

    constructor(ctx, shader, shaderOwner, renderTextureInfo, scissor, index) {

        this.ctx = ctx;
        this.shader = shader;
        this.shaderOwner = shaderOwner;
        this.renderTextureInfo = renderTextureInfo;
        this.scissor = scissor;
        this.index = index;
        this.length = 0;

    }

    get quads() {
        return this.ctx.renderState.quads;
    }

    getTexture(index) {
        return this.quads.getTexture(this.index + index);
    }

    getElementCore(index) {
        return this.quads.getElementCore(this.index + index);
    }

    getElement(index) {
        return this.quads.getElement(this.index + index);
    }

    getElementWidth(index) {
        return this.getElement(index).renderWidth;
    }

    getElementHeight(index) {
        return this.getElement(index).renderHeight;
    }

    getTextureWidth(index) {
        return this.quads.getTextureWidth(this.index + index);
    }

    getTextureHeight(index) {
        return this.quads.getTextureHeight(this.index + index);
    }

    getRenderWidth() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.w;
        } else {
            return this.ctx.stage.w;
        }
    }

    getRenderHeight() {
        if (this.renderTextureInfo) {
            return this.renderTextureInfo.h;
        } else {
            return this.ctx.stage.h;
        }
    }

}


/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreRenderExecutor.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreRenderExecutor)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


class CoreRenderExecutor {

    constructor(ctx) {
        this.ctx = ctx;

        this.renderState = ctx.renderState;

        this.gl = this.ctx.stage.gl;
    }

    destroy() {
    }

    _reset() {
        this._bindRenderTexture(null);
        this._setScissor(null);
        this._clearRenderTexture();
    }

    execute() {
        this._reset();

        let qops = this.renderState.quadOperations;

        let i = 0, j = 0, n = qops.length;
        while (i < n) {
            this._processQuadOperation(qops[i]);
            i++;
        }
    }

    _processQuadOperation(quadOperation) {
        if (quadOperation.renderTextureInfo && quadOperation.renderTextureInfo.ignore) {
            // Ignore quad operations when we are 're-using' another texture as the render texture result.
            return;
        }

        this._setupQuadOperation(quadOperation);
        this._execQuadOperation(quadOperation);

    }

    _setupQuadOperation(quadOperation) {
    }

    _execQuadOperation(op) {
        // Set render texture.
        let nativeTexture = op.renderTextureInfo ? op.renderTextureInfo.nativeTexture : null;

        if (this._renderTexture !== nativeTexture) {
            this._bindRenderTexture(nativeTexture);
        }

        if (op.renderTextureInfo && !op.renderTextureInfo.cleared) {
            this._setScissor(null);
            this._clearRenderTexture();
            op.renderTextureInfo.cleared = true;
            this._setScissor(op.scissor);
        } else {
            this._setScissor(op.scissor);
        }

        this._renderQuadOperation(op);
    }

    _renderQuadOperation(op) {
    }

    _bindRenderTexture(renderTexture) {
        this._renderTexture = renderTexture;
    }

    _clearRenderTexture(renderTexture) {
    }

    _setScissor(area) {
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/CoreRenderState.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CoreRenderState)
/* harmony export */ });
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class CoreRenderState {

    constructor(ctx) {
        this.ctx = ctx;

        this.stage = ctx.stage;

        this.defaultShader = this.stage.renderer.getDefaultShader(ctx);

        this.renderer = ctx.stage.renderer;

        this.quads = this.renderer.createCoreQuadList(ctx);

    }

    reset() {
        this._renderTextureInfo = null;

        this._scissor = null;

        this._shader = null;

        this._shaderOwner = null;

        this._realShader = null;

        this._check = false;

        this.quadOperations = [];

        this._texturizer = null;

        this._texturizerTemporary = false;

        this._quadOperation = null;

        this.quads.reset();

        this._temporaryTexturizers = [];
        
        this._isCachingTexturizer = false;

    }

    get length() {
        return this.quads.quadTextures.length;
    }

    setShader(shader, owner) {
        if (this._shaderOwner !== owner || this._realShader !== shader) {
            // Same shader owner: active shader is also the same.
            // Prevent any shader usage to save performance.

            this._realShader = shader;

            if (shader.useDefault()) {
                // Use the default shader when possible to prevent unnecessary program changes.
                shader = this.defaultShader;
            }
            if (this._shader !== shader || this._shaderOwner !== owner) {
                this._shader = shader;
                this._shaderOwner = owner;
                this._check = true;
            }
        }
    }

    get renderTextureInfo() {
        return this._renderTextureInfo;
    }

    setScissor(area) {
        if (this._scissor !== area) {
            if (area) {
                this._scissor = area;
            } else {
                this._scissor = null;
            }
            this._check = true;
        }
    }

    getScissor() {
        return this._scissor;
    }

    setRenderTextureInfo(renderTextureInfo) {
        if (this._renderTextureInfo !== renderTextureInfo) {
            this._renderTextureInfo = renderTextureInfo;
            this._scissor = null;
            this._check = true;
        }
    }

    /**
     * Sets the texturizer to be drawn during subsequent addQuads.
     * @param {ElementTexturizer} texturizer
     */
    setTexturizer(texturizer, cache = false) {
        this._texturizer = texturizer;
        this._cacheTexturizer = cache;
    }

    set isCachingTexturizer(v) {
        this._isCachingTexturizer = v;
    }

    get isCachingTexturizer() {
        return this._isCachingTexturizer;
    }

    addQuad(elementCore) {
        if (!this._quadOperation) {
            this._createQuadOperation();
        } else if (this._check && this._hasChanges()) {
            this._finishQuadOperation();
            this._check = false;
        }

        let nativeTexture = null;
        if (this._texturizer) {
            nativeTexture = this._texturizer.getResultTexture();

            if (!this._cacheTexturizer) {
                // We can release the temporary texture immediately after finalizing this quad operation.
                this._temporaryTexturizers.push(this._texturizer);
            }
        }

        if (!nativeTexture) {
            nativeTexture = elementCore._displayedTextureSource.nativeTexture;
        }

        if (this._renderTextureInfo) {
            if (this._shader === this.defaultShader && this._renderTextureInfo.empty) {
                // The texture might be reusable under some conditions. We will check them in ElementCore.renderer.
                this._renderTextureInfo.nativeTexture = nativeTexture;
                this._renderTextureInfo.offset = this.length;
            } else {
                // It is not possible to reuse another texture when there is more than one quad.
                this._renderTextureInfo.nativeTexture = null;
            }
            this._renderTextureInfo.empty = false;
        }

        this.quads.quadTextures.push(nativeTexture);
        this.quads.quadElements.push(elementCore);

        this._quadOperation.length++;

        this.renderer.addQuad(this, this.quads, this.length - 1)
    }

    finishedRenderTexture() {
        if (this._renderTextureInfo.nativeTexture) {
            // There was only one texture drawn in this render texture.
            // Check if we can reuse it so that we can optimize out an unnecessary render texture operation.
            // (it should exactly span this render texture).
            if (!this._isRenderTextureReusable()) {
                this._renderTextureInfo.nativeTexture = null;
            }
        }
    }

    _isRenderTextureReusable() {
        const offset = this._renderTextureInfo.offset;
        return (this.quads.quadTextures[offset].w === this._renderTextureInfo.w) &&
            (this.quads.quadTextures[offset].h === this._renderTextureInfo.h) &&
            this.renderer.isRenderTextureReusable(this, this._renderTextureInfo)
    }

    _hasChanges() {
        let q = this._quadOperation;
        if (this._shader !== q.shader) return true;
        if (this._shaderOwner !== q.shaderOwner) return true;
        if (this._renderTextureInfo !== q.renderTextureInfo) return true;
        if (this._scissor !== q.scissor) {
            if ((this._scissor[0] !== q.scissor[0]) || (this._scissor[1] !== q.scissor[1]) || (this._scissor[2] !== q.scissor[2]) || (this._scissor[3] !== q.scissor[3])) {
                return true;
            }
        }

        return false;
    }

    _finishQuadOperation(create = true) {
        if (this._quadOperation) {
            if (this._quadOperation.length || this._shader.addEmpty()) {
                if (!this._quadOperation.scissor || ((this._quadOperation.scissor[2] > 0) && (this._quadOperation.scissor[3] > 0))) {
                    // Ignore empty clipping regions.
                    this.quadOperations.push(this._quadOperation);
                }
            }

            if (this._temporaryTexturizers.length) {
                for (let i = 0, n = this._temporaryTexturizers.length; i < n; i++) {
                    // We can now reuse these render-to-textures in subsequent stages.
                    // Huge performance benefit when filtering (fast blur).
                    this._temporaryTexturizers[i].releaseRenderTexture();
                }
                this._temporaryTexturizers = [];
            }

            this._quadOperation = null;
        }

        if (create) {
            this._createQuadOperation();
        }
    }

    _createQuadOperation() {
        this._quadOperation = this.renderer.createCoreQuadOperation(
            this.ctx,
            this._shader,
            this._shaderOwner,
            this._renderTextureInfo,
            this._scissor,
            this.length
        );
        this._check = false;
    }

    finish() {
        if (this._quadOperation) {
            // Add remaining.
            this._finishQuadOperation(false);
        }

        this.renderer.finishRenderState(this);
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/ElementCore.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementCore)
/* harmony export */ });
/* harmony import */ var _flex_FlexTarget_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../flex/FlexTarget.mjs */ "./node_modules/@lightningjs/core/src/flex/FlexTarget.mjs");
/* harmony import */ var _ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ElementTexturizer.mjs */ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs");
/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils.mjs */ "./node_modules/@lightningjs/core/src/tree/Utils.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ElementCore {

    constructor(element) {
        this._element = element;

        this.ctx = element.stage.ctx;

        // The memory layout of the internal variables is affected by their position in the constructor.
        // It boosts performance to order them by usage of cpu-heavy functions (renderSimple and update).

        this._recalc = 0;

        this._parent = null;

        this._onUpdate = null;

        this._pRecalc = 0;

        this._worldContext = new ElementCoreContext();

        this._hasUpdates = false;

        this._localAlpha = 1;

        this._onAfterCalcs = null;

        this._onAfterUpdate = null;

        // All local translation/transform updates: directly propagated from x/y/w/h/scale/whatever.
        this._localPx = 0;
        this._localPy = 0;

        this._localTa = 1;
        this._localTb = 0;
        this._localTc = 0;
        this._localTd = 1;

        this._isComplex = false;

        this._dimsUnknown = false;

        this._clipping = false;

        // Used by both update and render.
        this._zSort = false;

        this._outOfBounds = 0;

        /**
         * The texture source to be displayed.
         * @type {TextureSource}
         */
        this._displayedTextureSource = null;

        this._zContextUsage = 0;

        this._children = null;

        this._hasRenderUpdates = 0;

        this._zIndexedChildren = null;

        this._renderContext = this._worldContext;

        this.renderState = this.ctx.renderState;

        this._scissor = null;

        // The ancestor ElementCore that owns the inherited shader. Null if none is active (default shader).
        this._shaderOwner = null;


        this._updateTreeOrder = 0;

        this._colorUl = this._colorUr = this._colorBl = this._colorBr = 0xFFFFFFFF;

        this._x = 0;
        this._y = 0;
        this._w = 0;
        this._h = 0;

        this._optFlags = 0;
        this._funcX = null;
        this._funcY = null;
        this._funcW = null;
        this._funcH = null;

        this._scaleX = 1;
        this._scaleY = 1;
        this._pivotX = 0.5;
        this._pivotY = 0.5;
        this._mountX = 0;
        this._mountY = 0;
        this._rotation = 0;

        this._alpha = 1;
        this._visible = true;

        this._ulx = 0;
        this._uly = 0;
        this._brx = 1;
        this._bry = 1;

        this._zIndex = 0;
        this._forceZIndexContext = false;
        this._zParent = null;

        this._isRoot = false;

        /**
         * Iff true, during zSort, this element should be 're-sorted' because either:
         * - zIndex did chang
         * - zParent did change
         * - element was moved in the render tree
         * @type {boolean}
         */
        this._zIndexResort = false;

        this._shader = null;

        // Element is rendered on another texture.
        this._renderToTextureEnabled = false;

        this._texturizer = null;

        this._useRenderToTexture = false;

        this._boundsMargin = null;

        this._recBoundsMargin = null;

        this._withinBoundsMargin = false;

        this._viewport = null;

        this._clipbox = true;

        this.render = this._renderSimple;

        this._layout = null;
    }

    get offsetX() {
        if (this._funcX) {
            return this._funcX;
        } else {
            if (this.hasFlexLayout()) {
                return this._layout.originalX;
            } else {
                return this._x;
            }
        }
    }

    set offsetX(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(v)) {
            this.funcX = v;
        } else {
            this._disableFuncX();
            if (this.hasFlexLayout()) {
                this.x += (v - this._layout.originalX);
                this._layout.setOriginalXWithoutUpdatingLayout(v);
            } else {
                this.x = v;
            }
        }
    }

    get x() {
        return this._x;
    }

    set x(v) {
        if (v !== this._x) {
            this._updateLocalTranslateDelta(v - this._x, 0);
            this._x = v;
        }
    }

    get funcX() {
        return (this._optFlags & 1 ? this._funcX : null);
    }

    set funcX(v) {
        if (this._funcX !== v) {
            this._optFlags |= 1;
            this._funcX = v;
            if (this.hasFlexLayout()) {
                this._layout.setOriginalXWithoutUpdatingLayout(0);
                this.layout.forceLayout();
            } else {
                this._x = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    _disableFuncX() {
        this._optFlags = this._optFlags & (0xFFFF - 1);
        this._funcX = null;
    }

    get offsetY() {
        if (this._funcY) {
            return this._funcY;
        } else {
            if (this.hasFlexLayout()) {
                return this._layout.originalY;
            } else {
                return this._y;
            }
        }
    }

    set offsetY(v) {
        if (_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(v)) {
            this.funcY = v;
        } else {
            this._disableFuncY();
            if (this.hasFlexLayout()) {
                this.y += (v - this._layout.originalY);
                this._layout.setOriginalYWithoutUpdatingLayout(v);
            } else {
                this.y = v;
            }
        }
    }

    get y() {
        return this._y;
    }

    set y(v) {
        if (v !== this._y) {
            this._updateLocalTranslateDelta(0, v - this._y);
            this._y = v;
        }
    }

    get funcY() {
        return (this._optFlags & 2 ? this._funcY : null);
    }

    set funcY(v) {
        if (this._funcY !== v) {
            this._optFlags |= 2;
            this._funcY = v;
            if (this.hasFlexLayout()) {
                this._layout.setOriginalYWithoutUpdatingLayout(0);
                this.layout.forceLayout();
            } else {
                this._y = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    _disableFuncY() {
        this._optFlags = this._optFlags & (0xFFFF - 2);
        this._funcY = null;
    }

    get funcW() {
        return (this._optFlags & 4 ? this._funcW : null);
    }

    set funcW(v) {
        if (this._funcW !== v) {
            this._optFlags |= 4;
            this._funcW = v;
            if (this.hasFlexLayout()) {
                this._layout._originalWidth = 0;
                this.layout.changedDimensions(true, false);
            } else {
                this._w = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    disableFuncW() {
        this._optFlags = this._optFlags & (0xFFFF - 4);
        this._funcW = null;
    }

    get funcH() {
        return (this._optFlags & 8 ? this._funcH : null);
    }

    set funcH(v) {
        if (this._funcH !== v) {
            this._optFlags |= 8;
            this._funcH = v;
            if (this.hasFlexLayout()) {
                this._layout._originalHeight = 0;
                this.layout.changedDimensions(false, true);
            } else {
                this._h = 0;
                this._triggerRecalcTranslate();
            }
        }
    }

    disableFuncH() {
        this._optFlags = this._optFlags & (0xFFFF - 8);
        this._funcH = null;
    }

    get w() {
        return this._w;
    }

    getRenderWidth() {
        if (this.hasFlexLayout()) {
            return this._layout.originalWidth;
        } else {
            return this._w;
        }
    }

    get h() {
        return this._h;
    }

    getRenderHeight() {
        if (this.hasFlexLayout()) {
            return this._layout.originalHeight;
        } else {
            return this._h;
        }
    }

    get scaleX() {
        return this._scaleX;
    }

    set scaleX(v) {
        if (this._scaleX !== v) {
            this._scaleX = v;
            this._updateLocalTransform();
        }
    }

    get scaleY() {
        return this._scaleY;
    }

    set scaleY(v) {
        if (this._scaleY !== v) {
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }

    get scale() {
        return this.scaleX;
    }

    set scale(v) {
        if (this._scaleX !== v || this._scaleY !== v) {
            this._scaleX = v;
            this._scaleY = v;
            this._updateLocalTransform();
        }
    }

    get pivotX() {
        return this._pivotX;
    }

    set pivotX(v) {
        if (this._pivotX !== v) {
            this._pivotX = v;
            this._updateLocalTranslate();
        }
    }

    get pivotY() {
        return this._pivotY;
    }

    set pivotY(v) {
        if (this._pivotY !== v) {
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }

    get pivot() {
        return this._pivotX;
    }

    set pivot(v) {
        if (this._pivotX !== v || this._pivotY !== v) {
            this._pivotX = v;
            this._pivotY = v;
            this._updateLocalTranslate();
        }
    }

    get mountX() {
        return this._mountX;
    }

    set mountX(v) {
        if (this._mountX !== v) {
            this._mountX = v;
            this._updateLocalTranslate();
        }
    }

    get mountY() {
        return this._mountY;
    }

    set mountY(v) {
        if (this._mountY !== v) {
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }

    get mount() {
        return this._mountX;
    }

    set mount(v) {
        if (this._mountX !== v || this._mountY !== v) {
            this._mountX = v;
            this._mountY = v;
            this._updateLocalTranslate();
        }
    }

    get rotation() {
        return this._rotation;
    }

    set rotation(v) {
        if (this._rotation !== v) {
            this._rotation = v;
            this._updateLocalTransform();
        }
    }

    get alpha() {
        return this._alpha;
    }

    set alpha(v) {
        // Account for rounding errors.
        v = (v > 1 ? 1 : (v < 1e-14 ? 0 : v));
        if (this._alpha !== v) {
            let prev = this._alpha;
            this._alpha = v;
            this._updateLocalAlpha();
            if ((prev === 0) !== (v === 0)) {
                this._element._updateEnabledFlag();
            }
        }
    }

    get visible() {
        return this._visible;
    }

    set visible(v) {
        if (this._visible !== v) {
            this._visible = v;
            this._updateLocalAlpha();
            this._element._updateEnabledFlag();

            if (this.hasFlexLayout()) {
                this.layout.setVisible(v);
            }
        }
    }

    _updateLocalTransform() {
        if (this._rotation !== 0 && this._rotation % (2 * Math.PI)) {
            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes
            let _sr = Math.sin(this._rotation);
            let _cr = Math.cos(this._rotation);

            this._setLocalTransform(
                _cr * this._scaleX,
                -_sr * this._scaleY,
                _sr * this._scaleX,
                _cr * this._scaleY
            );
        } else {
            this._setLocalTransform(
                this._scaleX,
                0,
                0,
                this._scaleY
            );
        }
        this._updateLocalTranslate();
    };

    _updateLocalTranslate() {
        this._recalcLocalTranslate();
        this._triggerRecalcTranslate();
    };

    _recalcLocalTranslate() {
        let pivotXMul = this._pivotX * this._w;
        let pivotYMul = this._pivotY * this._h;
        let px = this._x - (pivotXMul * this._localTa + pivotYMul * this._localTb) + pivotXMul;
        let py = this._y - (pivotXMul * this._localTc + pivotYMul * this._localTd) + pivotYMul;
        px -= this._mountX * this._w;
        py -= this._mountY * this._h;
        this._localPx = px;
        this._localPy = py;
    }

    _updateLocalTranslateDelta(dx, dy) {
        this._addLocalTranslate(dx, dy);
    };

    _updateLocalAlpha() {
        this._setLocalAlpha(this._visible ? this._alpha : 0);
    };

    /**
     * @param {number} type
     * 0: no updates
     * 1: re-invoke shader
     * 3: re-create render texture and re-invoke shader
     */
    setHasRenderUpdates(type) {
        if (this._worldContext.alpha) {
            // Ignore if 'world invisible'. Render updates will be reset to 3 for every element that becomes visible.
            let p = this;
            p._hasRenderUpdates = Math.max(type, p._hasRenderUpdates);
            while ((p = p._parent) && (p._hasRenderUpdates !== 3)) {
                p._hasRenderUpdates = 3;
            }
        }
    }

    /**
     * @param {Number} type
     *   1: alpha
     *   2: translate
     *   4: transform
     * 128: becomes visible
     * 256: flex layout updated
     */
    _setRecalc(type) {
        this._recalc |= type;

        this._setHasUpdates();

        // Any changes in descendants should trigger texture updates.
        if (this._parent) {
            this._parent.setHasRenderUpdates(3);
        }
    }

    _setHasUpdates() {
        let p = this;
        while (p && !p._hasUpdates) {
            p._hasUpdates = true;
            p = p._parent;
        }
    }

    getParent() {
        return this._parent;
    }

    setParent(parent) {
        if (parent !== this._parent) {
            let prevIsZContext = this.isZContext();
            let prevParent = this._parent;
            this._parent = parent;

            // Notify flex layout engine.
            if (this._layout || (parent && parent.isFlexContainer())) {
                this.layout.setParent(prevParent, parent);
            }

            if (prevParent) {
                // When elements are deleted, the render texture must be re-rendered.
                prevParent.setHasRenderUpdates(3);
            }

            this._setRecalc(1 + 2 + 4);

            if (this._parent) {
                // Force parent to propagate hasUpdates flag.
                this._parent._setHasUpdates();
            }

            if (this._zIndex === 0) {
                this.setZParent(parent);
            } else {
                this.setZParent(parent ? parent.findZContext() : null);
            }

            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                } else {
                    this.enableZContext(prevParent.findZContext());
                }
            }

            // Tree order did change: even if zParent stays the same, we must resort.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }

            if (!this._shader) {
                let newShaderOwner = parent && !parent._renderToTextureEnabled ? parent._shaderOwner : null;
                if (newShaderOwner !== this._shaderOwner) {
                    this.setHasRenderUpdates(1);
                    this._setShaderOwnerRecursive(newShaderOwner);
                }
            }
        }
    };

    enableZSort(force = false) {
        if (!this._zSort && this._zContextUsage > 0) {
            this._zSort = true;
            if (force) {
                // ZSort must be done, even if this element is invisible.
                // This is done to prevent memory leaks when removing element from inactive render branches.
                this.ctx.forceZSort(this);
            }
        }
    }

    addChildAt(index, child) {
        if (!this._children) this._children = [];
        this._children.splice(index, 0, child);
        child.setParent(this);
    };

    setChildAt(index, child) {
        if (!this._children) this._children = [];
        this._children[index].setParent(null);
        this._children[index] = child;
        child.setParent(this);
    }

    removeChildAt(index) {
        let child = this._children[index];
        this._children.splice(index, 1);
        child.setParent(null);
    };

    removeChildren() {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i].setParent(null);
            }

            this._children.splice(0);

            if (this._zIndexedChildren) {
                this._zIndexedChildren.splice(0);
            }
        }
    };

    syncChildren(removed, added, order) {
        this._children = order;
        for (let i = 0, n = removed.length; i < n; i++) {
            removed[i].setParent(null);
        }
        for (let i = 0, n = added.length; i < n; i++) {
            added[i].setParent(this);
        }
    }

    moveChild(fromIndex, toIndex) {
        let c = this._children[fromIndex];
        this._children.splice(fromIndex, 1);
        this._children.splice(toIndex, 0, c);

        // Tree order changed: must resort!;
        this._zIndexResort = true;
        if (this._zParent) {
            this._zParent.enableZSort();
        }
    }

    _setLocalTransform(a, b, c, d) {
        this._setRecalc(4);
        this._localTa = a;
        this._localTb = b;
        this._localTc = c;
        this._localTd = d;

        // We also regard negative scaling as a complex case, so that we can optimize the non-complex case better.
        this._isComplex = (b !== 0) || (c !== 0) || (a < 0) || (d < 0);
    };

    _addLocalTranslate(dx, dy) {
        this._localPx += dx;
        this._localPy += dy;
        this._triggerRecalcTranslate();
    }

    _setLocalAlpha(a) {
        if (!this._worldContext.alpha && ((this._parent && this._parent._worldContext.alpha) && a)) {
            // Element is becoming visible. We need to force update.
            this._setRecalc(1 + 128);
        } else {
            this._setRecalc(1);
        }

        if (a < 1e-14) {
            // Tiny rounding errors may cause failing visibility tests.
            a = 0;
        }

        this._localAlpha = a;
    };

    setDimensions(w, h, isEstimate = this._dimsUnknown) {
        // In case of an estimation, the update loop should perform different bound checks.
        this._dimsUnknown = isEstimate;

        if (this.hasFlexLayout()) {
            this._layout.originalWidth = w;
            this._layout.originalHeight = h;
        } else {
            if (this._w !== w || this._h !== h) {
                this._updateDimensions(w, h);
                return true;
            }
        }
        return false;
    };

    _updateDimensions(w, h) {
        if (this._w !== w || this._h !== h) {
            this._w = w;
            this._h = h;

            this._triggerRecalcTranslate();

            if (this._texturizer) {
                this._texturizer.releaseRenderTexture();
                this._texturizer.updateResultTexture();
            }
            // Due to width/height change: update the translation vector.
            this._updateLocalTranslate();
        }
    }

    setTextureCoords(ulx, uly, brx, bry) {
        this.setHasRenderUpdates(3);

        this._ulx = ulx;
        this._uly = uly;
        this._brx = brx;
        this._bry = bry;
    };

    get displayedTextureSource() {
        return this._displayedTextureSource;
    }

    setDisplayedTextureSource(textureSource) {
        this.setHasRenderUpdates(3);
        this._displayedTextureSource = textureSource;
    };

    get isRoot() {
        return this._isRoot;
    }

    setAsRoot() {
        // Use parent dummy.
        this._parent = new ElementCore(this._element);

        // After setting root, make sure it's updated.
        this._parent._hasRenderUpdates = 3;
        this._parent._hasUpdates = true;

        // Root is, and will always be, the primary zContext.
        this._isRoot = true;

        this.ctx.root = this;

        // Set scissor area of 'fake parent' to stage's viewport.
        this._parent._viewport = [0, 0, this.ctx.stage.coordsWidth, this.ctx.stage.coordsHeight];
        this._parent._scissor = this._parent._viewport;

        // When recBoundsMargin is null, the defaults are used (100 for all sides).
        this._parent._recBoundsMargin = null;

        this._setRecalc(1 + 2 + 4);
    };

    isAncestorOf(c) {
        let p = c;
        while (p = p._parent) {
            if (this === p) {
                return true;
            }
        }
        return false;
    };

    isZContext() {
        return (this._forceZIndexContext || this._renderToTextureEnabled || this._zIndex !== 0 || this._isRoot || !this._parent);
    };

    findZContext() {
        if (this.isZContext()) {
            return this;
        } else {
            return this._parent.findZContext();
        }
    };

    setZParent(newZParent) {
        if (this._zParent !== newZParent) {
            if (this._zParent !== null) {
                if (this._zIndex !== 0) {
                    this._zParent.decZContextUsage();
                }

                // We must filter out this item upon the next resort.
                this._zParent.enableZSort();
            }

            if (newZParent !== null) {
                let hadZContextUsage = (newZParent._zContextUsage > 0);

                // @pre: new parent's children array has already been modified.
                if (this._zIndex !== 0) {
                    newZParent.incZContextUsage();
                }

                if (newZParent._zContextUsage > 0) {
                    if (!hadZContextUsage && (this._parent === newZParent)) {
                        // This child was already in the children list.
                        // Do not add double.
                    } else {
                        // Add new child to array.
                        newZParent._zIndexedChildren.push(this);
                    }

                    // Order should be checked.
                    newZParent.enableZSort();
                }
            }

            this._zParent = newZParent;

            // Newly added element must be marked for resort.
            this._zIndexResort = true;
        }
    };

    incZContextUsage() {
        this._zContextUsage++;
        if (this._zContextUsage === 1) {
            if (!this._zIndexedChildren) {
                this._zIndexedChildren = [];
            }
            if (this._children) {
                // Copy.
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._zIndexedChildren.push(this._children[i]);
                }
                // Initially, children are already sorted properly (tree order).
                this._zSort = false;
            }
        }
    };

    decZContextUsage() {
        this._zContextUsage--;
        if (this._zContextUsage === 0) {
            this._zSort = false;
            this._zIndexedChildren.splice(0);
        }
    };

    get zIndex() {
        return this._zIndex;
    }

    set zIndex(zIndex) {
        if (this._zIndex !== zIndex) {
            this.setHasRenderUpdates(1);

            let newZParent = this._zParent;

            let prevIsZContext = this.isZContext();
            if (zIndex === 0 && this._zIndex !== 0) {
                if (this._parent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.decZContextUsage();
                    }
                } else {
                    newZParent = this._parent;
                }
            } else if (zIndex !== 0 && this._zIndex === 0) {
                newZParent = this._parent ? this._parent.findZContext() : null;
                if (newZParent === this._zParent) {
                    if (this._zParent) {
                        this._zParent.incZContextUsage();
                        this._zParent.enableZSort();
                    }
                }
            } else if (zIndex !== this._zIndex) {
                if (this._zParent && this._zParent._zContextUsage) {
                    this._zParent.enableZSort();
                }
            }

            if (newZParent !== this._zParent) {
                this.setZParent(null);
            }

            this._zIndex = zIndex;

            if (newZParent !== this._zParent) {
                this.setZParent(newZParent);
            }

            if (prevIsZContext !== this.isZContext()) {
                if (!this.isZContext()) {
                    this.disableZContext();
                } else {
                    this.enableZContext(this._parent.findZContext());
                }
            }

            // Make sure that resort is done.
            this._zIndexResort = true;
            if (this._zParent) {
                this._zParent.enableZSort();
            }
        }
    };

    get forceZIndexContext() {
        return this._forceZIndexContext;
    }

    set forceZIndexContext(v) {
        this.setHasRenderUpdates(1);

        let prevIsZContext = this.isZContext();
        this._forceZIndexContext = v;

        if (prevIsZContext !== this.isZContext()) {
            if (!this.isZContext()) {
                this.disableZContext();
            } else {
                this.enableZContext(this._parent.findZContext());
            }
        }
    };

    enableZContext(prevZContext) {
        if (prevZContext && prevZContext._zContextUsage > 0) {
            // Transfer from upper z context to this z context.
            const results = this._getZIndexedDescs();
            results.forEach((c) => {
                if (this.isAncestorOf(c) && c._zIndex !== 0) {
                    c.setZParent(this);
                }
            });
        }
    }

    _getZIndexedDescs() {
        const results = [];
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
        return results;
    }

    _getZIndexedDescsRec(results) {
        if (this._zIndex) {
            results.push(this);
        } else if (this._children && !this.isZContext()) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                this._children[i]._getZIndexedDescsRec(results);
            }
        }
    }

    disableZContext() {
        // Transfer from this z context to upper z context.
        if (this._zContextUsage > 0) {
            let newZParent = this._parent.findZContext();

            // Make sure that z-indexed children are up to date (old ones removed).
            if (this._zSort) {
                this.sortZIndexedChildren();
            }

            this._zIndexedChildren.slice().forEach(function (c) {
                if (c._zIndex !== 0) {
                    c.setZParent(newZParent);
                }
            });
        }
    };

    get colorUl() {
        return this._colorUl;
    }

    set colorUl(color) {
        if (this._colorUl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUl = color;
        }
    }

    get colorUr() {
        return this._colorUr;
    }

    set colorUr(color) {
        if (this._colorUr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorUr = color;
        }
    };

    get colorBl() {
        return this._colorBl;
    }

    set colorBl(color) {
        if (this._colorBl !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBl = color;
        }
    };

    get colorBr() {
        return this._colorBr;
    }

    set colorBr(color) {
        if (this._colorBr !== color) {
            this.setHasRenderUpdates(this._displayedTextureSource ? 3 : 1);
            this._colorBr = color;
        }
    };


    set onUpdate(f) {
        this._onUpdate = f;
        this._setRecalc(7);
    }

    set onAfterUpdate(f) {
        this._onAfterUpdate = f;
        this._setRecalc(7);
    }

    set onAfterCalcs(f) {
        this._onAfterCalcs = f;
        this._setRecalc(7);
    }

    get shader() {
        return this._shader;
    }

    set shader(v) {
        this.setHasRenderUpdates(1);

        let prevShader = this._shader;
        this._shader = v;
        if (!v && prevShader) {
            // Disabled shader.
            let newShaderOwner = (this._parent && !this._parent._renderToTextureEnabled ? this._parent._shaderOwner : null);
            this._setShaderOwnerRecursive(newShaderOwner);
        } else if (v) {
            // Enabled shader.
            this._setShaderOwnerRecursive(this);
        }
    }

    get activeShader() {
        return this._shaderOwner ? this._shaderOwner.shader : this.renderState.defaultShader;
    }

    get activeShaderOwner() {
        return this._shaderOwner;
    }

    get clipping() {
        return this._clipping;
    }

    set clipping(v) {
        if (this._clipping !== v) {
            this._clipping = v;

            // Force update of scissor by updating translate.
            // Alpha must also be updated because the scissor area may have been empty.
            this._setRecalc(1 + 2);
        }
    }

    get clipbox() {
        return this._clipbox;
    }

    set clipbox(v) {
        // In case of out-of-bounds element, all children will also be ignored.
        // It will save us from executing the update/render loops for those.
        // The optimization will be used immediately during the next frame.
        this._clipbox = v;
    }

    _setShaderOwnerRecursive(elementCore) {
        this._shaderOwner = elementCore;

        if (this._children && !this._renderToTextureEnabled) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                let c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    };

    _setShaderOwnerChildrenRecursive(elementCore) {
        if (this._children) {
            for (let i = 0, n = this._children.length; i < n; i++) {
                let c = this._children[i];
                if (!c._shader) {
                    c._setShaderOwnerRecursive(elementCore);
                    c._hasRenderUpdates = 3;
                }
            }
        }
    };

    _hasRenderContext() {
        return this._renderContext !== this._worldContext;
    }

    get renderContext() {
        return this._renderContext;
    }

    updateRenderToTextureEnabled() {
        // Enforce texturizer initialisation.
        let v = this.texturizer._enabled;

        if (v) {
            this._enableRenderToTexture();
        } else {
            this._disableRenderToTexture();
            this._texturizer.releaseRenderTexture();
        }
    }

    _enableRenderToTexture() {
        if (!this._renderToTextureEnabled) {
            let prevIsZContext = this.isZContext();

            this._renderToTextureEnabled = true;

            this._renderContext = new ElementCoreContext();

            // If render to texture is active, a new shader context is started.
            this._setShaderOwnerChildrenRecursive(null);

            if (!prevIsZContext) {
                // Render context forces z context.
                this.enableZContext(this._parent ? this._parent.findZContext() : null);
            }

            this.setHasRenderUpdates(3);

            // Make sure that the render coordinates get updated.
            this._setRecalc(7);

            this.render = this._renderAdvanced;
        }
    }

    _disableRenderToTexture() {
        if (this._renderToTextureEnabled) {
            this._renderToTextureEnabled = false;

            this._setShaderOwnerChildrenRecursive(this._shaderOwner);

            this._renderContext = this._worldContext;

            if (!this.isZContext()) {
                this.disableZContext();
            }

            // Make sure that the render coordinates get updated.
            this._setRecalc(7);

            this.setHasRenderUpdates(3);

            this.render = this._renderSimple;
        }
    }

    isWhite() {
        return (this._colorUl === 0xFFFFFFFF) && (this._colorUr === 0xFFFFFFFF) && (this._colorBl === 0xFFFFFFFF) && (this._colorBr === 0xFFFFFFFF);
    }

    hasSimpleTexCoords() {
        return (this._ulx === 0) && (this._uly === 0) && (this._brx === 1) && (this._bry === 1);
    }

    _stashTexCoords() {
        this._stashedTexCoords = [this._ulx, this._uly, this._brx, this._bry];
        this._ulx = 0;
        this._uly = 0;
        this._brx = 1;
        this._bry = 1;
    }

    _unstashTexCoords() {
        this._ulx = this._stashedTexCoords[0];
        this._uly = this._stashedTexCoords[1];
        this._brx = this._stashedTexCoords[2];
        this._bry = this._stashedTexCoords[3];
        this._stashedTexCoords = null;
    }

    _stashColors() {
        this._stashedColors = [this._colorUl, this._colorUr, this._colorBr, this._colorBl];
        this._colorUl = 0xFFFFFFFF;
        this._colorUr = 0xFFFFFFFF;
        this._colorBr = 0xFFFFFFFF;
        this._colorBl = 0xFFFFFFFF;
    }

    _unstashColors() {
        this._colorUl = this._stashedColors[0];
        this._colorUr = this._stashedColors[1];
        this._colorBr = this._stashedColors[2];
        this._colorBl = this._stashedColors[3];
        this._stashedColors = null;
    }

    isVisible() {
        return (this._localAlpha > 1e-14);
    };

    get outOfBounds() {
        return this._outOfBounds;
    }

    set boundsMargin(v) {

        /**
         *  null: inherit from parent.
         *  number[4]: specific margins: left, top, right, bottom.
         */
        this._boundsMargin = v ? v.slice() : null;

        // We force recalc in order to set all boundsMargin recursively during the next update.
        this._triggerRecalcTranslate();
    }

    get boundsMargin() {
        return this._boundsMargin;
    }

    update() {
        this._recalc |= this._parent._pRecalc;

        if (this._layout && this._layout.isEnabled()) {
            if (this._recalc & 256) {
                this._layout.layoutFlexTree();
            }
        } else if ((this._recalc & 2) && this._optFlags) {
            this._applyRelativeDimFuncs();
        }

        if (this._onUpdate) {
            // Block all 'upwards' updates when changing things in this branch.
            this._hasUpdates = true;
            this._onUpdate(this.element, this);
        }

        const pw = this._parent._worldContext;
        let w = this._worldContext;
        const visible = (pw.alpha && this._localAlpha);

        /**
         * We must update if:
         * - branch contains updates (even when invisible because it may contain z-indexed descendants)
         * - there are (inherited) updates and this branch is visible
         * - this branch becomes invisible (descs may be z-indexed so we must update all alpha values)
         */
        if (this._hasUpdates || (this._recalc && visible) || (w.alpha && !visible)) {
            let recalc = this._recalc;

            // Update world coords/alpha.
            if (recalc & 1) {
                if (!w.alpha && visible) {
                    // Becomes visible.
                    this._hasRenderUpdates = 3;
                }
                w.alpha = pw.alpha * this._localAlpha;

                if (w.alpha < 1e-14) {
                    // Tiny rounding errors may cause failing visibility tests.
                    w.alpha = 0;
                }
            }

            if (recalc & 6) {
                w.px = pw.px + this._localPx * pw.ta;
                w.py = pw.py + this._localPy * pw.td;
                if (pw.tb !== 0) w.px += this._localPy * pw.tb;
                if (pw.tc !== 0) w.py += this._localPx * pw.tc;
            }

            if (recalc & 4) {
                w.ta = this._localTa * pw.ta;
                w.tb = this._localTd * pw.tb;
                w.tc = this._localTa * pw.tc;
                w.td = this._localTd * pw.td;

                if (this._isComplex) {
                    w.ta += this._localTc * pw.tb;
                    w.tb += this._localTb * pw.ta;
                    w.tc += this._localTc * pw.td;
                    w.td += this._localTb * pw.tc;
                }
            }

            // Update render coords/alpha.
            const pr = this._parent._renderContext;
            if (this._parent._hasRenderContext()) {
                const init = this._renderContext === this._worldContext;
                if (init) {
                    // First render context build: make sure that it is fully initialized correctly.
                    // Otherwise, if we get into bounds later, the render context would not be initialized correctly.
                    this._renderContext = new ElementCoreContext();
                }

                const r = this._renderContext;

                // Update world coords/alpha.
                if (init || (recalc & 1)) {
                    r.alpha = pr.alpha * this._localAlpha;

                    if (r.alpha < 1e-14) {
                        r.alpha = 0;
                    }
                }

                if (init || (recalc & 6)) {
                    r.px = pr.px + this._localPx * pr.ta;
                    r.py = pr.py + this._localPy * pr.td;
                    if (pr.tb !== 0) r.px += this._localPy * pr.tb;
                    if (pr.tc !== 0) r.py += this._localPx * pr.tc;
                }

                if (init) {
                    // We set the recalc toggle, because we must make sure that the scissor is updated.
                    recalc |= 2;
                }

                if (init || (recalc & 4)) {
                    r.ta = this._localTa * pr.ta;
                    r.tb = this._localTd * pr.tb;
                    r.tc = this._localTa * pr.tc;
                    r.td = this._localTd * pr.td;

                    if (this._isComplex) {
                        r.ta += this._localTc * pr.tb;
                        r.tb += this._localTb * pr.ta;
                        r.tc += this._localTc * pr.td;
                        r.td += this._localTb * pr.tc;
                    }
                }
            } else {
                this._renderContext = this._worldContext;
            }

            if (this.ctx.updateTreeOrder === -1) {
                this.ctx.updateTreeOrder = this._updateTreeOrder + 1;
            } else {
                this._updateTreeOrder = this.ctx.updateTreeOrder++;
            }

            // Determine whether we must use a 'renderTexture'.
            const useRenderToTexture = this._renderToTextureEnabled && this._texturizer.mustRenderToTexture();
            if (this._useRenderToTexture !== useRenderToTexture) {
                // Coords must be changed.
                this._recalc |= 2 + 4;

                // Scissor may change: force update.
                recalc |= 2;

                if (!this._useRenderToTexture) {
                    // We must release the texture.
                    this._texturizer.release();
                }
            }
            this._useRenderToTexture = useRenderToTexture;

            const r = this._renderContext;

            const bboxW = this._dimsUnknown ? 2048 : this._w;
            const bboxH = this._dimsUnknown ? 2048 : this._h;

            // Calculate a bbox for this element.
            let sx, sy, ex, ey;
            const rComplex = (r.tb !== 0) || (r.tc !== 0) || (r.ta < 0) || (r.td < 0);
            if (rComplex) {
                sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
            } else {
                sx = r.px;
                ex = r.px + r.ta * bboxW;
                sy = r.py;
                ey = r.py + r.td * bboxH;
            }

            if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                // If we are dealing with a non-identity matrix, we must extend the bbox so that withinBounds and
                //  scissors will include the complete range of (positive) dimensions up to ,lh.
                const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                if (nx < sx) sx = nx;
                if (ny < sy) sy = ny;
                if (nx > ex) ex = nx;
                if (ny > ey) ey = ny;
            }

            if (recalc & 6 || !this._scissor /* initial */) {
                // Determine whether we must 'clip'.
                if (this._clipping && r.isSquare()) {
                    // If the parent renders to a texture, it's scissor should be ignored;
                    const area = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                    if (area) {
                        // Merge scissor areas.
                        const lx = Math.max(area[0], sx);
                        const ly = Math.max(area[1], sy);
                        this._scissor = [
                            lx,
                            ly,
                            Math.min(area[2] + area[0], ex) - lx,
                            Math.min(area[3] + area[1], ey) - ly
                        ];
                    } else {
                        this._scissor = [sx, sy, ex - sx, ey - sy];
                    }
                } else {
                    // No clipping: reuse parent scissor.
                    this._scissor = this._parent._useRenderToTexture ? this._parent._viewport : this._parent._scissor;
                }
            }

            // Calculate the outOfBounds margin.
            if (this._boundsMargin) {
                this._recBoundsMargin = this._boundsMargin;
            } else {
                this._recBoundsMargin = this._parent._recBoundsMargin;
            }

            if (this._onAfterCalcs) {
                // After calcs may change render coords, scissor and/or recBoundsMargin.
                if (this._onAfterCalcs(this.element)) {
                    // Recalculate bbox.
                    if (rComplex) {
                        sx = Math.min(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                        ex = Math.max(0, bboxW * r.ta, bboxW * r.ta + bboxH * r.tb, bboxH * r.tb) + r.px;
                        sy = Math.min(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                        ey = Math.max(0, bboxW * r.tc, bboxW * r.tc + bboxH * r.td, bboxH * r.td) + r.py;
                    } else {
                        sx = r.px;
                        ex = r.px + r.ta * bboxW;
                        sy = r.py;
                        ey = r.py + r.td * bboxH;
                    }

                    if (this._dimsUnknown && (rComplex || this._localTa < 1 || this._localTb < 1)) {
                        const nx = this._x * pr.ta + this._y * pr.tb + pr.px;
                        const ny = this._x * pr.tc + this._y * pr.td + pr.py;
                        if (nx < sx) sx = nx;
                        if (ny < sy) sy = ny;
                        if (nx > ex) ex = nx;
                        if (ny > ey) ey = ny;
                    }
                }
            }

            if (this._parent._outOfBounds === 2) {
                // Inherit parent out of boundsness.
                this._outOfBounds = 2;

                if (this._withinBoundsMargin) {
                    this._withinBoundsMargin = false;
                    this.element._disableWithinBoundsMargin();
                }
            } else {
                if (recalc & 6) {
                    // Recheck if element is out-of-bounds (all settings that affect this should enable recalc bit 2 or 4).
                    this._outOfBounds = 0;
                    let withinMargin = true;

                    // Offscreens are always rendered as long as the parent is within bounds.
                    if (!this._renderToTextureEnabled || !this._texturizer || !this._texturizer.renderOffscreen) {
                        if (this._scissor && (this._scissor[2] <= 0 || this._scissor[3] <= 0)) {
                            // Empty scissor area.
                            this._outOfBounds = 2;
                        } else {
                            // Use bbox to check out-of-boundness.
                            if ((this._scissor[0] > ex) ||
                                (this._scissor[1] > ey) ||
                                (sx > (this._scissor[0] + this._scissor[2])) ||
                                (sy > (this._scissor[1] + this._scissor[3]))
                            ) {
                                this._outOfBounds = 1;
                            }

                            if (this._outOfBounds) {
                                if (this._clipping || this._useRenderToTexture || (this._clipbox && (bboxW && bboxH))) {
                                    this._outOfBounds = 2;
                                }
                            }
                        }

                        withinMargin = (this._outOfBounds === 0);
                        if (!withinMargin) {
                            // Re-test, now with margins.
                            if (this._recBoundsMargin) {
                                withinMargin = !((ex < this._scissor[0] - this._recBoundsMargin[2]) ||
                                    (ey < this._scissor[1] - this._recBoundsMargin[3]) ||
                                    (sx > this._scissor[0] + this._scissor[2] + this._recBoundsMargin[0]) ||
                                    (sy > this._scissor[1] + this._scissor[3] + this._recBoundsMargin[1]));
                            } else {
                                withinMargin = !((ex < this._scissor[0] - 100) ||
                                    (ey < this._scissor[1] - 100) ||
                                    (sx > this._scissor[0] + this._scissor[2] + 100) ||
                                    (sy > this._scissor[1] + this._scissor[3] + 100));
                            }
                            if (withinMargin && this._outOfBounds === 2) {
                                // Children must be visited because they may contain elements that are within margin, so must be visible.
                                this._outOfBounds = 1;
                            }
                        }
                    }

                    if (this._withinBoundsMargin !== withinMargin) {
                        this._withinBoundsMargin = withinMargin;

                        if (this._withinBoundsMargin) {
                            // This may update things (txLoaded events) in the element itself, but also in descendants and ancestors.

                            // Changes in ancestors should be executed during the next call of the stage update. But we must
                            // take care that the _recalc and _hasUpdates flags are properly registered. That's why we clear
                            // both before entering the children, and use _pRecalc to transfer inherited updates instead of
                            // _recalc directly.

                            // Changes in descendants are automatically executed within the current update loop, though we must
                            // take care to not update the hasUpdates flag unnecessarily in ancestors. We achieve this by making
                            // sure that the hasUpdates flag of this element is turned on, which blocks it for ancestors.
                            this._hasUpdates = true;

                            const recalc = this._recalc;
                            this._recalc = 0;
                            this.element._enableWithinBoundsMargin();

                            if (this._recalc) {
                                // This element needs to be re-updated now, because we want the dimensions (and other changes) to be updated.
                                return this.update();
                            }

                            this._recalc = recalc;
                        } else {
                            this.element._disableWithinBoundsMargin();
                        }
                    }
                }
            }

            if (this._useRenderToTexture) {
                // Set viewport necessary for children scissor calculation.
                if (this._viewport) {
                    this._viewport[2] = bboxW;
                    this._viewport[3] = bboxH;
                } else {
                    this._viewport = [0, 0, bboxW, bboxH];
                }
            }

            // Filter out bits that should not be copied to the children (currently all are).
            this._pRecalc = (this._recalc & 135);

            // Clear flags so that future updates are properly detected.
            this._recalc = 0;
            this._hasUpdates = false;

            if (this._outOfBounds < 2) {
                if (this._useRenderToTexture) {
                    if (this._worldContext.isIdentity()) {
                        // Optimization.
                        // The world context is already identity: use the world context as render context to prevents the
                        // ancestors from having to update the render context.
                        this._renderContext = this._worldContext;
                    } else {
                        // Temporarily replace the render coord attribs by the identity matrix.
                        // This allows the children to calculate the render context.
                        this._renderContext = ElementCoreContext.IDENTITY;
                    }
                }

                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        this._children[i].update();
                    }
                }

                if (this._useRenderToTexture) {
                    this._renderContext = r;
                }
            } else {
                if (this._children) {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._hasUpdates) {
                            this._children[i].update();
                        } else {
                            // Make sure we don't lose the 'inherited' updates.
                            this._children[i]._recalc |= this._pRecalc;
                            this._children[i].updateOutOfBounds();
                        }
                    }
                }
            }

            if (this._onAfterUpdate) {
                this._onAfterUpdate(this.element);
            }
        } else {
            if (this.ctx.updateTreeOrder === -1 || this._updateTreeOrder >= this.ctx.updateTreeOrder) {
                // If new tree order does not interfere with the current (gaps allowed) there's no need to traverse the branch.
                this.ctx.updateTreeOrder = -1;
            } else {
                this.updateTreeOrder();
            }
        }
    }

    _applyRelativeDimFuncs() {
        if (this._optFlags & 1) {
            const x = this._funcX(this._parent.w);
            if (x !== this._x) {
                this._localPx += (x - this._x);
                this._x = x;
            }
        }
        if (this._optFlags & 2) {
            const y = this._funcY(this._parent.h);
            if (y !== this._y) {
                this._localPy += (y - this._y);
                this._y = y;
            }
        }

        let changedDims = false;
        if (this._optFlags & 4) {
            const w = this._funcW(this._parent.w);
            if (w !== this._w) {
                this._w = w;
                changedDims = true;
            }
        }
        if (this._optFlags & 8) {
            const h = this._funcH(this._parent.h);
            if (h !== this._h) {
                this._h = h;
                changedDims = true;
            }
        }

        if (changedDims) {
            // Recalc mount, scale position.
            this._recalcLocalTranslate();

            this.element.onDimensionsChanged(this._w, this._h);
        }
    }

    updateOutOfBounds() {
        // Propagate outOfBounds flag to descendants (necessary because of z-indexing).
        // Invisible elements are not drawn anyway. When alpha is updated, so will _outOfBounds.
        if (this._outOfBounds !== 2 && this._renderContext.alpha > 0) {

            // Inherit parent out of boundsness.
            this._outOfBounds = 2;

            if (this._withinBoundsMargin) {
                this._withinBoundsMargin = false;
                this.element._disableWithinBoundsMargin();
            }

            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateOutOfBounds();
                }
            }
        }
    }

    updateTreeOrder() {
        if (this._localAlpha && (this._outOfBounds !== 2)) {
            this._updateTreeOrder = this.ctx.updateTreeOrder++;

            if (this._children) {
                for (let i = 0, n = this._children.length; i < n; i++) {
                    this._children[i].updateTreeOrder();
                }
            }
        }
    }

    _renderSimple() {
        this._hasRenderUpdates = 0;

        if (this._zSort) {
            this.sortZIndexedChildren();
        }

        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            let renderState = this.renderState;

            if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                renderState.setShader(this.activeShader, this._shaderOwner);
                renderState.setScissor(this._scissor);
                this.renderState.addQuad(this);
            }

            // Also add children to the VBO.
            if (this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                } else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }

                    }
                }
            }
        }
    }

    _renderAdvanced() {
        const hasRenderUpdates = this._hasRenderUpdates;

        // We must clear the hasRenderUpdates flag before rendering, because updating result textures in combination
        // with z-indexing may trigger render updates on a render branch that is 'half done'.
        // We need to ensure that the full render branch is marked for render updates, not only half (leading to freeze).
        this._hasRenderUpdates = 0;

        if (this._zSort) {
            this.sortZIndexedChildren();
        }

        if (this._outOfBounds < 2 && this._renderContext.alpha) {
            let renderState = this.renderState;

            let mustRenderChildren = true;
            let renderTextureInfo;
            let prevRenderTextureInfo;
            if (this._useRenderToTexture) {
                if (this._w === 0 || this._h === 0) {
                    // Ignore this branch and don't draw anything.
                    return;
                } else if (!this._texturizer.hasRenderTexture() || (hasRenderUpdates >= 3)) {
                    // Switch to default shader for building up the render texture.
                    renderState.setShader(renderState.defaultShader, this);

                    prevRenderTextureInfo = renderState.renderTextureInfo;

                    renderTextureInfo = {
                        nativeTexture: null,
                        offset: 0,  // Set by CoreRenderState.
                        w: this._w,
                        h: this._h,
                        empty: true,
                        cleared: false,
                        ignore: false,
                        cache: false
                    };

                    if (this._texturizer.hasResultTexture() || (!renderState.isCachingTexturizer && (hasRenderUpdates < 3))) {
                        /**
                         * We don't always cache render textures.
                         *
                         * The rule is, that caching for a specific render texture is only enabled if:
                         * - There is a result texture to be updated.
                         * - There were no render updates -within the contents- since last frame (ElementCore.hasRenderUpdates < 3)
                         * - AND there are no ancestors that are being cached during this frame (CoreRenderState.isCachingTexturizer)
                         *   If an ancestor is cached anyway, it's probably not necessary to keep deeper caches. If the top level is to
                         *   change while a lower one is not, that lower level will be cached instead.
                         *
                         * In case of the fast blur element, this prevents having to cache all blur levels and stages, saving a huge amount
                         * of GPU memory!
                         *
                         * Especially when using multiple stacked layers of the same dimensions that are RTT this will have a very
                         * noticable effect on performance as less render textures need to be allocated.
                         */
                        renderTextureInfo.cache = true;
                        renderState.isCachingTexturizer = true;
                    }

                    if (!this._texturizer.hasResultTexture()) {
                        // We can already release the current texture to the pool, as it will be rebuild anyway.
                        // In case of multiple layers of 'filtering', this may save us from having to create one
                        //  render-to-texture layer.
                        // Notice that we don't do this when there is a result texture, as any other element may rely on
                        //  that result texture being filled.
                        this._texturizer.releaseRenderTexture();
                    }

                    renderState.setRenderTextureInfo(renderTextureInfo);
                    renderState.setScissor(null);

                    if (this._displayedTextureSource) {
                        let r = this._renderContext;

                        // Use an identity context for drawing the displayed texture to the render texture.
                        this._renderContext = ElementCoreContext.IDENTITY;

                        // Add displayed texture source in local coordinates.
                        this.renderState.addQuad(this);

                        this._renderContext = r;
                    }
                } else {
                    mustRenderChildren = false;
                }
            } else {
                if ((this._outOfBounds === 0) && this._displayedTextureSource) {
                    renderState.setShader(this.activeShader, this._shaderOwner);
                    renderState.setScissor(this._scissor);
                    this.renderState.addQuad(this);
                }
            }

            // Also add children to the VBO.
            if (mustRenderChildren && this._children) {
                if (this._zContextUsage) {
                    for (let i = 0, n = this._zIndexedChildren.length; i < n; i++) {
                        this._zIndexedChildren[i].render();
                    }
                } else {
                    for (let i = 0, n = this._children.length; i < n; i++) {
                        if (this._children[i]._zIndex === 0) {
                            // If zIndex is set, this item already belongs to a zIndexedChildren array in one of the ancestors.
                            this._children[i].render();
                        }
                    }
                }
            }

            if (this._useRenderToTexture) {
                let updateResultTexture = false;
                if (mustRenderChildren) {
                    // Finished refreshing renderTexture.
                    renderState.finishedRenderTexture();

                    // If nothing was rendered, we store a flag in the texturizer and prevent unnecessary
                    //  render-to-texture and filtering.
                    this._texturizer.empty = renderTextureInfo.empty;

                    if (renderTextureInfo.empty) {
                        // We ignore empty render textures and do not draw the final quad.

                        // The following cleans up memory and enforces that the result texture is also cleared.
                        this._texturizer.releaseRenderTexture();
                    } else if (renderTextureInfo.nativeTexture) {
                        // If nativeTexture is set, we can reuse that directly instead of creating a new render texture.
                        this._texturizer.reuseTextureAsRenderTexture(renderTextureInfo.nativeTexture);

                        renderTextureInfo.ignore = true;
                    } else {
                        if (this._texturizer.renderTextureReused) {
                            // Quad operations must be written to a render texture actually owned.
                            this._texturizer.releaseRenderTexture();
                        }
                        // Just create the render texture.
                        renderTextureInfo.nativeTexture = this._texturizer.getRenderTexture();
                    }

                    // Restore the parent's render texture.
                    renderState.setRenderTextureInfo(prevRenderTextureInfo);

                    updateResultTexture = true;
                }

                if (!this._texturizer.empty) {
                    let resultTexture = this._texturizer.getResultTexture();
                    if (updateResultTexture) {
                        if (resultTexture) {
                            // Logging the update frame can be handy for userland.
                            resultTexture.update = renderState.stage.frameCounter;
                        }
                        this._texturizer.updateResultTexture();
                    }

                    if (!this._texturizer.renderOffscreen) {
                        // Render result texture to the actual render target.
                        renderState.setShader(this.activeShader, this._shaderOwner);
                        renderState.setScissor(this._scissor);

                        // If no render texture info is set, the cache can be reused.
                        const cache = !renderTextureInfo || renderTextureInfo.cache;

                        renderState.setTexturizer(this._texturizer, cache);
                        this._stashTexCoords();
                        if (!this._texturizer.colorize) this._stashColors();
                        this.renderState.addQuad(this, true);
                        if (!this._texturizer.colorize) this._unstashColors();
                        this._unstashTexCoords();
                        renderState.setTexturizer(null);
                    }
                }
            }

            if (renderTextureInfo && renderTextureInfo.cache) {
                // Allow siblings to cache.
                renderState.isCachingTexturizer = false;
            }
        }
    }

    get zSort() {
        return this._zSort;
    }

    sortZIndexedChildren() {
        /**
         * We want to avoid resorting everything. Instead, we do a single pass of the full array:
         * - filtering out elements with a different zParent than this (were removed)
         * - filtering out, but also gathering (in a temporary array) the elements that have zIndexResort flag
         * - then, finally, we merge-sort both the new array and the 'old' one
         * - element may have been added 'double', so when merge-sorting also check for doubles.
         * - if the old one is larger (in size) than it should be, splice off the end of the array.
         */

        const n = this._zIndexedChildren.length;
        let ptr = 0;
        const a = this._zIndexedChildren;

        // Notice that items may occur multiple times due to z-index changing.
        const b = [];
        for (let i = 0; i < n; i++) {
            if (a[i]._zParent === this) {
                if (a[i]._zIndexResort) {
                    b.push(a[i]);
                } else {
                    if (ptr !== i) {
                        a[ptr] = a[i];
                    }
                    ptr++;
                }
            }
        }

        const m = b.length;
        if (m) {
            for (let j = 0; j < m; j++) {
                b[j]._zIndexResort = false;
            }

            b.sort(ElementCore.sortZIndexedChildren);
            const n = ptr;
            if (!n) {
                ptr = 0;
                let j = 0;
                do {
                    a[ptr++] = b[j++];
                } while (j < m);

                if (a.length > ptr) {
                    // Slice old (unnecessary) part off array.
                    a.splice(ptr);
                }
            } else {
                // Merge-sort arrays;
                ptr = 0;
                let i = 0;
                let j = 0;
                const mergeResult = [];
                do {
                    const v = (a[i]._zIndex === b[j]._zIndex ? a[i]._updateTreeOrder - b[j]._updateTreeOrder : a[i]._zIndex - b[j]._zIndex);

                    const add = v > 0 ? b[j++] : a[i++];

                    if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                        mergeResult[ptr++] = add;
                    }

                    if (i >= n) {
                        do {
                            const add = b[j++];
                            if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                mergeResult[ptr++] = add;
                            }
                        } while (j < m);
                        break;
                    } else if (j >= m) {
                        do {
                            const add = a[i++];
                            if (ptr === 0 || (mergeResult[ptr - 1] !== add)) {
                                mergeResult[ptr++] = add;
                            }
                        } while (i < n);
                        break;
                    }
                } while (true);

                this._zIndexedChildren = mergeResult;
            }
        } else {
            if (a.length > ptr) {
                // Slice old (unnecessary) part off array.
                a.splice(ptr);
            }
        }

        this._zSort = false;
    };

    get localTa() {
        return this._localTa;
    };

    get localTb() {
        return this._localTb;
    };

    get localTc() {
        return this._localTc;
    };

    get localTd() {
        return this._localTd;
    };

    get element() {
        return this._element;
    }

    get renderUpdates() {
        return this._hasRenderUpdates;
    }

    get texturizer() {
        if (!this._texturizer) {
            this._texturizer = new _ElementTexturizer_mjs__WEBPACK_IMPORTED_MODULE_2__["default"](this);
        }
        return this._texturizer;
    }

    getCornerPoints() {
        let w = this._worldContext;

        return [
            w.px,
            w.py,
            w.px + this._w * w.ta,
            w.py + this._w * w.tc,
            w.px + this._w * w.ta + this._h * w.tb,
            w.py + this._w * w.tc + this._h * w.td,
            w.px + this._h * w.tb,
            w.py + this._h * w.td
        ];
    };

    getRenderTextureCoords(relX, relY) {
        let r = this._renderContext;
        return [
            r.px + r.ta * relX + r.tb * relY,
            r.py + r.tc * relX + r.td * relY
        ];
    }

    getAbsoluteCoords(relX, relY) {
        let w = this._renderContext;
        return [
            w.px + w.ta * relX + w.tb * relY,
            w.py + w.tc * relX + w.td * relY
        ];
    }

    collectAtCoord(x, y, children) {
        // return when branch is hidden
        if (this._renderContext.alpha === 0) {
            return;
        }

        if (this.inBound(x, y)) {
            if (this._scissor) {
                if (this.inScissor()) {
                    children.push(this);
                }
            } else {
                children.push(this);
            }
        }

        if (this._children) {
            const j = this._children.length;
            for (let i = 0; i < j; i++) {
                this._children[i].collectAtCoord(x, y, children);
            }
        }

        return children.sort(ElementCore.sortZIndexedChildren);
    }

    inBound(tx, ty) {
        const c = this.getCornerPoints();
        return tx > c[0] && tx < c[2] && ty > c[1] && ty < c[7];
    }

    inScissor() {
        const sc = this._scissor;
        const c = this.getCornerPoints();

        return c[2] >= sc[0] && c[0] <= sc[0] + sc[2] && c[7] >= sc[1] && c[1] <= sc[1] + sc[3];
    }

    get layout() {
        this._ensureLayout();
        return this._layout;
    }

    get flex() {
        return this._layout ? this._layout.flex : null;
    }

    set flex(v) {
        this.layout.flex = v;
    }

    get flexItem() {
        return this._layout ? this._layout.flexItem : null;
    }

    set flexItem(v) {
        this.layout.flexItem = v;
    }

    isFlexItem() {
        return !!this._layout && this._layout.isFlexItemEnabled();
    }

    isFlexContainer() {
        return !!this._layout && this._layout.isFlexEnabled();
    }

    enableFlexLayout() {
        this._ensureLayout();
    }

    _ensureLayout() {
        if (!this._layout) {
            this._layout = new _flex_FlexTarget_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this);
        }
    }

    disableFlexLayout() {
        this._triggerRecalcTranslate();
    }

    hasFlexLayout() {
        return (this._layout && this._layout.isEnabled());
    }

    setLayout(x, y, w, h) {
        this.x = x;
        this.y = y;
        this._updateDimensions(w, h);
    }

    triggerLayout() {
        this._setRecalc(256);
    }

    _triggerRecalcTranslate() {
        this._setRecalc(2);
    }

}

class ElementCoreContext {

    constructor() {
        this.alpha = 1;

        this.px = 0;
        this.py = 0;

        this.ta = 1;
        this.tb = 0;
        this.tc = 0;
        this.td = 1;
    }

    isIdentity() {
        return this.alpha === 1 &&
            this.px === 0 &&
            this.py === 0 &&
            this.ta === 1 &&
            this.tb === 0 &&
            this.tc === 0 &&
            this.td === 1;
    }

    isSquare() {
        return this.tb === 0 && this.tc === 0;
    }

}

ElementCoreContext.IDENTITY = new ElementCoreContext();
ElementCore.sortZIndexedChildren = function (a, b) {
    return (a._zIndex === b._zIndex ? a._updateTreeOrder - b._updateTreeOrder : a._zIndex - b._zIndex);
};





/***/ }),

/***/ "./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@lightningjs/core/src/tree/core/ElementTexturizer.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ElementTexturizer)
/* harmony export */ });
/* harmony import */ var _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../TextureSource.mjs */ "./node_modules/@lightningjs/core/src/tree/TextureSource.mjs");
/*
 * If not stated otherwise in this file or this component's LICENSE file the
 * following copyright and licenses apply:
 *
 * Copyright 2020 Metrological
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



class ElementTexturizer {

    constructor(elementCore) {

        this._element = elementCore.element;
        this._core = elementCore;

        this.ctx = this._core.ctx;

        this._enabled = false;
        this.lazy = false;
        this._colorize = false;

        this._renderTexture = null;

        this._renderTextureReused = false;

        this._resultTextureSource = null;

        this._renderOffscreen = false;

        this.empty = false;
    }

    get enabled() {
        return this._enabled;
    }

    set enabled(v) {
        this._enabled = v;
        this._core.updateRenderToTextureEnabled();
    }

    get renderOffscreen() {
        return this._renderOffscreen;
    }

    set renderOffscreen(v) {
        this._renderOffscreen = v;
        this._core.setHasRenderUpdates(1);

        // This enforces rechecking the 'within bounds'.
        this._core._setRecalc(6);
    }

    get colorize() {
        return this._colorize;
    }

    set colorize(v) {
        if (this._colorize !== v) {
            this._colorize = v;

            // Only affects the finally drawn quad.
            this._core.setHasRenderUpdates(1);
        }
    }

    _getTextureSource() {
        if (!this._resultTextureSource) {
            this._resultTextureSource = new _TextureSource_mjs__WEBPACK_IMPORTED_MODULE_0__["default"](this._element.stage.textureManager);
            this.updateResultTexture();
        }
        return this._resultTextureSource;
    }

    hasResultTexture() {
        return !!this._resultTextureSource;
    }

    resultTextureInUse() {
        return this._resultTextureSource && this._resultTextureSource.hasEnabledElements();
    }

    updateResultTexture() {
        let resultTexture = this.getResultTexture();
        if (this._resultTextureSource) {
            if (this._resultTextureSource.nativeTexture !== resultTexture) {
                let w = resultTexture ? resultTexture.w : 0;
                let h = resultTexture ? resultTexture.h : 0;
                this._resultTextureSource.replaceNativeTexture(resultTexture, w, h);
            }

            // Texture will be updated: all elements using the source need to be updated as well.
            this._resultTextureSource.forEachEnabledElement(element => {
                element._updateDimensions();
                element.core.setHasRenderUpdates(3);
            });
        }
    }

    mustRenderToTexture() {
        // Check if we must really render as texture.
        if (this._enabled && !this.lazy) {
            return true;
        } else if (this._enabled && this.lazy && this._core._hasRenderUpdates < 3) {
            // Static-only: if renderToTexture did not need to update during last drawn frame, generate it as a cache.
            return true;
        }
        return false;
    }

    deactivate() {
        this.release();
    }

    get renderTextureReused() {
        return this._renderTextureReused;
    }

    release() {
        this.releaseRenderTexture();
    }

    releaseRenderTexture() {
        if (this._renderTexture) {
            if (!this._renderTextureReused) {
                this.ctx.releaseRenderTexture(this._renderTexture);
            }
            this._renderTexture = null;
            this._renderTextureReused = false;
            this.updateResultTexture();
        }
    }

    // Reuses the specified texture as the render texture (in ancestor).
    reuseTextureAsRenderTexture(nativeTexture) {
        if (this._renderTexture !== nativeTexture) {
            this.releaseRenderTexture();
            this._renderTexture = nativeTexture;
            this._renderTextureReused = true;
        }
    }

    hasRenderTexture() {
        return !!this._renderTexture;
    }

    getRenderTexture() {
        if (!this._renderTexture) {
            this._renderTexture = this.ctx.allocateRenderTexture(this._core._w, this._core._h);
            this._renderTextureReused = false;
        }
        return this._renderTexture;
    }

    getResultTexture() {
        return this._renderTexture;
    }

}



/***/ }),

/***/ "./node_modules/@lightningjs/sdk/package.json":
/*!****************************************************!*\
  !*** ./node_modules/@lightningjs/sdk/package.json ***!
  \****************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@lightningjs/sdk","version":"4.8.1","license":"Apache-2.0","scripts":{"postinstall":"node ./scripts/postinstall.js","lint":"eslint \'**/*.js\'","release":"npm publish --access public"},"lint-staged":{"*.js":["eslint --fix"],"src/startApp.js":["rollup -c ./rollup.config.js"]},"husky":{"hooks":{"pre-commit":"lint-staged"}},"dependencies":{"@babel/polyfill":"^7.11.5","@lightningjs/core":"*","@michieljs/execute-as-promise":"^1.0.0","deepmerge":"^4.2.2","localCookie":"github:WebPlatformForEmbedded/localCookie","shelljs":"^0.8.4","url-polyfill":"^1.1.10","whatwg-fetch":"^3.0.0"},"devDependencies":{"@babel/core":"^7.11.6","@babel/plugin-transform-parameters":"^7.10.5 ","@babel/plugin-transform-spread":"^7.11.0","@babel/preset-env":"^7.11.5","babel-eslint":"^10.1.0","eslint":"^7.10.0","eslint-config-prettier":"^6.12.0","eslint-plugin-prettier":"^3.1.4","husky":"^4.3.0","lint-staged":"^10.4.0","prettier":"^1.19.1","rollup":"^1.32.1","rollup-plugin-babel":"^4.4.0"},"repository":{"type":"git","url":"git@github.com:rdkcentral/Lightning-SDK.git"},"bugs":{"url":"https://github.com/rdkcentral/Lightning-SDK/issues"}}');

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"pt3-firebolt_hello_world-mock","version":"1.0.0","description":"","scripts":{"build":"webpack","dev":"cross-env NODE_ENV=development webpack serve"},"dependencies":{"@firebolt-js/sdk":"^0.6.0","@lightningjs/sdk":"^4.6.1"},"devDependencies":{"@babel/core":"^7.14.5","@babel/preset-env":"^7.14.5","copy-webpack-plugin":"^10.2.4","cross-env":"^7.0.3","html-webpack-plugin":"^5.5.0","pug":">=3.0.1","pug-loader":"^2.4.0","webpack":"^5.68.0","webpack-cli":"^4.9.2","webpack-dev-server":"^4.7.4"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************!*\
  !*** ./public/index.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lightningjs/sdk */ "./node_modules/@lightningjs/sdk/index.js");
/* harmony import */ var _src_App__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/App */ "./src/App.js");
/* harmony import */ var _src_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/settings */ "./src/settings.js");
/*
* Copyright 2021 Comcast Cable Communications Management, LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* SPDX-License-Identifier: Apache-2.0
*/






// launch the application with custom settings
const app = (0,_lightningjs_sdk__WEBPACK_IMPORTED_MODULE_0__.Launch)(_src_App__WEBPACK_IMPORTED_MODULE_1__.App, _src_settings__WEBPACK_IMPORTED_MODULE_2__.appSettings, _src_settings__WEBPACK_IMPORTED_MODULE_2__.platformSettings, _src_settings__WEBPACK_IMPORTED_MODULE_2__.appData);

// append the canvas to the dom
document.body.appendChild(app.stage.getCanvas());

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxnQ0FBZ0M7QUFDaEMsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7Ozs7QUFJQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBLCtDQUErQyxlQUFlO0FBQzlEOztBQUVBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7O0FBRUE7QUFDQSxrREFBa0QsU0FBUztBQUMzRDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsUUFBUTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7O0FBSUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0EsNERBQTREO0FBQzVEOztBQUVBOztBQUVBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7O0FBSUE7QUFDQSx5REFBeUQ7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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNGO0FBQ1Y7QUFDVCwyQkFBMkIsNERBQW1CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxRUFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxRUFBNEI7QUFDN0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLFNBQVMscURBQVk7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTOztBQUUzQyx1QkFBdUIsaURBQVE7QUFDL0I7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DOztBQUVyQixpQ0FBaUMsd0VBQStCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsVUFBVSxHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QjtBQUN6Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0QjtBQUNNO0FBQ21COztBQUVyRCxpRUFBZTtBQUNmLHlCQUF5QixxREFBWTs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQVc7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9FQUEyQjtBQUM1QywrQkFBK0IsOERBQXFCO0FBQ3BEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwyREFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIscURBQVk7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RCxzQ0FBc0Msc0JBQXNCO0FBQzVELHFDQUFxQyxxQkFBcUI7QUFDMUQsdUNBQXVDLHFCQUFxQjtBQUM1RCx5Q0FBeUMsdUJBQXVCO0FBQ2hFLHNDQUFzQyxpQkFBaUI7O0FBRXZEO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUN6RkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3QjtBQUNJOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0RBQVM7QUFDekI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRLGtEQUFTO0FBQ2pCO0FBQ0EsT0FBTztBQUNQLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQVE7QUFDaEI7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRLGtEQUFTO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0saURBQVE7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0JBQW9CLG9EQUFXOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsWUFBWSxrREFBUztBQUNyQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esc0NBQXNDLHlEQUF5RDtBQUMvRixHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDSTtBQUNBO0FBQ0U7QUFDTTtBQUNBO0FBQ1I7QUFDUjtBQUNNO0FBQ1I7QUFDWTtBQUNWO0FBQ1U7QUFDRjs7QUFFakM7O0FBRVAsaUVBQWU7QUFDZixFQUFFLHdEQUFZO0FBQ2QsRUFBRSx5REFBWTs7QUFFZCxFQUFFLGtEQUFTO0FBQ1gsRUFBRSxzREFBVztBQUNiO0FBQ0E7QUFDQSx3Q0FBd0MscURBQVc7QUFDbkQsd0NBQXdDLHFEQUFXO0FBQ25ELDRDQUE0Qyw2REFBZTtBQUMzRCw0Q0FBNEMsNkRBQWU7QUFDM0Qsb0NBQW9DLDZDQUFPO0FBQzNDLHVDQUF1QyxtREFBVTtBQUNqRCxtQ0FBbUMsMkNBQU07QUFDekMseUNBQXlDLHdEQUFZO0FBQ3JELG9DQUFvQyw4Q0FBTztBQUMzQzs7QUFFQSxjQUFjLHlEQUFXO0FBQ3pCO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDMUREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUM7QUFDekMsaUVBQWUseURBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQnhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEdBQUcsT0FBTyxHQUFHO0FBQ3JELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsR0FBRyxPQUFPLEdBQUc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlEQUFRO0FBQ2Q7QUFDQSxRQUFRLGlEQUFRO0FBQ2hCO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUSxrREFBUztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsRUFBRSxHQUFHLEVBQUU7QUFDbkQ7QUFDQTtBQUNBLDZCQUE2QixHQUFHLEtBQUssR0FBRyxLQUFLLEVBQUU7QUFDL0M7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsbUVBQW1FLEVBQUUsT0FBTztBQUM1RTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsWUFBWTs7Ozs7Ozs7Ozs7Ozs7OztBQ3JLM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsa0JBQWtCO0FBQzdFO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZTtBQUNmO0FBQ0EsSUFBSSxxREFBWTtBQUNoQixHQUFHO0FBQ0g7QUFDQSxJQUFJLHFEQUFZO0FBQ2hCLEdBQUc7QUFDSDtBQUNBLElBQUkscURBQVk7QUFDaEIsR0FBRztBQUNIO0FBQ0EsSUFBSSxxREFBWTtBQUNoQixHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsREQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNKO0FBQ0U7QUFDVjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVlLDBCQUEwQiw0REFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFEQUFZO0FBQ3BDLElBQUksaURBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU0seUVBQWdDLGVBQWU7QUFDNUUsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0EsMkJBQTJCLHNDQUFzQztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxJQUFJLGlEQUFRO0FBQ1o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCLGtEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxvRUFBMkI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFlBQVkscURBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLHlCQUF5QixrQ0FBa0M7QUFDM0Q7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyxJQUFJLGlEQUFRO0FBQ1o7QUFDQSxNQUFNLGlEQUFRO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxvRUFBMkI7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0NEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0I7O0FBRXhCO0FBQ0EsRUFBRSxpREFBUTtBQUNWOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUE4RDtBQUM5RCxhQUFhLGFBQWE7QUFDMUI7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxtQkFBbUIseUJBQXlCLE9BQU8sSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTs7QUFFQSxpRUFBZSxnQkFBZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUYvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ1o7O0FBRXhCLHVCQUF1Qiw0REFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSwyRUFBa0MsY0FBYztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVlLHdCQUF3Qiw0REFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU0sMkVBQWtDLGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZDQUE2QztBQUMvRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtDQUErQztBQUNqRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRLGlEQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLG1EQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFlBQVksaURBQVE7QUFDcEIsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0M7QUFDRjtBQUNlO0FBQ2Q7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFZO0FBQ3ZDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw0Q0FBUTtBQUNaO0FBQ0EsSUFBSTtBQUNKLElBQUksNENBQVE7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBLGtCQUFrQixnRUFBMkI7QUFDN0M7QUFDQSxjQUFjLCtDQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxvRUFBK0I7QUFDckMsTUFBTSw4REFBeUI7QUFDL0IsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLElBQUksOERBQXlCO0FBQzdCLElBQUksaUVBQTRCLEdBQUcscUVBQWdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDeElEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkU7O0FBRXRFO0FBQ1A7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFjO0FBQ25DO0FBQ0E7QUFDQSxrQkFBa0IscURBQVc7QUFDN0IsZ0JBQWdCLG1EQUFTO0FBQ3pCLGdCQUFnQixtREFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDOztBQUVsQztBQUNBO0FBQ0EsY0FBYyxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDM0QsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFZO0FBQ3BCO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0M7QUFDUzs7QUFFM0M7QUFDQSxvQkFBb0IsR0FBRyxxREFBYyxLQUFLLHFEQUFZO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFEQUFjLEVBQUUscURBQWM7QUFDM0M7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyRkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnQztBQUNFO0FBQ1E7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QiwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCLDhCQUE4QixXQUFXLElBQUksSUFBSTtBQUNqRDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQiwwREFBaUI7QUFDcEMsa0NBQWtDLFdBQVcsSUFBSSxJQUFJO0FBQ3JEO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQixJQUFJLElBQUk7QUFDeEQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCLG9DQUFvQyxXQUFXLElBQUksSUFBSTtBQUN2RDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6QixRQUFRLDREQUFtQjtBQUMzQixRQUFRLHlEQUFnQjtBQUN4QixRQUFRLG9EQUFXO0FBQ25CLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQVk7QUFDcEMsa0JBQWtCLHFEQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUFRO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpREFBUTtBQUNaO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLE1BQU0saURBQVE7QUFDZDtBQUNBLE1BQU07QUFDTixNQUFNLGtEQUFTO0FBQ2Y7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlEQUFRO0FBQ1o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpREFBUTtBQUNkO0FBQ0EsTUFBTTtBQUNOLE1BQU0sa0RBQVM7QUFDZjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpREFBUTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpREFBUTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sTUFBTSxrREFBUztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25MRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ087QUFDSztBQUNMOztBQUVwQyx3QkFBd0IsNERBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsOERBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVM7QUFDeEIsWUFBWSx3REFBZ0I7QUFDNUI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFvQjtBQUMvQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBV3dCOztBQWtCRDs7QUFFcUQ7QUFDa0I7QUFReEU7QUFDZTtBQUNpQjtBQUNwQjtBQUNBOztBQUVsQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwwREFBVTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvRUFBb0I7QUFDckMsc0JBQXNCLDZEQUFjO0FBQ3BDLG1CQUFtQiwwREFBVztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0EsTUFBTSx5REFBZTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsd0RBQVE7QUFDbEI7QUFDQSxRQUFRLFNBQVMsMERBQVU7QUFDM0I7QUFDQSxjQUFjLHdEQUFRO0FBQ3RCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVSx1REFBWTtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBLE1BQU0sMERBQVc7QUFDakI7QUFDQSxXQUFXLDREQUFjO0FBQ3pCLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSSxTQUFTLDBEQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDBEQUFXO0FBQ2pCLG9CQUFvQixXQUFXLFlBQVk7QUFDM0MsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0M7QUFDdkMsTUFBTSx3REFBUTtBQUNkLFVBQVUsMkRBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLHFFQUFzQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxxRUFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1REFBWTtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLHVEQUFZO0FBQ3BCLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLFNBQVMseURBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQWE7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlLHlEQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLDREQUFjOztBQUU5QjtBQUNBLFFBQVEsMERBQVc7QUFDbkIsc0JBQXNCLGtCQUFrQjtBQUN4QyxNQUFNO0FBQ04sOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsOERBQWUsQ0FBQyw0REFBYTs7QUFFbEQ7QUFDQTtBQUNBLHdDQUF3Qyw0REFBYTtBQUNyRDs7QUFFQSxNQUFNLHlEQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHdEQUFRO0FBQ2hCO0FBQ0EsTUFBTSxTQUFTLHdEQUFRO0FBQ3ZCO0FBQ0EsVUFBVSx5REFBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyREFBVzs7QUFFYjtBQUNBLHNCQUFzQiwyREFBWTtBQUNsQztBQUNBLFFBQVEsMERBQVU7QUFDbEIsd0JBQXdCLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBRyxJQUFJLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNERBQWE7QUFDdEM7QUFDQSwwQkFBMEIsaUVBQW1CLENBQUMsNkRBQWM7QUFDNUQseUNBQXlDLDZEQUFjO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHNEQUFNLFlBQVksZ0RBQUs7QUFDakMsUUFBUSxtREFBSTtBQUNaLFVBQVUsdURBQVk7QUFDdEI7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFlBQVksNkRBQWM7QUFDMUIsbUJBQW1CLG1EQUFJO0FBQ3ZCLFdBQVc7QUFDWDtBQUNBLFlBQVksdURBQVk7QUFDeEI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQVUsQ0FBQyw4REFBbUI7QUFDdEMsYUFBYSw4REFBbUI7QUFDaEM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJEQUFVO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBaUI7QUFDMUIsU0FBUyxnRUFBb0I7QUFDN0IsT0FBTztBQUNQO0FBQ0E7QUFDQSxJQUFJLFNBQVMsMkRBQWdCO0FBQzdCO0FBQ0EsZUFBZSx3REFBVTtBQUN6QixnQkFBZ0Isc0RBQVE7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0REFBYztBQUMxQixrQ0FBa0MsQ0FBQyw2REFBaUIsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sd0RBQVE7QUFDZDtBQUNBO0FBQ0EsSUFBSSxTQUFTLDBEQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxVQUFVLHdEQUFRO0FBQ2xCO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDREQUFhO0FBQzlCLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsa0VBQXlCO0FBQzNCLFFBQVEscUVBQXNCO0FBQzlCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBEQUFXO0FBQzlCLE1BQU0sd0RBQVE7QUFDZDtBQUNBLElBQUksU0FBUywwREFBVTtBQUN2QjtBQUNBLFVBQVUsd0RBQVE7QUFDbEI7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHdEQUFhO0FBQzNCO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCLEdBQUc7QUFDSCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGFBQWE7QUFDYixpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QjtBQUNBLFNBQVM7QUFDVCxPQUFPLDRDQUFTO0FBQ2hCO0FBQ0EsYUFBYSx3REFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwakJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0Q7QUFDYjtBQUN2Qjs7QUFFWjtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsd0RBQVE7QUFDaEIsdUJBQXVCLCtEQUFjO0FBQ3JDLE1BQU0sU0FBUyx5REFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBYTtBQUNwQzs7QUFFQTtBQUNBLElBQUksa0RBQVMsMkJBQTJCLFdBQVc7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzVLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTZDOztBQUU5QjtBQUNmLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYSwwREFBVTtBQUN2QixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xELFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBLFlBQVksS0FBSyxVQUFVLDJCQUEyQjtBQUN0RCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBLGNBQWMsS0FBSyx5Q0FBeUMsMkJBQTJCO0FBQ3ZGLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5R0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5Qzs7QUFFbEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVEQUFhO0FBQzFCLEdBQUc7QUFDSDs7Ozs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdEOztBQUV4RCxpRUFBZSwrQkFBK0I7QUFDOUMsT0FBTyxpREFBTztBQUNkO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBTyxJQUFJO0FBQ25DLFFBQVEsb0RBQVU7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1QztBQUNGO0FBQ0c7QUFDQTs7QUFFakM7QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCxtQkFBbUIsMERBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCxZQUFZLDBCQUEwQixFQUFFLFdBQVc7QUFDbkQ7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCx5QkFBeUIscURBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscURBQVk7QUFDOUQ7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUCxzQ0FBc0MsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8scUNBQXFDLHNEQUFhO0FBQ3pELHFCQUFxQixxREFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTSxHQUFHLFdBQVc7QUFDckMsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxHQUFHLFNBQVM7QUFDbEMsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUQ7QUFDSjtBQUMwQjtBQUNuQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUCxlQUFlLHNEQUFhO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLG1EQUFhOztBQUV2RDtBQUNBLHNCQUFzQixzREFBYztBQUNwQyx5QkFBeUIsaURBQVM7O0FBRWxDO0FBQ0EsY0FBYyxtREFBUzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNEQUFhO0FBQ3BELHlCQUF5Qix3REFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1DQUFtQztBQUN4RCxNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQixxQ0FBcUM7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrREFBUTtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQixvREFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUCxNQUFNLGlEQUFPO0FBQ2I7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFhaUI7O0FBRVU7QUFDdUQ7QUFDYTtBQUNqRDtBQUNFO0FBQ0w7QUFDbEI7QUFDVTtBQUNBO0FBQ2tCO0FBQ2pCOztBQUVwQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQVM7QUFDbkIsWUFBWSx5REFBZ0I7QUFDNUIsVUFBVSxrREFBYSxhQUFhLHlEQUFlO0FBQ25ELFVBQVU7QUFDVixVQUFVLGtEQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDhEQUFpQixlQUFlLHNEQUFhO0FBQzNEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrREFBUywwQkFBMEIsY0FBYyxtQkFBbUIsb0RBQVcsSUFBSTtBQUN6RjtBQUNBO0FBQ0EsUUFBUSxxREFBZ0I7QUFDeEI7QUFDQSxNQUFNO0FBQ04sTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxVQUFVLGlEQUFTO0FBQ25CLFFBQVEscURBQVU7QUFDbEIsUUFBUSxVQUFVLG9EQUFlO0FBQ2pDLFFBQVEsd0RBQWE7QUFDckI7O0FBRUE7QUFDQTtBQUNBLFFBQVEscURBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFEQUFZO0FBQ3pCLG9CQUFvQixnRUFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyx1REFBaUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQVc7QUFDbkIsVUFBVSx3REFBYSxlQUFlLGtEQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzREFBYSxNQUFNLHNEQUFhLEdBQUcsbURBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osbUJBQW1CLDREQUFlLENBQUMsMENBQUs7QUFDeEMsSUFBSSxnREFBVztBQUNmO0FBQ0EsUUFBUSxzREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxrREFBWTtBQUMzQixlQUFlLG1EQUFhOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkJBQTJCLEVBQUUsc0RBQVc7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGdEQUFTOztBQUVyQjtBQUNBLG1CQUFtQixvREFBVztBQUM5QjtBQUNBLFFBQVE7QUFDUjtBQUNBLFVBQVUsaURBQUk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixNQUFNLHlEQUFjO0FBQ3BCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUksa0RBQVM7QUFDYjs7QUFFQSxzQkFBc0Isb0RBQVc7QUFDakMsSUFBSSxnREFBUSxRQUFRLFNBQVM7QUFDN0I7QUFDQTs7QUFFTztBQUNQLGNBQWMsaURBQVM7QUFDdkIsaUJBQWlCLHFEQUFnQjs7QUFFakM7QUFDQSxNQUFNLG1EQUFTO0FBQ2Y7QUFDQTtBQUNBLFdBQVcsbURBQVM7QUFDcEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlEO0FBQ047QUFDUjtBQUNsQjs7QUFFbEI7O0FBRUE7QUFDUDtBQUNBLG9CQUFvQiw4Q0FBUztBQUM3QixJQUFJLGtEQUFhO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQsaUJBQWlCLHFEQUFlO0FBQ2hDO0FBQ0EsTUFBTSxpREFBSTtBQUNWO0FBQ0EsR0FBRztBQUNIOztBQUVPLDBCQUEwQix5Q0FBeUM7QUFDMUUsb0JBQW9CLHlEQUFpQjtBQUNyQyxzQkFBc0IsOERBQW9CO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcseURBQW1CO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSxrREFBSTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsWUFBWSxxREFBZTtBQUMzQjtBQUNBOztBQUVBLHVCQUF1QixxREFBZTtBQUN0Qzs7QUFFQTtBQUNBOztBQUVPO0FBQ1AsTUFBTSxvREFBVztBQUNqQixtQkFBbUIsK0NBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLE1BQU0sb0RBQVc7QUFDakIsWUFBWSxXQUFXLEVBQUUsK0NBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTyxvQkFBb0IsZ0JBQWdCLElBQUksR0FBRztBQUMzQztBQUNBO0FBQ0E7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUU7QUFDSDtBQUNoQztBQUNKO0FBQ2lDOztBQUVuRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsUUFBUTtBQUNyQjtBQUNPO0FBQ1AsU0FBUyxrREFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWEsWUFBWTtBQUN6QjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNELFFBQVEsaURBQWE7QUFDckIscUNBQXFDLDRDQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQWdCO0FBQzFCLDZCQUE2QixvREFBZ0I7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsSUFBSTs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxXQUFXOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUyxxREFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtDQUFVO0FBQ3ZCLE1BQU07QUFDTjtBQUNBO0FBQ0EsZUFBZSxxREFBaUI7QUFDaEMsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVLG9EQUFXO0FBQ3JCLGVBQWUsK0NBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxTQUFTLGtEQUFVOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBUTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBVztBQUNuQixxQkFBcUIsZ0RBQVc7QUFDaEM7QUFDQTtBQUNBLGFBQWEsb0RBQUs7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsYUFBYSxzREFBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsSUFBSTtBQUNuQyxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQixLQUFLLEVBQUUsNkRBQW1CLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsbURBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1AsTUFBTSxrREFBUTtBQUNkLG1CQUFtQixrREFBUztBQUM1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFXa0I7QUFDNEI7QUFDRTtBQUNGO0FBQ25CO0FBQ1M7QUFDWDtBQUNnQjtBQUNZO0FBQ047O0FBRS9DO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ087O0FBRVA7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRDQUFJO0FBQ1I7QUFDQTtBQUNBOztBQUVPO0FBQ1AsUUFBUSxzQkFBc0I7O0FBRTlCO0FBQ0Esa0JBQWtCLGdEQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBVztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0RBQVk7O0FBRTdCOztBQUVBLE1BQU0saURBQU87QUFDYjtBQUNBLElBQUksU0FBUyxvREFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtREFBUztBQUMxQjtBQUNBLG9CQUFvQixtREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdFQUFzQjtBQUNsQztBQUNBLG1CQUFtQiw0REFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxNQUFNLG9EQUFVO0FBQ2hCO0FBQ0E7QUFDQSxNQUFNLG1EQUFTO0FBQ2Y7QUFDQTtBQUNBLE1BQU0sb0RBQVU7QUFDaEI7QUFDQTtBQUNBLE1BQU0sb0RBQVU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0EsUUFBUSxnREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTixpQ0FBaUMsc0JBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBUyxxQ0FBcUMsbURBQVM7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLGlEQUFTO0FBQ2YsSUFBSSxvREFBVTtBQUNkLElBQUksa0JBQWtCLG1EQUFlO0FBQ3JDLElBQUksdURBQWE7QUFDakI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxpREFBSTtBQUNSLElBQUk7QUFDSixJQUFJLGlEQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLElBQUksdURBQWE7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDBEQUFvQixLQUFLLG9EQUFVO0FBQ3RELG1DQUFtQywwREFBb0I7QUFDdkQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQix3REFBb0I7QUFDMUM7QUFDQSxNQUFNLDJEQUFvQjtBQUMxQjtBQUNBOztBQUVBOztBQUVBLEVBQUUsaURBQVE7QUFDVixFQUFFLGlEQUFRO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVEQUFpQjs7QUFFdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwQztBQUNLO0FBQ1A7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsOEJBQThCLHdEQUFlOztBQUU3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLFFBQVEsbURBQVM7QUFDakI7QUFDQTs7QUFFQSxRQUFRLGtEQUFRO0FBQ2hCLGlCQUFpQixvREFBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyQztBQUNSO0FBQ1Y7O0FBRXpCOztBQUVPO0FBQ1AsT0FBTyxnREFBVztBQUNsQjtBQUNBO0FBQ0EsU0FBUyxvREFBZTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBLEVBQUUsd0RBQW1CO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNLGlEQUFJO0FBQ1Y7QUFDQSxHQUFHO0FBQ0gsTUFBTSw4Q0FBUztBQUNmLElBQUksa0RBQWE7QUFDakI7QUFDQTs7QUFFQTtBQUNBLFNBQVMsaURBQU87QUFDaEIsU0FBUyx5REFBb0I7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBUztBQUNqQixNQUFNLCtDQUFVO0FBQ2hCLE1BQU07QUFDTixNQUFNLGtEQUFhO0FBQ25CO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSxFQUFFLGtEQUFhO0FBQ2Y7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDO0FBQ3lCOztBQUUzRDtBQUNBOztBQUVPO0FBQ1AsY0FBYyxxREFBWTtBQUMxQjtBQUNBLFdBQVcseUVBQVc7QUFDdEI7O0FBRUE7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQzlERDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVPLHVCQUF1QixxREFBWTs7QUFFbkM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXdCOztBQUU0Qjs7QUFFcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQWE7QUFDdkQ7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsMENBQTBDLHdEQUFhO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBUTtBQUNuQztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLE1BQU0sa0RBQVM7QUFDZjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QjtBQUM1QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDUzs7QUFFekMsd0JBQXdCLHlEQUFZOztBQUVuRDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxpRkFBaUYsbUZBQXNDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJDQUEyQyxxRkFBd0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDZDQUE2QyxnRkFBbUM7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHFGQUF3QztBQUNoRjtBQUNBO0FBQ0EsVUFBVSxxQ0FBcUMsbUZBQXNDO0FBQ3JGO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQ0FBcUMsZ0ZBQW1DO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDLG9GQUF1QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFDQUFxQyxtRkFBc0M7QUFDckY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxtRkFBc0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDBGQUEwRixnRkFBbUM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSwwQkFBMEIsOERBQVc7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGdFQUFjLE9BQU8sZ0VBQWM7QUFDbkQ7QUFDQSx3QkFBd0Isd0VBQXNCO0FBQzlDLGtCQUFrQjtBQUNsQix3QkFBd0IseUVBQXVCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLG1FQUFpQjtBQUNwRCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxrRUFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCx5RUFBdUI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRW1EO0FBQ1Q7QUFDTTtBQUNWO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5THBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx1RUFBcUI7QUFDakM7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLDhEQUFpQjtBQUN2RCxRQUFRLGtFQUFnQjtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVvQztBQUNFO0FBQ2tCO0FBQ2hCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDb0I7QUFDaEM7O0FBRXJCO0FBQ2Y7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsOEVBQTRCO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQSxnQ0FBZ0Msb0VBQXVCO0FBQ3ZEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsOEVBQTRCO0FBQ25FOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0VBQWdCO0FBQ3hCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStDOztBQUVoQyx5QkFBeUIseURBQVk7O0FBRXBEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFEOztBQUV0Qyw4QkFBOEIsa0VBQVM7O0FBRXREO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVELHdCQUF3QiwyQkFBMkI7QUFDbkQseUJBQXlCLDJCQUEyQjtBQUNwRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUZBQWE7O0FBRWhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDs7QUFFdEMsNEJBQTRCLGtFQUFTOztBQUVwRDtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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Z0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0M7QUFDUzs7QUFFOUI7OztBQUdmO0FBQ0E7O0FBRUEsMkJBQTJCLDhEQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtFQUFnQjtBQUN4Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9DO0FBQ0k7QUFDUTs7QUFFakM7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQiw4RUFBaUM7QUFDakQsaUVBQWlFLDJFQUE4QjtBQUMvRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGtFQUFnQjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG1GQUFzQztBQUN6RTtBQUNBO0FBQ0EsbUNBQW1DLG1GQUFzQztBQUN6RTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3BlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RDs7QUFFekM7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSwrQkFBK0I7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBOztBQUVBOztBQUVBO0FB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7O0FBRS9DO0FBQ0E7QUFDQTtBQUNlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLDREQUFVO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlEOztBQUUxQzs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwrQkFBK0I7O0FBRTlDOztBQUVBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUseUVBQTRCO0FBQzNDOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEM7QUFDSjtBQUNRO0FBQ047O0FBRTdCOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQix1REFBVTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIseURBQVk7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLDJEQUFjO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsd0RBQVc7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0Msb0JBQW9CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7Ozs7Ozs7Ozs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQkFBMEI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBCQUEwQjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDBCQUEwQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUQ7QUFDSDs7QUFFckMsNEJBQTRCLGdFQUFhOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0VBQVc7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDs7QUFFdkMsMEJBQTBCLDhEQUFXOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBLG1CQUFtQixzRUFBZTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLDhEQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQix1RUFBcUI7QUFDaEQsNEJBQTRCLHVFQUFxQjs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsNEVBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEQ7QUFDZjs7QUFFNUIsMEJBQTBCLHdEQUFNOztBQUUvQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0RBQWtCOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ2U7O0FBRWY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ2UsNEJBQTRCLDBEQUFhOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRDO0FBQ0k7O0FBRWpDLGlDQUFpQywwREFBYTs7QUFFN0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOERBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDalFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkM7O0FBRTlCLDRCQUE0Qix3REFBVzs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEQ7QUFDZDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ2UsOEJBQThCLDBEQUFhOztBQUUxRDtBQUNBOztBQUVBLGlDQUFpQyxrRUFBWTs7QUFFN0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0IsWUFBWTs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsNEJBQTRCLDBEQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLHlCQUF5QiwwREFBYTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsNkVBQWdDOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsOEJBQThCLDBEQUFhOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDs7QUFFakMsNEJBQTRCLDBEQUFhOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzNRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQywrQkFBK0IsMERBQWE7O0FBRTNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyw4QkFBOEIsMERBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkVBQWdDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzRDtBQUNOOztBQUVqQyw0QkFBNEIsMERBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qix3RkFBc0M7QUFDOUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFlBQVk7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyxnQ0FBZ0MsMERBQWE7O0FBRTVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVoRDtBQUNBO0FBQ0E7QUFDZSw2QkFBNkIsMERBQWE7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEOztBQUVqQyxpQ0FBaUMsMERBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDTTs7QUFFdkMsbUNBQW1DLDBEQUFhO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix3RkFBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyx3RkFBc0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWdEO0FBQ007O0FBRXZDLHFDQUFxQywwREFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isd0ZBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRDtBQUNLOztBQUV0Qyw0QkFBNEIsMERBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3RkFBc0M7QUFDekYsNkRBQTZELHdGQUFzQztBQUNuRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLDZFQUFnQzs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7QUFDTTs7QUFFdkMsNkJBQTZCLDBEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix3RkFBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ0Q7O0FBRWpDLDZCQUE2QiwwREFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBK0M7QUFDM0YsMkNBQTJDLCtDQUErQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxpRUFBZSxpQkFBaUIsRUFBQzs7Ozs7Ozs7Ozs7Ozs7OztBQy81QmpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGtFQUFxQjtBQUNsQztBQUNBLFVBQVU7QUFDVjtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGdCQUFnQiw2REFBZ0I7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRWdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUUwQztBQUNPO0FBQ25COztBQUVFO0FBQ2U7QUFDYjs7QUFFbkI7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQiw2REFBVzs7QUFFckM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwyREFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZDQUE2QyxJQUFJOztBQUVqRDtBQUNBO0FBQ0EsZ0JBQWdCLGtFQUFxQjtBQUNyQztBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQscUNBQXFDLFNBQVMsR0FBRyxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywwR0FBMEc7QUFDMUcsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDBDQUEwQztBQUMxQyx1SEFBdUg7QUFDdkg7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDZEQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkRBQWdCO0FBQzVCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixrRUFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQixrRUFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFF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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7O0FDclJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTs7QUFFZjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxPQUFPO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHlEQUFZO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRWdDOzs7Ozs7Ozs7Ozs7Ozs7QUN6WWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ2xNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7O0FBRWY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR2U7O0FBRWY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7OztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlOztBQUVmO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUVBQXVFLE9BQU87QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRDs7QUFFcEM7O0FBRWY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDZEQUFnQjtBQUM1QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSw2REFBZ0I7QUFDNUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsT0FBTztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsT0FBTztBQUN0RTtBQUNBO0FBQ0E7O0FB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QUFFQTtBQUNBO0FBQ0EsK0JBQStCLDREQUFVO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0Q7QUFDdkI7Ozs7Ozs7Ozs7Ozs7Ozs7QUNudUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWlEOztBQUVsQzs7QUFFZjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsMERBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7VUMzS0E7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEM7O0FBRVQ7QUFDd0M7O0FBRXpFO0FBQ0EsWUFBWSx3REFBTSxDQUFDLHlDQUFHLEVBQUUsc0RBQVcsRUFBRSwyREFBZ0IsRUFBRSxrREFBTzs7QUFFOUQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BmaXJlYm9sdC1qcy9zZGsvZGlzdC9maXJlYm9sdC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0Fkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9BcHBsaWNhdGlvbi9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9BdWRpb1BsYXllci9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Db2xvcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvQ29sb3JzL3V0aWxzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0Zwc0NvdW50ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvSW1nL1NjYWxlZEltYWdlVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9JbWcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvS2V5Ym9hcmQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTGFuZ3VhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTGF1bmNoL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL0xpZ2h0bmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Mb2NhbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvTG9nL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01lZGlhUGxheWVyL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01ldGFkYXRhL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL01ldHJpY3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUGluL2RpYWxvZy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9QaW4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUHJvZmlsZS9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Qcm9maWxlL2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUHJvZmlsZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9QdXJjaGFzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9SZWdpc3RyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvYmFzZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL21vZGVsL1JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL21vZGVsL1JvdXRlLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci90cmFuc2l0aW9ucy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvY29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvZW1pdC5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvaGlzdG9yeS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvbG9hZGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy9wcm92aWRlci5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvcmVnZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvUm91dGVyL3V0aWxzL3JlZ2lzdGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy9yb3V0ZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9Sb3V0ZXIvdXRpbHMvcm91dGVyLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy90cmFuc2l0aW9uLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1JvdXRlci91dGlscy93aWRnZXRzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1NldHRpbmdzL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1N0b3JhZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVFYvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVFYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVXRpbHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVmVyc2lvbkxhYmVsL2luZGV4LmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9zZGsvc3JjL1ZpZGVvUGxheWVyL1ZpZGVvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9WaWRlb1BsYXllci9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvVmlkZW9QbGF5ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvaGVscGVycy9hdXRvU2V0dXBNaXhpbi5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvc2RrL3NyYy9oZWxwZXJzL2Vhc2VFeGVjdXRpb24uanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL3Nkay9zcmMvaGVscGVycy9zZXF1ZW5jZS5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbWljaGllbGpzL2V4ZWN1dGUtYXMtcHJvbWlzZS9zcmMvZXhlY3V0ZS1hcy1wcm9taXNlLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9sb2NhbENvb2tpZS9tb2R1bGUvbG9jYWxDb29raWUuanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9zcmMvQXBwLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vc3JjL015QnV0dG9uLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vc3JjL3NldHRpbmdzLmpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9FdmVudEVtaXR0ZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbkFjdGlvblNldHRpbmdzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvYW5pbWF0aW9uL0FuaW1hdGlvbk1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vQW5pbWF0aW9uU2V0dGluZ3MubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hbmltYXRpb24vVHJhbnNpdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FuaW1hdGlvbi9UcmFuc2l0aW9uTWFuYWdlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FuaW1hdGlvbi9UcmFuc2l0aW9uU2V0dGluZ3MubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9hcHBsaWNhdGlvbi9BcHBsaWNhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FwcGxpY2F0aW9uL0NvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2FwcGxpY2F0aW9uL1N0YXRlTWFjaGluZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2NvbXBvbmVudHMvQmxvb21Db21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL0JvcmRlckNvbXBvbmVudC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2NvbXBvbmVudHMvRmFzdEJsdXJDb21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL0xpc3RDb21wb25lbnQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9jb21wb25lbnRzL1Ntb290aFNjYWxlQ29tcG9uZW50Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9GbGV4Q29udGFpbmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9GbGV4SXRlbS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvRmxleFRhcmdldC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvRmxleFV0aWxzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvQ29udGVudEFsaWduZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9GbGV4TGF5b3V0Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvSXRlbUNvb3JkaW5hdGVzVXBkYXRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L0xpbmVMYXlvdXRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L1NwYWNpbmdDYWxjdWxhdG9yLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvZmxleC9sYXlvdXQvbGluZS9JdGVtQWxpZ25lci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2ZsZXgvbGF5b3V0L2xpbmUvSXRlbVBvc2l0aW9uZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9saW5lL0xpbmVMYXlvdXQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9saW5lL1NpemVHcm93ZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9mbGV4L2xheW91dC9saW5lL1NpemVTaHJpbmtlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL2xpZ2h0bmluZy5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3BsYXRmb3Jtcy9QbGF0Zm9ybUxvYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3BsYXRmb3Jtcy9icm93c2VyL0ltYWdlV29ya2VyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcGxhdGZvcm1zL2Jyb3dzZXIvV2ViUGxhdGZvcm0ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9SZW5kZXJlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2MyZC9DMmRDb3JlUXVhZExpc3QubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvQzJkQ29yZVF1YWRPcGVyYXRpb24ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvQzJkQ29yZVJlbmRlckV4ZWN1dG9yLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL0MyZFJlbmRlcmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL0MyZFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2MyZC9DMmRUZXh0dXJlVGludE1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9jMmQvc2hhZGVycy9CbHVyU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvYzJkL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL2NvbW1vbi9zaGFkZXJzL0dyYXlzY2FsZVNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3NwYXJrL1NwYXJrUmVuZGVyZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci9zcGFyay9zaGFkZXJzL1NwYXJrU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xDb3JlUXVhZExpc3QubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTENvcmVRdWFkT3BlcmF0aW9uLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xDb3JlUmVuZGVyRXhlY3V0b3IubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFJlbmRlcmVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvV2ViR0xTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9XZWJHTFNoYWRlclByb2dyYW0ubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0JveEJsdXJTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0NpcmN1bGFyUHVzaFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGVmYXVsdFNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRGl0aGVyaW5nU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9GYWRlT3V0U2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Ib2xlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9JbnZlcnNpb25TaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpZ2h0M2RTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpbmVhckJsdXJTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL01hZ25pZmllclNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvT3V0bGluZVNoYWRlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUGVyc3BlY3RpdmVTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1BpeGVsYXRlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9SYWRpYWxGaWx0ZXJTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1JhZGlhbEdyYWRpZW50U2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Sb3VuZGVkUmVjdGFuZ2xlU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9TcGlubmVyU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9TcGlubmVyU2hhZGVyMi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvVmlnbmV0dGVTaGFkZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9IdG1sVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL0ltYWdlVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL05vaXNlVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL1JlY3RhbmdsZVRleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9Tb3VyY2VUZXh0dXJlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdGV4dHVyZXMvU3RhdGljQ2FudmFzVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL1N0YXRpY1RleHR1cmUubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9UZXh0VGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RleHR1cmVzL1RleHRUZXh0dXJlUmVuZGVyZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90ZXh0dXJlcy9UZXh0VGV4dHVyZVJlbmRlcmVyQWR2YW5jZWQubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90b29scy9NdWx0aVNwbGluZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3Rvb2xzL09iak1lcmdlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3Rvb2xzL09iamVjdExpc3RQcm94eS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3Rvb2xzL09iamVjdExpc3RXcmFwcGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdG9vbHMvVG9vbHMubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90b29scy9XZWJHTFN0YXRlTWFuYWdlci5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvQmFzZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvRWxlbWVudC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvRWxlbWVudENoaWxkTGlzdC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvT2JqZWN0TGlzdC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvU2hhZGVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9TdGFnZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvU3RhZ2VVdGlscy5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvVGV4dHVyZS5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvVGV4dHVyZU1hbmFnZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1RleHR1cmVTb3VyY2UubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1RleHR1cmVUaHJvdHRsZXIubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL1V0aWxzLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0NvcmVDb250ZXh0Lm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0NvcmVRdWFkTGlzdC5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9Db3JlUXVhZE9wZXJhdGlvbi5tanMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svLi9ub2RlX21vZHVsZXMvQGxpZ2h0bmluZ2pzL2NvcmUvc3JjL3RyZWUvY29yZS9Db3JlUmVuZGVyRXhlY3V0b3IubWpzIiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vbm9kZV9tb2R1bGVzL0BsaWdodG5pbmdqcy9jb3JlL3NyYy90cmVlL2NvcmUvQ29yZVJlbmRlclN0YXRlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0VsZW1lbnRDb3JlLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay8uL25vZGVfbW9kdWxlcy9AbGlnaHRuaW5nanMvY29yZS9zcmMvdHJlZS9jb3JlL0VsZW1lbnRUZXh0dXJpemVyLm1qcyIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vcHQzLWZpcmVib2x0X2hlbGxvX3dvcmxkLW1vY2svd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9wdDMtZmlyZWJvbHRfaGVsbG9fd29ybGQtbW9jay93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3B0My1maXJlYm9sdF9oZWxsb193b3JsZC1tb2NrLy4vcHVibGljL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiovIC8vIFRoZSByZXF1aXJlIHNjb3BlXG4vKioqKioqLyB2YXIgX193ZWJwYWNrX3JlcXVpcmVfXyA9IHt9O1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4gIFwieXFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFjY2Vzc2liaWxpdHkpLFxuICBcIm1SXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY2NvdW50KSxcbiAgXCJaTFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWR2ZXJ0aXNpbmcpLFxuICBcIlZ5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBdXRoZW50aWNhdGlvbiksXG4gIFwiQVNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERldmljZSksXG4gIFwiUEdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERpc2NvdmVyeSksXG4gIFwieldcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV2ZW50cyksXG4gIFwiTjFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEtleWJvYXJkKSxcbiAgXCJGd1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTGlmZWN5Y2xlKSxcbiAgXCJXSFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9jYWxpemF0aW9uKSxcbiAgXCJaYlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9nKSxcbiAgXCJDM1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWV0cmljcyksXG4gIFwiYUVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBhcmFtZXRlcnMpLFxuICBcInQ0XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQbGF0Zm9ybSksXG4gIFwiTlpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFByb2ZpbGUpLFxuICBcIl9GXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTZWNvbmRTY3JlZW4pLFxuICBcIlpyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTZXR0aW5ncylcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvUHJvcC9Nb2NrUHJvcHMuanNcblxuXG5jb25zdCBtb2NrcyA9IHt9XG5cbmZ1bmN0aW9uIG1vY2sobW9kdWxlLCBtZXRob2QsIGFyZ3MsIGRlZikge1xuICBjb25zdCBmdWxsTWV0aG9kID0gYCR7bW9kdWxlfS4ke21ldGhvZH1gXG4gIGlmICgoYXJncyA9PSBudWxsKSB8fCAoYXJncy5sZW5ndGggPT09IDApKSB7XG4gICAgLy8gZ2V0XG4gICAgY29uc3QgcnYgPSBtb2Nrc1tmdWxsTWV0aG9kXSAmJiBtb2Nrc1tmdWxsTWV0aG9kXS52YWx1ZSA/IG1vY2tzW2Z1bGxNZXRob2RdLnZhbHVlIDogZGVmXG4gICAgcmV0dXJuIHJ2XG4gIH0gZWxzZSB7XG4gICAgLy8gc2V0XG4gICAgbGV0IG1vY2tNZXRob2QgPSBtb2Nrc1tmdWxsTWV0aG9kXVxuICAgIGlmIChtb2NrTWV0aG9kID09IG51bGwpIHtcbiAgICAgIG1vY2tNZXRob2QgPSB7XG4gICAgICAgIHN1YnNjcmliZXJzOiBbXVxuICAgICAgfVxuICAgIH1cbiAgICBtb2Nrc1tmdWxsTWV0aG9kXSA9IG1vY2tNZXRob2RcbiAgICBtb2NrTWV0aG9kLnZhbHVlID0gYXJnc1swXS52YWx1ZVxuICAgIFRyYW5zcG9ydF9tb2NrLmV2ZW50KG1vZHVsZSwgbWV0aG9kICsgJ0NoYW5nZWQnLCB7XG4gICAgICB2YWx1ZTogYXJnc1swXS52YWx1ZVxuICAgIH0pXG4gICAgcmV0dXJuIHt9XG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNb2NrUHJvcHMgPSAoe1xuICBtb2NrOiBtb2NrXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BY2Nlc3NpYmlsaXR5L2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBkZWZhdWx0cyA9ICh7XG5cbiAgICBjbG9zZWRDYXB0aW9uczoge1xuICBcImVuYWJsZWRcIjogdHJ1ZSxcbiAgXCJzdHlsZXNcIjoge1xuICAgIFwiZm9udEZhbWlseVwiOiBcIk1vbm9zcGFjZSBzYW5zLXNlcmlmXCIsXG4gICAgXCJmb250U2l6ZVwiOiAxLFxuICAgIFwiZm9udENvbG9yXCI6IFwiI2ZmZmZmZlwiLFxuICAgIFwiZm9udEVkZ2VcIjogXCJub25lXCIsXG4gICAgXCJmb250RWRnZUNvbG9yXCI6IFwiIzdGN0Y3RlwiLFxuICAgIFwiZm9udE9wYWNpdHlcIjogMTAwLFxuICAgIFwiYmFja2dyb3VuZENvbG9yXCI6IFwiIzAwMDAwMFwiLFxuICAgIFwiYmFja2dyb3VuZE9wYWNpdHlcIjogMTAwLFxuICAgIFwidGV4dEFsaWduXCI6IFwiY2VudGVyXCIsXG4gICAgXCJ0ZXh0QWxpZ25WZXJ0aWNhbFwiOiBcIm1pZGRsZVwiXG4gIH1cbn0sXG5cbiAgICBjbG9zZWRDYXB0aW9uc1NldHRpbmdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnYWNjZXNzaWJpbGl0eScsICdjbG9zZWRDYXB0aW9uc1NldHRpbmdzJywgYXJndW1lbnRzLCB7XG4gIFwiZW5hYmxlZFwiOiB0cnVlLFxuICBcInN0eWxlc1wiOiB7XG4gICAgXCJmb250RmFtaWx5XCI6IFwiTW9ub3NwYWNlIHNhbnMtc2VyaWZcIixcbiAgICBcImZvbnRTaXplXCI6IDEsXG4gICAgXCJmb250Q29sb3JcIjogXCIjZmZmZmZmXCIsXG4gICAgXCJmb250RWRnZVwiOiBcIm5vbmVcIixcbiAgICBcImZvbnRFZGdlQ29sb3JcIjogXCIjN0Y3RjdGXCIsXG4gICAgXCJmb250T3BhY2l0eVwiOiAxMDAsXG4gICAgXCJiYWNrZ3JvdW5kQ29sb3JcIjogXCIjMDAwMDAwXCIsXG4gICAgXCJiYWNrZ3JvdW5kT3BhY2l0eVwiOiAxMDAsXG4gICAgXCJ0ZXh0QWxpZ25cIjogXCJjZW50ZXJcIixcbiAgICBcInRleHRBbGlnblZlcnRpY2FsXCI6IFwibWlkZGxlXCJcbiAgfVxufSkgfSxcblxuICAgIHZvaWNlR3VpZGFuY2U6IHtcbiAgXCJlbmFibGVkXCI6IHRydWUsXG4gIFwic3BlZWRcIjogNVxufSxcblxuICAgIHZvaWNlR3VpZGFuY2VTZXR0aW5nczogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2FjY2Vzc2liaWxpdHknLCAndm9pY2VHdWlkYW5jZVNldHRpbmdzJywgYXJndW1lbnRzLCB7XG4gIFwiZW5hYmxlZFwiOiB0cnVlLFxuICBcInNwZWVkXCI6IDVcbn0pIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0FjY291bnQvZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEFjY291bnRfZGVmYXVsdHMgPSAoe1xuXG4gICAgaWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdhY2NvdW50JywgJ2lkJywgYXJndW1lbnRzLCBcIjEyM1wiKSB9LFxuXG4gICAgdWlkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnYWNjb3VudCcsICd1aWQnLCBhcmd1bWVudHMsIFwiZWU2NzIzYjgtN2FiMy00NjJjLThkOTMtZGJmNjEyMjc5OThlXCIpIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0FkdmVydGlzaW5nL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBZHZlcnRpc2luZ19kZWZhdWx0cyA9ICh7XG5cbiAgICBjb25maWc6IHtcbiAgXCJhZFNlcnZlclVybFwiOiBcImh0dHA6Ly9kZW1vLnYuZndtcm0ubmV0L2FkL3AvMVwiLFxuICBcImFkU2VydmVyVXJsVGVtcGxhdGVcIjogXCJodHRwOi8vZGVtby52LmZ3bXJtLm5ldC9hZC9wLzE/ZmxhZz0rc2x0cCtleHZ0K3NsY2IrZW1jcithbWNiK2FldGkmcHJvZj0xMjM0NTpjYWZfYWxsaW5vbmVfcHJvZmlsZSAmbnc9MTIzNDUmbW9kZT1saXZlJnZkdXI9MTIzJmNhaWQ9YTExMDUyMzAxOCZhc253PTM3MjQ2NCZjc2lkPWdtb3R0X2lvc190YWJsZXRfd2F0Y2hfbGl2ZV9FU1BOVSZzc253PTM3MjQ2NCZ2aXA9MTk4LjIwNS45Mi4xJnJlc3A9dm1hcDEmbWV0cj0xMDMxJnB2cm49MTIzNDUmdnBybj0xMjM0NSZ2Y2lkPTFYMENlN0wzeFJXbFRlTmhjN2JyOFElM0QlM0RcIixcbiAgXCJhZE5ldHdvcmtJZFwiOiBcIjUxOTE3OFwiLFxuICBcImFkUHJvZmlsZUlkXCI6IFwiMTIzNDU6Y2FmX2FsbGlub25lX3Byb2ZpbGVcIixcbiAgXCJhZFNpdGVTZWN0aW9uSWRcIjogXCJjYWZfYWxsaW5vbmVfcHJvZmlsZV9zZWN0aW9uXCIsXG4gIFwiYWRPcHRPdXRcIjogdHJ1ZSxcbiAgXCJwcml2YWN5RGF0YVwiOiBcImV3MEtJQ0FpY0dSMElqb2dJbWRrY0RwMk1TSXNEUW9nSUNKMWMxOXdjbWwyWVdONUlqb2dJakV0VGkwaUxBMEtJQ0FpYkcxMElqb2dJakVpSUEwS2ZRMEtcIixcbiAgXCJpZmFWYWx1ZVwiOiBcIjAxMjM0NTY3LTg5QUItQ0RFRi1HSDAxLTIzNDU2Nzg5QUJDRFwiLFxuICBcImlmYVwiOiBcImV3b2dJQ0oyWVd4MVpTSTZJQ0l3TVRJek5EVTJOeTA0T1VGQ0xVTkVSVVl0UjBnd01TMHlNelExTmpjNE9VRkNRMFFpTEFvZ0lDSnBabUZmZEhsd1pTSTZJQ0p6YzNCcFpDSXNDaUFnSW14dGRDSTZJQ0l3SWdwOUNnPT1cIixcbiAgXCJhcHBOYW1lXCI6IFwiRnV0dXJlVG9kYXlcIixcbiAgXCJhcHBCdW5kbGVJZFwiOiBcIkZ1dHVyZVRvZGF5LmNvbWNhc3RcIixcbiAgXCJkaXN0cmlidXRvckFwcElkXCI6IFwiMTAwMVwiLFxuICBcImRldmljZUFkQXR0cmlidXRlc1wiOiBcImV3b2dJQ0ppYjBGMGRISnBZblYwWlhOR2IzSlNaWFpUYUdGeVpVbGtJam9nSWpFeU16UWlDbjA9XCIsXG4gIFwiY29wcGFcIjogMCxcbiAgXCJhdXRoZW50aWNhdGlvbkVudGl0eVwiOiBcIjYwZjcyNDc1MjgxY2ZiYTM4NTI0MTNiZDUzZTk1N2Y2XCJcbn0sXG5cbiAgICBwb2xpY3k6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdhZHZlcnRpc2luZycsICdwb2xpY3knLCBhcmd1bWVudHMsIHtcbiAgXCJza2lwUmVzdHJpY3Rpb25cIjogXCJhZHNVbndhdGNoZWRcIixcbiAgXCJsaW1pdEFkVHJhY2tpbmdcIjogZmFsc2Vcbn0pIH0sXG5cbiAgICBhZHZlcnRpc2luZ0lkOiB7XG4gIFwiaWZhXCI6IFwiMDEyMzQ1NjctODlBQi1DREVGLUdIMDEtMjM0NTY3ODlBQkNEXCIsXG4gIFwiaWZhX3R5cGVcIjogXCJpZGZhXCIsXG4gIFwibG10XCI6IFwiMFwiXG59LFxuXG4gICAgZGV2aWNlQXR0cmlidXRlczoge30sXG5cbiAgICBhcHBCdW5kbGVJZDogXCJvcGVyYXRvci5hcHBcIlxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvQXV0aGVudGljYXRpb24vZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IEF1dGhlbnRpY2F0aW9uX2RlZmF1bHRzID0gKHtcblxuICAgIHRva2VuOiB7XG4gIFwidmFsdWVcIjogXCJleUpoYkdjaU9pSklVekkxTmlJc0luUjVjQ0k2SWtwWFZDSjkuZXlKemRXSWlPaUl4TWpNME5UWTNPRGt3SWl3aWJtRnRaU0k2SWtwdmFHNGdSRzlsSWl3aWFXRjBJam94TlRFMk1qTTVNREl5ZlEuU2ZsS3h3UkpTTWVLS0YyUVQ0ZndwTWVKZjM2UE9rNnlKVl9hZFFzc3c1Y1wiLFxuICBcImV4cGlyZXNcIjogXCIyMDIyLTA0LTIzVDE4OjI1OjQzLjUxMVpcIixcbiAgXCJ0eXBlXCI6IFwicGxhdGZvcm1cIlxufVxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvRGV2aWNlL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBEZXZpY2VfZGVmYXVsdHMgPSAoe1xuXG4gICAgaWQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnaWQnLCBhcmd1bWVudHMsIFwiMTIzXCIpIH0sXG5cbiAgICBkaXN0cmlidXRvcjogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdkaXN0cmlidXRvcicsIGFyZ3VtZW50cywgXCJDb21wYW55XCIpIH0sXG5cbiAgICBwbGF0Zm9ybTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdwbGF0Zm9ybScsIGFyZ3VtZW50cywgXCJXUEVcIikgfSxcblxuICAgIHVpZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICd1aWQnLCBhcmd1bWVudHMsIFwiZWU2NzIzYjgtN2FiMy00NjJjLThkOTMtZGJmNjEyMjc5OThlXCIpIH0sXG5cbiAgICB0eXBlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ3R5cGUnLCBhcmd1bWVudHMsIFwiU1RCXCIpIH0sXG5cbiAgICBtb2RlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdtb2RlbCcsIGFyZ3VtZW50cywgXCJ4aTZcIikgfSxcblxuICAgIHNrdTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICdza3UnLCBhcmd1bWVudHMsIFwiQVgwNjFBRUlcIikgfSxcblxuICAgIG1ha2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnbWFrZScsIGFyZ3VtZW50cywgXCJBcnJpc1wiKSB9LFxuXG4gICAgdmVyc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICd2ZXJzaW9uJywgYXJndW1lbnRzLCB7XG4gIFwic2RrXCI6IHtcbiAgICBcIm1ham9yXCI6IDAsXG4gICAgXCJtaW5vclwiOiA1LFxuICAgIFwicGF0Y2hcIjogMCxcbiAgICBcInJlYWRhYmxlXCI6IFwiRmlyZWJvbHQgSlMgU0RLIHYwLjUuMFwiXG4gIH0sXG4gIFwib3NcIjoge1xuICAgIFwibWFqb3JcIjogMCxcbiAgICBcIm1pbm9yXCI6IDEsXG4gICAgXCJwYXRjaFwiOiAwLFxuICAgIFwicmVhZGFibGVcIjogXCJGaXJlYm9sdCBPUyB2MC4xLjBcIlxuICB9LFxuICBcImRlYnVnXCI6IFwiXCJcbn0pIH0sXG5cbiAgICBoZGNwOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ2hkY3AnLCBhcmd1bWVudHMsIHtcbiAgXCJoZGNwMS40XCI6IHRydWUsXG4gIFwiaGRjcDIuMlwiOiB0cnVlXG59KSB9LFxuXG4gICAgaGRyOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ2hkcicsIGFyZ3VtZW50cywge1xuICBcImhkcjEwXCI6IHRydWUsXG4gIFwiaGRyMTBQbHVzXCI6IHRydWUsXG4gIFwiZG9sYnlWaXNpb25cIjogdHJ1ZSxcbiAgXCJobGdcIjogdHJ1ZVxufSkgfSxcblxuICAgIGF1ZGlvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ2F1ZGlvJywgYXJndW1lbnRzLCB7XG4gIFwic3RlcmVvXCI6IHRydWUsXG4gIFwiZG9sYnlEaWdpdGFsNS4xXCI6IHRydWUsXG4gIFwiZG9sYnlEaWdpdGFsNS4xK1wiOiB0cnVlLFxuICBcImRvbGJ5QXRtb3NcIjogdHJ1ZVxufSkgfSxcblxuICAgIHNjcmVlblJlc29sdXRpb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdkZXZpY2UnLCAnc2NyZWVuUmVzb2x1dGlvbicsIGFyZ3VtZW50cywgW1xuICAxOTIwLFxuICAxMDgwXG5dKSB9LFxuXG4gICAgdmlkZW9SZXNvbHV0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ3ZpZGVvUmVzb2x1dGlvbicsIGFyZ3VtZW50cywgW1xuICAxOTIwLFxuICAxMDgwXG5dKSB9LFxuXG4gICAgbmFtZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2RldmljZScsICduYW1lJywgYXJndW1lbnRzLCBcIkxpdmluZyBSb29tXCIpIH0sXG5cbiAgICBuZXR3b3JrOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnZGV2aWNlJywgJ25ldHdvcmsnLCBhcmd1bWVudHMsIHtcbiAgXCJzdGF0ZVwiOiBcImNvbm5lY3RlZFwiLFxuICBcInR5cGVcIjogXCJ3aWZpXCJcbn0pIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0Rpc2NvdmVyeS9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRGlzY292ZXJ5X2RlZmF1bHRzID0gKHtcblxuICAgIHBvbGljeTogZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ja1Byb3BzLm1vY2soJ2Rpc2NvdmVyeScsICdwb2xpY3knLCBhcmd1bWVudHMsIHtcbiAgXCJlbmFibGVSZWNvbW1lbmRhdGlvbnNcIjogdHJ1ZSxcbiAgXCJzaGFyZVdhdGNoSGlzdG9yeVwiOiB0cnVlLFxuICBcInJlbWVtYmVyV2F0Y2hlZFByb2dyYW1zXCI6IHRydWVcbn0pIH0sXG5cbiAgICBlbnRpdHlJbmZvOiB0cnVlLFxuXG4gICAgcHVyY2hhc2VkQ29udGVudDogdHJ1ZSxcblxuICAgIHdhdGNoZWQ6IHRydWUsXG5cbiAgICB3YXRjaE5leHQ6IHRydWUsXG5cbiAgICBlbnRpdGxlbWVudHM6IHRydWUsXG5cbiAgICBsYXVuY2g6IHRydWUsXG5cbiAgICBzaWduSW46IHRydWUsXG5cbiAgICBzaWduT3V0OiB0cnVlXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9LZXlib2FyZC9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgS2V5Ym9hcmRfZGVmYXVsdHMgPSAoe1xuXG4gICAgZW1haWw6IFwidXNlckBkb21haW4uY29tXCIsXG5cbiAgICBwYXNzd29yZDogXCJhYmMxMjNcIixcblxuICAgIHN0YW5kYXJkOiBcIkxpdmluZyBSb29tXCJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9nbG9iYWwuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxubGV0IGdcblxuaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuXHRnID0gc2VsZjtcbn0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0ZyA9IHdpbmRvdztcbn0gZWxzZSB7XG5cdGcgPSBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xufSBcblxuY29uc3QgZ2xvYmFsID0gZ1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFRyYW5zcG9ydF9nbG9iYWwgPSAoZ2xvYmFsKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9MaWZlY3ljbGUvZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5sZXQgaW5hY3RpdmUgPSB7XCJzdGF0ZVwiOlwiaW5hY3RpdmVcIixcInByZXZpb3VzXCI6XCJpbml0aWFsaXppbmdcIn1cbmxldCBmb3JlZ3JvdW5kID0ge1wic3RhdGVcIjpcImZvcmVncm91bmRcIixcInByZXZpb3VzXCI6XCJpbmFjdGl2ZVwifVxubGV0IGJhY2tncm91bmQgPSB7XCJzdGF0ZVwiOlwiYmFja2dyb3VuZFwiLFwicHJldmlvdXNcIjpcImZvcmVncm91bmRcIn1cbmxldCBzdXNwZW5kZWQgPSB7XCJzdGF0ZVwiOlwic3VzcGVuZGVkXCIsXCJwcmV2aW91c1wiOlwiaW5hY3RpdmVcIn1cbmxldCB1bmxvYWRpbmcgPSB7XCJzdGF0ZVwiOlwidW5sb2FkaW5nXCIsXCJwcmV2aW91c1wiOlwiaW5hY3RpdmVcIn1cblxuY29uc3QgZW1pdCA9ICh2YWx1ZSkgPT4ge1xuICB2YWx1ZS5wcmV2aW91cyA9IExpZmVjeWNsZS5zdGF0ZSgpXG4gIFRyYW5zcG9ydF9tb2NrLmV2ZW50KCdMaWZlY3ljbGUnLCB2YWx1ZS5zdGF0ZSwgdmFsdWUpXG59XG5cbmNvbnN0IGF1dG9tYXRpb24gPSBUcmFuc3BvcnRfZ2xvYmFsICYmIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCA/ICEhVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmF1dG9tYXRpb24gOiBmYWxzZVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExpZmVjeWNsZV9kZWZhdWx0cyA9ICh7XG4gIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICBpbmFjdGl2ZS5wcmV2aW91cyA9ICdpbml0aWFsaXppbmcnXG4gICAgc2V0VGltZW91dCgoKSA9PiBlbWl0KGluYWN0aXZlKSwgYXV0b21hdGlvbiA/IDEgOiA1MDApXG4gICAgZm9yZWdyb3VuZC5wcmV2aW91cyA9ICdpbmFjdGl2ZSdcbiAgICBzZXRUaW1lb3V0KCgpID0+IGVtaXQoZm9yZWdyb3VuZCksIGF1dG9tYXRpb24gPyAyIDogMTAwMClcbiAgfSxcblxuICBjbG9zZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgbGV0IHJlYXNvbiA9IHBhcmFtcy5yZWFzb25cbiAgICBpZiAocmVhc29uID09PSBMaWZlY3ljbGUuQ2xvc2VSZWFzb24uUkVNT1RFX0JVVFRPTikge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBlbWl0KGluYWN0aXZlKSwgYXV0b21hdGlvbiA/IDEgOiA1MDApXG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC52YWx1ZXMoTGlmZWN5Y2xlLkNsb3NlUmVhc29uKS5pbmNsdWRlcyhyZWFzb24pKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IGVtaXQoaW5hY3RpdmUpLCBhdXRvbWF0aW9uID8gMSA6IDUwMClcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZW1pdCh1bmxvYWRpbmcpLCBhdXRvbWF0aW9uID8gMiA6IDEwMDApXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IExpZmVjeWNsZS5maW5pc2hlZCgpLCBhdXRvbWF0aW9uID8gMzogMzAwMClcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgY2xvc2UgcmVhc29uXCJcbiAgICB9XG4gIH0sXG5cbiAgZmluaXNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLmxvY2F0aW9uKVxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5sb2NhdGlvbi5ocmVmID0gXCJhYm91dDpibGFua1wiXG4gIH0sXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0xvY2FsaXphdGlvbi9kZWZhdWx0cy5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTG9jYWxpemF0aW9uX2RlZmF1bHRzID0gKHtcblxuICAgIGxvY2FsaXR5OiBcIlBoaWxhZGVscGhpYVwiLFxuXG4gICAgcG9zdGFsQ29kZTogXCIxOTEwM1wiLFxuXG4gICAgY291bnRyeUNvZGU6IFwiVVNcIixcblxuICAgIGxhbmd1YWdlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2NrUHJvcHMubW9jaygnbG9jYWxpemF0aW9uJywgJ2xhbmd1YWdlJywgYXJndW1lbnRzLCBcImVuXCIpIH0sXG5cbiAgICBsb2NhbGU6IFwiZW4tVVNcIixcblxuICAgIGxhdGxvbjogW1xuICAzOS45NTQ5LFxuICA3NS4xNjk5XG5dLFxuXG4gICAgYWRkaXRpb25hbEluZm86IHt9XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9NZXRyaWNzL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBNZXRyaWNzX2RlZmF1bHRzID0gKHtcblxuICAgIHJlYWR5OiB0cnVlLFxuXG4gICAgc2lnbkluOiB0cnVlLFxuXG4gICAgc2lnbk91dDogdHJ1ZSxcblxuICAgIHN0YXJ0Q29udGVudDogdHJ1ZSxcblxuICAgIHN0b3BDb250ZW50OiB0cnVlLFxuXG4gICAgcGFnZTogdHJ1ZSxcblxuICAgIGFjdGlvbjogdHJ1ZSxcblxuICAgIGVycm9yOiB0cnVlLFxuXG4gICAgbWVkaWFMb2FkU3RhcnQ6IHRydWUsXG5cbiAgICBtZWRpYVBsYXk6IHRydWUsXG5cbiAgICBtZWRpYVBsYXlpbmc6IHRydWUsXG5cbiAgICBtZWRpYVBhdXNlOiB0cnVlLFxuXG4gICAgbWVkaWFXYWl0aW5nOiB0cnVlLFxuXG4gICAgbWVkaWFQcm9ncmVzczogdHJ1ZSxcblxuICAgIG1lZGlhU2Vla2luZzogdHJ1ZSxcblxuICAgIG1lZGlhU2Vla2VkOiB0cnVlLFxuXG4gICAgbWVkaWFSYXRlQ2hhbmdlOiB0cnVlLFxuXG4gICAgbWVkaWFSZW5kaXRpb25DaGFuZ2U6IHRydWUsXG5cbiAgICBtZWRpYUVuZGVkOiB0cnVlXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9QYXJhbWV0ZXJzL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQYXJhbWV0ZXJzX2RlZmF1bHRzID0gKHtcblxuICAgIGluaXRpYWxpemF0aW9uOiB7XG4gIFwibG10XCI6IDAsXG4gIFwidXNfcHJpdmFjeVwiOiBcIjEtWS1cIixcbiAgXCJkaXNjb3ZlcnlcIjoge1xuICAgIFwibmF2aWdhdGVUb1wiOiB7XG4gICAgICBcImFjdGlvblwiOiBcImVudGl0eVwiLFxuICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgXCJlbnRpdHlJZFwiOiBcImFiY1wiLFxuICAgICAgICBcImVudGl0eVR5cGVcIjogXCJwcm9ncmFtXCIsXG4gICAgICAgIFwicHJvZ3JhbVR5cGVcIjogXCJtb3ZpZVwiXG4gICAgICB9LFxuICAgICAgXCJjb250ZXh0XCI6IHtcbiAgICAgICAgXCJzb3VyY2VcIjogXCJ2b2ljZVwiXG4gICAgICB9XG4gICAgfVxuICB9XG59XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9Qcm9maWxlL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQcm9maWxlX2RlZmF1bHRzID0gKHtcblxuICAgIGFwcHJvdmVDb250ZW50UmF0aW5nOiBmYWxzZSxcblxuICAgIGFwcHJvdmVQdXJjaGFzZTogZmFsc2UsXG5cbiAgICBmbGFnczoge1xuICBcInVzZXJFeHBlcmllbmNlXCI6IFwiMTAwMFwiXG59XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9TZWNvbmRTY3JlZW4vZGVmYXVsdHMuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlY29uZFNjcmVlbl9kZWZhdWx0cyA9ICh7XG5cbiAgICBwcm90b2NvbHM6IHtcbiAgXCJkaWFsMS43XCI6IHRydWVcbn0sXG5cbiAgICBkZXZpY2U6IFwiZGV2aWNlLWlkXCIsXG5cbiAgICBmcmllbmRseU5hbWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vY2tQcm9wcy5tb2NrKCdzZWNvbmRzY3JlZW4nLCAnZnJpZW5kbHlOYW1lJywgYXJndW1lbnRzLCBcIkxpdmluZyBSb29tXCIpIH1cbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1BsYXRmb3JtL2RlZmF1bHRzLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQbGF0Zm9ybV9kZWZhdWx0cyA9ICh7XG4gIGxvY2FsaXphdGlvbjogTG9jYWxpemF0aW9uX2RlZmF1bHRzLFxuICBkZXZpY2U6IERldmljZV9kZWZhdWx0cyxcbiAgYWNjZXNzaWJpbGl0eTogZGVmYXVsdHMsXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9tb2NrLmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmxldCBsaXN0ZW5lclxuY29uc3Qgc2V0TW9ja0xpc3RlbmVyID0gZnVuYyA9PiB7IGxpc3RlbmVyID0gZnVuYyB9XG5cbmxldCBtb2NrX21vY2sgPSB7XG4gIGFjY2Vzc2liaWxpdHk6IGRlZmF1bHRzLFxuICBhY2NvdW50OiBBY2NvdW50X2RlZmF1bHRzLFxuICBhZHZlcnRpc2luZzogQWR2ZXJ0aXNpbmdfZGVmYXVsdHMsXG4gIGF1dGhlbnRpY2F0aW9uOiBBdXRoZW50aWNhdGlvbl9kZWZhdWx0cyxcbiAgZGV2aWNlOiBEZXZpY2VfZGVmYXVsdHMsXG4gIGRpc2NvdmVyeTogRGlzY292ZXJ5X2RlZmF1bHRzLFxuICBrZXlib2FyZDogS2V5Ym9hcmRfZGVmYXVsdHMsXG4gIGxpZmVjeWNsZTogTGlmZWN5Y2xlX2RlZmF1bHRzLFxuICBsb2NhbGl6YXRpb246IExvY2FsaXphdGlvbl9kZWZhdWx0cyxcbiAgbWV0cmljczogTWV0cmljc19kZWZhdWx0cyxcbiAgcGFyYW1ldGVyczogUGFyYW1ldGVyc19kZWZhdWx0cyxcbiAgcHJvZmlsZTogUHJvZmlsZV9kZWZhdWx0cyxcbiAgc2Vjb25kc2NyZWVuOiBTZWNvbmRTY3JlZW5fZGVmYXVsdHMsXG4gIHBsYXRmb3JtOiBQbGF0Zm9ybV9kZWZhdWx0cyxcbn1cblxubGV0IGNhbGxiYWNrXG5sZXQgdGVzdEhhcm5lc3NcblxuaWYgKFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCAmJiBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudGVzdEhhcm5lc3MpIHtcbiAgdGVzdEhhcm5lc3MgPSBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudGVzdEhhcm5lc3Ncbn1cblxuZnVuY3Rpb24gc2VuZChtZXNzYWdlKSB7XG4gIGxldCBqc29uID0gSlNPTi5wYXJzZShtZXNzYWdlKVxuICBsZXQgW21vZHVsZSwgbWV0aG9kXSA9IGpzb24ubWV0aG9kLnNwbGl0KCcuJylcblxuICBpZiAodGVzdEhhcm5lc3MgJiYgdGVzdEhhcm5lc3Mub25TZW5kKSB7XG4gICAgdGVzdEhhcm5lc3Mub25TZW5kKG1vZHVsZSwgbWV0aG9kLCBqc29uLnBhcmFtcywganNvbi5pZClcbiAgfVxuXG4gIC8vIHN0b3JlIHRoZSBJRCBvZiB0aGUgZmlyc3QgbGlzdGVuIGZvciBlYWNoIGV2ZW50XG4gIC8vIFRPRE86IHdoYXQgYWJvdXQgd2lsZCBjYXJkcz9cbiAgbGV0IHJlc3VsdFxuICB0cnkge1xuICAgIHJlc3VsdCA9IGdldFJlc3VsdChqc29uLm1ldGhvZCwganNvbi5wYXJhbXMpXG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeSh7IFxuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBlcnJvcjoge1xuICAgICAgICBjb2RlOiAtMzI2MDIsXG4gICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBwYXJhbXMgKHRoaXMgaXMgYSBtb2NrIGVycm9yIGZyb20gdGhlIG1vY2sgdHJhbnNwb3J0IGxheWVyKVwiXG4gICAgICB9LFxuICAgICAgaWQ6IGpzb24uaWRcbiAgICB9KSkpXG4gIH1cblxuICBzZXRUaW1lb3V0KCgpID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHsgXG4gICAganNvbnJwYzogJzIuMCcsXG4gICAgcmVzdWx0OiByZXN1bHQsXG4gICAgaWQ6IGpzb24uaWRcbiAgfSkpKVxufVxuXG5mdW5jdGlvbiByZWNlaXZlKF9jYWxsYmFjaykge1xuICBjYWxsYmFjayA9IF9jYWxsYmFja1xuXG4gIGlmICh0ZXN0SGFybmVzcyAmJiAodHlwZW9mIHRlc3RIYXJuZXNzLmluaXRpYWxpemUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgdGVzdEhhcm5lc3MuaW5pdGlhbGl6ZSh7XG4gICAgICBlbWl0OiBtb2NrX2V2ZW50LFxuICAgICAgbGlzdGVuOiBmdW5jdGlvbiguLi5hcmdzKSB7IGxpc3RlbmVyKC4uLmFyZ3MpIH0sXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBtb2NrX2V2ZW50KG1vZHVsZSwgZXZlbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gT2JqZWN0LmVudHJpZXMoVHJhbnNwb3J0LmdldEV2ZW50TWFwKCkpLmZpbmQoKFtrLCB2XSkgPT4gdi50b0xvd2VyQ2FzZSgpID09PSBtb2R1bGUudG9Mb3dlckNhc2UoKSArICcuJyArIGV2ZW50LnRvTG93ZXJDYXNlKCkpXG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGxldCBtZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBpZDogbGlzdGVuZXJbMF0sXG4gICAgICByZXN1bHQ6IHZhbHVlXG4gICAgfSlcbiAgICBjYWxsYmFjayhtZXNzYWdlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRvdEdyYWIob2JqID0ge30sIGtleSkge1xuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJylcbiAgbGV0IHJlZiA9IG9ialxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICByZWYgPSByZWZba2V5c1tpXV0gfHwge31cbiAgfVxuICByZXR1cm4gcmVmXG59XG5cbmZ1bmN0aW9uIGdldFJlc3VsdChtZXRob2QsIHBhcmFtcykge1xuICBsZXQgYXBpID0gZG90R3JhYihtb2NrX21vY2ssIG1ldGhvZClcblxuICBpZiAobWV0aG9kLm1hdGNoKC9eW2EtekEtWl0rXFwub25bQS1aYS16XSskLykpIHtcbiAgICBhcGkgPSB7XG4gICAgICBldmVudDogbWV0aG9kLFxuICAgICAgbGlzdGVuaW5nOiB0cnVlXG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBhcGkgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFyYW1zID09IG51bGwgPyBhcGkoKSA6IGFwaShwYXJhbXMpXG4gIH0gZWxzZSByZXR1cm4gYXBpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgVHJhbnNwb3J0X21vY2sgPSAoe1xuICBzZW5kOiBzZW5kLFxuICByZWNlaXZlOiByZWNlaXZlLFxuICBldmVudDogbW9ja19ldmVudFxufSk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9xdWV1ZS5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5jbGFzcyBRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgICB0aGlzLl9xdWV1ZSA9IFtdXG4gIH1cblxuICBzZW5kIChqc29uKSB7XG4gICAgdGhpcy5fcXVldWUucHVzaChqc29uKVxuICB9XG5cbiAgcmVjZWl2ZSAoX2NhbGxiYWNrKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBfY2FsbGJhY2tcbiAgfVxuXG4gIGZsdXNoICh0cmFuc3BvcnQpIHtcbiAgICB0cmFuc3BvcnQucmVjZWl2ZSh0aGlzLl9jYWxsYmFjaylcbiAgICB0aGlzLl9xdWV1ZS5mb3JFYWNoKGl0ZW0gPT4gdHJhbnNwb3J0LnNlbmQoaXRlbSkpXG4gIH1cbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1NldHRpbmdzL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cbmNvbnN0IHNldHRpbmdzID0ge31cbmNvbnN0IHN1YnNjcmliZXJzID0ge31cblxuY29uc3QgaW5pdFNldHRpbmdzID0gKGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzKSA9PiB7XG4gIHNldHRpbmdzWydhcHAnXSA9IGFwcFNldHRpbmdzXG4gIHNldHRpbmdzWydwbGF0Zm9ybSddID0ge1xuICAgIGxvZ0xldmVsOiAnV0FSTicsXG4gICAgLi4ucGxhdGZvcm1TZXR0aW5nc1xuICB9XG4gIHNldHRpbmdzWyd1c2VyJ10gPSB7fVxufVxuXG5jb25zdCBwdWJsaXNoID0gKGtleSwgdmFsdWUpID0+IHtcbiAgc3Vic2NyaWJlcnNba2V5XSAmJiBzdWJzY3JpYmVyc1trZXldLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKHZhbHVlKSlcbn1cblxuY29uc3QgU2V0dGluZ3NfZG90R3JhYiA9IChvYmogPSB7fSwga2V5KSA9PiB7XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvYmogPSBvYmpba2V5c1tpXV0gPSBvYmpba2V5c1tpXV0gIT09IHVuZGVmaW5lZCA/IG9ialtrZXlzW2ldXSA6IHt9XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnID8gKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID8gb2JqIDogdW5kZWZpbmVkKSA6IG9ialxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNldHRpbmdzID0gKHtcbiAgZ2V0KHR5cGUsIGtleSwgZmFsbGJhY2sgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB2YWwgPSBTZXR0aW5nc19kb3RHcmFiKHNldHRpbmdzW3R5cGVdLCBrZXkpXG4gICAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZmFsbGJhY2tcbiAgfSxcbiAgaGFzKHR5cGUsIGtleSkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0KHR5cGUsIGtleSlcbiAgfSxcbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICBzZXR0aW5nc1sndXNlciddW2tleV0gPSB2YWx1ZVxuICAgIHB1Ymxpc2goa2V5LCB2YWx1ZSlcbiAgfSxcbiAgc3Vic2NyaWJlKGtleSwgY2FsbGJhY2spIHtcbiAgICBzdWJzY3JpYmVyc1trZXldID0gc3Vic2NyaWJlcnNba2V5XSB8fCBbXVxuICAgIHN1YnNjcmliZXJzW2tleV0ucHVzaChjYWxsYmFjaylcbiAgfSxcbiAgdW5zdWJzY3JpYmUoa2V5LCBjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY29uc3QgaW5kZXggPSBzdWJzY3JpYmVyc1trZXldICYmIHN1YnNjcmliZXJzW2tleV0uZmluZEluZGV4KGNiID0+IGNiID09PSBjYWxsYmFjaylcbiAgICAgIGluZGV4ID4gLTEgJiYgc3Vic2NyaWJlcnNba2V5XS5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChrZXkgaW4gc3Vic2NyaWJlcnMpIHtcbiAgICAgICAgc3Vic2NyaWJlcnNba2V5XSA9IFtdXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjbGVhclN1YnNjcmliZXJzKCkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN1YnNjcmliZXJzKSkge1xuICAgICAgZGVsZXRlIHN1YnNjcmliZXJzW2tleV1cbiAgICB9XG4gIH0sXG4gIHNldExvZ0xldmVsIChsb2dMZXZlbCkge1xuICAgIHNldHRpbmdzLnBsYXRmb3JtLmxvZ0xldmVsID0gbG9nTGV2ZWxcbiAgfSxcbiAgZ2V0TG9nTGV2ZWwgKCkge1xuICAgIHJldHVybiBzZXR0aW5ncy5wbGF0Zm9ybS5sb2dMZXZlbFxuICB9XG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9MZWdhY3lUcmFuc3BvcnQuanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuY2xhc3MgTGVnYWN5VHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IgKGJyaWRnZSkge1xuICAgIHRoaXMuYnJpZGdlID0gYnJpZGdlXG4gIH1cblxuICBzZW5kIChtc2cpIHtcbiAgICB0aGlzLmJyaWRnZS5KU01lc3NhZ2VDaGFuZ2VkKG1zZywgKCkgPT4ge30pXG4gIH1cblxuICByZWNlaXZlIChjYWxsYmFjaykge1xuICAgIHdpbmRvdy4kYmFkZ2VyID0gd2luZG93LiRiYWRnZXIgfHwge31cbiAgICAvKiogSG9sZCBvbiB0byByZWFsICRiYWRnZXIgY2FsbGJhY2sgYW5kIGV2ZW50IG1ldGhvZHMgc28gdGhleSBjYW4gYmUgY2FsbGVkIGZvciBub24tanNvbnJwYyBtZXNzYWdlcyAqL1xuICAgIGNvbnN0IGJhZGdlckNhbGxiYWNrID0gd2luZG93LiRiYWRnZXIuY2FsbGJhY2sgPyB3aW5kb3cuJGJhZGdlci5jYWxsYmFjay5iaW5kKHdpbmRvdy4kYmFkZ2VyKSA6IG51bGxcbiAgICBjb25zdCBiYWRnZXJFdmVudCA9IHdpbmRvdy4kYmFkZ2VyLmV2ZW50ID8gd2luZG93LiRiYWRnZXIuZXZlbnQuYmluZCh3aW5kb3cuJGJhZGdlcikgOiBudWxsXG4gICAgd2luZG93LiRiYWRnZXIuY2FsbGJhY2sgPSAocGlkLCBzdWNjZXNzLCBqc29uKSA9PiB7XG4gICAgICBpZiAoanNvbi5qc29ucnBjKSB7XG4gICAgICAgIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KGpzb24pKVxuICAgICAgfSBlbHNlIGlmIChiYWRnZXJDYWxsYmFjaykge1xuICAgICAgICBiYWRnZXJDYWxsYmFjayhwaWQsIHN1Y2Nlc3MsIGpzb24pXG4gICAgICB9XG4gICAgfVxuICAgIHdpbmRvdy4kYmFkZ2VyLmV2ZW50ID0gKGhhbmRsZXJJZCwganNvbikgPT4ge1xuICAgICAgaWYgKGpzb24uanNvbnJwYykge1xuICAgICAgICBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShqc29uKSlcbiAgICAgIH0gZWxzZSBpZiAoYmFkZ2VyRXZlbnQpIHtcbiAgICAgICAgYmFkZ2VyRXZlbnQoaGFuZGxlcklkLCBqc29uKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBpc0xlZ2FjeSAodHJhbnNwb3J0KSB7XG4gICAgcmV0dXJuIExlZ2FjeVRyYW5zcG9ydC5pc1hSRVByb3h5KHRyYW5zcG9ydCkgfHwgKCh0cmFuc3BvcnQuc2VuZCA9PT0gdW5kZWZpbmVkKSAmJiAodHJhbnNwb3J0LkpTTWVzc2FnZUNoYW5nZWQpKVxuICB9XG5cbiAgc3RhdGljIGlzWFJFUHJveHkgKHRyYW5zcG9ydCkge1xuICAgIC8qKiBTZXQgdG9wIGJveGVzIHJ1bm5pbmcgWFJFIGhhcyBhIFwiUHJveHlcIiB0cmFuc3BvcnRcbiAgICAgKiBuYXRpdmUgb2JqZWN0IHRoYXQgaW50ZXJjZXB0cyBBTEwgbWV0aG9kIGNhbGxzLCBzbyB3ZVxuICAgICAqIGNhbm5vdCB0ZXN0IGZvciB0cmFuc3BvcnQuc2VuZCBleGlzdGVuY2UgYmVjYXVzZSBpdCB3aWxsIHJldHVybiB0cnVlXG4gICAgICogZXZlbiB0aG91Z2ggaXQgYWN0dWFsbHkgaXMgbm90IHN1cHBvcnRlZC4gQ2hlY2sgaWYgc29tZSBvYnNjdXJlIG1ldGhvZFxuICAgICAqIG5hbWUgbGlrZSBcInByb3h5T2JqZWN0VGVzdFwiIGlzIGRlZmluZWQuIElmIGl0IGlzIHRoZW4gd2Uga25vdyB3ZSBhcmUgdXNpbmcgYVxuICAgICAqIFByb3h5IG9iamVjdCBhbmQgdGh1cyBpcyBsZWdhY3kgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIHJldHVybiB0cmFuc3BvcnQucHJveHlPYmplY3RUZXN0ICE9PSB1bmRlZmluZWRcbiAgfVxufVxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvVHJhbnNwb3J0L1dlYnNvY2tldFRyYW5zcG9ydC5qc1xuY29uc3QgTUFYX1FVRVVFRF9NRVNTQUdFUyA9IDEwMFxuXG5jbGFzcyBXZWJzb2NrZXRUcmFuc3BvcnQge1xuICBjb25zdHJ1Y3RvciAoZW5kcG9pbnQpIHtcbiAgICB0aGlzLl9lbmRwb2ludCA9IGVuZHBvaW50XG4gICAgdGhpcy5fd3MgPSBudWxsXG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2VcbiAgICB0aGlzLl9xdWV1ZSA9IFtdXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gW11cbiAgfVxuXG4gIHNlbmQgKG1zZykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKVxuXG4gICAgaWYgKHRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fd3Muc2VuZChtc2cpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPCBNQVhfUVVFVUVEX01FU1NBR0VTKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2gobXNnKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlY2VpdmUgKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuXG4gICAgdGhpcy5fY29ubmVjdCgpXG4gICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spXG4gIH1cblxuICBfbm90aWZ5Q2FsbGJhY2tzIChtZXNzYWdlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fY2FsbGJhY2tzW2ldKG1lc3NhZ2UpLCAxKVxuICAgIH1cbiAgfVxuXG4gIF9jb25uZWN0ICgpIHtcbiAgICBpZiAodGhpcy5fd3MpIHJldHVyblxuICAgIHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldCh0aGlzLl9lbmRwb2ludClcbiAgICB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLl9ub3RpZnlDYWxsYmFja3MobWVzc2FnZS5kYXRhKVxuICAgIH0pXG4gICAgdGhpcy5fd3MuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBtZXNzYWdlID0+IHtcbiAgICB9KVxuICAgIHRoaXMuX3dzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgbWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLl93cyA9IG51bGxcbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgfSlcbiAgICB0aGlzLl93cy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgbWVzc2FnZSA9PiB7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3dzLnNlbmQodGhpcy5fcXVldWVbaV0pXG4gICAgICB9XG4gICAgICB0aGlzLl9xdWV1ZSA9IFtdXG4gICAgfSlcbiAgfVxufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1RyYW5zcG9ydC9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuXG5cbmNvbnN0IExFR0FDWV9UUkFOU1BPUlRfU0VSVklDRV9OQU1FID0gJ2NvbS5jb21jYXN0LkJyaWRnZU9iamVjdF8xJ1xubGV0IG1vZHVsZUluc3RhbmNlID0gbnVsbFxuXG5jb25zdCBpc0V2ZW50U3VjY2VzcyA9IHggPT4geCAmJiAodHlwZW9mIHguZXZlbnQgPT09ICdzdHJpbmcnKSAmJiAodHlwZW9mIHgubGlzdGVuaW5nID09PSAnYm9vbGVhbicpXG5cbmNsYXNzIFRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9wcm9taXNlcyA9IFtdXG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbFxuICAgIHRoaXMuX2lkID0gMVxuICAgIHRoaXMuX2V2ZW50RW1pdHRlcnMgPSBbXVxuICAgIHRoaXMuX2V2ZW50TWFwID0ge31cbiAgICB0aGlzLl9xdWV1ZSA9IG5ldyBRdWV1ZSgpXG4gICAgdGhpcy5fZGVwcmVjYXRlZCA9IHt9XG4gICAgdGhpcy5pc01vY2sgPSBmYWxzZVxuICB9XG5cbiAgc3RhdGljIGFkZEV2ZW50RW1pdHRlciAoZW1pdHRlcikge1xuICAgIFRyYW5zcG9ydC5nZXQoKS5fZXZlbnRFbWl0dGVycy5wdXNoKGVtaXR0ZXIpXG4gIH1cblxuICBzdGF0aWMgcmVnaXN0ZXJEZXByZWNhdGVkTWV0aG9kIChtb2R1bGUsIG1ldGhvZCwgYWx0ZXJuYXRpdmUpIHtcbiAgICBUcmFuc3BvcnQuZ2V0KCkuX2RlcHJlY2F0ZWRbbW9kdWxlLnRvTG93ZXJDYXNlKCkgKyAnLicgKyBtZXRob2QudG9Mb3dlckNhc2UoKV0gPSB7XG4gICAgICBhbHRlcm5hdGl2ZTogYWx0ZXJuYXRpdmUgfHwgJydcbiAgICB9XG4gIH1cblxuICBfZW5kcG9pbnQgKCkge1xuICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQgJiYgVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmVuZHBvaW50KSB7XG4gICAgICByZXR1cm4gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LmVuZHBvaW50XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdHJ1Y3RUcmFuc3BvcnRMYXllciAoKSB7XG4gICAgbGV0IHRyYW5zcG9ydFxuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5fZW5kcG9pbnQoKVxuICAgIGlmIChlbmRwb2ludCAmJiAoZW5kcG9pbnQuc3RhcnRzV2l0aCgnd3M6Ly8nKSB8fCBlbmRwb2ludC5zdGFydHNXaXRoKCd3c3M6Ly8nKSkpIHtcbiAgICAgIHRyYW5zcG9ydCA9IG5ldyBXZWJzb2NrZXRUcmFuc3BvcnQoZW5kcG9pbnQpXG4gICAgICB0cmFuc3BvcnQucmVjZWl2ZSh0aGlzLnJlY2VpdmVIYW5kbGVyLmJpbmQodGhpcykpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHR5cGVvZiBUcmFuc3BvcnRfZ2xvYmFsLlNlcnZpY2VNYW5hZ2VyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5TZXJ2aWNlTWFuYWdlciAmJlxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5TZXJ2aWNlTWFuYWdlci52ZXJzaW9uXG4gICAgKSB7XG4gICAgICAvLyBXaXJlIHVwIHRoZSBxdWV1ZVxuICAgICAgdHJhbnNwb3J0ID0gdGhpcy5fcXVldWVcbiAgICAgIC8vIGdldCB0aGUgZGVmYXVsdCBicmlkZ2Ugc2VydmljZSwgYW5kIGZsdXNoIHRoZSBxdWV1ZVxuICAgICAgVHJhbnNwb3J0X2dsb2JhbC5TZXJ2aWNlTWFuYWdlci5nZXRTZXJ2aWNlRm9ySmF2YVNjcmlwdChMRUdBQ1lfVFJBTlNQT1JUX1NFUlZJQ0VfTkFNRSwgc2VydmljZSA9PiB7XG4gICAgICAgIGlmIChMZWdhY3lUcmFuc3BvcnQuaXNMZWdhY3koc2VydmljZSkpIHtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBuZXcgTGVnYWN5VHJhbnNwb3J0KHNlcnZpY2UpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gc2VydmljZVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0TGF5ZXIodHJhbnNwb3J0KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc01vY2sgPSB0cnVlXG4gICAgICB0cmFuc3BvcnQgPSBUcmFuc3BvcnRfbW9ja1xuICAgICAgdHJhbnNwb3J0LnJlY2VpdmUodGhpcy5yZWNlaXZlSGFuZGxlci5iaW5kKHRoaXMpKVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0XG4gIH1cblxuICBzZXRUcmFuc3BvcnRMYXllciAodGwpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0bFxuICAgIHRoaXMuX3F1ZXVlLmZsdXNoKHRsKVxuICB9XG5cbiAgc3RhdGljIHNlbmQgKG1vZHVsZSwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICAvKiogVHJhbnNwb3J0IHNpbmdsZXRvbiBhY3Jvc3MgYWxsIFNES3MgdG8ga2VlcCBzaW5nbGUgaWQgbWFwICovXG4gICAgcmV0dXJuIFRyYW5zcG9ydC5nZXQoKS5fc2VuZChtb2R1bGUsIG1ldGhvZCwgcGFyYW1zKVxuICB9XG5cbiAgX3NlbmQgKG1vZHVsZSwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcHJvbWlzZXNbdGhpcy5faWRdID0ge31cbiAgICAgIHRoaXMuX3Byb21pc2VzW3RoaXMuX2lkXS5wcm9taXNlID0gdGhpc1xuICAgICAgdGhpcy5fcHJvbWlzZXNbdGhpcy5faWRdLnJlc29sdmUgPSByZXNvbHZlXG4gICAgICB0aGlzLl9wcm9taXNlc1t0aGlzLl9pZF0ucmVqZWN0ID0gcmVqZWN0XG5cbiAgICAgIGNvbnN0IGRlcHJlY2F0ZWQgPSB0aGlzLl9kZXByZWNhdGVkW21vZHVsZS50b0xvd2VyQ2FzZSgpICsgJy4nICsgbWV0aG9kLnRvTG93ZXJDYXNlKCldXG4gICAgICBpZiAoZGVwcmVjYXRlZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6ICR7bW9kdWxlfS4ke21ldGhvZH0oKSBpcyBkZXByZWNhdGVkLiBgICsgZGVwcmVjYXRlZC5hbHRlcm5hdGl2ZSlcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcmUgdGhlIElEIG9mIHRoZSBmaXJzdCBsaXN0ZW4gZm9yIGVhY2ggZXZlbnRcbiAgICAgIC8vIFRPRE86IHdoYXQgYWJvdXQgd2lsZCBjYXJkcz9cbiAgICAgIGlmIChtZXRob2QubWF0Y2goL15vbltBLVpdLykpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5saXN0ZW4pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudE1hcFt0aGlzLl9pZF0gPSBtb2R1bGUudG9Mb3dlckNhc2UoKSArICcuJyArIG1ldGhvZFsyXS50b0xvd2VyQ2FzZSgpICsgbWV0aG9kLnN1YnN0cigzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50TWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRNYXBba2V5XSA9PT0gbW9kdWxlLnRvTG93ZXJDYXNlKCkgKyAnLicgKyBtZXRob2RbMl0udG9Mb3dlckNhc2UoKSArIG1ldGhvZC5zdWJzdHIoMykpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50TWFwW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IGpzb24gPSB7IGpzb25ycGM6ICcyLjAnLCBtZXRob2Q6IG1vZHVsZSArICcuJyArIG1ldGhvZCwgcGFyYW1zOiBwYXJhbXMsIGlkOiB0aGlzLl9pZCB9XG4gICAgdGhpcy5faWQrK1xuXG4gICAgY29uc3QgbXNnID0gSlNPTi5zdHJpbmdpZnkoanNvbilcbiAgICBpZiAoU2V0dGluZ3MuZ2V0TG9nTGV2ZWwoKSA9PT0gJ0RFQlVHJykge1xuICAgICAgY29uc29sZS5kZWJ1ZygnU2VuZGluZyBtZXNzYWdlIHRvIHRyYW5zcG9ydDogJyArIG1zZylcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNwb3J0LnNlbmQobXNnKVxuXG4gICAgcmV0dXJuIHBcbiAgfVxuXG4gIHN0YXRpYyBnZXRFdmVudE1hcCAoKSB7XG4gICAgcmV0dXJuIFRyYW5zcG9ydC5nZXQoKS5fZXZlbnRNYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIGEgZ2xvYmFsIHRyYW5zcG9ydCwgdXNlIHRoYXQuIE90aGVyd2lzZSwgdXNlIHRoZSBtb2R1bGUtc2NvcGVkIHRyYW5zcG9ydCBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge1RyYW5zcG9ydH1cbiAgICovXG4gIHN0YXRpYyBnZXQgKCkge1xuICAgIHJldHVybiBUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudHJhbnNwb3J0ID8gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRyYW5zcG9ydCA6IG1vZHVsZUluc3RhbmNlXG4gIH1cblxuICByZWNlaXZlSGFuZGxlciAobWVzc2FnZSkge1xuICAgIGlmIChTZXR0aW5ncy5nZXRMb2dMZXZlbCgpID09PSAnREVCVUcnKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdHJhbnNwb3J0OiAnICsgbWVzc2FnZSlcbiAgICB9XG4gICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UobWVzc2FnZSlcbiAgICBjb25zdCBwID0gdGhpcy5fcHJvbWlzZXNbanNvbi5pZF1cblxuICAgIGlmIChwKSB7XG4gICAgICBpZiAoanNvbi5lcnJvcikgcC5yZWplY3QoanNvbi5lcnJvcilcbiAgICAgIGVsc2Uge1xuICAgICAgICBwLnJlc29sdmUoanNvbi5yZXN1bHQpXG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fcHJvbWlzZXNbanNvbi5pZF1cbiAgICB9XG5cbiAgICAvLyBldmVudCByZXNwb25zZXMgbmVlZCB0byBiZSBlbWl0dGVkLCBldmVuIGFmdGVyIHRoZSBsaXN0ZW4gY2FsbCBpcyByZXNvbHZlZFxuICAgIGlmICh0aGlzLl9ldmVudE1hcFtqc29uLmlkXSAmJiAhaXNFdmVudFN1Y2Nlc3MoanNvbi5yZXN1bHQpKSB7XG4gICAgICBjb25zdCBtb2R1bGVldmVudCA9IHRoaXMuX2V2ZW50TWFwW2pzb24uaWRdXG4gICAgICBpZiAobW9kdWxlZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRFbWl0dGVycy5mb3JFYWNoKGVtaXQgPT4ge1xuICAgICAgICAgIGVtaXQobW9kdWxlZXZlbnQuc3BsaXQoJy4nKVswXSwgbW9kdWxlZXZlbnQuc3BsaXQoJy4nKVsxXSwganNvbi5yZXN1bHQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5pdCAoKSB7XG4gICAgaW5pdFNldHRpbmdzKHt9LCB7IGxvZzogdHJ1ZSB9KVxuICAgIHRoaXMuX3F1ZXVlLnJlY2VpdmUodGhpcy5yZWNlaXZlSGFuZGxlci5iaW5kKHRoaXMpKVxuICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQpIHtcbiAgICAgIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQubW9ja1RyYW5zcG9ydExheWVyID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaXNNb2NrID0gdHJ1ZVxuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydExheWVyKFRyYW5zcG9ydF9tb2NrKVxuICAgICAgfSBlbHNlIGlmIChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQuZ2V0VHJhbnNwb3J0TGF5ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnRMYXllcihUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQuZ2V0VHJhbnNwb3J0TGF5ZXIoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydCA9PSBudWxsKSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQgPSB0aGlzLmNvbnN0cnVjdFRyYW5zcG9ydExheWVyKClcbiAgICB9XG4gIH1cbn1cblxuLyoqIFNldCB1cCBzaW5nbGV0b24gYW5kIGluaXRpYWxpemUgaXQgKi9cblRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCA9IFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdCB8fCB7fVxuaWYgKChUcmFuc3BvcnRfZ2xvYmFsLl9fZmlyZWJvbHQudHJhbnNwb3J0ID09IG51bGwpICYmIChtb2R1bGVJbnN0YW5jZSA9PSBudWxsKSkge1xuICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0KClcbiAgdHJhbnNwb3J0LmluaXQoKVxuICBpZiAodHJhbnNwb3J0LmlzTW9jaykge1xuICAgIC8qKiBXZSBzaG91bGQgdXNlIHRoZSBtb2NrIHRyYW5zcG9ydCBidWlsdCB3aXRoIHRoZSBTREssIG5vdCBhIGdsb2JhbCAqL1xuICAgIG1vZHVsZUluc3RhbmNlID0gdHJhbnNwb3J0XG4gIH0gZWxzZSB7XG4gICAgVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0ID0gVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0IHx8IHt9XG4gICAgVHJhbnNwb3J0X2dsb2JhbC5fX2ZpcmVib2x0LnRyYW5zcG9ydCA9IHRyYW5zcG9ydFxuICB9XG4gIFRyYW5zcG9ydF9nbG9iYWwuX19maXJlYm9sdC5zZXRUcmFuc3BvcnRMYXllciA9IHRyYW5zcG9ydC5zZXRUcmFuc3BvcnRMYXllci5iaW5kKHRyYW5zcG9ydClcbn1cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0V2ZW50cy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5sZXQgbGlzdGVuZXJJZCA9IDBcblxuLy8gaG9sZHMgYSBtYXAgb2YgJHttb2R1bGV9LiR7ZXZlbnR9ID0+IGxpc3RlbmVySWQsIGUuZy4gY2FsbGJhY2sgbWV0aG9kIGlkXG4vLyBub3RlIHRoYXQgb25lIGNhbGxiYWNrIGNhbiBsaXN0ZW4gdG8gbXVsdGlwbGUgZXZlbnRzLCBlLmcuICdkaXNjb3ZlcnkuKidcbmNvbnN0IGxpc3RlbmVycyA9IHt9XG5cbi8vIGhvbGRzIGEgbWFwIG9mICR7bW9kdWxlfS4ke2V2ZW50fSA9PiBUcmFuc3BvcnQuc2VuZCBjYWxscyAob25seSBjYWxsZWQgb25jZSBwZXIgZXZlbnQpXG4vLyBub3RlIHRoYXQgdGhlIGtleXMgaGVyZSBNVVNUIE5PVCBjb250YWluIHdpbGQgY2FyZHNcbmNvbnN0IGVuYWJsZWRFdmVudHMgPSB7fVxuXG5jb25zdCBvbmNlcnMgPSBbXVxuY29uc3QgdmFsaWRFdmVudHMgPSB7fVxubGV0IHRyYW5zcG9ydEluaXRpYWxpemVkID0gZmFsc2VcblxuY29uc3QgRXZlbnRzX2VtaXQgPSAobW9kdWxlLCBldmVudCwgdmFsdWUpID0+IHtcbiAgY2FsbENhbGxiYWNrcyhsaXN0ZW5lcnNbbW9kdWxlICsgJy4qJ10sIFtldmVudCwgdmFsdWVdKVxuICBjYWxsQ2FsbGJhY2tzKGxpc3RlbmVyc1ttb2R1bGUgKyAnLicgKyBldmVudF0sIFt2YWx1ZV0pXG59XG5cbmNvbnN0IHJlZ2lzdGVyRXZlbnRzID0gKG1vZHVsZSwgZXZlbnRzKSA9PiB7XG4gIHZhbGlkRXZlbnRzW21vZHVsZS50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50cy5jb25jYXQoKVxufVxuXG5jb25zdCBjYWxsQ2FsbGJhY2tzID0gKGNicywgYXJncykgPT4ge1xuICBjYnMgJiZcbiAgICBPYmplY3Qua2V5cyhjYnMpLmZvckVhY2gobGlzdGVuZXJJZCA9PiB7XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYnNbbGlzdGVuZXJJZF1cbiAgICAgIGlmIChvbmNlcnMuaW5kZXhPZihwYXJzZUludChsaXN0ZW5lcklkKSkgPj0gMCkge1xuICAgICAgICBvbmNlcnMuc3BsaWNlKG9uY2Vycy5pbmRleE9mKHBhcnNlSW50KGxpc3RlbmVySWQpKSwgMSlcbiAgICAgICAgZGVsZXRlIGNic1tsaXN0ZW5lcklkXVxuICAgICAgfVxuICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgYXJncylcbiAgICB9KVxufVxuXG5jb25zdCBkb0xpc3RlbiA9IGZ1bmN0aW9uKG1vZHVsZSwgZXZlbnQsIGNhbGxiYWNrLCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHZhbGlkIGNhbGxiYWNrIGZ1bmN0aW9uIHByb3ZpZGVkLicpXG4gIH0gZWxzZSB7XG4gICAgaWYgKG1vZHVsZSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ05vIHZhbGlkIG1vZHVsZSBuYW1lIHByb3ZpZGVkJylcbiAgICB9XG5cbiAgICBsZXQgZXZlbnRzID0gKGV2ZW50ID09PSAnKicgPyB2YWxpZEV2ZW50c1ttb2R1bGVdIDogW2V2ZW50XSkgLy8gZXhwbG9kZXMgd2lsZGNhcmRzIGludG8gYW4gYXJyYXlcbiAgICBsZXQgcHJvbWlzZXMgPSBbXVxuICAgIGNvbnN0IGtleSA9IG1vZHVsZSArICcuJyArIGV2ZW50IC8vIHRoaXMgbWlnaHQgYmUgYSB3aWxkY2FyZCwgZS5nLiAnbGlmZWN5Y2xlLionXG4gICAgbGlzdGVuZXJJZCsrXG4gICAgbGlzdGVuZXJzW2tleV0gPSBsaXN0ZW5lcnNba2V5XSB8fCB7fVxuICAgIGxpc3RlbmVyc1trZXldWycnK2xpc3RlbmVySWRdID0gY2FsbGJhY2tcblxuICAgIGlmIChvbmNlKSB7XG4gICAgICBvbmNlcnMucHVzaChsaXN0ZW5lcklkKVxuICAgIH1cblxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIC8vIENoZWNrIGVhY2ggZXZlbnQsIGFuZCBvbmx5IHR1cm4gb24gZXZlbnRzIChub3Qgd2lsZGNhcmRzKSB0aGF0IGFyZSBvZmZcbiAgICAgIGlmICghZW5hYmxlZEV2ZW50c1ttb2R1bGUgKyAnLicgKyBldmVudF0pIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChcbiAgICAgICAgICBUcmFuc3BvcnQuc2VuZChtb2R1bGUsICdvbicgKyBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc3Vic3RyKDEpLCB7IGxpc3RlbjogdHJ1ZSB9KVxuICAgICAgICApXG4gICAgICAgIGVuYWJsZWRFdmVudHNbbW9kdWxlICsgJy4nICsgZXZlbnRdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0XG4gICAgbGV0IHAgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHJlc29sdmUgPSByZXNcbiAgICAgIHJlamVjdCA9IHJlalxuICAgIH0pXG5cbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihyZXNwb25zZXMgPT4ge1xuICAgICAgICByZXNvbHZlKGxpc3RlbmVySWQpXG4gICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIC8vIFByb21pc2UuYWxsIHJlamVjdHMgaWYgYXQgbGVhc3Qgb25lIHByb21pc2UgcmVqZWN0cy4uLiB3ZSBkb24ndCB3YW50IHRoYXQgYmVoYXZpb3IgaGVyZVxuICAgICAgICAvLyBUT0RPOiBEbyBzb21ldGhpbmcgYmV0dGVyIHRoYW4gZmFpbCBzaWxlbnRseVxuICAgICAgICBpZiAoZXZlbnQgPT09ICcqJykge1xuICAgICAgICAgIHJlc29sdmUobGlzdGVuZXJJZClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzb2x2ZShsaXN0ZW5lcklkKVxuICAgIH1cblxuICAgIHJldHVybiBwXG4gIH1cbn1cblxuY29uc3QgZ2V0TGlzdGVuQXJncyA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpXG4gIGNvbnN0IG1vZHVsZSA9IGFyZ3NbMF0udG9Mb3dlckNhc2UoKSB8fCAnKidcbiAgY29uc3QgZXZlbnQgPSBhcmdzWzFdIHx8ICcqJ1xuICByZXR1cm4gW21vZHVsZSwgZXZlbnQsIGNhbGxiYWNrXVxufVxuXG5jb25zdCBvbmNlID0gZnVuY3Rpb24oLi4uYXJncykge1xuICBjb25zdCBbbW9kdWxlLCBldmVudCwgY2FsbGJhY2tdID0gZ2V0TGlzdGVuQXJncyguLi5hcmdzKVxuICByZXR1cm4gZG9MaXN0ZW4obW9kdWxlLCBldmVudCwgY2FsbGJhY2ssIHRydWUpXG59XG5cbmNvbnN0IGxpc3RlbiA9IGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgaW5pdCgpXG4gIGNvbnN0IFttb2R1bGUsIGV2ZW50LCBjYWxsYmFja10gPSBnZXRMaXN0ZW5BcmdzKC4uLmFyZ3MpXG4gIHJldHVybiBkb0xpc3Rlbihtb2R1bGUsIGV2ZW50LCBjYWxsYmFjaywgZmFsc2UpXG59XG5cbmNvbnN0IGluaXQgPSAoKSA9PiB7XG4gIGlmICghdHJhbnNwb3J0SW5pdGlhbGl6ZWQpIHtcbiAgICBUcmFuc3BvcnQuYWRkRXZlbnRFbWl0dGVyKEV2ZW50c19lbWl0KVxuICAgIHNldE1vY2tMaXN0ZW5lcihsaXN0ZW4pXG4gICAgdHJhbnNwb3J0SW5pdGlhbGl6ZWQgPSB0cnVlXG4gIH1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBFdmVudHMgPSAoe1xuICBsaXN0ZW46IGxpc3RlbixcbiAgb25jZTogb25jZSxcbiAgLy8gVE9ETzogY2xlYXIgbmVlZHMgdG8gZ28gdGhyb3VnaCBUcmFuc3BvcnQgTGF5ZXJcbiAgY2xlYXIobW9kdWxlT3JJZCA9IGZhbHNlLCBldmVudCA9IGZhbHNlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVPcklkID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3Qgc2VhcmNoSWQgPSBtb2R1bGVPcklkLnRvU3RyaW5nKClcbiAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZXZlcnkoa2V5ID0+IHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1trZXldW3NlYXJjaElkXSkge1xuICAgICAgICAgIC8vIGRlbGV0ZSBjYWxsYmFja1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XVtzZWFyY2hJZF1cbiAgICAgICAgICAvLyBkZWxldGUgdGhlIHdob2xlIG5hbWVzcGFjZSBpZiBpdCB3YXMgdGhlIG9ubHkgY2FsbGJhY2tcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobGlzdGVuZXJzW2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1trZXldXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIW1vZHVsZU9ySWQgJiYgIWV2ZW50KSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGxpc3RlbmVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghZXZlbnQpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobGlzdGVuZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKGtleS5pbmRleE9mKG1vZHVsZU9ySWQudG9Mb3dlckNhc2UoKSkgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNba2V5XVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbbW9kdWxlT3JJZCArICcuJyArIGV2ZW50XVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYnJvYWRjYXN0KGV2ZW50LCB2YWx1ZSkge1xuICAgIEV2ZW50c19lbWl0KCdhcHAnLCBldmVudCwgdmFsdWUpXG4gIH0sXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1Byb3AvaW5kZXguanNcblxuXG5cbmZ1bmN0aW9uIHByb3AobW9kdWxlTmFtZSwga2V5LCBhcmdzLCBpbW11dGFibGUsIHJlYWRvbmx5KSB7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIGdldHRlclxuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZChtb2R1bGVOYW1lLCBrZXkpXG4gIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBzdWJzY3JpYmVcbiAgICBpZiAoaW1tdXRhYmxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdWJzY3JpYmUgdG8gYW4gaW1tdXRhYmxlIHByb3BlcnR5JylcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50cy5saXN0ZW4obW9kdWxlTmFtZSwga2V5ICsgJ0NoYW5nZWQnLCBhcmdzWzBdKVxuICB9IGVsc2Uge1xuICAgIC8vIHNldHRlclxuICAgIGlmIChpbW11dGFibGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBhIHZhbHVlIHRvIGFuIGltbXV0YWJsZSBwcm9wZXJ0eScpXG4gICAgfVxuICAgIGlmIChyZWFkb25seSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IGEgdmFsdWUgdG8gYSByZWFkb25seSBwcm9wZXJ0eScpXG4gICAgfVxuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZChtb2R1bGVOYW1lLCBrZXksIHtcbiAgICAgIHZhbHVlOiBhcmdzWzBdXG4gICAgfSlcbiAgfVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFByb3AgPSAoe1xuICBwcm9wOiBwcm9wXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9BY2Nlc3NpYmlsaXR5L2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdBY2Nlc3NpYmlsaXR5JywgT2JqZWN0LnZhbHVlcyhbXCJjbG9zZWRDYXB0aW9uc1NldHRpbmdzQ2hhbmdlZFwiLFwidm9pY2VHdWlkYW5jZVNldHRpbmdzQ2hhbmdlZFwiXSkpXG5cblRyYW5zcG9ydC5yZWdpc3RlckRlcHJlY2F0ZWRNZXRob2QoJ0FjY2Vzc2liaWxpdHknLCAnY2xvc2VkQ2FwdGlvbnMnLCAnVXNlIEFjY2Vzc2liaWxpdHkuY2xvc2VkQ2FwdGlvbnNTZXR0aW5ncygpIGluc3RlYWQuJylcblRyYW5zcG9ydC5yZWdpc3RlckRlcHJlY2F0ZWRNZXRob2QoJ0FjY2Vzc2liaWxpdHknLCAndm9pY2VHdWlkYW5jZScsICdVc2UgQWNjZXNzaWJpbGl0eS52b2ljZUd1aWRhbmNlU2V0dGluZ3MoKSBpbnN0ZWFkLicpXG5cblxuZnVuY3Rpb24gY2xvc2VkQ2FwdGlvbnMoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYWNjZXNzaWJpbGl0eScsICdjbG9zZWRDYXB0aW9ucycsIHsgIH0pXG59XG5mdW5jdGlvbiBjbG9zZWRDYXB0aW9uc1NldHRpbmdzKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhY2Nlc3NpYmlsaXR5JywgICdjbG9zZWRDYXB0aW9uc1NldHRpbmdzJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gdm9pY2VHdWlkYW5jZSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdhY2Nlc3NpYmlsaXR5JywgJ3ZvaWNlR3VpZGFuY2UnLCB7ICB9KVxufVxuZnVuY3Rpb24gdm9pY2VHdWlkYW5jZVNldHRpbmdzKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhY2Nlc3NpYmlsaXR5JywgICd2b2ljZUd1aWRhbmNlU2V0dGluZ3MnLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBBY2Nlc3NpYmlsaXR5X2xpc3RlbiguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMubGlzdGVuKCdhY2Nlc3NpYmlsaXR5JywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIEFjY2Vzc2liaWxpdHlfb25jZSguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMub25jZSgnYWNjZXNzaWJpbGl0eScsIC4uLmFyZ3MpXG59XG5cbmZ1bmN0aW9uIGNsZWFyKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5jbGVhcignYWNjZXNzaWJpbGl0eScsIC4uLmFyZ3MpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQWNjZXNzaWJpbGl0eSA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgY2xvc2VkQ2FwdGlvbnNTZXR0aW5nc0NoYW5nZWQ6J2Nsb3NlZENhcHRpb25zU2V0dGluZ3NDaGFuZ2VkJyxcbiAgICB2b2ljZUd1aWRhbmNlU2V0dGluZ3NDaGFuZ2VkOid2b2ljZUd1aWRhbmNlU2V0dGluZ3NDaGFuZ2VkJ1xuICB9LFxuY2xvc2VkQ2FwdGlvbnMsXG4gIGNsb3NlZENhcHRpb25zU2V0dGluZ3MsXG4gIHZvaWNlR3VpZGFuY2UsXG4gIHZvaWNlR3VpZGFuY2VTZXR0aW5ncyxcbiAgbGlzdGVuOiBBY2Nlc3NpYmlsaXR5X2xpc3RlbixcbiAgb25jZTogQWNjZXNzaWJpbGl0eV9vbmNlLFxuICBjbGVhclxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvQWNjb3VudC9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gaWQoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2FjY291bnQnLCAgJ2lkJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuZnVuY3Rpb24gdWlkKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhY2NvdW50JywgICd1aWQnLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgQWNjb3VudCA9ICh7XG5cbmlkLFxuICB1aWRcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0FkdmVydGlzaW5nL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdBZHZlcnRpc2luZycsIE9iamVjdC52YWx1ZXMoW1wicG9saWN5Q2hhbmdlZFwiXSkpXG5cblxuXG5mdW5jdGlvbiBjb25maWcob3B0aW9ucykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2FkdmVydGlzaW5nJywgJ2NvbmZpZycsIHsgb3B0aW9ucyB9KVxufVxuZnVuY3Rpb24gcG9saWN5KCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdhZHZlcnRpc2luZycsICAncG9saWN5JywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gYWR2ZXJ0aXNpbmdJZCgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdhZHZlcnRpc2luZycsICdhZHZlcnRpc2luZ0lkJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gZGV2aWNlQXR0cmlidXRlcygpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdhZHZlcnRpc2luZycsICdkZXZpY2VBdHRyaWJ1dGVzJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gYXBwQnVuZGxlSWQoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYWR2ZXJ0aXNpbmcnLCAnYXBwQnVuZGxlSWQnLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBBZHZlcnRpc2luZ19saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignYWR2ZXJ0aXNpbmcnLCAuLi5hcmdzKVxufSBcblxuZnVuY3Rpb24gQWR2ZXJ0aXNpbmdfb25jZSguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMub25jZSgnYWR2ZXJ0aXNpbmcnLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBBZHZlcnRpc2luZ19jbGVhciguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMuY2xlYXIoJ2FkdmVydGlzaW5nJywgLi4uYXJncylcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBZHZlcnRpc2luZyA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgcG9saWN5Q2hhbmdlZDoncG9saWN5Q2hhbmdlZCdcbiAgfSxcblxuICBTa2lwUmVzdHJpY3Rpb246IHtcbiAgICBOT05FOiAnbm9uZScsXG4gICAgQURTX1VOV0FUQ0hFRDogJ2Fkc1Vud2F0Y2hlZCcsXG4gICAgQURTX0FMTDogJ2Fkc0FsbCcsXG4gICAgQUxMOiAnYWxsJ1xuICB9LFxuXG5jb25maWcsXG4gIHBvbGljeSxcbiAgYWR2ZXJ0aXNpbmdJZCxcbiAgZGV2aWNlQXR0cmlidXRlcyxcbiAgYXBwQnVuZGxlSWQsXG4gIGxpc3RlbjogQWR2ZXJ0aXNpbmdfbGlzdGVuLFxuICBvbmNlOiBBZHZlcnRpc2luZ19vbmNlLFxuICBjbGVhcjogQWR2ZXJ0aXNpbmdfY2xlYXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0F1dGhlbnRpY2F0aW9uL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5mdW5jdGlvbiB0b2tlbih0eXBlLCBvcHRpb25zKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnYXV0aGVudGljYXRpb24nLCAndG9rZW4nLCB7IHR5cGUsIG9wdGlvbnMgfSlcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBBdXRoZW50aWNhdGlvbiA9ICh7XG5cblxuICBUb2tlblR5cGU6IHtcbiAgICBQTEFURk9STTogJ3BsYXRmb3JtJyxcbiAgICBERVZJQ0U6ICdkZXZpY2UnLFxuICAgIERJU1RSSUJVVE9SOiAnZGlzdHJpYnV0b3InXG4gIH0sXG5cbnRva2VuXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9EZXZpY2UvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cblxucmVnaXN0ZXJFdmVudHMoJ0RldmljZScsIE9iamVjdC52YWx1ZXMoW1wiZGV2aWNlTmFtZUNoYW5nZWRcIixcImhkY3BDaGFuZ2VkXCIsXCJoZHJDaGFuZ2VkXCIsXCJhdWRpb0NoYW5nZWRcIixcInNjcmVlblJlc29sdXRpb25DaGFuZ2VkXCIsXCJ2aWRlb1Jlc29sdXRpb25DaGFuZ2VkXCIsXCJuYW1lQ2hhbmdlZFwiLFwibmV0d29ya0NoYW5nZWRcIl0pKVxuXG5UcmFuc3BvcnQucmVnaXN0ZXJEZXByZWNhdGVkTWV0aG9kKCdEZXZpY2UnLCAnb25EZXZpY2VOYW1lQ2hhbmdlZCcsICdVc2UgRGV2aWNlLm5hbWUoKSBpbnN0ZWFkLicpXG5cbmZ1bmN0aW9uIHZlcnNpb24oKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSggKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgVHJhbnNwb3J0LnNlbmQoJ2RldmljZScsICd2ZXJzaW9uJykudGhlbiggdiA9PiB7XG4gICAgICAgICAgdiA9IHYgfHwge31cbiAgICAgICAgICB2LnNkayA9IHYuc2RrIHx8IHt9XG4gICAgICAgICAgdi5zZGsubWFqb3IgPSBwYXJzZUludCgnMCcpXG4gICAgICAgICAgdi5zZGsubWlub3IgPSBwYXJzZUludCgnNicpXG4gICAgICAgICAgdi5zZGsucGF0Y2ggPSBwYXJzZUludCgnMCcpXG4gICAgICAgICAgdi5zZGsucmVhZGFibGUgPSAnVGhlIEZpcmVib2x0IEpTIFNESydcbiAgICAgICAgICByZXNvbHZlKHYpICAgIFxuICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIERldmljZV9pZCgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICdpZCcsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIGRpc3RyaWJ1dG9yKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ2Rpc3RyaWJ1dG9yJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuZnVuY3Rpb24gcGxhdGZvcm0oKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAncGxhdGZvcm0nLCBhcmd1bWVudHMsIHRydWUsIHRydWUpXG59XG5mdW5jdGlvbiBEZXZpY2VfdWlkKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3VpZCcsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIHR5cGUoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAndHlwZScsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIG1vZGVsKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ21vZGVsJywgYXJndW1lbnRzLCB0cnVlLCB0cnVlKVxufVxuZnVuY3Rpb24gc2t1KCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ3NrdScsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIG1ha2UoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnbWFrZScsIGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIGhkY3AoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnaGRjcCcsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5mdW5jdGlvbiBoZHIoKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnaGRyJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIGF1ZGlvKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ2F1ZGlvJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIHNjcmVlblJlc29sdXRpb24oKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAnc2NyZWVuUmVzb2x1dGlvbicsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5mdW5jdGlvbiB2aWRlb1Jlc29sdXRpb24oKSB7XG4gIHJldHVybiBQcm9wLnByb3AoJ2RldmljZScsICAndmlkZW9SZXNvbHV0aW9uJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cbmZ1bmN0aW9uIERldmljZV9uYW1lKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdkZXZpY2UnLCAgJ25hbWUnLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuZnVuY3Rpb24gbmV0d29yaygpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGV2aWNlJywgICduZXR3b3JrJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gRGV2aWNlX2xpc3RlbiguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMubGlzdGVuKCdkZXZpY2UnLCAuLi5hcmdzKVxufSBcblxuZnVuY3Rpb24gRGV2aWNlX29uY2UoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLm9uY2UoJ2RldmljZScsIC4uLmFyZ3MpXG59XG5cbmZ1bmN0aW9uIERldmljZV9jbGVhciguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMuY2xlYXIoJ2RldmljZScsIC4uLmFyZ3MpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRGV2aWNlID0gKHtcblxuICBldmVudHM6IHtcbiAgICBkZXZpY2VOYW1lQ2hhbmdlZDonZGV2aWNlTmFtZUNoYW5nZWQnLFxuICAgIGhkY3BDaGFuZ2VkOidoZGNwQ2hhbmdlZCcsXG4gICAgaGRyQ2hhbmdlZDonaGRyQ2hhbmdlZCcsXG4gICAgYXVkaW9DaGFuZ2VkOidhdWRpb0NoYW5nZWQnLFxuICAgIHNjcmVlblJlc29sdXRpb25DaGFuZ2VkOidzY3JlZW5SZXNvbHV0aW9uQ2hhbmdlZCcsXG4gICAgdmlkZW9SZXNvbHV0aW9uQ2hhbmdlZDondmlkZW9SZXNvbHV0aW9uQ2hhbmdlZCcsXG4gICAgbmFtZUNoYW5nZWQ6J25hbWVDaGFuZ2VkJyxcbiAgICBuZXR3b3JrQ2hhbmdlZDonbmV0d29ya0NoYW5nZWQnXG4gIH0sXG5cbiAgTmV0d29ya1R5cGU6IHtcbiAgICBXSUZJOiAnd2lmaScsXG4gICAgRVRIRVJORVQ6ICdldGhlcm5ldCcsXG4gICAgSFlCUklEOiAnaHlicmlkJ1xuICB9LFxuXG5cbiAgTmV0d29ya1N0YXRlOiB7XG4gICAgQ09OTkVDVEVEOiAnY29ubmVjdGVkJyxcbiAgICBESVNDT05ORUNURUQ6ICdkaXNjb25uZWN0ZWQnXG4gIH0sXG5cblxuICBBdWRpb1Byb2ZpbGU6IHtcbiAgICBTVEVSRU86ICdzdGVyZW8nLFxuICAgIERPTEJZX0RJR0lUQUxfNV8xOiAnZG9sYnlEaWdpdGFsNS4xJyxcbiAgICBET0xCWV9ESUdJVEFMXzdfMTogJ2RvbGJ5RGlnaXRhbDcuMScsXG4gICAgRE9MQllfRElHSVRBTF81XzFfUExVUzogJ2RvbGJ5RGlnaXRhbDUuMSsnLFxuICAgIERPTEJZX0RJR0lUQUxfN18xX1BMVVM6ICdkb2xieURpZ2l0YWw3LjErJyxcbiAgICBET0xCWV9BVE1PUzogJ2RvbGJ5QXRtb3MnXG4gIH0sXG5cblxuICB2ZXJzaW9uLFxuaWQ6IERldmljZV9pZCxcbiAgZGlzdHJpYnV0b3IsXG4gIHBsYXRmb3JtLFxuICB1aWQ6IERldmljZV91aWQsXG4gIHR5cGUsXG4gIG1vZGVsLFxuICBza3UsXG4gIG1ha2UsXG4gIGhkY3AsXG4gIGhkcixcbiAgYXVkaW8sXG4gIHNjcmVlblJlc29sdXRpb24sXG4gIHZpZGVvUmVzb2x1dGlvbixcbiAgbmFtZTogRGV2aWNlX25hbWUsXG4gIG5ldHdvcmssXG4gIGxpc3RlbjogRGV2aWNlX2xpc3RlbixcbiAgb25jZTogRGV2aWNlX29uY2UsXG4gIGNsZWFyOiBEZXZpY2VfY2xlYXJcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTWV0cmljcy9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gcmVhZHkoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdyZWFkeScsIHt9KVxufVxuXG5mdW5jdGlvbiBzaWduSW4oKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdzaWduSW4nLCB7fSlcbn1cblxuZnVuY3Rpb24gc2lnbk91dCgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ3NpZ25PdXQnLCB7fSlcbn1cblxuXG5cbmZ1bmN0aW9uIHN0YXJ0Q29udGVudChlbnRpdHlJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnc3RhcnRDb250ZW50JywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBzdG9wQ29udGVudChlbnRpdHlJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnc3RvcENvbnRlbnQnLCB7IGVudGl0eUlkIH0pXG59XG5cbmZ1bmN0aW9uIHBhZ2UocGFnZUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdwYWdlJywgeyBwYWdlSWQgfSlcbn1cblxuZnVuY3Rpb24gYWN0aW9uKGNhdGVnb3J5LCB0eXBlLCBwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdhY3Rpb24nLCB7IGNhdGVnb3J5LCB0eXBlLCBwYXJhbWV0ZXJzIH0pXG59XG5cbmZ1bmN0aW9uIGVycm9yKHR5cGUsIGNvZGUsIGRlc2NyaXB0aW9uLCB2aXNpYmxlLCBwYXJhbWV0ZXJzKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdlcnJvcicsIHsgdHlwZSwgY29kZSwgZGVzY3JpcHRpb24sIHZpc2libGUsIHBhcmFtZXRlcnMgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFMb2FkU3RhcnQoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhTG9hZFN0YXJ0JywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVBsYXkoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhUGxheScsIHsgZW50aXR5SWQgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFQbGF5aW5nKGVudGl0eUlkKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVBsYXlpbmcnLCB7IGVudGl0eUlkIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhUGF1c2UoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhUGF1c2UnLCB7IGVudGl0eUlkIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhV2FpdGluZyhlbnRpdHlJZCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFXYWl0aW5nJywgeyBlbnRpdHlJZCB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVByb2dyZXNzKGVudGl0eUlkLCBwcm9ncmVzcykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFQcm9ncmVzcycsIHsgZW50aXR5SWQsIHByb2dyZXNzIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhU2Vla2luZyhlbnRpdHlJZCwgdGFyZ2V0KSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVNlZWtpbmcnLCB7IGVudGl0eUlkLCB0YXJnZXQgfSlcbn1cblxuZnVuY3Rpb24gbWVkaWFTZWVrZWQoZW50aXR5SWQsIHBvc2l0aW9uKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbWV0cmljcycsICdtZWRpYVNlZWtlZCcsIHsgZW50aXR5SWQsIHBvc2l0aW9uIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhUmF0ZUNoYW5nZShlbnRpdHlJZCwgcmF0ZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFSYXRlQ2hhbmdlJywgeyBlbnRpdHlJZCwgcmF0ZSB9KVxufVxuXG5mdW5jdGlvbiBtZWRpYVJlbmRpdGlvbkNoYW5nZShlbnRpdHlJZCwgYml0cmF0ZSwgd2lkdGgsIGhlaWdodCwgcHJvZmlsZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ21ldHJpY3MnLCAnbWVkaWFSZW5kaXRpb25DaGFuZ2UnLCB7IGVudGl0eUlkLCBiaXRyYXRlLCB3aWR0aCwgaGVpZ2h0LCBwcm9maWxlIH0pXG59XG5cbmZ1bmN0aW9uIG1lZGlhRW5kZWQoZW50aXR5SWQpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdtZXRyaWNzJywgJ21lZGlhRW5kZWQnLCB7IGVudGl0eUlkIH0pXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgTWV0cmljcyA9ICh7XG5cblxuICBFcnJvclR5cGU6IHtcbiAgICBORVRXT1JLOiAnbmV0d29yaycsXG4gICAgTUVESUE6ICdtZWRpYScsXG4gICAgUkVTVFJJQ1RJT046ICdyZXN0cmljdGlvbicsXG4gICAgRU5USVRMRU1FTlQ6ICdlbnRpdGxlbWVudCcsXG4gICAgT1RIRVI6ICdvdGhlcidcbiAgfSxcblxuc3RhcnRDb250ZW50LFxuICBzdG9wQ29udGVudCxcbiAgcGFnZSxcbiAgYWN0aW9uLFxuICBlcnJvcixcbiAgbWVkaWFMb2FkU3RhcnQsXG4gIG1lZGlhUGxheSxcbiAgbWVkaWFQbGF5aW5nLFxuICBtZWRpYVBhdXNlLFxuICBtZWRpYVdhaXRpbmcsXG4gIG1lZGlhUHJvZ3Jlc3MsXG4gIG1lZGlhU2Vla2luZyxcbiAgbWVkaWFTZWVrZWQsXG4gIG1lZGlhUmF0ZUNoYW5nZSxcbiAgbWVkaWFSZW5kaXRpb25DaGFuZ2UsXG4gIG1lZGlhRW5kZWRcbn0pO1xuXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9EaXNjb3ZlcnkvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cblxucmVnaXN0ZXJFdmVudHMoJ0Rpc2NvdmVyeScsIE9iamVjdC52YWx1ZXMoW1wibmF2aWdhdGVUb1wiLFwicG9saWN5Q2hhbmdlZFwiXSkpXG5cblxuZnVuY3Rpb24gRGlzY292ZXJ5X3BvbGljeSgpIHtcbiAgcmV0dXJuIFByb3AucHJvcCgnZGlzY292ZXJ5JywgICdwb2xpY3knLCBhcmd1bWVudHMsIGZhbHNlLCB0cnVlKVxufVxuXG5sZXQgZW50aXR5SW5mb0hhc0NhbGxiYWNrID0gZmFsc2VcblxuZnVuY3Rpb24gZW50aXR5SW5mbyAoZGF0YSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGVudGl0eUluZm9IYXNDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5ub3QgcmVnaXN0ZXIgbW9yZSB0aGFuIG9uZSBlbnRpdHlJbmZvIGhhbmRsZXIuJylcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3VtZW50c1swXVxuICAgIGVudGl0eUluZm9IYXNDYWxsYmFjayA9IHRydWVcbiAgICByZXR1cm4gRXZlbnRzLmxpc3RlbignZGlzY292ZXJ5JywgJ3B1bGxFbnRpdHlJbmZvJywgKHJlcXVlc3QpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2socmVxdWVzdC5wYXJhbWV0ZXJzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdlbnRpdHlJbmZvJywgcGFyYW1zKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgRmFpbGVkIHRvIHNlbmQgZW50aXR5SW5mbyBwdWxsIHJlc3BvbnNlIHRocm91Z2ggVHJhbnNwb3J0IExheWVyOiAke21zZ31gLCBwYXJzZUludChlcnJvci5jb2RlKSB8fCA1MDAsIGZhbHNlLCByZXF1ZXN0LnBhcmFtZXRlcnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBlcnJvciA6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gRXJyb3InXG4gICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgQXBwICdlbnRpdHlJbmZvJyBjYWxsYmFjayBmYWlsZWQ6ICR7bXNnfWAsIHBhcnNlSW50KGVycm9yLmNvZGUpIHx8IDUwMCwgZmFsc2UsIHJlcXVlc3QucGFyYW1ldGVycylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICBJbnRlcm5hbE1ldHJpY3Muc2RrLmVycm9yKGBBcHAgJ2VudGl0eUluZm8nIGNhbGxiYWNrIGZhaWxlZDogJHttc2d9YCwgcGFyc2VJbnQoZXJyb3IuY29kZSkgfHwgNTAwLCBmYWxzZSwgcmVxdWVzdC5wYXJhbWV0ZXJzKVxuICAgIH1cbiAgICB9KVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ2VudGl0eUluZm8nLCB7IGRhdGEgfSlcbiAgfVxufVxuXG5sZXQgcHVyY2hhc2VkQ29udGVudEhhc0NhbGxiYWNrID0gZmFsc2VcblxuZnVuY3Rpb24gcHVyY2hhc2VkQ29udGVudCAoZGF0YSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHB1cmNoYXNlZENvbnRlbnRIYXNDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdDYW5ub3QgcmVnaXN0ZXIgbW9yZSB0aGFuIG9uZSBwdXJjaGFzZWRDb250ZW50IGhhbmRsZXIuJylcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3VtZW50c1swXVxuICAgIHB1cmNoYXNlZENvbnRlbnRIYXNDYWxsYmFjayA9IHRydWVcbiAgICByZXR1cm4gRXZlbnRzLmxpc3RlbignZGlzY292ZXJ5JywgJ3B1bGxQdXJjaGFzZWRDb250ZW50JywgKHJlcXVlc3QpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsbGJhY2socmVxdWVzdC5wYXJhbWV0ZXJzKS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgY29ycmVsYXRpb25JZDogcmVxdWVzdC5jb3JyZWxhdGlvbklkLFxuICAgICAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgICAgICB9XG4gICAgICAgICAgVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdwdXJjaGFzZWRDb250ZW50JywgcGFyYW1zKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgRmFpbGVkIHRvIHNlbmQgcHVyY2hhc2VkQ29udGVudCBwdWxsIHJlc3BvbnNlIHRocm91Z2ggVHJhbnNwb3J0IExheWVyOiAke21zZ31gLCBwYXJzZUludChlcnJvci5jb2RlKSB8fCA1MDAsIGZhbHNlLCByZXF1ZXN0LnBhcmFtZXRlcnMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgPyBlcnJvciA6IGVycm9yLm1lc3NhZ2UgfHwgJ1Vua25vd24gRXJyb3InXG4gICAgICAgICAgSW50ZXJuYWxNZXRyaWNzLnNkay5lcnJvcihgQXBwICdwdXJjaGFzZWRDb250ZW50JyBjYWxsYmFjayBmYWlsZWQ6ICR7bXNnfWAsIHBhcnNlSW50KGVycm9yLmNvZGUpIHx8IDUwMCwgZmFsc2UsIHJlcXVlc3QucGFyYW1ldGVycylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2YgZXJyb3IgPT09ICdzdHJpbmcnID8gZXJyb3IgOiBlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIEVycm9yJ1xuICAgICAgICBJbnRlcm5hbE1ldHJpY3Muc2RrLmVycm9yKGBBcHAgJ3B1cmNoYXNlZENvbnRlbnQnIGNhbGxiYWNrIGZhaWxlZDogJHttc2d9YCwgcGFyc2VJbnQoZXJyb3IuY29kZSkgfHwgNTAwLCBmYWxzZSwgcmVxdWVzdC5wYXJhbWV0ZXJzKVxuICAgIH1cbiAgICB9KVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3B1cmNoYXNlZENvbnRlbnQnLCB7IGRhdGEgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXRjaGVkKGVudGl0eUlkLCBwcm9ncmVzcywgY29tcGxldGVkLCB3YXRjaGVkT24pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XG4gICAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnd2F0Y2hlZCcsIGFyZ3VtZW50c1swXSlcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICd3YXRjaGVkJywgeyBlbnRpdHlJZCwgcHJvZ3Jlc3MsIGNvbXBsZXRlZCwgd2F0Y2hlZE9uIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gd2F0Y2hOZXh0KHRpdGxlLCBpZGVudGlmaWVycywgZXhwaXJlcywgaW1hZ2VzKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3dhdGNoTmV4dCcsIHsgdGl0bGUsIGlkZW50aWZpZXJzLCBleHBpcmVzLCBpbWFnZXMgfSlcbn1cblxuZnVuY3Rpb24gZW50aXRsZW1lbnRzKGVudGl0bGVtZW50cykge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdlbnRpdGxlbWVudHMnLCB7IGVudGl0bGVtZW50cyB9KVxufVxuXG5mdW5jdGlvbiBsYXVuY2goYXBwSWQsIGludGVudCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2Rpc2NvdmVyeScsICdsYXVuY2gnLCB7IGFwcElkLCBpbnRlbnQgfSlcbn1cblxuXG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9zaWduSW4oZW50aXRsZW1lbnRzKSB7XG4gICAgY29uc3QgcCA9IFRyYW5zcG9ydC5zZW5kKCdkaXNjb3ZlcnknLCAnc2lnbkluJywgeyBlbnRpdGxlbWVudHMgfSlcbiAgICBcbiAgICBwLnRoZW4oXyA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoXyA9PiB7XG4gICAgICAgICAgICBzaWduSW4oZW50aXRsZW1lbnRzKVxuICAgICAgICB9KSAgICBcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBcbn1cblxuXG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9zaWduT3V0KCkge1xuICAgIGNvbnN0IHAgPSBUcmFuc3BvcnQuc2VuZCgnZGlzY292ZXJ5JywgJ3NpZ25PdXQnLCB7ICB9KVxuICAgIFxuICAgIHAudGhlbihfID0+IHtcbiAgICAgICAgc2V0VGltZW91dChfID0+IHtcbiAgICAgICAgICAgIHNpZ25PdXQoKVxuICAgICAgICB9KSAgICBcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBcbn1cblxuZnVuY3Rpb24gRGlzY292ZXJ5X2xpc3RlbiguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMubGlzdGVuKCdkaXNjb3ZlcnknLCAuLi5hcmdzKVxufSBcblxuZnVuY3Rpb24gRGlzY292ZXJ5X29uY2UoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLm9uY2UoJ2Rpc2NvdmVyeScsIC4uLmFyZ3MpXG59XG5cbmZ1bmN0aW9uIERpc2NvdmVyeV9jbGVhciguLi5hcmdzKSB7XG4gIHJldHVybiBFdmVudHMuY2xlYXIoJ2Rpc2NvdmVyeScsIC4uLmFyZ3MpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgRGlzY292ZXJ5ID0gKHtcblxuICBldmVudHM6IHtcbiAgICBuYXZpZ2F0ZVRvOiduYXZpZ2F0ZVRvJyxcbiAgICBwb2xpY3lDaGFuZ2VkOidwb2xpY3lDaGFuZ2VkJ1xuICB9LFxucG9saWN5OiBEaXNjb3ZlcnlfcG9saWN5LFxuICBlbnRpdHlJbmZvLFxuICBwdXJjaGFzZWRDb250ZW50LFxuICB3YXRjaGVkLFxuICB3YXRjaE5leHQsXG4gIGVudGl0bGVtZW50cyxcbiAgbGF1bmNoLFxuICBzaWduSW46IERpc2NvdmVyeV9zaWduSW4sXG4gIHNpZ25PdXQ6IERpc2NvdmVyeV9zaWduT3V0LFxuICBsaXN0ZW46IERpc2NvdmVyeV9saXN0ZW4sXG4gIG9uY2U6IERpc2NvdmVyeV9vbmNlLFxuICBjbGVhcjogRGlzY292ZXJ5X2NsZWFyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9LZXlib2FyZC9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gZW1haWwodHlwZSwgbWVzc2FnZSkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2tleWJvYXJkJywgJ2VtYWlsJywgeyB0eXBlLCBtZXNzYWdlIH0pXG59XG5cbmZ1bmN0aW9uIEtleWJvYXJkX3Bhc3N3b3JkKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdrZXlib2FyZCcsICdwYXNzd29yZCcsIHsgbWVzc2FnZSB9KVxufVxuXG5mdW5jdGlvbiBzdGFuZGFyZChtZXNzYWdlKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgna2V5Ym9hcmQnLCAnc3RhbmRhcmQnLCB7IG1lc3NhZ2UgfSlcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBLZXlib2FyZCA9ICh7XG5cblxuICBFbWFpbFVzYWdlOiB7XG4gICAgU0lHTl9JTjogJ3NpZ25JbicsXG4gICAgU0lHTl9VUDogJ3NpZ25VcCdcbiAgfSxcblxuZW1haWwsXG4gIHBhc3N3b3JkOiBLZXlib2FyZF9wYXNzd29yZCxcbiAgc3RhbmRhcmRcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL0xpZmVjeWNsZS9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxucmVnaXN0ZXJFdmVudHMoJ0xpZmVjeWNsZScsIE9iamVjdC52YWx1ZXMoW1wiaW5hY3RpdmVcIixcImZvcmVncm91bmRcIixcImJhY2tncm91bmRcIixcInN1c3BlbmRlZFwiLFwidW5sb2FkaW5nXCJdKSlcblxuXG5jb25zdCBzdG9yZSA9IHtcbiAgX2N1cnJlbnQ6ICdpbml0aWFsaXppbmcnLFxuICBnZXQgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFxuICB9XG59XG5cbkV2ZW50cy5saXN0ZW4oJ0xpZmVjeWNsZScsIChldmVudCwgdmFsdWUpID0+IHtcbiAgc3RvcmUuX2N1cnJlbnQgPSBldmVudFxufSlcblxuXG47XG5cbmZ1bmN0aW9uIExpZmVjeWNsZV9yZWFkeSgpIHtcbiAgICBjb25zdCBwID0gVHJhbnNwb3J0LnNlbmQoJ2xpZmVjeWNsZScsICdyZWFkeScsIHsgIH0pXG4gICAgXG4gICAgcC50aGVuKF8gPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KF8gPT4ge1xuICAgICAgICAgICAgcmVhZHkoKVxuICAgICAgICB9KSAgICBcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBcbn1cblxuZnVuY3Rpb24gTGlmZWN5Y2xlX2Nsb3NlKHJlYXNvbikge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xpZmVjeWNsZScsICdjbG9zZScsIHsgcmVhc29uIH0pXG59XG5cbmZ1bmN0aW9uIExpZmVjeWNsZV9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignbGlmZWN5Y2xlJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIExpZmVjeWNsZV9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdsaWZlY3ljbGUnLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBMaWZlY3ljbGVfY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdsaWZlY3ljbGUnLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBzdGF0ZSgpIHtcbiAgcmV0dXJuIHN0b3JlLmN1cnJlbnRcbn1cblxuZnVuY3Rpb24gZmluaXNoZWQoKSB7XG4gIGlmIChzdG9yZS5jdXJyZW50ID09PSAndW5sb2FkaW5nJykge1xuICAgIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbGlmZWN5Y2xlJywgJ2ZpbmlzaGVkJylcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyAnQ2Fubm90IGNhbGwgZmluaXNoZWQoKSBleGNlcHQgd2hlbiBpbiB0aGUgdW5sb2FkaW5nIHRyYW5zaXRpb24nXG4gIH1cbn1cblxuLy8gcHVibGljIEFQSVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMaWZlY3ljbGUgPSAoe1xuXG4gIGV2ZW50czoge1xuICAgIGluYWN0aXZlOidpbmFjdGl2ZScsXG4gICAgZm9yZWdyb3VuZDonZm9yZWdyb3VuZCcsXG4gICAgYmFja2dyb3VuZDonYmFja2dyb3VuZCcsXG4gICAgc3VzcGVuZGVkOidzdXNwZW5kZWQnLFxuICAgIHVubG9hZGluZzondW5sb2FkaW5nJ1xuICB9LFxuXG5cbiAgTGlmZWN5Y2xlU3RhdGU6IHtcbiAgICBJTklUSUFMSVpJTkc6ICdpbml0aWFsaXppbmcnLFxuICAgIElOQUNUSVZFOiAnaW5hY3RpdmUnLFxuICAgIEJBQ0tHUk9VTkQ6ICdiYWNrZ3JvdW5kJyxcbiAgICBGT1JFR1JPVU5EOiAnZm9yZWdyb3VuZCcsXG4gICAgU1VTUEVOREVEOiAnc3VzcGVuZGVkJyxcbiAgICBVTkxPQURJTkc6ICd1bmxvYWRpbmcnXG4gIH0sXG5cblxuICBDbG9zZVJlYXNvbjoge1xuICAgIFJFTU9URV9CVVRUT046ICdyZW1vdGVCdXR0b24nLFxuICAgIFVTRVJfRVhJVDogJ3VzZXJFeGl0JyxcbiAgICBFUlJPUjogJ2Vycm9yJ1xuICB9LFxuXG5cbiAgc3RhdGUsXG4gIGZpbmlzaGVkLFxuXG5yZWFkeTogTGlmZWN5Y2xlX3JlYWR5LFxuICBjbG9zZTogTGlmZWN5Y2xlX2Nsb3NlLFxuICBsaXN0ZW46IExpZmVjeWNsZV9saXN0ZW4sXG4gIG9uY2U6IExpZmVjeWNsZV9vbmNlLFxuICBjbGVhcjogTGlmZWN5Y2xlX2NsZWFyICBcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTG9jYWxpemF0aW9uL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdMb2NhbGl6YXRpb24nLCBPYmplY3QudmFsdWVzKFtcImxhbmd1YWdlQ2hhbmdlZFwiXSkpXG5cblxuXG5mdW5jdGlvbiBsb2NhbGl0eSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdsb2NhbGl6YXRpb24nLCAnbG9jYWxpdHknLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBwb3N0YWxDb2RlKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdwb3N0YWxDb2RlJywgeyAgfSlcbn1cblxuZnVuY3Rpb24gY291bnRyeUNvZGUoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbG9jYWxpemF0aW9uJywgJ2NvdW50cnlDb2RlJywgeyAgfSlcbn1cbmZ1bmN0aW9uIGxhbmd1YWdlKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdsb2NhbGl6YXRpb24nLCAgJ2xhbmd1YWdlJywgYXJndW1lbnRzLCBmYWxzZSwgdHJ1ZSlcbn1cblxuZnVuY3Rpb24gbG9jYWxlKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdsb2NhbGUnLCB7ICB9KVxufVxuXG5mdW5jdGlvbiBsYXRsb24oKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnbG9jYWxpemF0aW9uJywgJ2xhdGxvbicsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGFkZGl0aW9uYWxJbmZvKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ2xvY2FsaXphdGlvbicsICdhZGRpdGlvbmFsSW5mbycsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIExvY2FsaXphdGlvbl9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3RlbignbG9jYWxpemF0aW9uJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIExvY2FsaXphdGlvbl9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdsb2NhbGl6YXRpb24nLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBMb2NhbGl6YXRpb25fY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdsb2NhbGl6YXRpb24nLCAuLi5hcmdzKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExvY2FsaXphdGlvbiA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgbGFuZ3VhZ2VDaGFuZ2VkOidsYW5ndWFnZUNoYW5nZWQnXG4gIH0sXG5sb2NhbGl0eSxcbiAgcG9zdGFsQ29kZSxcbiAgY291bnRyeUNvZGUsXG4gIGxhbmd1YWdlLFxuICBsb2NhbGUsXG4gIGxhdGxvbixcbiAgYWRkaXRpb25hbEluZm8sXG4gIGxpc3RlbjogTG9jYWxpemF0aW9uX2xpc3RlbixcbiAgb25jZTogTG9jYWxpemF0aW9uX29uY2UsXG4gIGNsZWFyOiBMb2NhbGl6YXRpb25fY2xlYXJcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL1BhcmFtZXRlcnMvaW5kZXguanNcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGluaXRpYWxpemF0aW9uKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ3BhcmFtZXRlcnMnLCAnaW5pdGlhbGl6YXRpb24nLCB7ICB9KVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFBhcmFtZXRlcnMgPSAoe1xuXG5pbml0aWFsaXphdGlvblxufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvUHJvZmlsZS9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuZnVuY3Rpb24gYXBwcm92ZUNvbnRlbnRSYXRpbmcoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgncHJvZmlsZScsICdhcHByb3ZlQ29udGVudFJhdGluZycsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGFwcHJvdmVQdXJjaGFzZSgpIHtcbiAgcmV0dXJuIFRyYW5zcG9ydC5zZW5kKCdwcm9maWxlJywgJ2FwcHJvdmVQdXJjaGFzZScsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGZsYWdzKCkge1xuICByZXR1cm4gVHJhbnNwb3J0LnNlbmQoJ3Byb2ZpbGUnLCAnZmxhZ3MnLCB7ICB9KVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFByb2ZpbGUgPSAoe1xuXG5hcHByb3ZlQ29udGVudFJhdGluZyxcbiAgYXBwcm92ZVB1cmNoYXNlLFxuICBmbGFnc1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvU2Vjb25kU2NyZWVuL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cbnJlZ2lzdGVyRXZlbnRzKCdTZWNvbmRTY3JlZW4nLCBPYmplY3QudmFsdWVzKFtcImxhdW5jaFJlcXVlc3RcIixcImNsb3NlUmVxdWVzdFwiLFwiZnJpZW5kbHlOYW1lQ2hhbmdlZFwiXSkpXG5cblxuXG5mdW5jdGlvbiBwcm90b2NvbHMoKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnc2Vjb25kc2NyZWVuJywgJ3Byb3RvY29scycsIHsgIH0pXG59XG5cbmZ1bmN0aW9uIGRldmljZSh0eXBlKSB7XG4gIHJldHVybiBUcmFuc3BvcnQuc2VuZCgnc2Vjb25kc2NyZWVuJywgJ2RldmljZScsIHsgdHlwZSB9KVxufVxuZnVuY3Rpb24gZnJpZW5kbHlOYW1lKCkge1xuICByZXR1cm4gUHJvcC5wcm9wKCdzZWNvbmRzY3JlZW4nLCAgJ2ZyaWVuZGx5TmFtZScsIGFyZ3VtZW50cywgZmFsc2UsIHRydWUpXG59XG5cbmZ1bmN0aW9uIFNlY29uZFNjcmVlbl9saXN0ZW4oLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmxpc3Rlbignc2Vjb25kc2NyZWVuJywgLi4uYXJncylcbn0gXG5cbmZ1bmN0aW9uIFNlY29uZFNjcmVlbl9vbmNlKC4uLmFyZ3MpIHtcbiAgcmV0dXJuIEV2ZW50cy5vbmNlKCdzZWNvbmRzY3JlZW4nLCAuLi5hcmdzKVxufVxuXG5mdW5jdGlvbiBTZWNvbmRTY3JlZW5fY2xlYXIoLi4uYXJncykge1xuICByZXR1cm4gRXZlbnRzLmNsZWFyKCdzZWNvbmRzY3JlZW4nLCAuLi5hcmdzKVxufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IFNlY29uZFNjcmVlbiA9ICh7XG5cbiAgZXZlbnRzOiB7XG4gICAgbGF1bmNoUmVxdWVzdDonbGF1bmNoUmVxdWVzdCcsXG4gICAgY2xvc2VSZXF1ZXN0OidjbG9zZVJlcXVlc3QnLFxuICAgIGZyaWVuZGx5TmFtZUNoYW5nZWQ6J2ZyaWVuZGx5TmFtZUNoYW5nZWQnXG4gIH0sXG5wcm90b2NvbHMsXG4gIGRldmljZSxcbiAgZnJpZW5kbHlOYW1lLFxuICBsaXN0ZW46IFNlY29uZFNjcmVlbl9saXN0ZW4sXG4gIG9uY2U6IFNlY29uZFNjcmVlbl9vbmNlLFxuICBjbGVhcjogU2Vjb25kU2NyZWVuX2NsZWFyXG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2J1aWxkL3Nkay9qYXZhc2NyaXB0L3NyYy9QbGF0Zm9ybS9pbmRleC5qc1xuLypcbiAqIENvcHlyaWdodCAyMDIxIENvbWNhc3QgQ2FibGUgQ29tbXVuaWNhdGlvbnMgTWFuYWdlbWVudCwgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuXG5cblxuXG5cblxuLy8gcHVibGljIEFQSVxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBQbGF0Zm9ybSA9ICh7XG4gIExvY2FsaXphdGlvbjogTG9jYWxpemF0aW9uLFxuICBEZXZpY2U6IERldmljZSxcbiAgQWNjZXNzaWJpbGl0eTogQWNjZXNzaWJpbGl0eSxcbn0pO1xuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9idWlsZC9zZGsvamF2YXNjcmlwdC9zcmMvTG9nL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5jb25zdCBwcmVwTG9nID0gKHR5cGUsIGFyZ3MpID0+IHtcbiAgY29uc3QgY29sb3JzID0ge1xuICAgIEluZm86ICdncmVlbicsXG4gICAgRGVidWc6ICdncmF5JyxcbiAgICBXYXJuOiAnb3JhbmdlJyxcbiAgICBFcnJvcjogJ3JlZCcsXG4gIH1cblxuICBhcmdzID0gQXJyYXkuZnJvbShhcmdzKVxuICByZXR1cm4gW1xuICAgICclYycgKyAoYXJncy5sZW5ndGggPiAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyA/IGFyZ3Muc2hpZnQoKSA6IHR5cGUpLFxuICAgICdiYWNrZ3JvdW5kLWNvbG9yOiAnICsgY29sb3JzW3R5cGVdICsgJzsgY29sb3I6IHdoaXRlOyBwYWRkaW5nOiAycHggNHB4OyBib3JkZXItcmFkaXVzOiAycHgnLFxuICAgIGFyZ3MsXG4gIF1cbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb2cgPSAoe1xuICBpbmZvKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgcHJlcExvZygnSW5mbycsIGFyZ3VtZW50cykpXG4gIH0sXG4gIGRlYnVnKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5kZWJ1Zy5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdEZWJ1ZycsIGFyZ3VtZW50cykpXG4gIH0sXG4gIGVycm9yKCkge1xuICAgIFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnbG9nJykgJiYgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdFcnJvcicsIGFyZ3VtZW50cykpXG4gIH0sXG4gIHdhcm4oKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgcHJlcExvZygnV2FybicsIGFyZ3VtZW50cykpXG4gIH0sXG59KTtcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvc2RrL2phdmFzY3JpcHQvc3JjL2luZGV4LmpzXG4vKlxuICogQ29weXJpZ2h0IDIwMjEgQ29tY2FzdCBDYWJsZSBDb21tdW5pY2F0aW9ucyBNYW5hZ2VtZW50LCBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWNjZXNzaWJpbGl0eSA9IF9fd2VicGFja19leHBvcnRzX18ueXE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FjY291bnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm1SO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BZHZlcnRpc2luZyA9IF9fd2VicGFja19leHBvcnRzX18uWkw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0F1dGhlbnRpY2F0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5WeTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGV2aWNlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5BUztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGlzY292ZXJ5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QRztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy56VztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fS2V5Ym9hcmQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk4xO1xudmFyIF9fd2VicGFja19leHBvcnRzX19MaWZlY3ljbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZ3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2NhbGl6YXRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLldIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2cgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlpiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19NZXRyaWNzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5DMztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFyYW1ldGVycyA9IF9fd2VicGFja19leHBvcnRzX18uYUU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BsYXRmb3JtID0gX193ZWJwYWNrX2V4cG9ydHNfXy50NDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJvZmlsZSA9IF9fd2VicGFja19leHBvcnRzX18uTlo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NlY29uZFNjcmVlbiA9IF9fd2VicGFja19leHBvcnRzX18uX0Y7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NldHRpbmdzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5acjtcbmV4cG9ydCB7IF9fd2VicGFja19leHBvcnRzX19BY2Nlc3NpYmlsaXR5IGFzIEFjY2Vzc2liaWxpdHksIF9fd2VicGFja19leHBvcnRzX19BY2NvdW50IGFzIEFjY291bnQsIF9fd2VicGFja19leHBvcnRzX19BZHZlcnRpc2luZyBhcyBBZHZlcnRpc2luZywgX193ZWJwYWNrX2V4cG9ydHNfX0F1dGhlbnRpY2F0aW9uIGFzIEF1dGhlbnRpY2F0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fRGV2aWNlIGFzIERldmljZSwgX193ZWJwYWNrX2V4cG9ydHNfX0Rpc2NvdmVyeSBhcyBEaXNjb3ZlcnksIF9fd2VicGFja19leHBvcnRzX19FdmVudHMgYXMgRXZlbnRzLCBfX3dlYnBhY2tfZXhwb3J0c19fS2V5Ym9hcmQgYXMgS2V5Ym9hcmQsIF9fd2VicGFja19leHBvcnRzX19MaWZlY3ljbGUgYXMgTGlmZWN5Y2xlLCBfX3dlYnBhY2tfZXhwb3J0c19fTG9jYWxpemF0aW9uIGFzIExvY2FsaXphdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX0xvZyBhcyBMb2csIF9fd2VicGFja19leHBvcnRzX19NZXRyaWNzIGFzIE1ldHJpY3MsIF9fd2VicGFja19leHBvcnRzX19QYXJhbWV0ZXJzIGFzIFBhcmFtZXRlcnMsIF9fd2VicGFja19leHBvcnRzX19QbGF0Zm9ybSBhcyBQbGF0Zm9ybSwgX193ZWJwYWNrX2V4cG9ydHNfX1Byb2ZpbGUgYXMgUHJvZmlsZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NlY29uZFNjcmVlbiBhcyBTZWNvbmRTY3JlZW4sIF9fd2VicGFja19leHBvcnRzX19TZXR0aW5ncyBhcyBTZXR0aW5ncyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJlYm9sdC5qcy5tYXAiLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgbG5nIGZyb20gJy4vc3JjL2xpZ2h0bmluZy5tanMnO1xuZXhwb3J0IGRlZmF1bHQgbG5nO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IHsgZGVmYXVsdCBhcyBBZHMgfSBmcm9tICcuL3NyYy9BZHMnXG5leHBvcnQgeyBBcHBEYXRhIH0gZnJvbSAnLi9zcmMvQXBwbGljYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIEFwcGxpY2F0aW9uIH0gZnJvbSAnLi9zcmMvQXBwbGljYXRpb24nXG5leHBvcnQgeyBkZWZhdWx0IGFzIEF1ZGlvUGxheWVyIH0gZnJvbSAnLi9zcmMvQXVkaW9QbGF5ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIENvbG9ycyB9IGZyb20gJy4vc3JjL0NvbG9ycydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSW1nIH0gZnJvbSAnLi9zcmMvSW1nJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBLZXlib2FyZCB9IGZyb20gJy4vc3JjL0tleWJvYXJkJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYXVuY2ggfSBmcm9tICcuL3NyYy9MYXVuY2gnXG5leHBvcnQgeyBkZWZhdWx0IGFzIExpZ2h0bmluZyB9IGZyb20gJy4vc3JjL0xpZ2h0bmluZydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTG9jYWxlIH0gZnJvbSAnLi9zcmMvTG9jYWxlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMYW5ndWFnZSB9IGZyb20gJy4vc3JjL0xhbmd1YWdlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMb2cgfSBmcm9tICcuL3NyYy9Mb2cnXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1lZGlhUGxheWVyIH0gZnJvbSAnLi9zcmMvTWVkaWFQbGF5ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1ldHJpY3MgfSBmcm9tICcuL3NyYy9NZXRyaWNzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQaW4gfSBmcm9tICcuL3NyYy9QaW4nXG5leHBvcnQgeyBkZWZhdWx0IGFzIFByb2ZpbGUgfSBmcm9tICcuL3NyYy9Qcm9maWxlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBQdXJjaGFzZSB9IGZyb20gJy4vc3JjL1B1cmNoYXNlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZWdpc3RyeSB9IGZyb20gJy4vc3JjL1JlZ2lzdHJ5J1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSb3V0ZXIgfSBmcm9tICcuL3NyYy9Sb3V0ZXInXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNldHRpbmdzIH0gZnJvbSAnLi9zcmMvU2V0dGluZ3MnXG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0b3JhZ2UgfSBmcm9tICcuL3NyYy9TdG9yYWdlJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUViB9IGZyb20gJy4vc3JjL1RWJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBVdGlscyB9IGZyb20gJy4vc3JjL1V0aWxzJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBWaWRlb1BsYXllciB9IGZyb20gJy4vc3JjL1ZpZGVvUGxheWVyJ1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZXRhZGF0YSB9IGZyb20gJy4vc3JjL01ldGFkYXRhJ1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5pbXBvcnQgeyBtZWRpYVVybCB9IGZyb20gJy4uL1ZpZGVvUGxheWVyJ1xuXG5sZXQgY29uc3VtZXJcblxubGV0IGdldEFkcyA9ICgpID0+IHtcbiAgLy8gdG9kbzogZW5hYmxlIHNvbWUgZGVmYXVsdCBhZHMgZHVyaW5nIGRldmVsb3BtZW50LCBtYXliZSBmcm9tIHRoZSBzZXR0aW5ncy5qc29uXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgIHByZXJvbGxzOiBbXSxcbiAgICBtaWRyb2xsczogW10sXG4gICAgcG9zdHJvbGxzOiBbXSxcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRBZHMgPSBjb25maWcgPT4ge1xuICBpZiAoY29uZmlnLmdldEFkcykge1xuICAgIGdldEFkcyA9IGNvbmZpZy5nZXRBZHNcbiAgfVxufVxuXG5jb25zdCBzdGF0ZSA9IHtcbiAgYWN0aXZlOiBmYWxzZSxcbn1cblxuY29uc3QgcGxheVNsb3QgPSAoc2xvdCA9IFtdKSA9PiB7XG4gIHJldHVybiBzbG90LnJlZHVjZSgocHJvbWlzZSwgYWQpID0+IHtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBwbGF5QWQoYWQpXG4gICAgfSlcbiAgfSwgUHJvbWlzZS5yZXNvbHZlKG51bGwpKVxufVxuXG5jb25zdCBwbGF5QWQgPSBhZCA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpZiAoc3RhdGUuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgTG9nLmluZm8oJ0FkJywgJ1NraXBwaW5nIGFkZCBkdWUgdG8gaW5hY3RpdmUgc3RhdGUnKVxuICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgIH1cbiAgICAvLyBpcyBpdCBzYWZlIHRvIHJlbHkgb24gdmlkZW9wbGF5ZXIgcGx1Z2luIGFscmVhZHkgY3JlYXRlZCB0aGUgdmlkZW8gdGFnP1xuICAgIGNvbnN0IHZpZGVvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKVswXVxuICAgIHZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICB2aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICB2aWRlb0VsLnNyYyA9IG1lZGlhVXJsKGFkLnVybClcbiAgICB2aWRlb0VsLmxvYWQoKVxuXG4gICAgbGV0IHRpbWVFdmVudHMgPSBudWxsXG4gICAgbGV0IHRpbWVvdXRcblxuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAvLyByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goaGFuZGxlciA9PlxuICAgICAgICB2aWRlb0VsLnJlbW92ZUV2ZW50TGlzdGVuZXIoaGFuZGxlciwgaGFuZGxlcnNbaGFuZGxlcl0pXG4gICAgICApXG4gICAgICByZXNvbHZlKClcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBwbGF5KCkge1xuICAgICAgICBMb2cuaW5mbygnQWQnLCAnUGxheSBhZCcsIGFkLnVybClcbiAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ1BsYXknLCBhZClcbiAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICdkZWZhdWx0SW1wcmVzc2lvbicpXG4gICAgICB9LFxuICAgICAgZW5kZWQoKSB7XG4gICAgICAgIGZpcmVPbkNvbnN1bWVyKCdFbmRlZCcsIGFkKVxuICAgICAgICBzZW5kQmVhY29uKGFkLmNhbGxiYWNrcywgJ2NvbXBsZXRlJylcbiAgICAgICAgY2xlYW51cCgpXG4gICAgICB9LFxuICAgICAgdGltZXVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aW1lRXZlbnRzICYmIHZpZGVvRWwuZHVyYXRpb24pIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgd2hlbiB0byBmaXJlIHRoZSB0aW1lIGJhc2VkIGV2ZW50cyAobm93IHRoYXQgZHVyYXRpb24gaXMga25vd24pXG4gICAgICAgICAgdGltZUV2ZW50cyA9IHtcbiAgICAgICAgICAgIGZpcnN0UXVhcnRpbGU6IHZpZGVvRWwuZHVyYXRpb24gLyA0LFxuICAgICAgICAgICAgbWlkUG9pbnQ6IHZpZGVvRWwuZHVyYXRpb24gLyAyLFxuICAgICAgICAgICAgdGhpcmRRdWFydGlsZTogKHZpZGVvRWwuZHVyYXRpb24gLyA0KSAqIDMsXG4gICAgICAgICAgfVxuICAgICAgICAgIExvZy5pbmZvKCdBZCcsICdDYWxjdWxhdGVkIHF1YXJ0aWxlcyB0aW1lcycsIHsgdGltZUV2ZW50cyB9KVxuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aW1lRXZlbnRzICYmXG4gICAgICAgICAgdGltZUV2ZW50cy5maXJzdFF1YXJ0aWxlICYmXG4gICAgICAgICAgdmlkZW9FbC5jdXJyZW50VGltZSA+PSB0aW1lRXZlbnRzLmZpcnN0UXVhcnRpbGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ0ZpcnN0UXVhcnRpbGUnLCBhZClcbiAgICAgICAgICBkZWxldGUgdGltZUV2ZW50cy5maXJzdFF1YXJ0aWxlXG4gICAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICdmaXJzdFF1YXJ0aWxlJylcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZUV2ZW50cyAmJiB0aW1lRXZlbnRzLm1pZFBvaW50ICYmIHZpZGVvRWwuY3VycmVudFRpbWUgPj0gdGltZUV2ZW50cy5taWRQb2ludCkge1xuICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdNaWRQb2ludCcsIGFkKVxuICAgICAgICAgIGRlbGV0ZSB0aW1lRXZlbnRzLm1pZFBvaW50XG4gICAgICAgICAgc2VuZEJlYWNvbihhZC5jYWxsYmFja3MsICdtaWRQb2ludCcpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRpbWVFdmVudHMgJiZcbiAgICAgICAgICB0aW1lRXZlbnRzLnRoaXJkUXVhcnRpbGUgJiZcbiAgICAgICAgICB2aWRlb0VsLmN1cnJlbnRUaW1lID49IHRpbWVFdmVudHMudGhpcmRRdWFydGlsZVxuICAgICAgICApIHtcbiAgICAgICAgICBmaXJlT25Db25zdW1lcignVGhpcmRRdWFydGlsZScsIGFkKVxuICAgICAgICAgIGRlbGV0ZSB0aW1lRXZlbnRzLnRoaXJkUXVhcnRpbGVcbiAgICAgICAgICBzZW5kQmVhY29uKGFkLmNhbGxiYWNrcywgJ3RoaXJkUXVhcnRpbGUnKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhbGxlZCgpIHtcbiAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ1N0YWxsZWQnLCBhZClcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNsZWFudXAoKVxuICAgICAgICB9LCA1MDAwKSAvLyBtYWtlIHRpbWVvdXQgY29uZmlndXJhYmxlXG4gICAgICB9LFxuICAgICAgY2FucGxheSgpIHtcbiAgICAgICAgdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICAgIH0sXG4gICAgICBlcnJvcigpIHtcbiAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ0Vycm9yJywgYWQpXG4gICAgICAgIGNsZWFudXAoKVxuICAgICAgfSxcbiAgICAgIC8vIHRoaXMgZG9lc24ndCB3b3JrIHJlbGlhYmx5IG9uIHNreSBib3gsIG1vdmVkIGxvZ2ljIHRvIHRpbWVVcGRhdGUgZXZlbnRcbiAgICAgIC8vIGxvYWRlZG1ldGFkYXRhKCkge1xuICAgICAgLy8gICAvLyBjYWxjdWxhdGUgd2hlbiB0byBmaXJlIHRoZSB0aW1lIGJhc2VkIGV2ZW50cyAobm93IHRoYXQgZHVyYXRpb24gaXMga25vd24pXG4gICAgICAvLyAgIHRpbWVFdmVudHMgPSB7XG4gICAgICAvLyAgICAgZmlyc3RRdWFydGlsZTogdmlkZW9FbC5kdXJhdGlvbiAvIDQsXG4gICAgICAvLyAgICAgbWlkUG9pbnQ6IHZpZGVvRWwuZHVyYXRpb24gLyAyLFxuICAgICAgLy8gICAgIHRoaXJkUXVhcnRpbGU6ICh2aWRlb0VsLmR1cmF0aW9uIC8gNCkgKiAzLFxuICAgICAgLy8gICB9XG4gICAgICAvLyB9LFxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIGNsZWFudXAoKVxuICAgICAgfSxcbiAgICAgIC8vIHRvZG86IHBhdXNlLCByZXN1bWUsIG11dGUsIHVubXV0ZSBiZWFjb25zXG4gICAgfVxuICAgIC8vIGFkZCBhbGwgbGlzdGVuZXJzXG4gICAgT2JqZWN0LmtleXMoaGFuZGxlcnMpLmZvckVhY2goaGFuZGxlciA9PiB2aWRlb0VsLmFkZEV2ZW50TGlzdGVuZXIoaGFuZGxlciwgaGFuZGxlcnNbaGFuZGxlcl0pKVxuXG4gICAgdmlkZW9FbC5wbGF5KClcbiAgfSlcbn1cblxuY29uc3Qgc2VuZEJlYWNvbiA9IChjYWxsYmFja3MsIGV2ZW50KSA9PiB7XG4gIGlmIChjYWxsYmFja3MgJiYgY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgIExvZy5pbmZvKCdBZCcsICdTZW5kaW5nIGJlYWNvbicsIGV2ZW50LCBjYWxsYmFja3NbZXZlbnRdKVxuICAgIHJldHVybiBjYWxsYmFja3NbZXZlbnRdLnJlZHVjZSgocHJvbWlzZSwgdXJsKSA9PiB7XG4gICAgICByZXR1cm4gcHJvbWlzZS50aGVuKCgpID0+XG4gICAgICAgIGZldGNoKHVybClcbiAgICAgICAgICAvLyBhbHdheXMgcmVzb2x2ZSwgYWxzbyBpbiBjYXNlIG9mIGEgZmV0Y2ggZXJyb3IgKHNvIHdlIGRvbid0IGJsb2NrIGZpcmluZyB0aGUgcmVzdCBvZiB0aGUgYmVhY29ucyBmb3IgdGhpcyBldmVudClcbiAgICAgICAgICAvLyBub3RlOiBmb3IgZmV0Y2ggZmFpbGVkIGh0dHAgcmVzcG9uc2VzIGRvbid0IHRocm93IGFuIEVycm9yIDopXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdCZWFjb24nICsgZXZlbnQgKyAnU2VudCcpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaXJlT25Db25zdW1lcignQmVhY29uJyArIGV2ZW50ICsgJ0ZhaWxlZCcgKyByZXNwb25zZS5zdGF0dXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUobnVsbClcbiAgICAgICAgICB9KVxuICAgICAgKVxuICAgIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSlcbiAgfSBlbHNlIHtcbiAgICBMb2cuaW5mbygnQWQnLCAnTm8gY2FsbGJhY2sgZm91bmQgZm9yICcgKyBldmVudClcbiAgfVxufVxuXG5jb25zdCBmaXJlT25Db25zdW1lciA9IChldmVudCwgYXJncykgPT4ge1xuICBpZiAoY29uc3VtZXIpIHtcbiAgICBjb25zdW1lci5maXJlKCckYWQnICsgZXZlbnQsIGFyZ3MpXG4gICAgY29uc3VtZXIuZmlyZSgnJGFkRXZlbnQnLCBldmVudCwgYXJncylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldChjb25maWcsIHZpZGVvUGxheWVyQ29uc3VtZXIpIHtcbiAgICBpZiAoY29uZmlnLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgcHJlcm9sbHMoKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICBjb25zdW1lciA9IHZpZGVvUGxheWVyQ29uc3VtZXJcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIExvZy5pbmZvKCdBZCcsICdTdGFydGluZyBzZXNzaW9uJylcbiAgICAgIGdldEFkcyhjb25maWcpLnRoZW4oYWRzID0+IHtcbiAgICAgICAgTG9nLmluZm8oJ0FkJywgJ0FQSSByZXN1bHQnLCBhZHMpXG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIHByZXJvbGxzKCkge1xuICAgICAgICAgICAgaWYgKGFkcy5wcmVyb2xsKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZSA9IHRydWVcbiAgICAgICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ1ByZXJvbGxTbG90SW1wcmVzc2lvbicsIGFkcylcbiAgICAgICAgICAgICAgc2VuZEJlYWNvbihhZHMucHJlcm9sbC5jYWxsYmFja3MsICdzbG90SW1wcmVzc2lvbicpXG4gICAgICAgICAgICAgIHJldHVybiBwbGF5U2xvdChhZHMucHJlcm9sbC5hZHMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZpcmVPbkNvbnN1bWVyKCdQcmVyb2xsU2xvdEVuZCcsIGFkcylcbiAgICAgICAgICAgICAgICBzZW5kQmVhY29uKGFkcy5wcmVyb2xsLmNhbGxiYWNrcywgJ3Nsb3RFbmQnKVxuICAgICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZSA9IGZhbHNlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1pZHJvbGxzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3N0cm9sbHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICB9LFxuICBjYW5jZWwoKSB7XG4gICAgTG9nLmluZm8oJ0FkJywgJ0NhbmNlbCBBZCcpXG4gICAgc3RhdGUuYWN0aXZlID0gZmFsc2VcbiAgfSxcbiAgc3RvcCgpIHtcbiAgICBMb2cuaW5mbygnQWQnLCAnU3RvcCBBZCcpXG4gICAgc3RhdGUuYWN0aXZlID0gZmFsc2VcbiAgICAvLyBmaXhtZTogZHVwbGljYXRpb25cbiAgICBjb25zdCB2aWRlb0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJylbMF1cbiAgICB2aWRlb0VsLnBhdXNlKClcbiAgICB2aWRlb0VsLnJlbW92ZUF0dHJpYnV0ZSgnc3JjJylcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJ1xuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgTG9jYWxlIGZyb20gJy4uL0xvY2FsZSdcbmltcG9ydCBNZXRyaWNzIGZyb20gJy4uL01ldHJpY3MnXG5pbXBvcnQgVmVyc2lvbkxhYmVsIGZyb20gJy4uL1ZlcnNpb25MYWJlbCdcbmltcG9ydCBGcHNDb3VudGVyIGZyb20gJy4uL0Zwc0NvdW50ZXInXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCB7IGluaXRMYW5ndWFnZSB9IGZyb20gJy4uL0xhbmd1YWdlJ1xuaW1wb3J0IFV0aWxzIGZyb20gJy4uL1V0aWxzJ1xuaW1wb3J0IFJlZ2lzdHJ5IGZyb20gJy4uL1JlZ2lzdHJ5J1xuaW1wb3J0IHsgaW5pdENvbG9ycyB9IGZyb20gJy4uL0NvbG9ycydcblxuaW1wb3J0IHBhY2thZ2VJbmZvIGZyb20gJy4uLy4uL3BhY2thZ2UuanNvbidcblxuZXhwb3J0IGxldCBBcHBJbnN0YW5jZVxuZXhwb3J0IGxldCBBcHBEYXRhXG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICBzdGFnZTogeyB3OiAxOTIwLCBoOiAxMDgwLCBjbGVhckNvbG9yOiAweDAwMDAwMDAwLCBjYW52YXMyZDogZmFsc2UgfSxcbiAgZGVidWc6IGZhbHNlLFxuICBkZWZhdWx0Rm9udEZhY2U6ICdSb2JvdG9SZWd1bGFyJyxcbiAga2V5czoge1xuICAgIDg6ICdCYWNrJyxcbiAgICAxMzogJ0VudGVyJyxcbiAgICAyNzogJ01lbnUnLFxuICAgIDM3OiAnTGVmdCcsXG4gICAgMzg6ICdVcCcsXG4gICAgMzk6ICdSaWdodCcsXG4gICAgNDA6ICdEb3duJyxcbiAgICAxNzQ6ICdDaGFubmVsRG93bicsXG4gICAgMTc1OiAnQ2hhbm5lbFVwJyxcbiAgICAxNzg6ICdTdG9wJyxcbiAgICAyNTA6ICdQbGF5UGF1c2UnLFxuICAgIDE5MTogJ1NlYXJjaCcsIC8vIFVzZSBcIi9cIiBmb3Iga2V5Ym9hcmRcbiAgICA0MDk6ICdTZWFyY2gnLFxuICB9LFxufVxuXG5jb25zdCBjdXN0b21Gb250RmFjZXMgPSBbXVxuXG5jb25zdCBmb250TG9hZGVyID0gKGZvbnRzLCBzdG9yZSkgPT5cbiAgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGZvbnRzXG4gICAgICAubWFwKCh7IGZhbWlseSwgdXJsLCB1cmxzLCBkZXNjcmlwdG9ycyB9KSA9PiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNyYyA9IHVybHNcbiAgICAgICAgICA/IHVybHMubWFwKHVybCA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiAndXJsKCcgKyB1cmwgKyAnKSdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiAndXJsKCcgKyB1cmwgKyAnKSdcbiAgICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UoZmFtaWx5LCBzcmMsIGRlc2NyaXB0b3JzIHx8IHt9KVxuICAgICAgICBzdG9yZS5wdXNoKGZvbnRGYWNlKVxuICAgICAgICBMb2cuaW5mbygnTG9hZGluZyBmb250JywgZmFtaWx5KVxuICAgICAgICBkb2N1bWVudC5mb250cy5hZGQoZm9udEZhY2UpXG4gICAgICAgIHJldHVybiBmb250RmFjZS5sb2FkKClcbiAgICAgIH0pXG4gICAgICAucmVkdWNlKChwcm9taXNlLCBtZXRob2QpID0+IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigoKSA9PiBtZXRob2QoKSlcbiAgICAgIH0sIFByb21pc2UucmVzb2x2ZShudWxsKSlcbiAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAuY2F0Y2gocmVqZWN0KVxuICB9KVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihBcHAsIGFwcERhdGEsIHBsYXRmb3JtU2V0dGluZ3MpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBwbGF0Zm9ybVNldHRpbmdzXG5cbiAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgIGRlZmF1bHRPcHRpb25zLnN0YWdlWyd3J10gPSB3aWR0aFxuICAgIGRlZmF1bHRPcHRpb25zLnN0YWdlWydoJ10gPSBoZWlnaHRcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsncHJlY2lzaW9uJ10gPSB3aWR0aCAvIDE5MjBcbiAgfVxuXG4gIC8vIHN1cHBvcnQgZm9yIDcyMHAgYnJvd3NlclxuICBpZiAoIXdpZHRoICYmICFoZWlnaHQgJiYgd2luZG93LmlubmVySGVpZ2h0ID09PSA3MjApIHtcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsndyddID0gMTI4MFxuICAgIGRlZmF1bHRPcHRpb25zLnN0YWdlWydoJ10gPSA3MjBcbiAgICBkZWZhdWx0T3B0aW9ucy5zdGFnZVsncHJlY2lzaW9uJ10gPSAxMjgwIC8gMTkyMFxuICB9XG5cbiAgcmV0dXJuIGNsYXNzIEFwcGxpY2F0aW9uIGV4dGVuZHMgTGlnaHRuaW5nLkFwcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICBjb25zdCBjb25maWcgPSBEZWVwbWVyZ2UoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpXG4gICAgICAvLyBEZWVwbWVyZ2UgYnJlYWtzIEhUTUxDYW52YXNFbGVtZW50LCBzbyByZXN0b3JlIHRoZSBwYXNzZWQgaW4gY2FudmFzLlxuICAgICAgaWYgKG9wdGlvbnMuc3RhZ2UuY2FudmFzKSB7XG4gICAgICAgIGNvbmZpZy5zdGFnZS5jYW52YXMgPSBvcHRpb25zLnN0YWdlLmNhbnZhc1xuICAgICAgfVxuICAgICAgc3VwZXIoY29uZmlnKVxuICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcbiAgICB9XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdzogMTkyMCxcbiAgICAgICAgaDogMTA4MCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0dXAoKSB7XG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMubG9hZEZvbnRzKChBcHAuY29uZmlnICYmIEFwcC5jb25maWcuZm9udHMpIHx8IChBcHAuZ2V0Rm9udHMgJiYgQXBwLmdldEZvbnRzKCkpIHx8IFtdKSxcbiAgICAgICAgLy8gdG8gYmUgZGVwcmVjYXRlZFxuICAgICAgICBMb2NhbGUubG9hZCgoQXBwLmNvbmZpZyAmJiBBcHAuY29uZmlnLmxvY2FsZSkgfHwgKEFwcC5nZXRMb2NhbGUgJiYgQXBwLmdldExvY2FsZSgpKSksXG4gICAgICAgIEFwcC5sYW5ndWFnZSAmJiB0aGlzLmxvYWRMYW5ndWFnZShBcHAubGFuZ3VhZ2UoKSksXG4gICAgICAgIEFwcC5jb2xvcnMgJiYgdGhpcy5sb2FkQ29sb3JzKEFwcC5jb2xvcnMoKSksXG4gICAgICBdKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgTWV0cmljcy5hcHAubG9hZGVkKClcblxuICAgICAgICAgIEFwcERhdGEgPSBhcHBEYXRhXG5cbiAgICAgICAgICBBcHBJbnN0YW5jZSA9IHRoaXMuc3RhZ2UuYyh7XG4gICAgICAgICAgICByZWY6ICdBcHAnLFxuICAgICAgICAgICAgdHlwZTogQXBwLFxuICAgICAgICAgICAgekluZGV4OiAxLFxuICAgICAgICAgICAgZm9yY2VaSW5kZXhDb250ZXh0OiAhIXBsYXRmb3JtU2V0dGluZ3Muc2hvd1ZlcnNpb24gfHwgISFwbGF0Zm9ybVNldHRpbmdzLnNob3dGcHMsXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHRoaXMuY2hpbGRMaXN0LmEoQXBwSW5zdGFuY2UpXG5cbiAgICAgICAgICB0aGlzLl9yZWZvY3VzKClcblxuICAgICAgICAgIExvZy5pbmZvKCdBcHAgdmVyc2lvbicsIHRoaXMuY29uZmlnLnZlcnNpb24pXG4gICAgICAgICAgTG9nLmluZm8oJ1NESyB2ZXJzaW9uJywgcGFja2FnZUluZm8udmVyc2lvbilcblxuICAgICAgICAgIGlmIChwbGF0Zm9ybVNldHRpbmdzLnNob3dWZXJzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkTGlzdC5hKHtcbiAgICAgICAgICAgICAgcmVmOiAnVmVyc2lvbkxhYmVsJyxcbiAgICAgICAgICAgICAgdHlwZTogVmVyc2lvbkxhYmVsLFxuICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLmNvbmZpZy52ZXJzaW9uLFxuICAgICAgICAgICAgICBzZGtWZXJzaW9uOiBwYWNrYWdlSW5mby52ZXJzaW9uLFxuICAgICAgICAgICAgICB6SW5kZXg6IDEsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwbGF0Zm9ybVNldHRpbmdzLnNob3dGcHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRMaXN0LmEoe1xuICAgICAgICAgICAgICByZWY6ICdGcHNDb3VudGVyJyxcbiAgICAgICAgICAgICAgdHlwZTogRnBzQ291bnRlcixcbiAgICAgICAgICAgICAgekluZGV4OiAxLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdXBlci5fc2V0dXAoKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goY29uc29sZS5lcnJvcilcbiAgICB9XG5cbiAgICBfaGFuZGxlQmFjaygpIHtcbiAgICAgIHRoaXMuY2xvc2VBcHAoKVxuICAgIH1cblxuICAgIF9oYW5kbGVFeGl0KCkge1xuICAgICAgdGhpcy5jbG9zZUFwcCgpXG4gICAgfVxuXG4gICAgY2xvc2VBcHAoKSB7XG4gICAgICBMb2cuaW5mbygnU2lnbmFsaW5nIEFwcCBDbG9zZScpXG5cbiAgICAgIGlmIChwbGF0Zm9ybVNldHRpbmdzLm9uQ2xvc2UgJiYgdHlwZW9mIHBsYXRmb3JtU2V0dGluZ3Mub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbGF0Zm9ybVNldHRpbmdzLm9uQ2xvc2UoLi4uYXJndW1lbnRzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICBMb2cuaW5mbygnQ2xvc2luZyBBcHAnKVxuXG4gICAgICBTZXR0aW5ncy5jbGVhclN1YnNjcmliZXJzKClcbiAgICAgIFJlZ2lzdHJ5LmNsZWFyKClcblxuICAgICAgdGhpcy5jaGlsZExpc3QucmVtb3ZlKHRoaXMudGFnKCdBcHAnKSlcbiAgICAgIHRoaXMuY2xlYW51cEZvbnRzKClcbiAgICAgIC8vIGZvcmNlIHRleHR1cmUgZ2FyYmFnZSBjb2xsZWN0XG4gICAgICB0aGlzLnN0YWdlLmdjKClcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgbG9hZEZvbnRzKGZvbnRzKSB7XG4gICAgICByZXR1cm4gcGxhdGZvcm1TZXR0aW5ncy5mb250TG9hZGVyICYmIHR5cGVvZiBwbGF0Zm9ybVNldHRpbmdzLmZvbnRMb2FkZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBwbGF0Zm9ybVNldHRpbmdzLmZvbnRMb2FkZXIoZm9udHMsIGN1c3RvbUZvbnRGYWNlcylcbiAgICAgICAgOiBmb250TG9hZGVyKGZvbnRzLCBjdXN0b21Gb250RmFjZXMpXG4gICAgfVxuXG4gICAgY2xlYW51cEZvbnRzKCkge1xuICAgICAgaWYgKCdkZWxldGUnIGluIGRvY3VtZW50LmZvbnRzKSB7XG4gICAgICAgIGN1c3RvbUZvbnRGYWNlcy5mb3JFYWNoKGZvbnRGYWNlID0+IHtcbiAgICAgICAgICBMb2cuaW5mbygnUmVtb3ZpbmcgZm9udCcsIGZvbnRGYWNlLmZhbWlseSlcbiAgICAgICAgICBkb2N1bWVudC5mb250cy5kZWxldGUoZm9udEZhY2UpXG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2cuaW5mbygnTm8gc3VwcG9ydCBmb3IgcmVtb3ZpbmcgbWFudWFsbHktYWRkZWQgZm9udHMnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRMYW5ndWFnZShjb25maWcpIHtcbiAgICAgIGxldCBmaWxlID0gVXRpbHMuYXNzZXQoJ3RyYW5zbGF0aW9ucy5qc29uJylcbiAgICAgIGxldCBsYW5ndWFnZSA9IGNvbmZpZ1xuXG4gICAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBsYW5ndWFnZSA9IGNvbmZpZy5sYW5ndWFnZSB8fCBudWxsXG4gICAgICAgIGZpbGUgPSBjb25maWcuZmlsZSB8fCBmaWxlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbml0TGFuZ3VhZ2UoZmlsZSwgbGFuZ3VhZ2UpXG4gICAgfVxuXG4gICAgbG9hZENvbG9ycyhjb25maWcpIHtcbiAgICAgIGxldCBmaWxlID0gVXRpbHMuYXNzZXQoJ2NvbG9ycy5qc29uJylcbiAgICAgIGlmIChjb25maWcgJiYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSkge1xuICAgICAgICBmaWxlID0gY29uZmlnXG4gICAgICB9XG4gICAgICByZXR1cm4gaW5pdENvbG9ycyhmaWxlKVxuICAgIH1cblxuICAgIHNldCBmb2N1cyh2KSB7XG4gICAgICB0aGlzLl9mb2N1c3NlZCA9IHZcbiAgICAgIHRoaXMuX3JlZm9jdXMoKVxuICAgIH1cblxuICAgIF9nZXRGb2N1c2VkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZvY3Vzc2VkIHx8IHRoaXMudGFnKCdBcHAnKVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXVkaW9QbGF5ZXIge31cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuaW1wb3J0IHsgbWVyZ2VDb2xvcnMsIGNhbGN1bGF0ZUFscGhhLCBpc09iamVjdCwgaXNTdHJpbmcsIGFyZ2JUb0hTTEEsIGhzbGFUb0FSR0IgfSBmcm9tICcuL3V0aWxzLmpzJ1xuXG5sZXQgY29sb3JzID0ge1xuICB3aGl0ZTogJyNmZmZmZmYnLFxuICBibGFjazogJyMwMDAwMDAnLFxuICByZWQ6ICcjZmYwMDAwJyxcbiAgZ3JlZW46ICcjMDBmZjAwJyxcbiAgYmx1ZTogJyMwMDAwZmYnLFxuICB5ZWxsb3c6ICcjZmVmZjAwJyxcbiAgY3lhbjogJyMwMGZlZmYnLFxuICBtYWdlbnRhOiAnI2ZmMDBmZicsXG59XG5cbmNvbnN0IG5vcm1hbGl6ZWRDb2xvcnMgPSB7XG4gIC8vc3RvcmUgZm9yIG5vcm1hbGl6ZWQgY29sb3JzXG59XG5cbmNvbnN0IGFkZENvbG9ycyA9IChjb2xvcnNUb0FkZCwgdmFsdWUpID0+IHtcbiAgaWYgKGlzT2JqZWN0KGNvbG9yc1RvQWRkKSkge1xuICAgIC8vIGNsZWFuIHVwIG5vcm1hbGl6ZWRDb2xvcnMgaWYgdGhleSBleGlzdCBpbiB0aGUgdG8gYmUgYWRkZWQgY29sb3JzXG4gICAgT2JqZWN0LmtleXMoY29sb3JzVG9BZGQpLmZvckVhY2goY29sb3IgPT4gY2xlYW5VcE5vcm1hbGl6ZWRDb2xvcnMoY29sb3IpKVxuICAgIGNvbG9ycyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbG9ycywgY29sb3JzVG9BZGQpXG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29sb3JzVG9BZGQpICYmIHZhbHVlKSB7XG4gICAgY2xlYW5VcE5vcm1hbGl6ZWRDb2xvcnMoY29sb3JzVG9BZGQpXG4gICAgY29sb3JzW2NvbG9yc1RvQWRkXSA9IHZhbHVlXG4gIH1cbn1cblxuY29uc3QgY2xlYW5VcE5vcm1hbGl6ZWRDb2xvcnMgPSBjb2xvciA9PiB7XG4gIGZvciAobGV0IGMgaW4gbm9ybWFsaXplZENvbG9ycykge1xuICAgIGlmIChjLmluZGV4T2YoY29sb3IpID4gLTEpIHtcbiAgICAgIGRlbGV0ZSBub3JtYWxpemVkQ29sb3JzW2NdXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbml0Q29sb3JzID0gZmlsZSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmaWxlID09PSAnb2JqZWN0Jykge1xuICAgICAgYWRkQ29sb3JzKGZpbGUpXG4gICAgICByZXNvbHZlKClcbiAgICB9XG4gICAgZmV0Y2goZmlsZSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICBhZGRDb2xvcnMoanNvbilcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAnQ29sb3JzIGZpbGUgJyArIGZpbGUgKyAnIG5vdCBmb3VuZCdcbiAgICAgICAgTG9nLmVycm9yKGVycm9yKVxuICAgICAgICByZWplY3QoZXJyb3IpXG4gICAgICB9KVxuICB9KVxufVxuXG5jb25zdCBub3JtYWxpemVDb2xvclRvQVJHQiA9IGNvbG9yID0+IHtcbiAgbGV0IHRhcmdldENvbG9yID0gbm9ybWFsaXplZENvbG9yc1tjb2xvcl0gfHwgY29sb3JzW2NvbG9yXSB8fCBjb2xvclxuICBpZiAoIXRhcmdldENvbG9yKSB7XG4gICAgdGFyZ2V0Q29sb3IgPSBjb2xvclxuICB9XG4gIGNvbnN0IGNoZWNrID0gL14jKFswLTlBLUZdezN9fFswLTlBLUZdezZ9KSQvaVxuICBpZiAoaXNTdHJpbmcodGFyZ2V0Q29sb3IpICYmIGNoZWNrLnRlc3QodGFyZ2V0Q29sb3IpKSB7XG4gICAgbGV0IGhleCA9IGNoZWNrLmV4ZWModGFyZ2V0Q29sb3IpWzFdXG4gICAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICAgIGhleCA9IGhleFxuICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgIC5tYXAodmFsdWUgPT4ge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSArIHZhbHVlXG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcnKVxuICAgIH1cbiAgICB0YXJnZXRDb2xvciA9IGAweGZmJHtoZXh9YCAqIDFcbiAgfVxuICBpZiAoIW5vcm1hbGl6ZWRDb2xvcnNbY29sb3JdKSB7XG4gICAgbm9ybWFsaXplZENvbG9yc1tjb2xvcl0gPSB0YXJnZXRDb2xvclxuICB9XG4gIHJldHVybiB0YXJnZXRDb2xvciB8fCAweGZmZmZmZmZmXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvbG9yID0+IHtcbiAgcmV0dXJuIENvbG9yLmdlbmVyYXRlKGNvbG9yKVxufVxuXG5jb25zdCBDb2xvciA9IHtcbiAgY29sb3I6IG51bGwsXG4gIGdlbmVyYXRlOiBmdW5jdGlvbih2YWx1ZSA9IHRoaXMuY29sb3IpIHtcbiAgICBpZiAobm9ybWFsaXplZENvbG9yc1t2YWx1ZV0pIHtcbiAgICAgIHRoaXMuY29sb3IgPSBub3JtYWxpemVkQ29sb3JzW3ZhbHVlXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbG9yID0gbm9ybWFsaXplQ29sb3JUb0FSR0IodmFsdWUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xvclxuICB9LFxuICBhbHBoYTogZnVuY3Rpb24ocGVyY2VudGFnZSkge1xuICAgIHRoaXMuY29sb3IgPSBjYWxjdWxhdGVBbHBoYSh0aGlzLmNvbG9yLCBNYXRoLmFicyhwZXJjZW50YWdlKSlcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBkYXJrZXIocGVyY2VudGFnZSkge1xuICAgIGNvbnN0IGhzbCA9IGFyZ2JUb0hTTEEodGhpcy5jb2xvcilcbiAgICBoc2wubCA9IGhzbC5sICogKDEgLSBwZXJjZW50YWdlKVxuICAgIHRoaXMuY29sb3IgPSBoc2xhVG9BUkdCKGhzbClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBsaWdodGVyKHBlcmNlbnRhZ2UpIHtcbiAgICBjb25zdCBoc2wgPSBhcmdiVG9IU0xBKHRoaXMuY29sb3IpXG4gICAgaHNsLmwgPSBoc2wubCArICgxIC0gaHNsLmwpICogcGVyY2VudGFnZVxuICAgIHRoaXMuY29sb3IgPSBoc2xhVG9BUkdCKGhzbClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBzYXR1cmF0aW9uKHBlcmNlbnRhZ2UpIHtcbiAgICBjb25zdCBoc2wgPSBhcmdiVG9IU0xBKHRoaXMuY29sb3IpXG4gICAgaHNsLnMgPSBwZXJjZW50YWdlXG4gICAgdGhpcy5jb2xvciA9IGhzbGFUb0FSR0IoaHNsKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIGxpZ2h0bmVzcyhwZXJjZW50YWdlKSB7XG4gICAgY29uc3QgaHNsID0gYXJnYlRvSFNMQSh0aGlzLmNvbG9yKVxuICAgIGhzbC5sID0gcGVyY2VudGFnZVxuICAgIHRoaXMuY29sb3IgPSBoc2xhVG9BUkdCKGhzbClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICBodWUoZGVncmVlcykge1xuICAgIGNvbnN0IGhzbCA9IGFyZ2JUb0hTTEEodGhpcy5jb2xvcilcbiAgICBoc2wuaCA9IGRlZ3JlZXNcbiAgICB0aGlzLmNvbG9yID0gaHNsYVRvQVJHQihoc2wpXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgbWl4KGFyZ2IsIHApIHtcbiAgICB0aGlzLmNvbG9yID0gbWVyZ2VDb2xvcnModGhpcy5jb2xvciwgYXJnYiwgcClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGlzT2JqZWN0ID0gdiA9PiB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgJiYgdiAhPT0gbnVsbFxufVxuXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSB2ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnc3RyaW5nJ1xufVxuXG5leHBvcnQgY29uc3QgZ2V0UmdiYUNvbXBvbmVudHMgPSBhcmdiID0+IHtcbiAgcmV0dXJuIHtcbiAgICByOiAoKGFyZ2IgLyA2NTUzNikgfCAwKSAlIDI1NixcbiAgICBnOiAoKGFyZ2IgLyAyNTYpIHwgMCkgJSAyNTYsXG4gICAgYjogKGFyZ2IgKiAxKSAlIDI1NixcbiAgICBhOiAoYXJnYiAvIDE2Nzc3MjE2KSB8IDAsXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGxpbWl0V2l0aGluUmFuZ2UgPSAobnVtLCBtaW4sIG1heCkgPT4ge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpXG59XG5cbmV4cG9ydCBjb25zdCBtZXJnZUNvbG9ycyA9IChjMSwgYzIsIHApID0+IHtcbiAgbGV0IHIxID0gKChjMSAvIDY1NTM2KSB8IDApICUgMjU2XG4gIGxldCBnMSA9ICgoYzEgLyAyNTYpIHwgMCkgJSAyNTZcbiAgbGV0IGIxID0gYzEgJSAyNTZcbiAgbGV0IGExID0gKGMxIC8gMTY3NzcyMTYpIHwgMFxuICBsZXQgcjIgPSAoKGMyIC8gNjU1MzYpIHwgMCkgJSAyNTZcbiAgbGV0IGcyID0gKChjMiAvIDI1NikgfCAwKSAlIDI1NlxuICBsZXQgYjIgPSBjMiAlIDI1NlxuICBsZXQgYTIgPSAoYzIgLyAxNjc3NzIxNikgfCAwXG4gIGxldCByID0gcjEgKiBwICsgcjIgKiAoMSAtIHApXG4gIGxldCBnID0gZzEgKiBwICsgZzIgKiAoMSAtIHApXG4gIGxldCBiID0gYjEgKiBwICsgYjIgKiAoMSAtIHApXG4gIGxldCBhID0gYTEgKiBwICsgYTIgKiAoMSAtIHApXG4gIHJldHVybiBNYXRoLnJvdW5kKGEpICogMTY3NzcyMTYgKyBNYXRoLnJvdW5kKHIpICogNjU1MzYgKyBNYXRoLnJvdW5kKGcpICogMjU2ICsgTWF0aC5yb3VuZChiKVxufVxuXG5leHBvcnQgY29uc3QgY2FsY3VsYXRlQWxwaGEgPSAoYXJnYiwgcCkgPT4ge1xuICBpZiAocCA+IDEpIHtcbiAgICBwIC89IDEwMFxuICB9IGVsc2UgaWYgKHAgPCAwKSB7XG4gICAgcCA9IDBcbiAgfVxuICBsZXQgciA9ICgoYXJnYiAvIDY1NTM2KSB8IDApICUgMjU2XG4gIGxldCBnID0gKChhcmdiIC8gMjU2KSB8IDApICUgMjU2XG4gIGxldCBiID0gYXJnYiAlIDI1NlxuICByZXR1cm4gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiICsgKChwICogMjU1KSB8IDApICogMTY3NzcyMTZcbn1cblxuZXhwb3J0IGNvbnN0IG1lcmdlQ29sb3JBbHBoYSA9IChjLCBhbHBoYSkgPT4ge1xuICBsZXQgYSA9ICgoKGMgLyAxNjc3NzIxNikgfCAwKSAqIGFscGhhKSB8IDBcbiAgcmV0dXJuIChcbiAgICAoKCgoKGMgPj4gMTYpICYgMHhmZikgKiBhKSAvIDI1NSkgJiAweGZmKSArXG4gICAgKCgoKGMgJiAweGZmMDApICogYSkgLyAyNTUpICYgMHhmZjAwKSArXG4gICAgKCgoKChjICYgMHhmZikgPDwgMTYpICogYSkgLyAyNTUpICYgMHhmZjAwMDApICtcbiAgICAoYSA8PCAyNClcbiAgKVxufVxuXG5jb25zdCBnZXRBcmdiTnVtYmVyID0gcmdiYSA9PiB7XG4gIHJnYmFbMF0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMF0pKVxuICByZ2JhWzFdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzFdKSlcbiAgcmdiYVsyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVsyXSkpXG4gIHJnYmFbM10gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbM10pKVxuICBsZXQgdiA9ICgocmdiYVszXSB8IDApIDw8IDI0KSArICgocmdiYVswXSB8IDApIDw8IDE2KSArICgocmdiYVsxXSB8IDApIDw8IDgpICsgKHJnYmFbMl0gfCAwKVxuICBpZiAodiA8IDApIHtcbiAgICB2ID0gMHhmZmZmZmZmZiArIHYgKyAxXG4gIH1cbiAgcmV0dXJuIHZcbn1cblxuZXhwb3J0IGNvbnN0IGFyZ2JUb0hzdmEgPSBhcmdiID0+IHtcbiAgY29uc3QgY29sb3IgPSBnZXRSZ2JhQ29tcG9uZW50cyhhcmdiKVxuICBsZXQgciA9IGNvbG9yLnIgLyAyNTVcbiAgbGV0IGcgPSBjb2xvci5nIC8gMjU1XG4gIGxldCBiID0gY29sb3IuYiAvIDI1NVxuICBsZXQgaCA9IDBcbiAgbGV0IHMgPSAwXG5cbiAgY29uc3QgY01heCA9IE1hdGgubWF4KHIsIGcsIGIpXG4gIGNvbnN0IGNNaW4gPSBNYXRoLm1pbihyLCBnLCBiKVxuICBjb25zdCBkZWx0YSA9IGNNYXggLSBjTWluXG5cbiAgLy9jYWxjdWxhdGUgaHVlXG4gIGlmIChkZWx0YSA8IDAuMDAwMDEpIHtcbiAgICBoID0gMFxuICB9IGVsc2UgaWYgKGNNYXggIT09IDAgfHwgY01pbiAhPT0gMCkge1xuICAgIGlmIChyID09PSBjTWF4KSB7XG4gICAgICBoID0gKDYwICogKChnIC0gYikgLyBkZWx0YSkgKyAzNjApICUgMzYwXG4gICAgfSBlbHNlIGlmIChnID09PSBjTWF4KSB7XG4gICAgICBoID0gKDYwICogKChiIC0gcikgLyBkZWx0YSkgKyAxMjApICUgMzYwXG4gICAgfSBlbHNlIGlmIChiID09PSBjTWF4KSB7XG4gICAgICBoID0gKDYwICogKChyIC0gZykgLyBkZWx0YSkgKyAyNDApICUgMzYwXG4gICAgfVxuICB9XG5cbiAgLy9jYWxjIHNhdHVyYXRpb25cbiAgaWYgKGNNYXggPiAwKSB7XG4gICAgcyA9IGRlbHRhIC8gY01heFxuICB9XG4gIHJldHVybiB7XG4gICAgaCxcbiAgICBzLFxuICAgIHY6IGNNYXgsXG4gICAgYTogY29sb3IuYSAvIDI1NSxcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgaHN2YVRvQXJnYiA9IGNvbG9yID0+IHtcbiAgY29uc3QgaCA9IGNvbG9yLmhcbiAgY29uc3QgYyA9IGNvbG9yLnYgKiBjb2xvci5zXG4gIGNvbnN0IG0gPSBjb2xvci52IC0gY1xuICBjb25zdCB4ID0gYyAqICgxLjAgLSBNYXRoLmFicygoKGggLyA2MCkgJSAyKSAtIDEpKVxuICBsZXQgciA9IDBcbiAgbGV0IGcgPSAwXG4gIGxldCBiID0gMFxuXG4gIGlmICgwIDw9IGggJiYgaCA8IDYwKSB7XG4gICAgciA9IGNcbiAgICBnID0geFxuICB9IGVsc2UgaWYgKDYwIDw9IGggJiYgaCA8IDEyMCkge1xuICAgIHIgPSB4XG4gICAgZyA9IGNcbiAgfSBlbHNlIGlmICgxMjAgPD0gaCAmJiBoIDwgMTgwKSB7XG4gICAgZyA9IGNcbiAgICBiID0geFxuICB9IGVsc2UgaWYgKDE4MCA8PSBoICYmIGggPCAyNDApIHtcbiAgICBnID0geFxuICAgIGIgPSBjXG4gIH0gZWxzZSBpZiAoMjQwIDw9IGggJiYgaCA8IDMwMCkge1xuICAgIHIgPSB4XG4gICAgYiA9IGNcbiAgfSBlbHNlIGlmICgzMDAgPD0gaCAmJiBoIDwgMzYwKSB7XG4gICAgciA9IGNcbiAgICBiID0geFxuICB9XG5cbiAgciA9IE1hdGgucm91bmQoKHIgKyBtKSAqIDI1NS4wKVxuICBnID0gTWF0aC5yb3VuZCgoZyArIG0pICogMjU1LjApXG4gIGIgPSBNYXRoLnJvdW5kKChiICsgbSkgKiAyNTUuMClcbiAgcmV0dXJuIGdldEFyZ2JOdW1iZXIoW3IsIGcsIGIsIGNvbG9yLmEgKiAyNTVdKVxufVxuXG5leHBvcnQgY29uc3QgYXJnYlRvSFNMQSA9IGFyZ2IgPT4ge1xuICBjb25zdCBjb2wgPSBnZXRSZ2JhQ29tcG9uZW50cyhhcmdiKVxuICBjb25zdCByID0gY29sLnIgLyAyNTVcbiAgY29uc3QgZyA9IGNvbC5nIC8gMjU1XG4gIGNvbnN0IGIgPSBjb2wuYiAvIDI1NVxuXG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpXG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpXG5cbiAgbGV0IGggPSAwXG4gIGxldCBzID0gMFxuICBjb25zdCBsID0gKG1pbiArIG1heCkgKiAwLjVcbiAgaWYgKGwgPiAwKSB7XG4gICAgY29uc3QgbWF4TWluID0gbWF4IC0gbWluXG4gICAgaWYgKG1heE1pbiA+IDApIHtcbiAgICAgIGNvbnN0IHIyID0gKG1heCAtIHIpIC8gbWF4TWluXG4gICAgICBjb25zdCBnMiA9IChtYXggLSBnKSAvIG1heE1pblxuICAgICAgY29uc3QgYjIgPSAobWF4IC0gYikgLyBtYXhNaW5cbiAgICAgIGlmIChsIDwgMC41KSB7XG4gICAgICAgIHMgPSBtYXggKyBtaW5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSAyIC0gbWF4IC0gbWluXG4gICAgICB9XG5cbiAgICAgIGlmIChyID09PSBtYXggJiYgZyA9PT0gbWluKSB7XG4gICAgICAgIGggPSA1LjAgKyBiMlxuICAgICAgfSBlbHNlIGlmIChyID09PSBtYXgpIHtcbiAgICAgICAgaCA9IDEuMCAtIGcyXG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heCAmJiBiID09PSBtaW4pIHtcbiAgICAgICAgaCA9IDEuMCArIHIyXG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgICBoID0gMy4wIC0gYjJcbiAgICAgIH0gZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG4gICAgICAgIGggPSAzLjAgKyBnMlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaCA9IDUuMCAtIHIyXG4gICAgICB9XG4gICAgICBoID0gaCAvIDZcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaDogaCAlIDEsIHMsIGwsIGE6IGNvbC5hIH1cbn1cblxuZXhwb3J0IGNvbnN0IGhzbGFUb0FSR0IgPSBoc2xhID0+IHtcbiAgbGV0IHIgPSAxXG4gIGxldCBnID0gMVxuICBsZXQgYiA9IDFcblxuICBsZXQgaCA9IGhzbGEuaFxuICBsZXQgcyA9IGhzbGEuc1xuICBsZXQgbCA9IGhzbGEubFxuXG4gIGlmIChoIDwgMCkge1xuICAgIGggKz0gMVxuICB9XG4gIGxldCBtYXggPSAwXG4gIGlmIChsIDw9IDAuNSkge1xuICAgIG1heCA9IGwgKiAoMS4wICsgcylcbiAgfSBlbHNlIHtcbiAgICBtYXggPSBsICsgcyAtIGwgKiBzXG4gIH1cblxuICBpZiAobWF4ID4gMCkge1xuICAgIGggKj0gNi4wXG4gICAgY29uc3QgbWluID0gbCArIGwgLSBtYXhcbiAgICBjb25zdCBtaW5NYXggPSAobWF4IC0gbWluKSAvIG1heFxuICAgIGNvbnN0IHNleHRhbnQgPSBNYXRoLmZsb29yKGgpXG4gICAgY29uc3QgZnJhY3QgPSBoIC0gc2V4dGFudFxuICAgIGNvbnN0IG1pbk1heEZyYWN0ID0gbWF4ICogbWluTWF4ICogZnJhY3RcbiAgICBjb25zdCBtaWQxID0gbWluICsgbWluTWF4RnJhY3RcbiAgICBjb25zdCBtaWQyID0gbWF4IC0gbWluTWF4RnJhY3RcblxuICAgIGlmIChzZXh0YW50ID09PSAwKSB7XG4gICAgICByID0gbWF4XG4gICAgICBnID0gbWlkMVxuICAgICAgYiA9IG1pblxuICAgIH1cbiAgICBpZiAoc2V4dGFudCA9PT0gMSkge1xuICAgICAgciA9IG1pZDJcbiAgICAgIGcgPSBtYXhcbiAgICAgIGIgPSBtaW5cbiAgICB9XG4gICAgaWYgKHNleHRhbnQgPT09IDIpIHtcbiAgICAgIHIgPSBtaW5cbiAgICAgIGcgPSBtYXhcbiAgICAgIGIgPSBtaWQxXG4gICAgfVxuICAgIGlmIChzZXh0YW50ID09PSAzKSB7XG4gICAgICByID0gbWluXG4gICAgICBnID0gbWlkMlxuICAgICAgYiA9IG1heFxuICAgIH1cbiAgICBpZiAoc2V4dGFudCA9PT0gNCkge1xuICAgICAgciA9IG1pZDFcbiAgICAgIGcgPSBtaW5cbiAgICAgIGIgPSBtYXhcbiAgICB9XG4gICAgaWYgKHNleHRhbnQgPT09IDUpIHtcbiAgICAgIHIgPSBtYXhcbiAgICAgIGcgPSBtaW5cbiAgICAgIGIgPSBtaWQyXG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRBcmdiTnVtYmVyKFtNYXRoLmZsb29yKHIgKiAyNTUpLCBNYXRoLmZsb29yKGcgKiAyNTUpLCBNYXRoLmZsb29yKGIgKiAyNTUpLCBoc2xhLmFdKVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZwc0luZGljYXRvciBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZWN0OiB0cnVlLFxuICAgICAgY29sb3I6IDB4ZmZmZmZmZmYsXG4gICAgICB0ZXh0dXJlOiBMaWdodG5pbmcuVG9vbHMuZ2V0Um91bmRSZWN0KDgwLCA4MCwgNDApLFxuICAgICAgaDogODAsXG4gICAgICB3OiA4MCxcbiAgICAgIHg6IDEwMCxcbiAgICAgIHk6IDEwMCxcbiAgICAgIG1vdW50OiAxLFxuICAgICAgQmFja2dyb3VuZDoge1xuICAgICAgICB4OiAzLFxuICAgICAgICB5OiAzLFxuICAgICAgICB0ZXh0dXJlOiBMaWdodG5pbmcuVG9vbHMuZ2V0Um91bmRSZWN0KDcyLCA3MiwgMzYpLFxuICAgICAgICBjb2xvcjogMHhmZjAwODAwMCxcbiAgICAgIH0sXG4gICAgICBDb3VudGVyOiB7XG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgaDogaCA9PiBoLFxuICAgICAgICB5OiAxMCxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIGZvbnRTaXplOiAzMixcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIFRleHQ6IHtcbiAgICAgICAgdzogdyA9PiB3LFxuICAgICAgICBoOiBoID0+IGgsXG4gICAgICAgIHk6IDQ4LFxuICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgZm9udFNpemU6IDE1LFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdGV4dDogJ0ZQUycsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIF9zZXR1cCgpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIC4uLntcbiAgICAgICAgbG9nOiBmYWxzZSxcbiAgICAgICAgaW50ZXJ2YWw6IDUwMCxcbiAgICAgICAgdGhyZXNob2xkOiAxLFxuICAgICAgfSxcbiAgICAgIC4uLlNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnc2hvd0ZwcycpLFxuICAgIH1cblxuICAgIHRoaXMuZnBzID0gMFxuICAgIHRoaXMubGFzdEZwcyA9IHRoaXMuZnBzIC0gdGhpcy5jb25maWcudGhyZXNob2xkXG5cbiAgICBjb25zdCBmcHNDYWxjdWxhdG9yID0gKCkgPT4ge1xuICAgICAgdGhpcy5mcHMgPSB+figxIC8gdGhpcy5zdGFnZS5kdClcbiAgICB9XG4gICAgdGhpcy5zdGFnZS5vbignZnJhbWVTdGFydCcsIGZwc0NhbGN1bGF0b3IpXG4gICAgdGhpcy5zdGFnZS5vZmYoJ2ZyYW1lc3RhcnQnLCBmcHNDYWxjdWxhdG9yKVxuICAgIHRoaXMuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLnNob3dGcHMuYmluZCh0aGlzKSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpXG4gIH1cblxuICBfZmlyc3RBY3RpdmUoKSB7XG4gICAgdGhpcy5zaG93RnBzKClcbiAgfVxuXG4gIF9kZXRhY2goKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKVxuICB9XG5cbiAgc2hvd0ZwcygpIHtcbiAgICBpZiAoTWF0aC5hYnModGhpcy5sYXN0RnBzIC0gdGhpcy5mcHMpIDw9IHRoaXMuY29uZmlnLnRocmVzaG9sZCkgcmV0dXJuXG4gICAgdGhpcy5sYXN0RnBzID0gdGhpcy5mcHNcbiAgICAvLyBncmVlblxuICAgIGxldCBiZ0NvbG9yID0gMHhmZjAwODAwMFxuICAgIC8vIG9yYW5nZVxuICAgIGlmICh0aGlzLmZwcyA8PSA0MCAmJiB0aGlzLmZwcyA+IDIwKSBiZ0NvbG9yID0gMHhmZmZmYTUwMFxuICAgIC8vIHJlZFxuICAgIGVsc2UgaWYgKHRoaXMuZnBzIDw9IDIwKSBiZ0NvbG9yID0gMHhmZmZmMDAwMFxuXG4gICAgdGhpcy50YWcoJ0JhY2tncm91bmQnKS5zZXRTbW9vdGgoJ2NvbG9yJywgYmdDb2xvcilcbiAgICB0aGlzLnRhZygnQ291bnRlcicpLnRleHQgPSBgJHt0aGlzLmZwc31gXG5cbiAgICB0aGlzLmNvbmZpZy5sb2cgJiYgTG9nLmluZm8oJ0ZQUycsIHRoaXMuZnBzKVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uL0xpZ2h0bmluZydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NhbGVkSW1hZ2VUZXh0dXJlIGV4dGVuZHMgTGlnaHRuaW5nLnRleHR1cmVzLkltYWdlVGV4dHVyZSB7XG4gIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgc3VwZXIoc3RhZ2UpXG4gICAgdGhpcy5fc2NhbGluZ09wdGlvbnMgPSB1bmRlZmluZWRcbiAgfVxuXG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLnJlc2l6ZU1vZGUgPSB0aGlzLl9zY2FsaW5nT3B0aW9ucyA9IG9wdGlvbnNcbiAgfVxuXG4gIF9nZXRMb29rdXBJZCgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5fc3JjfS0ke3RoaXMuX3NjYWxpbmdPcHRpb25zLnR5cGV9LSR7dGhpcy5fc2NhbGluZ09wdGlvbnMud30tJHt0aGlzLl9zY2FsaW5nT3B0aW9ucy5ofWBcbiAgfVxuXG4gIGdldE5vbkRlZmF1bHRzKCkge1xuICAgIGNvbnN0IG9iaiA9IHN1cGVyLmdldE5vbkRlZmF1bHRzKClcbiAgICBpZiAodGhpcy5fc3JjKSB7XG4gICAgICBvYmouc3JjID0gdGhpcy5fc3JjXG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gJy4uL1V0aWxzJ1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IFNjYWxlZEltYWdlVGV4dHVyZSBmcm9tICcuL1NjYWxlZEltYWdlVGV4dHVyZSdcblxuZXhwb3J0IGRlZmF1bHQgKGltYWdlVXJsLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IGltYWdlU2VydmVyVXJsID0gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdpbWFnZVNlcnZlclVybCcpXG5cbiAgLy8gbWFrZSBhbmQgcmV0dXJuIFNjYWxlZEltYWdlVGV4dHVyZVxuICBjb25zdCBtYWtlID0gb3B0aW9ucyA9PiB7XG4gICAgLy8gbG9jYWwgYXNzZXQsIHdyYXAgaXQgaW4gVXRpbHMuYXNzZXQoKVxuICAgIGlmICghL14oPzpodHRwcz86KT9cXC9cXC8vaS50ZXN0KGltYWdlVXJsKSkge1xuICAgICAgaW1hZ2VVcmwgPSBVdGlscy5hc3NldChpbWFnZVVybClcbiAgICB9XG5cbiAgICAvLyBvbmx5IHBhc3MgdG8gaW1hZ2Ugc2VydmVyIGlmIGltYWdlU2VydmVyVXJsIGlzIGNvbmZpZ3VyZWRcbiAgICAvLyBhbmQgaWYgdGhlIGFzc2V0IGlzbid0IGxvY2FsIHRvIHRoZSBhcHAgKGkuZS4gaGFzIHNhbWUgb3JpZ2luKVxuICAgIGlmIChpbWFnZVNlcnZlclVybCAmJiBpbWFnZVVybC5pbmRleE9mKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pID09PSAtMSkge1xuICAgICAgaW1hZ2VVcmwgPSBVdGlscy5lbnN1cmVVcmxXaXRoUHJvdG9jb2woXG4gICAgICAgIGltYWdlU2VydmVyVXJsICsgJz8nICsgVXRpbHMubWFrZVF1ZXJ5U3RyaW5nKGltYWdlVXJsLCBvcHRpb25zKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaWdodG5pbmcgd2lsbCBoYW5kbGUgdGhlIHJlc2l6aW5nIGFuZCBoYXMgb25seSAyIGZsYXZvdXJzIChjb3ZlciBhbmQgY29udGFpbilcbiAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdjcm9wJykgb3B0aW9ucy50eXBlID0gJ2NvdmVyJ1xuICAgICAgZWxzZSBvcHRpb25zLnR5cGUgPSAnY29udGFpbidcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogU2NhbGVkSW1hZ2VUZXh0dXJlLFxuICAgICAgc3JjOiBpbWFnZVVybCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIGRlZmF1bHRcbiAgY29uc3Qgc2V0T3B0aW9ucyA9IG9wdGlvbnMgPT4ge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICAuLi57XG4gICAgICAgIHR5cGU6ICdjb250YWluJyxcbiAgICAgICAgdzogMCxcbiAgICAgICAgaDogMCxcbiAgICAgIH0sXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH1cbiAgICBjb25zdCBpbWFnZVF1YWxpdHkgPSBNYXRoLm1heChcbiAgICAgIDAuMSxcbiAgICAgIE1hdGgubWluKDEsIChwYXJzZUZsb2F0KFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnaW1hZ2UucXVhbGl0eScpKSB8fCAxMDApIC8gMTAwKVxuICAgIClcblxuICAgIG9wdGlvbnMudyA9IG9wdGlvbnMudyAqIGltYWdlUXVhbGl0eVxuICAgIG9wdGlvbnMuaCA9IG9wdGlvbnMuaCAqIGltYWdlUXVhbGl0eVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICAvLyBpZiBvcHRpb25zIGFyZSBwYXNzZWQsIHJldHVybiBzY2FsZWQgaW1hZ2UgcmlnaHQgYXdheVxuICBpZiAob3B0aW9ucykge1xuICAgIHJldHVybiBtYWtlKHNldE9wdGlvbnMob3B0aW9ucykpXG4gIH1cblxuICAvLyBvdGhlcndpc2UgcmV0dXJuICdjaGFpbmVkJyBmdW5jdGlvbnNcbiAgcmV0dXJuIHtcbiAgICAvLyBvZmZpY2lhbCBhcGlcbiAgICBleGFjdDogKHcsIGgpID0+IG1ha2Uoc2V0T3B0aW9ucyh7IHR5cGU6ICdleGFjdCcsIHcsIGggfSkpLFxuICAgIGxhbmRzY2FwZTogdyA9PiBtYWtlKHNldE9wdGlvbnMoeyB0eXBlOiAnbGFuZHNjYXBlJywgdyB9KSksXG4gICAgcG9ydHJhaXQ6IGggPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ3BvcnRyYWl0JywgaCB9KSksXG4gICAgY292ZXI6ICh3LCBoKSA9PiBtYWtlKHNldE9wdGlvbnMoeyB0eXBlOiAnY292ZXInLCB3LCBoIH0pKSxcbiAgICBjb250YWluOiAodywgaCkgPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ2NvbnRhaW4nLCB3LCBoIH0pKSxcbiAgICBvcmlnaW5hbDogKCkgPT4gbWFrZShzZXRPcHRpb25zKHsgdHlwZTogJ2NvbnRhaW4nIH0pKSxcblxuICAgIC8vIHRvZG86IGFkZCBwb3NpdGlvbmluZyAtIGkuZS4gdG9wLCBib3R0b20sIGNlbnRlciwgbGVmdCBldGMuXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHt9XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcbmltcG9ydCBVdGlscyBmcm9tICcuLi9VdGlscydcblxubGV0IG1ldGEgPSB7fVxubGV0IHRyYW5zbGF0aW9ucyA9IHt9XG5sZXQgbGFuZ3VhZ2UgPSBudWxsXG5sZXQgZGljdGlvbmFyeSA9IG51bGxcblxuZXhwb3J0IGNvbnN0IGluaXRMYW5ndWFnZSA9IChmaWxlLCBsYW5ndWFnZSA9IG51bGwpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZXRjaChmaWxlKVxuICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgLnRoZW4oanNvbiA9PiB7XG4gICAgICAgIHNldFRyYW5zbGF0aW9ucyhqc29uKVxuICAgICAgICAvLyBzZXQgbGFuZ3VhZ2UgKGRpcmVjdGx5IG9yIGluIGEgcHJvbWlzZSlcbiAgICAgICAgdHlwZW9mIGxhbmd1YWdlID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gbGFuZ3VhZ2UgJiYgdHlwZW9mIGxhbmd1YWdlLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IGxhbmd1YWdlXG4gICAgICAgICAgICAgIC50aGVuKGxhbmcgPT5cbiAgICAgICAgICAgICAgICBzZXRMYW5ndWFnZShsYW5nKVxuICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgIExvZy5lcnJvcihlKVxuICAgICAgICAgICAgICAgIHJlamVjdChlKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIDogc2V0TGFuZ3VhZ2UobGFuZ3VhZ2UpXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAnTGFuZ3VhZ2UgZmlsZSAnICsgZmlsZSArICcgbm90IGZvdW5kJ1xuICAgICAgICBMb2cuZXJyb3IoZXJyb3IpXG4gICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgIH0pXG4gIH0pXG59XG5cbmNvbnN0IHNldFRyYW5zbGF0aW9ucyA9IG9iaiA9PiB7XG4gIGlmICgnbWV0YScgaW4gb2JqKSB7XG4gICAgbWV0YSA9IHsgLi4ub2JqLm1ldGEgfVxuICAgIGRlbGV0ZSBvYmoubWV0YVxuICB9XG4gIHRyYW5zbGF0aW9ucyA9IG9ialxufVxuXG5jb25zdCBnZXRMYW5ndWFnZSA9ICgpID0+IHtcbiAgcmV0dXJuIGxhbmd1YWdlXG59XG5cbmNvbnN0IHNldExhbmd1YWdlID0gbG5nID0+IHtcbiAgbGFuZ3VhZ2UgPSBudWxsXG4gIGRpY3Rpb25hcnkgPSBudWxsXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAobG5nIGluIHRyYW5zbGF0aW9ucykge1xuICAgICAgbGFuZ3VhZ2UgPSBsbmdcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCdtYXAnIGluIG1ldGEgJiYgbG5nIGluIG1ldGEubWFwICYmIG1ldGEubWFwW2xuZ10gaW4gdHJhbnNsYXRpb25zKSB7XG4gICAgICAgIGxhbmd1YWdlID0gbWV0YS5tYXBbbG5nXVxuICAgICAgfSBlbHNlIGlmICgnZGVmYXVsdCcgaW4gbWV0YSAmJiBtZXRhLmRlZmF1bHQgaW4gdHJhbnNsYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID1cbiAgICAgICAgICAnVHJhbnNsYXRpb25zIGZvciBMYW5ndWFnZSAnICtcbiAgICAgICAgICBsYW5ndWFnZSArXG4gICAgICAgICAgJyBub3QgZm91bmQuIFVzaW5nIGRlZmF1bHQgbGFuZ3VhZ2UgJyArXG4gICAgICAgICAgbWV0YS5kZWZhdWx0XG4gICAgICAgIExvZy53YXJuKGVycm9yKVxuICAgICAgICBsYW5ndWFnZSA9IG1ldGEuZGVmYXVsdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSAnVHJhbnNsYXRpb25zIGZvciBMYW5ndWFnZSAnICsgbGFuZ3VhZ2UgKyAnIG5vdCBmb3VuZC4nXG4gICAgICAgIExvZy5lcnJvcihlcnJvcilcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgTG9nLmluZm8oJ1NldHRpbmcgbGFuZ3VhZ2UgdG8nLCBsYW5ndWFnZSlcblxuICAgICAgY29uc3QgdHJhbnNsYXRpb25zT2JqID0gdHJhbnNsYXRpb25zW2xhbmd1YWdlXVxuICAgICAgaWYgKHR5cGVvZiB0cmFuc2xhdGlvbnNPYmogPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGRpY3Rpb25hcnkgPSB0cmFuc2xhdGlvbnNPYmpcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc2xhdGlvbnNPYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IFV0aWxzLmFzc2V0KHRyYW5zbGF0aW9uc09iailcblxuICAgICAgICBmZXRjaCh1cmwpXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKVxuICAgICAgICAgIC50aGVuKGpzb24gPT4ge1xuICAgICAgICAgICAgLy8gc2F2ZSB0aGUgdHJhbnNsYXRpb25zIGZvciB0aGlzIGxhbmd1YWdlICh0byBwcmV2ZW50IGxvYWRpbmcgdHdpY2UpXG4gICAgICAgICAgICB0cmFuc2xhdGlvbnNbbGFuZ3VhZ2VdID0ganNvblxuICAgICAgICAgICAgZGljdGlvbmFyeSA9IGpzb25cbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSAnRXJyb3Igd2hpbGUgZmV0Y2hpbmcgJyArIHVybFxuICAgICAgICAgICAgTG9nLmVycm9yKGVycm9yLCBlKVxuICAgICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHRyYW5zbGF0ZShrZXkpIHtcbiAgICBsZXQgcmVwbGFjZW1lbnRzID0gWy4uLmFyZ3VtZW50c10uc2xpY2UoMSlcblxuICAgIC8vIG5vIHJlcGxhY2VtZW50cyBzbyBqdXN0IHRyYW5zbGF0ZWQgc3RyaW5nXG4gICAgaWYgKHJlcGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAoZGljdGlvbmFyeSAmJiBkaWN0aW9uYXJ5W2tleV0pIHx8IGtleVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVwbGFjZW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgcmVwbGFjZW1lbnRzWzBdID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXBsYWNlbWVudHMgPSByZXBsYWNlbWVudHMucG9wKClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKFxuICAgICAgICAvLyBtYXBzIGFycmF5IGlucHV0IHRvIGFuIG9iamVjdCB7MDogJ2l0ZW0xJywgMTogJ2l0ZW0yJ31cbiAgICAgICAgQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudHMpID8gT2JqZWN0LmFzc2lnbih7fSwgcmVwbGFjZW1lbnRzKSA6IHJlcGxhY2VtZW50c1xuICAgICAgKS5yZWR1Y2UoKHRleHQsIHJlcGxhY2VtZW50S2V5KSA9PiB7XG4gICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoXG4gICAgICAgICAgbmV3IFJlZ0V4cCgne1xcXFxzPycgKyByZXBsYWNlbWVudEtleSArICdcXFxccz99JywgJ2cnKSxcbiAgICAgICAgICByZXBsYWNlbWVudHNbcmVwbGFjZW1lbnRLZXldXG4gICAgICAgIClcbiAgICAgIH0sIChkaWN0aW9uYXJ5ICYmIGRpY3Rpb25hcnlba2V5XSkgfHwga2V5KVxuICAgIH1cbiAgfSxcblxuICB0cmFuc2xhdGlvbnMob2JqKSB7XG4gICAgc2V0VHJhbnNsYXRpb25zKG9iailcbiAgfSxcblxuICBzZXQobGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4gc2V0TGFuZ3VhZ2UobGFuZ3VhZ2UpXG4gIH0sXG5cbiAgZ2V0KCkge1xuICAgIHJldHVybiBnZXRMYW5ndWFnZSgpXG4gIH0sXG5cbiAgYXZhaWxhYmxlKCkge1xuICAgIGNvbnN0IGxhbmd1YWdlS2V5cyA9IE9iamVjdC5rZXlzKHRyYW5zbGF0aW9ucylcbiAgICByZXR1cm4gbGFuZ3VhZ2VLZXlzLm1hcChrZXkgPT4gKHsgY29kZToga2V5LCBuYW1lOiAobWV0YS5uYW1lcyAmJiBtZXRhLm5hbWVzW2tleV0pIHx8IGtleSB9KSlcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGluaXRVdGlscyB9IGZyb20gJy4uL1V0aWxzJ1xuaW1wb3J0IHsgaW5pdFByb2ZpbGUgfSBmcm9tICcuLi9Qcm9maWxlJ1xuaW1wb3J0IHsgaW5pdE1ldHJpY3MgfSBmcm9tICcuLi9NZXRyaWNzJ1xuaW1wb3J0IHsgaW5pdFNldHRpbmdzIH0gZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgeyBpbml0TWVkaWFQbGF5ZXIgfSBmcm9tICcuLi9NZWRpYVBsYXllcidcbmltcG9ydCB7IGluaXRWaWRlb1BsYXllciB9IGZyb20gJy4uL1ZpZGVvUGxheWVyJ1xuaW1wb3J0IHsgaW5pdFN0b3JhZ2UgfSBmcm9tICcuLi9TdG9yYWdlJ1xuaW1wb3J0IHsgaW5pdEFkcyB9IGZyb20gJy4uL0FkcydcbmltcG9ydCB7IGluaXRSb3V0ZXIgfSBmcm9tICcuLi9Sb3V0ZXInXG5pbXBvcnQgeyBpbml0VFYgfSBmcm9tICcuLi9UVidcbmltcG9ydCB7IGluaXRQdXJjaGFzZSB9IGZyb20gJy4uL1B1cmNoYXNlJ1xuaW1wb3J0IHsgaW5pdFBpbiB9IGZyb20gJy4uL1BpbidcbmltcG9ydCB7IGluaXRNZXRhZGF0YSB9IGZyb20gJy4uL01ldGFkYXRhJ1xuaW1wb3J0IEFwcGxpY2F0aW9uIGZyb20gJy4uL0FwcGxpY2F0aW9uJ1xuXG5leHBvcnQgbGV0IEFwcGxpY2F0aW9uSW5zdGFuY2VcblxuZXhwb3J0IGRlZmF1bHQgKEFwcCwgYXBwU2V0dGluZ3MsIHBsYXRmb3JtU2V0dGluZ3MsIGFwcERhdGEpID0+IHtcbiAgaW5pdFNldHRpbmdzKGFwcFNldHRpbmdzLCBwbGF0Zm9ybVNldHRpbmdzKVxuICBpbml0TWV0YWRhdGEoYXBwU2V0dGluZ3MpXG5cbiAgaW5pdFV0aWxzKHBsYXRmb3JtU2V0dGluZ3MpXG4gIGluaXRTdG9yYWdlKClcbiAgLy8gSW5pdGlhbGl6ZSBwbHVnaW5zXG4gIGlmIChwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMpIHtcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucHJvZmlsZSAmJiBpbml0UHJvZmlsZShwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucHJvZmlsZSlcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWV0cmljcyAmJiBpbml0TWV0cmljcyhwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWV0cmljcylcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWVkaWFQbGF5ZXIgJiYgaW5pdE1lZGlhUGxheWVyKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5tZWRpYVBsYXllcilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMubWVkaWFQbGF5ZXIgJiYgaW5pdFZpZGVvUGxheWVyKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5tZWRpYVBsYXllcilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMuYWRzICYmIGluaXRBZHMocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLmFkcylcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucm91dGVyICYmIGluaXRSb3V0ZXIocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnJvdXRlcilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMudHYgJiYgaW5pdFRWKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy50dilcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucHVyY2hhc2UgJiYgaW5pdFB1cmNoYXNlKHBsYXRmb3JtU2V0dGluZ3MucGx1Z2lucy5wdXJjaGFzZSlcbiAgICBwbGF0Zm9ybVNldHRpbmdzLnBsdWdpbnMucGluICYmIGluaXRQaW4ocGxhdGZvcm1TZXR0aW5ncy5wbHVnaW5zLnBpbilcbiAgfVxuXG4gIGNvbnN0IGFwcCA9IEFwcGxpY2F0aW9uKEFwcCwgYXBwRGF0YSwgcGxhdGZvcm1TZXR0aW5ncylcbiAgQXBwbGljYXRpb25JbnN0YW5jZSA9IG5ldyBhcHAoYXBwU2V0dGluZ3MpXG4gIHJldHVybiBBcHBsaWNhdGlvbkluc3RhbmNlXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJ0BsaWdodG5pbmdqcy9jb3JlJ1xuZXhwb3J0IGRlZmF1bHQgTGlnaHRuaW5nXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFNpbXBsZSBtb2R1bGUgZm9yIGxvY2FsaXphdGlvbiBvZiBzdHJpbmdzLlxuICpcbiAqIEhvdyB0byB1c2U6XG4gKiAxLiBDcmVhdGUgbG9jYWxpemF0aW9uIGZpbGUgd2l0aCBmb2xsb3dpbmcgSlNPTiBmb3JtYXQ6XG4gKiB7XG4gKiAgIFwiZW5cIiA6e1xuICogICAgIFwiaG93XCI6IFwiSG93IGRvIHlvdSB3YW50IHlvdXIgZWdnIHRvZGF5P1wiLFxuICogICAgIFwiYm9pbGVkRWdnXCI6IFwiQm9pbGVkIGVnZ1wiLFxuICogICAgIFwic29mdEJvaWxlZEVnZ1wiOiBcIlNvZnQtYm9pbGVkIGVnZ1wiLFxuICogICAgIFwiY2hvaWNlXCI6IFwiSG93IHRvIGNob29zZSB0aGUgZWdnXCIsXG4gKiAgICAgXCJidXlRdWVzdGlvblwiOiBcIkknZCBsaWtlIHRvIGJ1eSB7MH0gZWdncywgezF9IGRvbGxhcnMgZWFjaC5cIlxuICogICB9LFxuICpcbiAqICAgXCJpdFwiOiB7XG4gKiAgICAgXCJob3dcIjogXCJDb21lIHZ1b2kgaWwgdHVvIHVvdm8gb2dnaT9cIixcbiAqICAgICBcImJvaWxlZEVnZ1wiOiBcIlVvdm8gc29kb1wiLFxuICogICAgIFwic29mdEJvaWxlZEVnZ1wiOiBcIlVvdm8gYWxsYSBjb3F1ZVwiLFxuICogICAgIFwiY2hvaWNlXCI6IFwiQ29tZSBzY2VnbGllcmUgbCd1b3ZvXCIsXG4gKiAgICAgXCJidXlRdWVzdGlvblwiOiBcIk1pIHBpYWNlcmViYmUgY29tcHJhcmUgezB9IHVvdmEsIHsxfSBkb2xsYXJpIGNpYXNjdW5hLlwiXG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAyLiBVc2UgTG9jYWxlJ3MgbW9kdWxlIGxvYWQgbWV0aG9kLCBzcGVjaWZ5aW5nIHBhdGggdG8geW91ciBsb2NhbGl6YXRpb24gZmlsZSBhbmQgc2V0IGNob3NlbiBsYW5ndWFnZSwgZS5nLjpcbiAqICAgID4gTG9jYWxlLmxvYWQoJ3N0YXRpYy9sb2NhbGUvbG9jYWxlLmpzb24nKTtcbiAqICAgID4gTG9jYWxlLnNldExhbmd1YWdlKCdlbicpO1xuICpcbiAqIDMuIFVzZSBsb2NhbGl6YXRpb24gc3RyaW5nczpcbiAqICAgID4gY29uc29sZS5sb2coTG9jYWxlLnRyLmhvdyk7XG4gKiAgICBIb3cgZG8geW91IHdhbnQgeW91ciBlZ2cgdG9kYXk/XG4gKiAgICA+IGNvbnNvbGUubG9nKExvY2FsZS50ci5ib2lsZWRFZ2cpO1xuICogICAgQm9pbGVkIGVnZ1xuICpcbiAqIDQuIFN0cmluZyBmb3JtYXR0aW5nXG4gKiAgICA+IGNvbnNvbGUubG9nKExvY2FsZS50ci5idXlRdWVzdGlvbi5mb3JtYXQoMTAsIDAuNSkpO1xuICogICAgSSdkIGxpa2UgdG8gYnV5IDEwIGVnZ3MsIDAuNSBkb2xsYXJzIGVhY2guXG4gKi9cblxuaW1wb3J0IExvZyBmcm9tICcuLi9Mb2cnXG5cbmxldCB3YXJuZWQgPSBmYWxzZVxuY29uc3QgZGVwcmVjYXRlZCA9IChmb3JjZSA9IGZhbHNlKSA9PiB7XG4gIGlmIChmb3JjZSA9PT0gdHJ1ZSB8fCB3YXJuZWQgPT09IGZhbHNlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgW1xuICAgICAgICBcIlRoZSAnTG9jYWxlJy1wbHVnaW4gaW4gdGhlIExpZ2h0bmluZy1TREsgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlcy5cIixcbiAgICAgICAgXCJQbGVhc2UgY29uc2lkZXIgdXNpbmcgdGhlIG5ldyAnTGFuZ3VhZ2UnLXBsdWdpbiBpbnN0ZWFkLlwiLFxuICAgICAgICAnaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9sYW5ndWFnZScsXG4gICAgICBdLmpvaW4oJ1xcblxcbicpXG4gICAgKVxuICB9XG4gIHdhcm5lZCA9IHRydWVcbn1cbmNsYXNzIExvY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX19lbmFibGVkID0gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0cmFuc2xhdGlvbiBvYmplY3QgZnJvbSBleHRlcm5hbCBqc29uIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdG8gcmVzb3VyY2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBhc3luYyBsb2FkKHBhdGgpIHtcbiAgICBpZiAoIXRoaXMuX19lbmFibGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCBmZXRjaChwYXRoKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3AgPT4ge1xuICAgICAgICB0aGlzLmxvYWRGcm9tT2JqZWN0KHJlc3ApXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgbGFuZ3VhZ2UgdXNlZCBieSBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsYW5nXG4gICAqL1xuICBzZXRMYW5ndWFnZShsYW5nKSB7XG4gICAgZGVwcmVjYXRlZCgpXG4gICAgdGhpcy5fX2VuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5sYW5ndWFnZSA9IGxhbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHJlZmVyZW5jZSB0byB0cmFuc2xhdGlvbiBvYmplY3QgZm9yIGN1cnJlbnQgbGFuZ3VhZ2UuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldCB0cigpIHtcbiAgICBkZXByZWNhdGVkKHRydWUpXG4gICAgcmV0dXJuIHRoaXMuX190ck9ialt0aGlzLmxhbmd1YWdlXVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWRzIHRyYW5zbGF0aW9uIG9iamVjdCBmcm9tIGV4aXN0aW5nIG9iamVjdCAoYmluZHMgZXhpc3Rpbmcgb2JqZWN0KS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRyT2JqXG4gICAqL1xuICBsb2FkRnJvbU9iamVjdCh0ck9iaikge1xuICAgIGRlcHJlY2F0ZWQoKVxuICAgIGNvbnN0IGZhbGxiYWNrTGFuZ3VhZ2UgPSAnZW4nXG4gICAgaWYgKE9iamVjdC5rZXlzKHRyT2JqKS5pbmRleE9mKHRoaXMubGFuZ3VhZ2UpID09PSAtMSkge1xuICAgICAgTG9nLndhcm4oJ05vIHRyYW5zbGF0aW9ucyBmb3VuZCBmb3I6ICcgKyB0aGlzLmxhbmd1YWdlKVxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRyT2JqKS5pbmRleE9mKGZhbGxiYWNrTGFuZ3VhZ2UpID4gLTEpIHtcbiAgICAgICAgTG9nLndhcm4oJ1VzaW5nIGZhbGxiYWNrIGxhbmd1YWdlOiAnICsgZmFsbGJhY2tMYW5ndWFnZSlcbiAgICAgICAgdGhpcy5sYW5ndWFnZSA9IGZhbGxiYWNrTGFuZ3VhZ2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gJ05vIHRyYW5zbGF0aW9ucyBmb3VuZCBmb3IgZmFsbGJhY2sgbGFuZ3VhZ2U6ICcgKyBmYWxsYmFja0xhbmd1YWdlXG4gICAgICAgIExvZy5lcnJvcihlcnJvcilcbiAgICAgICAgdGhyb3cgRXJyb3IoZXJyb3IpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fX3RyT2JqID0gdHJPYmpcbiAgICBmb3IgKGNvbnN0IGxhbmcgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9fdHJPYmopKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0ciBvZiBPYmplY3Qua2V5cyhsYW5nKSkge1xuICAgICAgICBsYW5nW3N0cl0gPSBuZXcgTG9jYWxpemVkU3RyaW5nKGxhbmdbc3RyXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRlbmRlZCBzdHJpbmcgY2xhc3MgdXNlZCBmb3IgbG9jYWxpemF0aW9uLlxuICovXG5jbGFzcyBMb2NhbGl6ZWRTdHJpbmcgZXh0ZW5kcyBTdHJpbmcge1xuICAvKipcbiAgICogUmV0dXJucyBmb3JtYXR0ZWQgTG9jYWxpemVkU3RyaW5nLlxuICAgKiBSZXBsYWNlcyBlYWNoIHBsYWNlaG9sZGVyIHZhbHVlIChlLmcuIHswfSwgezF9KSB3aXRoIGNvcnJlc3BvbmRpbmcgYXJndW1lbnQuXG4gICAqXG4gICAqIEUuZy46XG4gICAqID4gbmV3IExvY2FsaXplZFN0cmluZygnezB9IGFuZCB7MX0gYW5kIHswfScpLmZvcm1hdCgnQScsICdCJyk7XG4gICAqIEEgYW5kIEIgYW5kIEFcbiAgICpcbiAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzIExpc3Qgb2YgYXJndW1lbnRzIGZvciBwbGFjZWhvbGRlcnMuXG4gICAqL1xuICBmb3JtYXQoLi4uYXJncykge1xuICAgIGNvbnN0IHN1YiA9IGFyZ3MucmVkdWNlKChzdHJpbmcsIGFyZywgaW5kZXgpID0+IHN0cmluZy5zcGxpdChgeyR7aW5kZXh9fWApLmpvaW4oYXJnKSwgdGhpcylcbiAgICByZXR1cm4gbmV3IExvY2FsaXplZFN0cmluZyhzdWIpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IExvY2FsZSgpXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5cbmNvbnN0IHByZXBMb2cgPSAodHlwZSwgYXJncykgPT4ge1xuICBjb25zdCBjb2xvcnMgPSB7XG4gICAgSW5mbzogJ2dyZWVuJyxcbiAgICBEZWJ1ZzogJ2dyYXknLFxuICAgIFdhcm46ICdvcmFuZ2UnLFxuICAgIEVycm9yOiAncmVkJyxcbiAgfVxuXG4gIGFyZ3MgPSBBcnJheS5mcm9tKGFyZ3MpXG4gIHJldHVybiBbXG4gICAgJyVjJyArIChhcmdzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnID8gYXJncy5zaGlmdCgpIDogdHlwZSksXG4gICAgJ2JhY2tncm91bmQtY29sb3I6ICcgKyBjb2xvcnNbdHlwZV0gKyAnOyBjb2xvcjogd2hpdGU7IHBhZGRpbmc6IDJweCA0cHg7IGJvcmRlci1yYWRpdXM6IDJweCcsXG4gICAgYXJncyxcbiAgXVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGluZm8oKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdJbmZvJywgYXJndW1lbnRzKSlcbiAgfSxcbiAgZGVidWcoKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLmRlYnVnLmFwcGx5KGNvbnNvbGUsIHByZXBMb2coJ0RlYnVnJywgYXJndW1lbnRzKSlcbiAgfSxcbiAgZXJyb3IoKSB7XG4gICAgU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdsb2cnKSAmJiBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIHByZXBMb2coJ0Vycm9yJywgYXJndW1lbnRzKSlcbiAgfSxcbiAgd2FybigpIHtcbiAgICBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ2xvZycpICYmIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBwcmVwTG9nKCdXYXJuJywgYXJndW1lbnRzKSlcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuaW1wb3J0IE1ldHJpY3MgZnJvbSAnLi4vTWV0cmljcydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuXG5jb25zdCBldmVudHMgPSBbXG4gICd0aW1ldXBkYXRlJyxcbiAgJ2Vycm9yJyxcbiAgJ2VuZGVkJyxcbiAgJ2xvYWRlZGRhdGEnLFxuICAnY2FucGxheScsXG4gICdwbGF5JyxcbiAgJ3BsYXlpbmcnLFxuICAncGF1c2UnLFxuICAnbG9hZHN0YXJ0JyxcbiAgJ3NlZWtpbmcnLFxuICAnc2Vla2VkJyxcbiAgJ2VuY3J5cHRlZCcsXG5dXG5cbmxldCBtZWRpYVVybCA9IHVybCA9PiB1cmxcblxuZXhwb3J0IGNvbnN0IGluaXRNZWRpYVBsYXllciA9IGNvbmZpZyA9PiB7XG4gIGlmIChjb25maWcubWVkaWFVcmwpIHtcbiAgICBtZWRpYVVybCA9IGNvbmZpZy5tZWRpYVVybFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lZGlhcGxheWVyIGV4dGVuZHMgTGlnaHRuaW5nLkNvbXBvbmVudCB7XG4gIF9jb25zdHJ1Y3QoKSB7XG4gICAgdGhpcy5fc2tpcFJlbmRlclRvVGV4dHVyZSA9IGZhbHNlXG4gICAgdGhpcy5fbWV0cmljcyA9IG51bGxcbiAgICB0aGlzLl90ZXh0dXJlTW9kZSA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAndGV4dHVyZU1vZGUnKSB8fCBmYWxzZVxuICAgIExvZy5pbmZvKCdUZXh0dXJlIG1vZGU6ICcgKyB0aGlzLl90ZXh0dXJlTW9kZSlcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBbXG4gICAgICAgIFwiVGhlICdNZWRpYVBsYXllcictcGx1Z2luIGluIHRoZSBMaWdodG5pbmctU0RLIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZXMuXCIsXG4gICAgICAgIFwiUGxlYXNlIGNvbnNpZGVyIHVzaW5nIHRoZSBuZXcgJ1ZpZGVvUGxheWVyJy1wbHVnaW4gaW5zdGVhZC5cIixcbiAgICAgICAgJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvdmlkZW9wbGF5ZXInLFxuICAgICAgXS5qb2luKCdcXG5cXG4nKVxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFZpZGVvOiB7XG4gICAgICAgIFZpZGVvV3JhcDoge1xuICAgICAgICAgIFZpZGVvVGV4dHVyZToge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwaXZvdDogMC41LFxuICAgICAgICAgICAgdGV4dHVyZTogeyB0eXBlOiBMaWdodG5pbmcudGV4dHVyZXMuU3RhdGljVGV4dHVyZSwgb3B0aW9uczoge30gfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBzZXQgc2tpcFJlbmRlclRvVGV4dHVyZSh2KSB7XG4gICAgdGhpcy5fc2tpcFJlbmRlclRvVGV4dHVyZSA9IHZcbiAgfVxuXG4gIGdldCB0ZXh0dXJlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGV4dHVyZU1vZGVcbiAgfVxuXG4gIGdldCB2aWRlb1ZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKCdWaWRlbycpXG4gIH1cblxuICBfaW5pdCgpIHtcbiAgICAvL3JlLXVzZSB2aWRlb3RhZyBpZiBhbHJlYWR5IHRoZXJlXG4gICAgY29uc3QgdmlkZW9FbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndmlkZW8nKVxuICAgIGlmICh2aWRlb0VscyAmJiB2aWRlb0Vscy5sZW5ndGggPiAwKSB0aGlzLnZpZGVvRWwgPSB2aWRlb0Vsc1swXVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy52aWRlb0VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKVxuICAgICAgdGhpcy52aWRlb0VsLnNldEF0dHJpYnV0ZSgnaWQnLCAndmlkZW8tcGxheWVyJylcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS56SW5kZXggPSAnMSdcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICB0aGlzLnZpZGVvRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxMDAlJylcbiAgICAgIHRoaXMudmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxMDAlJylcblxuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSB0aGlzLnRleHR1cmVNb2RlID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy52aWRlb0VsKVxuICAgIH1cbiAgICBpZiAodGhpcy50ZXh0dXJlTW9kZSAmJiAhdGhpcy5fc2tpcFJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgdGhpcy5fY3JlYXRlVmlkZW9UZXh0dXJlKClcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBbXVxuICB9XG5cbiAgX3JlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBlID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX21ldHJpY3MgJiYgdGhpcy5fbWV0cmljc1tldmVudF0gJiYgdHlwZW9mIHRoaXMuX21ldHJpY3NbZXZlbnRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fbWV0cmljc1tldmVudF0oeyBjdXJyZW50VGltZTogdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lIH0pXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maXJlKGV2ZW50LCB7IHZpZGVvRWxlbWVudDogdGhpcy52aWRlb0VsLCBldmVudDogZSB9KVxuICAgICAgfVxuICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnB1c2goaGFuZGxlcilcbiAgICAgIHRoaXMudmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKVxuICAgIH0pXG4gIH1cblxuICBfZGVyZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBMb2cuaW5mbygnRGVyZWdpc3RlcmluZyBldmVudCBsaXN0ZW5lcnMgTWVkaWFQbGF5ZXInKVxuICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCwgaW5kZXgpID0+IHtcbiAgICAgIHRoaXMudmlkZW9FbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmV2ZW50SGFuZGxlcnNbaW5kZXhdKVxuICAgIH0pXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzID0gW11cbiAgfVxuXG4gIF9hdHRhY2goKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKVxuICB9XG5cbiAgX2RldGFjaCgpIHtcbiAgICB0aGlzLl9kZXJlZ2lzdGVyTGlzdGVuZXJzKClcbiAgICB0aGlzLmNsb3NlKClcbiAgfVxuXG4gIF9jcmVhdGVWaWRlb1RleHR1cmUoKSB7XG4gICAgY29uc3Qgc3RhZ2UgPSB0aGlzLnN0YWdlXG5cbiAgICBjb25zdCBnbCA9IHN0YWdlLmdsXG4gICAgY29uc3QgZ2xUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpXG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUilcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpXG5cbiAgICB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zID0geyBzb3VyY2U6IGdsVGV4dHVyZSwgdzogdGhpcy52aWRlb0VsLndpZHRoLCBoOiB0aGlzLnZpZGVvRWwuaGVpZ2h0IH1cbiAgfVxuXG4gIF9zdGFydFVwZGF0aW5nVmlkZW9UZXh0dXJlKCkge1xuICAgIGlmICh0aGlzLnRleHR1cmVNb2RlICYmICF0aGlzLl9za2lwUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICBjb25zdCBzdGFnZSA9IHRoaXMuc3RhZ2VcbiAgICAgIGlmICghdGhpcy5fdXBkYXRlVmlkZW9UZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UgJiYgdGhpcy52aWRlb0VsLnZpZGVvV2lkdGggJiYgdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gc3RhZ2UuZ2xcblxuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuXG4gICAgICAgICAgICAvLyBXaGVuIEJSMl9QQUNLQUdFX0dTVDFfUExVR0lOU19CQURfUExVR0lOX0RFQlVHVVRJTFMgaXMgbm90IHNldCBpbiBXUEUsIHdlYmtpdERlY29kZWRGcmFtZUNvdW50IHdpbGwgbm90IGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAgIC8vIFdlJ2xsIGZhbGxiYWNrIHRvIGZpeGVkIDMwZnBzIGluIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIGNvbnN0IGZyYW1lQ291bnQgPSB0aGlzLnZpZGVvRWwud2Via2l0RGVjb2RlZEZyYW1lQ291bnRcblxuICAgICAgICAgICAgY29uc3QgbXVzdFVwZGF0ZSA9IGZyYW1lQ291bnRcbiAgICAgICAgICAgICAgPyB0aGlzLl9sYXN0RnJhbWUgIT09IGZyYW1lQ291bnRcbiAgICAgICAgICAgICAgOiB0aGlzLl9sYXN0VGltZSA8IGN1cnJlbnRUaW1lIC0gMzBcblxuICAgICAgICAgICAgaWYgKG11c3RVcGRhdGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBmcmFtZUNvdW50XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UpXG4gICAgICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSlcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudmlkZW9FbClcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLnZpZGVvRWwud2Via2l0RGVjb2RlZEZyYW1lQ291bnRcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcudmlzaWJsZSA9IHRydWVcblxuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMudyA9IHRoaXMudmlkZW9FbC52aWRlb1dpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5oID0gdGhpcy52aWRlb0VsLnZpZGVvSGVpZ2h0XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRBc3BlY3RSYXRpbyA9IHRoaXMudmlkZW9UZXh0dXJlVmlldy53IC8gdGhpcy52aWRlb1RleHR1cmVWaWV3LmhcbiAgICAgICAgICAgICAgICBjb25zdCByZWFsQXNwZWN0UmF0aW8gPSB0aGlzLnZpZGVvRWwudmlkZW9XaWR0aCAvIHRoaXMudmlkZW9FbC52aWRlb0hlaWdodFxuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZEFzcGVjdFJhdGlvID4gcmVhbEFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcuc2NhbGVYID0gcmVhbEFzcGVjdFJhdGlvIC8gZXhwZWN0ZWRBc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmVWaWV3LnNjYWxlWSA9IDFcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmVWaWV3LnNjYWxlWSA9IGV4cGVjdGVkQXNwZWN0UmF0aW8gLyByZWFsQXNwZWN0UmF0aW9cbiAgICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy5zY2FsZVggPSAxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgTG9nLmVycm9yKCd0ZXhJbWFnZTJkIHZpZGVvJywgZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wVXBkYXRpbmdWaWRlb1RleHR1cmUoKVxuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy52aXNpYmxlID0gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZS5zb3VyY2UuZm9yY2VSZW5kZXJVcGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl91cGRhdGluZ1ZpZGVvVGV4dHVyZSkge1xuICAgICAgICBzdGFnZS5vbignZnJhbWVTdGFydCcsIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSlcbiAgICAgICAgdGhpcy5fdXBkYXRpbmdWaWRlb1RleHR1cmUgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3N0b3BVcGRhdGluZ1ZpZGVvVGV4dHVyZSgpIHtcbiAgICBpZiAodGhpcy50ZXh0dXJlTW9kZSkge1xuICAgICAgY29uc3Qgc3RhZ2UgPSB0aGlzLnN0YWdlXG4gICAgICBzdGFnZS5yZW1vdmVMaXN0ZW5lcignZnJhbWVTdGFydCcsIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSlcbiAgICAgIHRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlID0gZmFsc2VcbiAgICAgIHRoaXMudmlkZW9UZXh0dXJlVmlldy52aXNpYmxlID0gZmFsc2VcblxuICAgICAgaWYgKHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlKSB7XG4gICAgICAgIGNvbnN0IGdsID0gc3RhZ2UuZ2xcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UpXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSlcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGVTZXR0aW5ncyhzZXR0aW5ncyA9IHt9KSB7XG4gICAgLy8gVGhlIENvbXBvbmVudCB0aGF0ICdjb25zdW1lcycgdGhlIG1lZGlhIHBsYXllci5cbiAgICB0aGlzLl9jb25zdW1lciA9IHNldHRpbmdzLmNvbnN1bWVyXG5cbiAgICBpZiAodGhpcy5fY29uc3VtZXIgJiYgdGhpcy5fY29uc3VtZXIuZ2V0TWVkaWFwbGF5ZXJTZXR0aW5ncykge1xuICAgICAgLy8gQWxsb3cgY29uc3VtZXIgdG8gYWRkIHNldHRpbmdzLlxuICAgICAgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHNldHRpbmdzLCB0aGlzLl9jb25zdW1lci5nZXRNZWRpYXBsYXllclNldHRpbmdzKCkpXG4gICAgfVxuXG4gICAgaWYgKCFMaWdodG5pbmcuVXRpbHMuZXF1YWxWYWx1ZXModGhpcy5fc3RyZWFtLCBzZXR0aW5ncy5zdHJlYW0pKSB7XG4gICAgICBpZiAoc2V0dGluZ3Muc3RyZWFtICYmIHNldHRpbmdzLnN0cmVhbS5rZXlTeXN0ZW0pIHtcbiAgICAgICAgbmF2aWdhdG9yXG4gICAgICAgICAgLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyhcbiAgICAgICAgICAgIHNldHRpbmdzLnN0cmVhbS5rZXlTeXN0ZW0uaWQsXG4gICAgICAgICAgICBzZXR0aW5ncy5zdHJlYW0ua2V5U3lzdGVtLmNvbmZpZ1xuICAgICAgICAgIClcbiAgICAgICAgICAudGhlbihrZXlTeXN0ZW1BY2Nlc3MgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGtleVN5c3RlbUFjY2Vzcy5jcmVhdGVNZWRpYUtleXMoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oY3JlYXRlZE1lZGlhS2V5cyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb0VsLnNldE1lZGlhS2V5cyhjcmVhdGVkTWVkaWFLZXlzKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnN0cmVhbSAmJiBzZXR0aW5ncy5zdHJlYW0uc3JjKSB0aGlzLm9wZW4oc2V0dGluZ3Muc3RyZWFtLnNyYylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2V0IHVwIE1lZGlhS2V5cycpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Muc3RyZWFtICYmIHNldHRpbmdzLnN0cmVhbS5zcmMpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBoZXJlIHRvIGJlIGJhY2t3YXJkcyBjb21wYXRpYmxlLCB3aWxsIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gaW4gZnV0dXJlIHNkayByZWxlYXNlXG4gICAgICAgIGlmIChTZXR0aW5ncy5nZXQoJ2FwcCcsICdobHMnKSkge1xuICAgICAgICAgIGlmICghd2luZG93Lkhscykge1xuICAgICAgICAgICAgd2luZG93LkhscyA9IGNsYXNzIEhscyB7XG4gICAgICAgICAgICAgIHN0YXRpYyBpc1N1cHBvcnRlZCgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2hscy1saWdodCBub3QgaW5jbHVkZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aW5kb3cuSGxzLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faGxzKSB0aGlzLl9obHMgPSBuZXcgd2luZG93Lkhscyh7IGxpdmVEdXJhdGlvbkluZmluaXR5OiB0cnVlIH0pXG4gICAgICAgICAgICB0aGlzLl9obHMubG9hZFNvdXJjZShzZXR0aW5ncy5zdHJlYW0uc3JjKVxuICAgICAgICAgICAgdGhpcy5faGxzLmF0dGFjaE1lZGlhKHRoaXMudmlkZW9FbClcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wZW4oc2V0dGluZ3Muc3RyZWFtLnNyYylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9XG4gICAgICB0aGlzLl9zdHJlYW0gPSBzZXR0aW5ncy5zdHJlYW1cbiAgICB9XG5cbiAgICB0aGlzLl9zZXRIaWRlKHNldHRpbmdzLmhpZGUpXG4gICAgdGhpcy5fc2V0VmlkZW9BcmVhKHNldHRpbmdzLnZpZGVvUG9zKVxuICB9XG5cbiAgX3NldEhpZGUoaGlkZSkge1xuICAgIGlmICh0aGlzLnRleHR1cmVNb2RlKSB7XG4gICAgICB0aGlzLnRhZygnVmlkZW8nKS5zZXRTbW9vdGgoJ2FscGhhJywgaGlkZSA/IDAgOiAxKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGUgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJ1xuICAgIH1cbiAgfVxuXG4gIG9wZW4odXJsLCBzZXR0aW5ncyA9IHsgaGlkZTogZmFsc2UsIHZpZGVvUG9zaXRpb246IG51bGwgfSkge1xuICAgIC8vIHByZXAgdGhlIG1lZGlhIHVybCB0byBwbGF5IGRlcGVuZGluZyBvbiBwbGF0Zm9ybSAobWVkaWFQbGF5ZXJwbHVnaW4pXG4gICAgdXJsID0gbWVkaWFVcmwodXJsKVxuICAgIHRoaXMuX21ldHJpY3MgPSBNZXRyaWNzLm1lZGlhKHVybClcbiAgICBMb2cuaW5mbygnUGxheWluZyBzdHJlYW0nLCB1cmwpXG4gICAgaWYgKHRoaXMuYXBwbGljYXRpb24ubm9WaWRlbykge1xuICAgICAgTG9nLmluZm8oJ25vVmlkZW8gb3B0aW9uIHNldCwgc28gaWdub3Jpbmc6ICcgKyB1cmwpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gY2xvc2UgdGhlIHZpZGVvIHdoZW4gb3BlbmluZyBzYW1lIHVybCBhcyBjdXJyZW50IChlZmZlY3RpdmVseSByZWxvYWRpbmcpXG4gICAgaWYgKHRoaXMudmlkZW9FbC5nZXRBdHRyaWJ1dGUoJ3NyYycpID09PSB1cmwpIHtcbiAgICAgIHRoaXMuY2xvc2UoKVxuICAgIH1cbiAgICB0aGlzLnZpZGVvRWwuc2V0QXR0cmlidXRlKCdzcmMnLCB1cmwpXG5cbiAgICAvLyBmb3JjZSBoaWRlLCB0aGVuIGZvcmNlIHNob3cgKGluIG5leHQgdGljayEpXG4gICAgLy8gKGZpeGVzIGNvbWNhc3QgcGxheWJhY2sgcm9sbG92ZXIgaXNzdWUpXG4gICAgdGhpcy52aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudmlkZW9FbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICB9KVxuXG4gICAgdGhpcy5fc2V0SGlkZShzZXR0aW5ncy5oaWRlKVxuICAgIHRoaXMuX3NldFZpZGVvQXJlYShzZXR0aW5ncy52aWRlb1Bvc2l0aW9uIHx8IFswLCAwLCAxOTIwLCAxMDgwXSlcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gcGF1c2UgZmlyc3QgaW4gb3JkZXIgdG8gc3RvcCBzb3VuZC5cbiAgICB0aGlzLnZpZGVvRWwucGF1c2UoKVxuICAgIHRoaXMudmlkZW9FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpXG5cbiAgICAvLyBmb3JjZSBsb2FkIHRvIHJlc2V0IGV2ZXJ5dGhpbmcgd2l0aG91dCBlcnJvcnNcbiAgICB0aGlzLnZpZGVvRWwubG9hZCgpXG5cbiAgICB0aGlzLl9jbGVhclNyYygpXG5cbiAgICB0aGlzLnZpZGVvRWwuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICB9XG5cbiAgcGxheVBhdXNlKCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZygpKSB7XG4gICAgICB0aGlzLmRvUGF1c2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUGxheSgpXG4gICAgfVxuICB9XG5cbiAgZ2V0IG11dGVkKCkge1xuICAgIHJldHVybiB0aGlzLnZpZGVvRWwubXV0ZWRcbiAgfVxuXG4gIHNldCBtdXRlZCh2KSB7XG4gICAgdGhpcy52aWRlb0VsLm11dGVkID0gdlxuICB9XG5cbiAgZ2V0IGxvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9FbC5sb29wXG4gIH1cblxuICBzZXQgbG9vcCh2KSB7XG4gICAgdGhpcy52aWRlb0VsLmxvb3AgPSB2XG4gIH1cblxuICBpc1BsYXlpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCkgPT09ICdQbGF5aW5nJ1xuICB9XG5cbiAgZG9QbGF5KCkge1xuICAgIHRoaXMudmlkZW9FbC5wbGF5KClcbiAgfVxuXG4gIGRvUGF1c2UoKSB7XG4gICAgdGhpcy52aWRlb0VsLnBhdXNlKClcbiAgfVxuXG4gIHJlbG9hZCgpIHtcbiAgICB2YXIgdXJsID0gdGhpcy52aWRlb0VsLmdldEF0dHJpYnV0ZSgnc3JjJylcbiAgICB0aGlzLmNsb3NlKClcbiAgICB0aGlzLnZpZGVvRWwuc3JjID0gdXJsXG4gIH1cblxuICBnZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSlcbiAgfVxuXG4gIHNldFBvc2l0aW9uKHBvcykge1xuICAgIHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSA9IHBvc1xuICB9XG5cbiAgZ2V0RHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnZpZGVvRWwuZHVyYXRpb24pXG4gIH1cblxuICBzZWVrKHRpbWUsIGFic29sdXRlID0gZmFsc2UpIHtcbiAgICBpZiAoYWJzb2x1dGUpIHtcbiAgICAgIHRoaXMudmlkZW9FbC5jdXJyZW50VGltZSA9IHRpbWVcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lICs9IHRpbWVcbiAgICB9XG4gIH1cblxuICBnZXQgdmlkZW9UZXh0dXJlVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy50YWcoJ1ZpZGVvJykudGFnKCdWaWRlb1RleHR1cmUnKVxuICB9XG5cbiAgZ2V0IHZpZGVvVGV4dHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWRlb1RleHR1cmVWaWV3LnRleHR1cmVcbiAgfVxuXG4gIF9zZXRWaWRlb0FyZWEodmlkZW9Qb3MpIHtcbiAgICBpZiAoTGlnaHRuaW5nLlV0aWxzLmVxdWFsVmFsdWVzKHRoaXMuX3ZpZGVvUG9zLCB2aWRlb1BvcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3ZpZGVvUG9zID0gdmlkZW9Qb3NcblxuICAgIGlmICh0aGlzLnRleHR1cmVNb2RlKSB7XG4gICAgICB0aGlzLnZpZGVvVGV4dHVyZVZpZXcucGF0Y2goe1xuICAgICAgICBzbW9vdGg6IHtcbiAgICAgICAgICB4OiB2aWRlb1Bvc1swXSxcbiAgICAgICAgICB5OiB2aWRlb1Bvc1sxXSxcbiAgICAgICAgICB3OiB2aWRlb1Bvc1syXSAtIHZpZGVvUG9zWzBdLFxuICAgICAgICAgIGg6IHZpZGVvUG9zWzNdIC0gdmlkZW9Qb3NbMV0sXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpXG4gICAgICB0aGlzLnZpZGVvRWwuc3R5bGUubGVmdCA9IE1hdGgucm91bmQodmlkZW9Qb3NbMF0gKiBwcmVjaXNpb24pICsgJ3B4J1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLnRvcCA9IE1hdGgucm91bmQodmlkZW9Qb3NbMV0gKiBwcmVjaXNpb24pICsgJ3B4J1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLndpZHRoID0gTWF0aC5yb3VuZCgodmlkZW9Qb3NbMl0gLSB2aWRlb1Bvc1swXSkgKiBwcmVjaXNpb24pICsgJ3B4J1xuICAgICAgdGhpcy52aWRlb0VsLnN0eWxlLmhlaWdodCA9IE1hdGgucm91bmQoKHZpZGVvUG9zWzNdIC0gdmlkZW9Qb3NbMV0pICogcHJlY2lzaW9uKSArICdweCdcbiAgICB9XG4gIH1cblxuICBfZmlyZUNvbnN1bWVyKGV2ZW50LCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuX2NvbnN1bWVyKSB7XG4gICAgICB0aGlzLl9jb25zdW1lci5maXJlKGV2ZW50LCBhcmdzKVxuICAgIH1cbiAgfVxuXG4gIF9lcXVhbEluaXREYXRhKGJ1ZjEsIGJ1ZjIpIHtcbiAgICBpZiAoIWJ1ZjEgfHwgIWJ1ZjIpIHJldHVybiBmYWxzZVxuICAgIGlmIChidWYxLmJ5dGVMZW5ndGggIT0gYnVmMi5ieXRlTGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBkdjEgPSBuZXcgSW50OEFycmF5KGJ1ZjEpXG4gICAgY29uc3QgZHYyID0gbmV3IEludDhBcnJheShidWYyKVxuICAgIGZvciAobGV0IGkgPSAwOyBpICE9IGJ1ZjEuYnl0ZUxlbmd0aDsgaSsrKSBpZiAoZHYxW2ldICE9IGR2MltpXSkgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGVycm9yKGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckVycm9yJywgYXJncylcbiAgICB0aGlzLl9zZXRTdGF0ZSgnJylcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGxvYWRlZGRhdGEoYXJncykge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyTG9hZGVkRGF0YScsIGFyZ3MpXG4gIH1cblxuICBwbGF5KGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclBsYXknLCBhcmdzKVxuICB9XG5cbiAgcGxheWluZyhhcmdzKSB7XG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJQbGF5aW5nJywgYXJncylcbiAgICB0aGlzLl9zZXRTdGF0ZSgnUGxheWluZycpXG4gIH1cblxuICBjYW5wbGF5KGFyZ3MpIHtcbiAgICB0aGlzLnZpZGVvRWwucGxheSgpXG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJTdGFydCcsIGFyZ3MpXG4gIH1cblxuICBsb2Fkc3RhcnQoYXJncykge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyTG9hZCcsIGFyZ3MpXG4gIH1cblxuICBzZWVrZWQoKSB7XG4gICAgdGhpcy5fZmlyZUNvbnN1bWVyKCckbWVkaWFwbGF5ZXJTZWVrZWQnLCB7XG4gICAgICBjdXJyZW50VGltZTogdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lLFxuICAgICAgZHVyYXRpb246IHRoaXMudmlkZW9FbC5kdXJhdGlvbiB8fCAxLFxuICAgIH0pXG4gIH1cblxuICBzZWVraW5nKCkge1xuICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyU2Vla2luZycsIHtcbiAgICAgIGN1cnJlbnRUaW1lOiB0aGlzLnZpZGVvRWwuY3VycmVudFRpbWUsXG4gICAgICBkdXJhdGlvbjogdGhpcy52aWRlb0VsLmR1cmF0aW9uIHx8IDEsXG4gICAgfSlcbiAgfVxuXG4gIGR1cmF0aW9uY2hhbmdlKGFyZ3MpIHtcbiAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllckR1cmF0aW9uQ2hhbmdlJywgYXJncylcbiAgfVxuXG4gIGVuY3J5cHRlZChhcmdzKSB7XG4gICAgY29uc3QgdmlkZW8gPSBhcmdzLnZpZGVvRWxlbWVudFxuICAgIGNvbnN0IGV2ZW50ID0gYXJncy5ldmVudFxuICAgIC8vIEZJWE1FOiBEb3VibGUgZW5jcnlwdGVkIGV2ZW50cyBuZWVkIHRvIGJlIHByb3Blcmx5IGZpbHRlcmVkIGJ5IEdzdHJlYW1lclxuICAgIGlmICh2aWRlby5tZWRpYUtleXMgJiYgIXRoaXMuX2VxdWFsSW5pdERhdGEodGhpcy5fcHJldmlvdXNJbml0RGF0YSwgZXZlbnQuaW5pdERhdGEpKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c0luaXREYXRhID0gZXZlbnQuaW5pdERhdGFcbiAgICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyRW5jcnlwdGVkJywgYXJncylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX3N0YXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgY2xhc3MgUGxheWluZyBleHRlbmRzIHRoaXMge1xuICAgICAgICAkZW50ZXIoKSB7XG4gICAgICAgICAgdGhpcy5fc3RhcnRVcGRhdGluZ1ZpZGVvVGV4dHVyZSgpXG4gICAgICAgIH1cbiAgICAgICAgJGV4aXQoKSB7XG4gICAgICAgICAgdGhpcy5fc3RvcFVwZGF0aW5nVmlkZW9UZXh0dXJlKClcbiAgICAgICAgfVxuICAgICAgICB0aW1ldXBkYXRlKCkge1xuICAgICAgICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyUHJvZ3Jlc3MnLCB7XG4gICAgICAgICAgICBjdXJyZW50VGltZTogdGhpcy52aWRlb0VsLmN1cnJlbnRUaW1lLFxuICAgICAgICAgICAgZHVyYXRpb246IHRoaXMudmlkZW9FbC5kdXJhdGlvbiB8fCAxLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgZW5kZWQoYXJncykge1xuICAgICAgICAgIHRoaXMuX2ZpcmVDb25zdW1lcignJG1lZGlhcGxheWVyRW5kZWQnLCBhcmdzKVxuICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCcnKVxuICAgICAgICB9XG4gICAgICAgIHBhdXNlKGFyZ3MpIHtcbiAgICAgICAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclBhdXNlJywgYXJncylcbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnUGxheWluZy5QYXVzZWQnKVxuICAgICAgICB9XG4gICAgICAgIF9jbGVhclNyYygpIHtcbiAgICAgICAgICB0aGlzLl9maXJlQ29uc3VtZXIoJyRtZWRpYXBsYXllclN0b3AnLCB7fSlcbiAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnJylcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgX3N0YXRlcygpIHtcbiAgICAgICAgICByZXR1cm4gW2NsYXNzIFBhdXNlZCBleHRlbmRzIHRoaXMge31dXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgXVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xubGV0IG1ldGFkYXRhID0ge31cblxuZXhwb3J0IGNvbnN0IGluaXRNZXRhZGF0YSA9IG1ldGFkYXRhT2JqID0+IHtcbiAgbWV0YWRhdGEgPSBtZXRhZGF0YU9ialxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldChrZXksIGZhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGtleSBpbiBtZXRhZGF0YSA/IG1ldGFkYXRhW2tleV0gOiBmYWxsYmFja1xuICB9LFxuICBhcHBJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2lkJylcbiAgfSxcbiAgc2FmZUFwcElkKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnaWQnKS5yZXBsYWNlKC9bXjAtOWEtekEtWl8kXS9nLCAnXycpXG4gIH0sXG4gIGFwcE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCduYW1lJylcbiAgfSxcbiAgYXBwVmVyc2lvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0KCd2ZXJzaW9uJykgfHwgJycpLnNwbGl0KCctJykuc2hpZnQoKVxuICB9LFxuICBhcHBJY29uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnaWNvbicpXG4gIH0sXG4gIC8vIFZlcnNpb24gZnJvbSBhcHAgc3RvcmUgKHdpdGggY29tbWl0IGhhc2gpXG4gIGFwcEZ1bGxWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndmVyc2lvbicpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxubGV0IHNlbmRNZXRyaWMgPSAodHlwZSwgZXZlbnQsIHBhcmFtcykgPT4ge1xuICBMb2cuaW5mbygnU2VuZGluZyBtZXRyaWMnLCB0eXBlLCBldmVudCwgcGFyYW1zKVxufVxuXG5leHBvcnQgY29uc3QgaW5pdE1ldHJpY3MgPSBjb25maWcgPT4ge1xuICBzZW5kTWV0cmljID0gY29uZmlnLnNlbmRNZXRyaWNcbn1cblxuLy8gYXZhaWxhYmxlIG1ldHJpYyBwZXIgY2F0ZWdvcnlcbmNvbnN0IG1ldHJpY3MgPSB7XG4gIGFwcDogWydsYXVuY2gnLCAnbG9hZGVkJywgJ3JlYWR5JywgJ2Nsb3NlJ10sXG4gIHBhZ2U6IFsndmlldycsICdsZWF2ZSddLFxuICB1c2VyOiBbJ2NsaWNrJywgJ2lucHV0J10sXG4gIG1lZGlhOiBbXG4gICAgJ2Fib3J0JyxcbiAgICAnY2FucGxheScsXG4gICAgJ2VuZGVkJyxcbiAgICAncGF1c2UnLFxuICAgICdwbGF5JyxcbiAgICAvLyB3aXRoIHNvbWUgdmlkZW9zIHRoZXJlIG9jY3VyIGFsbW9zdCBjb25zdGFudCBzdXNwZW5kIGV2ZW50cyAuLi4gc2hvdWxkIGludmVzdGlnYXRlXG4gICAgLy8gJ3N1c3BlbmQnLFxuICAgICd2b2x1bWVjaGFuZ2UnLFxuICAgICd3YWl0aW5nJyxcbiAgICAnc2Vla2luZycsXG4gICAgJ3NlZWtlZCcsXG4gIF0sXG59XG5cbi8vIGVycm9yIG1ldHJpYyBmdW5jdGlvbiAoYWRkZWQgdG8gZWFjaCBjYXRlZ29yeSlcbmNvbnN0IGVycm9yTWV0cmljID0gKHR5cGUsIG1lc3NhZ2UsIGNvZGUsIHZpc2libGUsIHBhcmFtcyA9IHt9KSA9PiB7XG4gIHBhcmFtcyA9IHsgcGFyYW1zLCAuLi57IG1lc3NhZ2UsIGNvZGUsIHZpc2libGUgfSB9XG4gIHNlbmRNZXRyaWModHlwZSwgJ2Vycm9yJywgcGFyYW1zKVxufVxuXG5jb25zdCBNZXRyaWMgPSAodHlwZSwgZXZlbnRzLCBvcHRpb25zID0ge30pID0+IHtcbiAgcmV0dXJuIGV2ZW50cy5yZWR1Y2UoXG4gICAgKG9iaiwgZXZlbnQpID0+IHtcbiAgICAgIG9ialtldmVudF0gPSAobmFtZSwgcGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgcGFyYW1zID0geyAuLi5vcHRpb25zLCAuLi4obmFtZSA/IHsgbmFtZSB9IDoge30pLCAuLi5wYXJhbXMgfVxuICAgICAgICBzZW5kTWV0cmljKHR5cGUsIGV2ZW50LCBwYXJhbXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqXG4gICAgfSxcbiAgICB7XG4gICAgICBlcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgZXJyb3JNZXRyaWModHlwZSwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKVxuICAgICAgfSxcbiAgICAgIGV2ZW50KG5hbWUsIHBhcmFtcykge1xuICAgICAgICBzZW5kTWV0cmljKHR5cGUsIG5hbWUsIHBhcmFtcylcbiAgICAgIH0sXG4gICAgfVxuICApXG59XG5cbmNvbnN0IE1ldHJpY3MgPSB0eXBlcyA9PiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0eXBlcykucmVkdWNlKFxuICAgIChvYmosIHR5cGUpID0+IHtcbiAgICAgIC8vIG1lZGlhIG1ldHJpYyB3b3JrcyBhIGJpdCBkaWZmZXJlbnQhXG4gICAgICAvLyBpdCdzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgdXJsIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBhdmFpbGFibGUgbWV0cmljc1xuICAgICAgLy8gdXJsIGlzIGF1dG9tYXRpY2FsbHkgcGFzc2VkIGFzIGEgcGFyYW0gaW4gZXZlcnkgbWV0cmljXG4gICAgICB0eXBlID09PSAnbWVkaWEnXG4gICAgICAgID8gKG9ialt0eXBlXSA9IHVybCA9PiBNZXRyaWModHlwZSwgdHlwZXNbdHlwZV0sIHsgdXJsIH0pKVxuICAgICAgICA6IChvYmpbdHlwZV0gPSBNZXRyaWModHlwZSwgdHlwZXNbdHlwZV0pKVxuICAgICAgcmV0dXJuIG9ialxuICAgIH0sXG4gICAgeyBlcnJvcjogZXJyb3JNZXRyaWMsIGV2ZW50OiBzZW5kTWV0cmljIH1cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBNZXRyaWNzKG1ldHJpY3MpXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uL0xpZ2h0bmluZydcbmltcG9ydCBQaW4gZnJvbSAnLi4vUGluJ1xuXG5jbGFzcyBQaW5JbnB1dCBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3OiAxMjAsXG4gICAgICBoOiAxNTAsXG4gICAgICByZWN0OiB0cnVlLFxuICAgICAgY29sb3I6IDB4ZmY5NDkzOTMsXG4gICAgICBhbHBoYTogMC41LFxuICAgICAgc2hhZGVyOiB7IHR5cGU6IExpZ2h0bmluZy5zaGFkZXJzLlJvdW5kZWRSZWN0YW5nbGUsIHJhZGl1czogMTAgfSxcbiAgICAgIE5yOiB7XG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgeTogMjQsXG4gICAgICAgIHRleHQ6IHtcbiAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmYzMzMzMzMsXG4gICAgICAgICAgZm9udFNpemU6IDgwLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIHNldCBpbmRleCh2KSB7XG4gICAgdGhpcy54ID0gdiAqICgxMjAgKyAyNClcbiAgfVxuXG4gIHNldCBucih2KSB7XG4gICAgdGhpcy5fdGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcblxuICAgIGlmICh2KSB7XG4gICAgICB0aGlzLnNldFNtb290aCgnYWxwaGEnLCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFNtb290aCgnYWxwaGEnLCAwLjUpXG4gICAgfVxuXG4gICAgdGhpcy50YWcoJ05yJykucGF0Y2goe1xuICAgICAgdGV4dDoge1xuICAgICAgICB0ZXh0OiAodiAmJiB2LnRvU3RyaW5nKCkpIHx8ICcnLFxuICAgICAgICBmb250U2l6ZTogdiA9PT0gJyonID8gMTIwIDogODAsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBpZiAodiAmJiB2ICE9PSAnKicpIHtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgICAgICAgdGhpcy5uciA9ICcqJ1xuICAgICAgfSwgNzUwKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaW5EaWFsb2cgZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcbiAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgekluZGV4OiAxLFxuICAgICAgdzogdyA9PiB3LFxuICAgICAgaDogaCA9PiBoLFxuICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgIGNvbG9yOiAweGRkMDAwMDAwLFxuICAgICAgYWxwaGE6IDAuMDAwMDAxLFxuICAgICAgRGlhbG9nOiB7XG4gICAgICAgIHc6IDY0OCxcbiAgICAgICAgaDogMzIwLFxuICAgICAgICB5OiBoID0+IChoIC0gMzIwKSAvIDIsXG4gICAgICAgIHg6IHcgPT4gKHcgLSA2NDgpIC8gMixcbiAgICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgICAgY29sb3I6IDB4ZGQzMzMzMzMsXG4gICAgICAgIHNoYWRlcjogeyB0eXBlOiBMaWdodG5pbmcuc2hhZGVycy5Sb3VuZGVkUmVjdGFuZ2xlLCByYWRpdXM6IDEwIH0sXG4gICAgICAgIEluZm86IHtcbiAgICAgICAgICB5OiAyNCxcbiAgICAgICAgICB4OiA0OCxcbiAgICAgICAgICB0ZXh0OiB7IHRleHQ6ICdQbGVhc2UgZW50ZXIgeW91ciBQSU4nLCBmb250U2l6ZTogMzIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgTXNnOiB7XG4gICAgICAgICAgeTogMjYwLFxuICAgICAgICAgIHg6IDQ4LFxuICAgICAgICAgIHRleHQ6IHsgdGV4dDogJycsIGZvbnRTaXplOiAyOCwgdGV4dENvbG9yOiAweGZmZmZmZmZmIH0sXG4gICAgICAgIH0sXG4gICAgICAgIENvZGU6IHtcbiAgICAgICAgICB4OiA0OCxcbiAgICAgICAgICB5OiA5NixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogUGluSW5wdXQsXG4gICAgICAgIGluZGV4OiBpLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLnRhZygnQ29kZScpLmNoaWxkcmVuID0gY2hpbGRyZW5cbiAgfVxuXG4gIGdldCBwaW4oKSB7XG4gICAgaWYgKCF0aGlzLl9waW4pIHRoaXMuX3BpbiA9ICcnXG4gICAgcmV0dXJuIHRoaXMuX3BpblxuICB9XG5cbiAgc2V0IHBpbih2KSB7XG4gICAgaWYgKHYubGVuZ3RoIDw9IDQpIHtcbiAgICAgIGNvbnN0IG1hc2tlZFBpbiA9IG5ldyBBcnJheShNYXRoLm1heCh2Lmxlbmd0aCAtIDEsIDApKS5maWxsKCcqJywgMCwgdi5sZW5ndGggLSAxKVxuICAgICAgdi5sZW5ndGggJiYgbWFza2VkUGluLnB1c2godi5sZW5ndGggPiB0aGlzLl9waW4ubGVuZ3RoID8gdi5zbGljZSgtMSkgOiAnKicpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB0aGlzLnRhZygnQ29kZScpLmNoaWxkcmVuW2ldLm5yID0gbWFza2VkUGluW2ldIHx8ICcnXG4gICAgICB9XG4gICAgICB0aGlzLl9waW4gPSB2XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1zZygpIHtcbiAgICBpZiAoIXRoaXMuX21zZykgdGhpcy5fbXNnID0gJydcbiAgICByZXR1cm4gdGhpcy5fbXNnXG4gIH1cblxuICBzZXQgbXNnKHYpIHtcbiAgICB0aGlzLl90aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KVxuXG4gICAgdGhpcy5fbXNnID0gdlxuICAgIGlmICh0aGlzLl9tc2cpIHtcbiAgICAgIHRoaXMudGFnKCdNc2cnKS50ZXh0ID0gdGhpcy5fbXNnXG4gICAgICB0aGlzLnRhZygnSW5mbycpLnNldFNtb290aCgnYWxwaGEnLCAwLjUpXG4gICAgICB0aGlzLnRhZygnQ29kZScpLnNldFNtb290aCgnYWxwaGEnLCAwLjUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudGFnKCdNc2cnKS50ZXh0ID0gJydcbiAgICAgIHRoaXMudGFnKCdJbmZvJykuc2V0U21vb3RoKCdhbHBoYScsIDEpXG4gICAgICB0aGlzLnRhZygnQ29kZScpLnNldFNtb290aCgnYWxwaGEnLCAxKVxuICAgIH1cbiAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLm1zZyA9ICcnXG4gICAgfSwgMjAwMClcbiAgfVxuXG4gIF9maXJzdEFjdGl2ZSgpIHtcbiAgICB0aGlzLnNldFNtb290aCgnYWxwaGEnLCAxKVxuICB9XG5cbiAgX2hhbmRsZUtleShldmVudCkge1xuICAgIGlmICh0aGlzLm1zZykge1xuICAgICAgdGhpcy5tc2cgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB2YWwgPSBwYXJzZUludChldmVudC5rZXkpXG4gICAgICBpZiAodmFsID4gLTEpIHtcbiAgICAgICAgdGhpcy5waW4gKz0gdmFsXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUJhY2soKSB7XG4gICAgaWYgKHRoaXMubXNnKSB7XG4gICAgICB0aGlzLm1zZyA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLnBpbi5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5waW4gPSB0aGlzLnBpbi5zbGljZSgwLCB0aGlzLnBpbi5sZW5ndGggLSAxKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUGluLmhpZGUoKVxuICAgICAgICB0aGlzLnJlc29sdmUoZmFsc2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUVudGVyKCkge1xuICAgIGlmICh0aGlzLm1zZykge1xuICAgICAgdGhpcy5tc2cgPSBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICBQaW4uc3VibWl0KHRoaXMucGluKVxuICAgICAgICAudGhlbih2YWwgPT4ge1xuICAgICAgICAgIHRoaXMubXNnID0gJ1VubG9ja2luZyAuLi4nXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBQaW4uaGlkZSgpXG4gICAgICAgICAgfSwgMTAwMClcbiAgICAgICAgICB0aGlzLnJlc29sdmUodmFsKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgdGhpcy5tc2cgPSBlXG4gICAgICAgICAgdGhpcy5yZWplY3QoZSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcbmltcG9ydCBQaW5EaWFsb2cgZnJvbSAnLi9kaWFsb2cnXG5pbXBvcnQgeyBBcHBsaWNhdGlvbkluc3RhbmNlIH0gZnJvbSAnLi4vTGF1bmNoJ1xuaW1wb3J0IHsgTG9nIH0gZnJvbSAnLi4vLi4vaW5kZXgnXG5cbi8vIG9ubHkgdXNlZCBkdXJpbmcgbG9jYWwgZGV2ZWxvcG1lbnRcbmxldCB1bmxvY2tlZCA9IGZhbHNlXG5jb25zdCBjb250ZXh0SXRlbXMgPSBbJ3B1cmNoYXNlJywgJ3BhcmVudGFsJ11cblxubGV0IHN1Ym1pdCA9IChwaW4sIGNvbnRleHQpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAocGluLnRvU3RyaW5nKCkgPT09IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAncGluJywgJzAwMDAnKS50b1N0cmluZygpKSB7XG4gICAgICB1bmxvY2tlZCA9IHRydWVcbiAgICAgIHJlc29sdmUodW5sb2NrZWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdCgnSW5jb3JyZWN0IHBpbicpXG4gICAgfVxuICB9KVxufVxuXG5sZXQgY2hlY2sgPSBjb250ZXh0ID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIHJlc29sdmUodW5sb2NrZWQpXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBpbml0UGluID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5zdWJtaXQgJiYgdHlwZW9mIGNvbmZpZy5zdWJtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdWJtaXQgPSBjb25maWcuc3VibWl0XG4gIH1cbiAgaWYgKGNvbmZpZy5jaGVjayAmJiB0eXBlb2YgY29uZmlnLmNoZWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2hlY2sgPSBjb25maWcuY2hlY2tcbiAgfVxufVxuXG5sZXQgcGluRGlhbG9nID0gbnVsbFxuXG5jb25zdCBjb250ZXh0Q2hlY2sgPSBjb250ZXh0ID0+IHtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIExvZy5pbmZvKCdQbGVhc2UgcHJvdmlkZSBjb250ZXh0IGV4cGxpY2l0bHknKVxuICAgIHJldHVybiBjb250ZXh0SXRlbXNbMF1cbiAgfSBlbHNlIGlmICghY29udGV4dEl0ZW1zLmluY2x1ZGVzKGNvbnRleHQpKSB7XG4gICAgTG9nLndhcm4oJ0luY29ycmVjdCBjb250ZXh0IHByb3ZpZGVkJylcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gY29udGV4dFxufVxuXG4vLyBQdWJsaWMgQVBJXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNob3coKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHBpbkRpYWxvZyA9IEFwcGxpY2F0aW9uSW5zdGFuY2Uuc3RhZ2UuYyh7XG4gICAgICAgIHJlZjogJ1BpbkRpYWxvZycsXG4gICAgICAgIHR5cGU6IFBpbkRpYWxvZyxcbiAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0LFxuICAgICAgfSlcbiAgICAgIEFwcGxpY2F0aW9uSW5zdGFuY2UuY2hpbGRMaXN0LmEocGluRGlhbG9nKVxuICAgICAgQXBwbGljYXRpb25JbnN0YW5jZS5mb2N1cyA9IHBpbkRpYWxvZ1xuICAgIH0pXG4gIH0sXG4gIGhpZGUoKSB7XG4gICAgQXBwbGljYXRpb25JbnN0YW5jZS5mb2N1cyA9IG51bGxcbiAgICBBcHBsaWNhdGlvbkluc3RhbmNlLmNoaWxkcmVuID0gQXBwbGljYXRpb25JbnN0YW5jZS5jaGlsZHJlbi5tYXAoXG4gICAgICBjaGlsZCA9PiBjaGlsZCAhPT0gcGluRGlhbG9nICYmIGNoaWxkXG4gICAgKVxuICAgIHBpbkRpYWxvZyA9IG51bGxcbiAgfSxcbiAgc3VibWl0KHBpbiwgY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dENoZWNrKGNvbnRleHQpXG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgc3VibWl0KHBpbiwgY29udGV4dClcbiAgICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdCgnSW5jb3JyZWN0IENvbnRleHQgcHJvdmlkZWQnKVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIHVubG9ja2VkKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHRDaGVjayhjb250ZXh0KVxuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIGNoZWNrKGNvbnRleHQpXG4gICAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0luY29ycmVjdCBDb250ZXh0IHByb3ZpZGVkJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBsb2NrZWQoY29udGV4dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dENoZWNrKGNvbnRleHQpXG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgY2hlY2soY29udGV4dClcbiAgICAgICAgICAgIC50aGVuKHVubG9ja2VkID0+IHJlc29sdmUoISEhdW5sb2NrZWQpKVxuICAgICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0luY29ycmVjdCBDb250ZXh0IHByb3ZpZGVkJylcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgZ2V0TG9jYWxlLCBnZXRMYW5ndWFnZSwgZ2V0Q291bnRyeUNvZGUsIGdldExhdExvbiB9IGZyb20gJy4vaGVscGVycydcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm9maWxlID0ge1xuICBhZ2VSYXRpbmc6ICdhZHVsdCcsXG4gIGNpdHk6ICdOZXcgWW9yaycsXG4gIHppcENvZGU6ICcyNzUwNScsXG4gIGNvdW50cnlDb2RlOiAoKSA9PiBnZXRDb3VudHJ5Q29kZSgnVVMnKSxcbiAgaXA6ICcxMjcuMC4wLjEnLFxuICBob3VzZWhvbGQ6ICdiMjI0NGU5ZDRjMDQ4MjZjY2Q1YTdiMmMyYTUwZTdkNCcsXG4gIGxhbmd1YWdlOiAoKSA9PiBnZXRMYW5ndWFnZSgnZW4nKSxcbiAgbGF0bG9uOiAoKSA9PiBnZXRMYXRMb24oWzQwLjcxMjgsIDc0LjAwNl0pLFxuICBsb2NhbGU6ICgpID0+IGdldExvY2FsZSgnZW4tVVMnKSxcbiAgbWFjOiAnMDA6MDA6MDA6MDA6MDA6MDAnLFxuICBvcGVyYXRvcjogJ21ldHJvbG9naWNhbCcsXG4gIHBsYXRmb3JtOiAnbWV0cm9sb2dpY2FsJyxcbiAgcGFja2FnZXM6IFtdLFxuICB1aWQ6ICdlZTY3MjNiOC03YWIzLTQ2MmMtOGQ5My1kYmY2MTIyNzk5OGUnLFxuICBzdGJUeXBlOiAnbWV0cm9sb2dpY2FsJyxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi9TZXR0aW5ncydcblxuY29uc3QgZm9ybWF0TG9jYWxlID0gbG9jYWxlID0+IHtcbiAgaWYgKGxvY2FsZSAmJiBsb2NhbGUubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIGAke2xvY2FsZS50b0xvd2VyQ2FzZSgpfS0ke2xvY2FsZS50b1VwcGVyQ2FzZSgpfWBcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbG9jYWxlXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldExvY2FsZSA9IGRlZmF1bHRWYWx1ZSA9PiB7XG4gIGlmICgnbGFuZ3VhZ2UnIGluIG5hdmlnYXRvcikge1xuICAgIGNvbnN0IGxvY2FsZSA9IGZvcm1hdExvY2FsZShuYXZpZ2F0b3IubGFuZ3VhZ2UpXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShsb2NhbGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZWZhdWx0VmFsdWUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldExhbmd1YWdlID0gZGVmYXVsdFZhbHVlID0+IHtcbiAgaWYgKCdsYW5ndWFnZScgaW4gbmF2aWdhdG9yKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBmb3JtYXRMb2NhbGUobmF2aWdhdG9yLmxhbmd1YWdlKS5zbGljZSgwLCAyKVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGFuZ3VhZ2UpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZWZhdWx0VmFsdWUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldENvdW50cnlDb2RlID0gZGVmYXVsdFZhbHVlID0+IHtcbiAgaWYgKCdsYW5ndWFnZScgaW4gbmF2aWdhdG9yKSB7XG4gICAgY29uc3QgY291bnRyeUNvZGUgPSBmb3JtYXRMb2NhbGUobmF2aWdhdG9yLmxhbmd1YWdlKS5zbGljZSgzLCA1KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY291bnRyeUNvZGUpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZWZhdWx0VmFsdWUpXG4gIH1cbn1cblxuY29uc3QgaGFzT3JBc2tGb3JHZW9Mb2NhdGlvblBlcm1pc3Npb24gPSAoKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAvLyBmb3JjZSB0byBwcm9tcHQgZm9yIGxvY2F0aW9uIHBlcm1pc3Npb25cbiAgICBpZiAoU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdmb3JjZUJyb3dzZXJHZW9sb2NhdGlvbicpID09PSB0cnVlKSByZXNvbHZlKHRydWUpXG4gICAgaWYgKCdwZXJtaXNzaW9ucycgaW4gbmF2aWdhdG9yICYmIHR5cGVvZiBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5hdmlnYXRvci5wZXJtaXNzaW9ucy5xdWVyeSh7IG5hbWU6ICdnZW9sb2NhdGlvbicgfSkudGhlbihzdGF0dXMgPT4ge1xuICAgICAgICByZXNvbHZlKHN0YXR1cy5zdGF0ZSA9PT0gJ2dyYW50ZWQnIHx8IHN0YXR1cy5zdGF0dXMgPT09ICdncmFudGVkJylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoZmFsc2UpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0TGF0TG9uID0gZGVmYXVsdFZhbHVlID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGhhc09yQXNrRm9yR2VvTG9jYXRpb25QZXJtaXNzaW9uKCkudGhlbihncmFudGVkID0+IHtcbiAgICAgIGlmIChncmFudGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICgnZ2VvbG9jYXRpb24nIGluIG5hdmlnYXRvcikge1xuICAgICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oXG4gICAgICAgICAgICAvLyBzdWNjZXNzXG4gICAgICAgICAgICByZXN1bHQgPT5cbiAgICAgICAgICAgICAgcmVzdWx0ICYmIHJlc3VsdC5jb29yZHMgJiYgcmVzb2x2ZShbcmVzdWx0LmNvb3Jkcy5sYXRpdHVkZSwgcmVzdWx0LmNvb3Jkcy5sb25naXR1ZGVdKSxcbiAgICAgICAgICAgIC8vIGVycm9yXG4gICAgICAgICAgICAoKSA9PiByZXNvbHZlKGRlZmF1bHRWYWx1ZSksXG4gICAgICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVuYWJsZUhpZ2hBY2N1cmFjeTogdHJ1ZSxcbiAgICAgICAgICAgICAgdGltZW91dDogNTAwMCxcbiAgICAgICAgICAgICAgbWF4aW11bUFnZTogMCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHF1ZXJ5Rm9yTGF0TG9uKCkudGhlbihyZXN1bHQgPT4gcmVzb2x2ZShyZXN1bHQgfHwgZGVmYXVsdFZhbHVlKSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5Rm9yTGF0TG9uKCkudGhlbihyZXN1bHQgPT4gcmVzb2x2ZShyZXN1bHQgfHwgZGVmYXVsdFZhbHVlKSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCBxdWVyeUZvckxhdExvbiA9ICgpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGZldGNoKCdodHRwczovL2dlb2xvY2F0aW9uLWRiLmNvbS9qc29uLycpXG4gICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAudGhlbigoeyBsYXRpdHVkZSwgbG9uZ2l0dWRlIH0pID0+XG4gICAgICAgIGxhdGl0dWRlICYmIGxvbmdpdHVkZSA/IHJlc29sdmUoW2xhdGl0dWRlLCBsb25naXR1ZGVdKSA6IHJlc29sdmUoZmFsc2UpXG4gICAgICApXG4gICAgICAuY2F0Y2goKCkgPT4gcmVzb2x2ZShmYWxzZSkpXG4gIH0pXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgeyBkZWZhdWx0UHJvZmlsZSB9IGZyb20gJy4vZGVmYXVsdHMnXG5cbmxldCBnZXRJbmZvID0ga2V5ID0+IHtcbiAgY29uc3QgcHJvZmlsZSA9IHsgLi4uZGVmYXVsdFByb2ZpbGUsIC4uLlNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAncHJvZmlsZScpIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlb2YgcHJvZmlsZVtrZXldID09PSAnZnVuY3Rpb24nID8gcHJvZmlsZVtrZXldKCkgOiBwcm9maWxlW2tleV0pXG59XG5cbmxldCBzZXRJbmZvID0gKGtleSwgcGFyYW1zKSA9PiB7XG4gIGlmIChrZXkgaW4gZGVmYXVsdFByb2ZpbGUpIGRlZmF1bHRQcm9maWxlW2tleV0gPSBwYXJhbXNcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRQcm9maWxlID0gY29uZmlnID0+IHtcbiAgZ2V0SW5mbyA9IGNvbmZpZy5nZXRJbmZvXG4gIHNldEluZm8gPSBjb25maWcuc2V0SW5mb1xufVxuXG5jb25zdCBnZXRPclNldCA9IChrZXksIHBhcmFtcykgPT4gKHBhcmFtcyA/IHNldEluZm8oa2V5LCBwYXJhbXMpIDogZ2V0SW5mbyhrZXkpKVxuXG4vLyBwdWJsaWMgQVBJXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFnZVJhdGluZyhwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2FnZVJhdGluZycsIHBhcmFtcylcbiAgfSxcbiAgY2l0eShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2NpdHknLCBwYXJhbXMpXG4gIH0sXG4gIHppcENvZGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCd6aXBDb2RlJywgcGFyYW1zKVxuICB9LFxuICBjb3VudHJ5Q29kZShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2NvdW50cnlDb2RlJywgcGFyYW1zKVxuICB9LFxuICBpcChwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2lwJywgcGFyYW1zKVxuICB9LFxuICBob3VzZWhvbGQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdob3VzZWhvbGQnLCBwYXJhbXMpXG4gIH0sXG4gIGxhbmd1YWdlKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnbGFuZ3VhZ2UnLCBwYXJhbXMpXG4gIH0sXG4gIGxhdGxvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ2xhdGxvbicsIHBhcmFtcylcbiAgfSxcbiAgbG9jYWxlKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnbG9jYWxlJywgcGFyYW1zKVxuICB9LFxuICBtYWMocGFyYW1zKSB7XG4gICAgcmV0dXJuIGdldE9yU2V0KCdtYWMnLCBwYXJhbXMpXG4gIH0sXG4gIG9wZXJhdG9yKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgnb3BlcmF0b3InLCBwYXJhbXMpXG4gIH0sXG4gIHBsYXRmb3JtKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgncGxhdGZvcm0nLCBwYXJhbXMpXG4gIH0sXG4gIHBhY2thZ2VzKHBhcmFtcykge1xuICAgIHJldHVybiBnZXRPclNldCgncGFja2FnZXMnLCBwYXJhbXMpXG4gIH0sXG4gIHVpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ3VpZCcsIHBhcmFtcylcbiAgfSxcbiAgc3RiVHlwZShwYXJhbXMpIHtcbiAgICByZXR1cm4gZ2V0T3JTZXQoJ3N0YlR5cGUnLCBwYXJhbXMpXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgUHJvZmlsZSBmcm9tICcuLi9Qcm9maWxlJ1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IHNlcXVlbmNlIGZyb20gJy4uL2hlbHBlcnMvc2VxdWVuY2UnXG5cbmxldCBjc3BVcmwgPSAnaHR0cDovL3BheW1lbnQtY3NwLWV4YW1wbGUubWV0cm9sb2dpY2FsLmNvbTo4MDgwLydcbmxldCBiaWxsaW5nVXJsID0gJ2h0dHBzOi8vcGF5bWVudC1zZGsubWV0cm9sb2dpY2FsLmNvbS8nXG5cbmxldCBjc3BFbmRwb2ludHMgPSB7XG4gIGFzc2V0czoge1xuICAgIHVyaTogJy9hc3NldHMnLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gIH0sXG4gIGFzc2V0OiB7XG4gICAgdXJpOiAnL2Fzc2V0cy86aWQnLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gIH0sXG4gIHNpZ25hdHVyZToge1xuICAgIHVyaTogJy9hc3NldHMvOmlkL3NpZ25hdHVyZScsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gIH0sXG4gIHN1YnNjcmliZToge1xuICAgIHVyaTogJy9hc3NldHMvOmlkL3N1YnNjcmliZScsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gIH0sXG4gIHVuc3Vic2NyaWJlOiB7XG4gICAgdXJpOiAnL2Fzc2V0cy86aWQvdW5zdWJzY3JpYmUnLFxuICAgIG1ldGhvZDogJ1BPU1QnLFxuICB9LFxufVxuXG5leHBvcnQgY29uc3QgaW5pdFB1cmNoYXNlID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5iaWxsaW5nVXJsKSBiaWxsaW5nVXJsID0gY29uZmlnLmJpbGxpbmdVcmxcbn1cblxuY29uc3QgY3JlYXRlVXJsID0gKHVyaSwgYmFzZVVybCwgcGFyYW1zID0ge30pID0+IHtcbiAgcmV0dXJuIG5ldyBVUkwoXG4gICAgLy8gc3ByaW5rbGUgaW4gdGhlIHBhcmFtc1xuICAgIE9iamVjdC5rZXlzKHBhcmFtcylcbiAgICAgIC5yZWR1Y2UoKHJlcywga2V5KSA9PiByZXMucmVwbGFjZShuZXcgUmVnRXhwKCc6JyArIGtleSwgJ2cnKSwgcGFyYW1zW2tleV0pLCB1cmkpXG4gICAgICAvLyByZW1vdmUgYW55IGxlYWRpbmcgc2xhc2ggZnJvbSB1cmlcbiAgICAgIC5yZXBsYWNlKC9eXFwvLywgJycpLFxuICAgIC8vIG1ha2Ugc3VyZSBiYXNlVXJsIGFsd2F5cyBoYXMgYSB0cmFpbGluZyBzbGFzaFxuICAgIC9cXC8kLy50ZXN0KGJhc2VVcmwpID8gYmFzZVVybCA6IGJhc2VVcmwucmVwbGFjZSgvJC8sICcvJylcbiAgKVxufVxuXG5jb25zdCByZXF1ZXN0ID0gKHVybCwgbWV0aG9kID0gJ0dFVCcsIGRhdGEsIGhlYWRlcnMgPSB7fSkgPT4ge1xuICBpZiAobWV0aG9kID09PSAnR0VUJyAmJiBkYXRhKSB7XG4gICAgdXJsLnNlYXJjaCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoZGF0YSlcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZmV0Y2godXJsLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgYm9keTogbWV0aG9kICE9PSAnR0VUJyAmJiBkYXRhID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiBudWxsLFxuICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiAocmVzcG9uc2Uub2sgPyByZXNvbHZlKHJlc3BvbnNlLmpzb24oKSkgOiByZWplY3QocmVzcG9uc2Uuc3RhdHVzVGV4dCkpKVxuICAgICAgLmNhdGNoKHJlamVjdClcbiAgfSlcbn1cblxuY29uc3QgY3NwUmVxdWVzdCA9ICh0eXBlLCBkYXRhID0gbnVsbCwgcGFyYW1zID0ge30pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBlbmRwb2ludCA9IGNzcEVuZHBvaW50c1t0eXBlXVxuXG4gICAgaWYgKCFlbmRwb2ludCkge1xuICAgICAgcmVqZWN0KCdObyBlbmRwb2ludCBmb3VuZCBmb3IgXCInICsgdHlwZSArICdcIiBjYWxsJylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuZHBvaW50LmNhbGxiYWNrICYmIHR5cGVvZiBlbmRwb2ludC5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbmRwb2ludFxuICAgICAgICAgIC5jYWxsYmFjayhkYXRhLCBwYXJhbXMpXG4gICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdChcbiAgICAgICAgICBjcmVhdGVVcmwoZW5kcG9pbnQudXJpLCBjc3BVcmwsIHBhcmFtcyksXG4gICAgICAgICAgZW5kcG9pbnQubWV0aG9kLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC4uLihlbmRwb2ludC5kYXRhIHx8IHt9KSxcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmRwb2ludC5oZWFkZXJzIHx8IHt9XG4gICAgICAgIClcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5jb25zdCBiaWxsaW5nUmVxdWVzdCA9ICh1cmksIGRhdGEsIG1ldGhvZCA9ICdQT1NUJykgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcXVlc3QoY3JlYXRlVXJsKHVyaSwgYmlsbGluZ1VybCksIG1ldGhvZCwgZGF0YSlcbiAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAuY2F0Y2gocmVqZWN0KVxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldHVwKGNvbmZpZykge1xuICAgIGlmIChjb25maWcuY3NwVXJsKSBjc3BVcmwgPSBjb25maWcuY3NwVXJsXG4gICAgaWYgKGNvbmZpZy5lbmRwb2ludHMpIGNzcEVuZHBvaW50cyA9IHsgY3NwRW5kcG9pbnRzLCAuLi5jb25maWcuZW5kcG9pbnRzIH1cbiAgfSxcbiAgYXNzZXRzKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBQcm9maWxlLmhvdXNlaG9sZCgpLnRoZW4oaG91c2Vob2xkID0+IHtcbiAgICAgICAgY3NwUmVxdWVzdCgnYXNzZXRzJywgeyBob3VzZWhvbGQgfSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIGFzc2V0KGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFByb2ZpbGUuaG91c2Vob2xkKCkudGhlbihob3VzZWhvbGQgPT4ge1xuICAgICAgICBjc3BSZXF1ZXN0KCdhc3NldCcsIHsgaG91c2Vob2xkIH0sIHsgaWQgfSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIHNpZ25hdHVyZShpZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBQcm9taXNlLmFsbChbUHJvZmlsZS5ob3VzZWhvbGQoKV0pLnRoZW4oKFtob3VzZWhvbGRdKSA9PiB7XG4gICAgICAgIGNzcFJlcXVlc3QoJ3NpZ25hdHVyZScsIHsgaG91c2Vob2xkIH0sIHsgaWQgfSlcbiAgICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICB9KVxuICAgIH0pXG4gIH0sXG4gIHN1YnNjcmliZShpZCwgdHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY3NwUmVxdWVzdCgnc3Vic2NyaWJlJywgeyAuLi50cmFuc2FjdGlvbiB9LCB7IGlkIH0pXG4gICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfSxcbiAgdW5zdWJzY3JpYmUoaWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgUHJvZmlsZS5ob3VzZWhvbGQoKS50aGVuKGhvdXNlaG9sZCA9PiB7XG4gICAgICAgIGNzcFJlcXVlc3QoJ3Vuc3Vic2NyaWJlJywgeyBob3VzZWhvbGQgfSwgeyBpZCB9KVxuICAgICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSxcbiAgcGF5bWVudChzaWduYXR1cmUgPSB7fSwgdHlwZSA9ICdpbi1hcHAnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgUHJvZmlsZS5ob3VzZWhvbGQoKSxcbiAgICAgICAgUHJvZmlsZS5jb3VudHJ5Q29kZSgpLFxuICAgICAgICBQcm9maWxlLm9wZXJhdG9yKCksXG4gICAgICAgIFByb2ZpbGUubWFjKCksXG4gICAgICAgIFByb2ZpbGUudWlkKCksXG4gICAgICBdKVxuICAgICAgICAudGhlbigoW2hvdXNlaG9sZCwgY291bnRyeSwgb3BlcmF0b3IsIG1hYywgdWlkXSkgPT4ge1xuICAgICAgICAgIGJpbGxpbmdSZXF1ZXN0KCcvJywge1xuICAgICAgICAgICAgcHVyY2hhc2U6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IFNldHRpbmdzLmdldCgnYXBwJywgJ2lkJyksXG4gICAgICAgICAgICBuYW1lOiBTZXR0aW5ncy5nZXQoJ2FwcCcsICdpZCcpLFxuICAgICAgICAgICAgaG91c2Vob2xkLFxuICAgICAgICAgICAgY291bnRyeSxcbiAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgbWFjLFxuICAgICAgICAgICAgdWlkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfSxcbiAgY29uZmlybSh0cmFuc2FjdGlvbklkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGJpbGxpbmdSZXF1ZXN0KCcvY29uZmlybScsIHtcbiAgICAgICAgdHJhbnNhY3Rpb25JZCxcbiAgICAgIH0pXG4gICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfSxcbiAgYnV5KGFzc2V0SWQsIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgbGV0IHRyYW5zYWN0aW9uSWRcbiAgICAgIHNlcXVlbmNlKFtcbiAgICAgICAgKCkgPT4gdGhpcy5zaWduYXR1cmUoYXNzZXRJZCksXG4gICAgICAgIHNpZ25hdHVyZSA9PiB0aGlzLnBheW1lbnQoc2lnbmF0dXJlLCB0eXBlKSxcbiAgICAgICAgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICAgIHRyYW5zYWN0aW9uSWQgPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbklkXG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKGFzc2V0SWQsIHRyYW5zYWN0aW9uKVxuICAgICAgICB9LFxuICAgICAgICAoKSA9PiB0aGlzLmNvbmZpcm0odHJhbnNhY3Rpb25JZCksXG4gICAgICBdKVxuICAgICAgICAudGhlbihyZXNvbHZlKVxuICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgIH0pXG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxuY29uc3QgcmVnaXN0cnkgPSB7XG4gIGV2ZW50TGlzdGVuZXJzOiBbXSxcbiAgdGltZW91dHM6IFtdLFxuICBpbnRlcnZhbHM6IFtdLFxuICB0YXJnZXRzOiBbXSxcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICAvLyBUaW1lb3V0c1xuICBzZXRUaW1lb3V0KGNiLCB0aW1lb3V0LCAuLi5wYXJhbXMpIHtcbiAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4ge1xuICAgICAgICByZWdpc3RyeS50aW1lb3V0cyA9IHJlZ2lzdHJ5LnRpbWVvdXRzLmZpbHRlcihpZCA9PiBpZCAhPT0gdGltZW91dElkKVxuICAgICAgICBjYi5hcHBseShudWxsLCBwYXJhbXMpXG4gICAgICB9LFxuICAgICAgdGltZW91dCxcbiAgICAgIHBhcmFtc1xuICAgIClcbiAgICBMb2cuaW5mbygnU2V0IFRpbWVvdXQnLCAnSUQ6ICcgKyB0aW1lb3V0SWQpXG4gICAgcmVnaXN0cnkudGltZW91dHMucHVzaCh0aW1lb3V0SWQpXG4gICAgcmV0dXJuIHRpbWVvdXRJZFxuICB9LFxuXG4gIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpIHtcbiAgICBpZiAocmVnaXN0cnkudGltZW91dHMuaW5kZXhPZih0aW1lb3V0SWQpID4gLTEpIHtcbiAgICAgIHJlZ2lzdHJ5LnRpbWVvdXRzID0gcmVnaXN0cnkudGltZW91dHMuZmlsdGVyKGlkID0+IGlkICE9PSB0aW1lb3V0SWQpXG4gICAgICBMb2cuaW5mbygnQ2xlYXIgVGltZW91dCcsICdJRDogJyArIHRpbWVvdXRJZClcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIExvZy5lcnJvcignQ2xlYXIgVGltZW91dCcsICdJRCAnICsgdGltZW91dElkICsgJyBub3QgZm91bmQnKVxuICAgIH1cbiAgfSxcblxuICBjbGVhclRpbWVvdXRzKCkge1xuICAgIHJlZ2lzdHJ5LnRpbWVvdXRzLmZvckVhY2godGltZW91dElkID0+IHtcbiAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZClcbiAgICB9KVxuICB9LFxuXG4gIC8vIEludGVydmFsc1xuICBzZXRJbnRlcnZhbChjYiwgaW50ZXJ2YWwsIC4uLnBhcmFtcykge1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmVnaXN0cnkuaW50ZXJ2YWxzLmZpbHRlcihpZCA9PiBpZCAhPT0gaW50ZXJ2YWxJZClcbiAgICAgICAgY2IuYXBwbHkobnVsbCwgcGFyYW1zKVxuICAgICAgfSxcbiAgICAgIGludGVydmFsLFxuICAgICAgcGFyYW1zXG4gICAgKVxuICAgIExvZy5pbmZvKCdTZXQgSW50ZXJ2YWwnLCAnSUQ6ICcgKyBpbnRlcnZhbElkKVxuICAgIHJlZ2lzdHJ5LmludGVydmFscy5wdXNoKGludGVydmFsSWQpXG4gICAgcmV0dXJuIGludGVydmFsSWRcbiAgfSxcblxuICBjbGVhckludGVydmFsKGludGVydmFsSWQpIHtcbiAgICBpZiAocmVnaXN0cnkuaW50ZXJ2YWxzLmluZGV4T2YoaW50ZXJ2YWxJZCkgPiAtMSkge1xuICAgICAgcmVnaXN0cnkuaW50ZXJ2YWxzID0gcmVnaXN0cnkuaW50ZXJ2YWxzLmZpbHRlcihpZCA9PiBpZCAhPT0gaW50ZXJ2YWxJZClcbiAgICAgIExvZy5pbmZvKCdDbGVhciBJbnRlcnZhbCcsICdJRDogJyArIGludGVydmFsSWQpXG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIExvZy5lcnJvcignQ2xlYXIgSW50ZXJ2YWwnLCAnSUQgJyArIGludGVydmFsSWQgKyAnIG5vdCBmb3VuZCcpXG4gICAgfVxuICB9LFxuXG4gIGNsZWFySW50ZXJ2YWxzKCkge1xuICAgIHJlZ2lzdHJ5LmludGVydmFscy5mb3JFYWNoKGludGVydmFsSWQgPT4ge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKGludGVydmFsSWQpXG4gICAgfSlcbiAgfSxcblxuICAvLyBFdmVudCBsaXN0ZW5lcnNcbiAgYWRkRXZlbnRMaXN0ZW5lcih0YXJnZXQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpXG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPVxuICAgICAgcmVnaXN0cnkudGFyZ2V0cy5pbmRleE9mKHRhcmdldCkgPiAtMVxuICAgICAgICA/IHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpXG4gICAgICAgIDogcmVnaXN0cnkudGFyZ2V0cy5wdXNoKHRhcmdldCkgLSAxXG5cbiAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF0gPSByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF0gfHwge31cbiAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdID0gcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XSB8fCBbXVxuICAgIHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XVtldmVudF0ucHVzaChoYW5kbGVyKVxuICAgIExvZy5pbmZvKFxuICAgICAgJ0FkZCBldmVudExpc3RlbmVyJyxcbiAgICAgICdUYXJnZXQ6JyxcbiAgICAgIHRhcmdldCxcbiAgICAgICdFdmVudDogJyArIGV2ZW50LFxuICAgICAgJ0hhbmRsZXI6JyxcbiAgICAgIGhhbmRsZXIudG9TdHJpbmcoKVxuICAgIClcbiAgfSxcblxuICByZW1vdmVFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpXG4gICAgaWYgKFxuICAgICAgdGFyZ2V0SW5kZXggPiAtMSAmJlxuICAgICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdICYmXG4gICAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdICYmXG4gICAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdLmluZGV4T2YoaGFuZGxlcikgPiAtMVxuICAgICkge1xuICAgICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnNbdGFyZ2V0SW5kZXhdW2V2ZW50XSA9IHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XVtcbiAgICAgICAgZXZlbnRcbiAgICAgIF0uZmlsdGVyKGZuID0+IGZuICE9PSBoYW5kbGVyKVxuICAgICAgTG9nLmluZm8oXG4gICAgICAgICdSZW1vdmUgZXZlbnRMaXN0ZW5lcicsXG4gICAgICAgICdUYXJnZXQ6JyxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICAnRXZlbnQ6ICcgKyBldmVudCxcbiAgICAgICAgJ0hhbmRsZXI6JyxcbiAgICAgICAgaGFuZGxlci50b1N0cmluZygpXG4gICAgICApXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcilcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nLmVycm9yKFxuICAgICAgICAnUmVtb3ZlIGV2ZW50TGlzdGVuZXInLFxuICAgICAgICAnTm90IGZvdW5kJyxcbiAgICAgICAgJ1RhcmdldCcsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgJ0V2ZW50OiAnICsgZXZlbnQsXG4gICAgICAgICdIYW5kbGVyJyxcbiAgICAgICAgaGFuZGxlci50b1N0cmluZygpXG4gICAgICApXG4gICAgfVxuICB9LFxuXG4gIC8vIGlmIGBldmVudGAgaXMgb21pdHRlZCwgcmVtb3ZlcyBhbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRhcmdldFxuICAvLyBpZiBgdGFyZ2V0YCBpcyBhbHNvIG9taXR0ZWQsIHJlbW92ZXMgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRhcmdldCwgZXZlbnQpIHtcbiAgICBpZiAodGFyZ2V0ICYmIGV2ZW50KSB7XG4gICAgICBjb25zdCB0YXJnZXRJbmRleCA9IHJlZ2lzdHJ5LnRhcmdldHMuaW5kZXhPZih0YXJnZXQpXG4gICAgICBpZiAodGFyZ2V0SW5kZXggPiAtMSkge1xuICAgICAgICByZWdpc3RyeS5ldmVudExpc3RlbmVyc1t0YXJnZXRJbmRleF1bZXZlbnRdLmZvckVhY2goaGFuZGxlciA9PiB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gcmVnaXN0cnkudGFyZ2V0cy5pbmRleE9mKHRhcmdldClcbiAgICAgIGlmICh0YXJnZXRJbmRleCA+IC0xKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzW3RhcmdldEluZGV4XSkuZm9yRWFjaChfZXZlbnQgPT4ge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCBfZXZlbnQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlZ2lzdHJ5LmV2ZW50TGlzdGVuZXJzKS5mb3JFYWNoKHRhcmdldEluZGV4ID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyhyZWdpc3RyeS50YXJnZXRzW3RhcmdldEluZGV4XSlcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8vIENsZWFyIGV2ZXJ5dGhpbmcgKHRvIGJlIGNhbGxlZCB1cG9uIGFwcCBjbG9zZSBmb3IgcHJvcGVyIGNsZWFudXApXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0cygpXG4gICAgdGhpcy5jbGVhckludGVydmFscygpXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpXG4gICAgcmVnaXN0cnkuZXZlbnRMaXN0ZW5lcnMgPSBbXVxuICAgIHJlZ2lzdHJ5LnRpbWVvdXRzID0gW11cbiAgICByZWdpc3RyeS5pbnRlcnZhbHMgPSBbXVxuICAgIHJlZ2lzdHJ5LnRhcmdldHMgPSBbXVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgeyBkZWZhdWx0IGFzIFJvdXRlciB9IGZyb20gJy4vaW5kZXgnXG5pbXBvcnQgeyByb3V0ZXJDb25maWcgfSBmcm9tICcuL3V0aWxzL3JvdXRlci5qcydcbmltcG9ydCB7IGlzQm9vbGVhbiB9IGZyb20gJy4vdXRpbHMvaGVscGVycydcblxuZXhwb3J0IGNsYXNzIFJvdXRlZEFwcCBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBQYWdlczoge1xuICAgICAgICBmb3JjZVpJbmRleENvbnRleHQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIGlzIGEgZGVmYXVsdCBMb2FkaW5nIHBhZ2UgdGhhdCB3aWxsIGJlIG1hZGUgdmlzaWJsZVxuICAgICAgICogZHVyaW5nIGRhdGEtcHJvdmlkZXIgb24oKSB5b3UgQ0FOIG92ZXJyaWRlIGluIGNoaWxkLWNsYXNzXG4gICAgICAgKi9cbiAgICAgIExvYWRpbmc6IHtcbiAgICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgICAgdzogMTkyMCxcbiAgICAgICAgaDogMTA4MCxcbiAgICAgICAgY29sb3I6IDB4ZmYwMDAwMDAsXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICB6SW5kZXg6IDk5LFxuICAgICAgICBMYWJlbDoge1xuICAgICAgICAgIG1vdW50OiAwLjUsXG4gICAgICAgICAgeDogOTYwLFxuICAgICAgICAgIHk6IDU0MCxcbiAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICB0ZXh0OiAnTG9hZGluZy4uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX3N0YXRlcygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgY2xhc3MgTG9hZGluZyBleHRlbmRzIHRoaXMge1xuICAgICAgICAkZW50ZXIoKSB7XG4gICAgICAgICAgdGhpcy50YWcoJ0xvYWRpbmcnKS52aXNpYmxlID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgJGV4aXQoKSB7XG4gICAgICAgICAgdGhpcy50YWcoJ0xvYWRpbmcnKS52aXNpYmxlID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsYXNzIFdpZGdldHMgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgJGVudGVyKGFyZ3MsIHdpZGdldCkge1xuICAgICAgICAgIC8vIHN0b3JlIHdpZGdldCByZWZlcmVuY2VcbiAgICAgICAgICB0aGlzLl93aWRnZXQgPSB3aWRnZXRcblxuICAgICAgICAgIC8vIHNpbmNlIGl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGJlaGF2aW91clxuICAgICAgICAgIC8vIGlzIG5vbi1yZW1vdGUgZHJpdmVuIHdlIGZvcmNlIGEgcmVjYWxjdWxhdGlvblxuICAgICAgICAgIC8vIG9mIHRoZSBmb2N1c3BhdGhcbiAgICAgICAgICB0aGlzLl9yZWZvY3VzKClcbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRGb2N1c2VkKCkge1xuICAgICAgICAgIC8vIHdlIGRlbGVnYXRlIGZvY3VzIHRvIHNlbGVjdGVkIHdpZGdldFxuICAgICAgICAgIC8vIHNvIGl0IGNhbiBjb25zdW1lIHJlbW90ZWNvbnRyb2wgcHJlc3Nlc1xuICAgICAgICAgIHJldHVybiB0aGlzLl93aWRnZXRcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdG8gd2lkZ2V0IHRvIHdpZGdldCBmb2N1cyBkZWxlZ2F0aW9uXG4gICAgICAgIHJlbG9hZCh3aWRnZXQpIHtcbiAgICAgICAgICB0aGlzLl93aWRnZXQgPSB3aWRnZXRcbiAgICAgICAgICB0aGlzLl9yZWZvY3VzKClcbiAgICAgICAgfVxuXG4gICAgICAgIF9oYW5kbGVLZXkoKSB7XG4gICAgICAgICAgY29uc3QgcmVzdG9yZUZvY3VzID0gcm91dGVyQ29uZmlnLmdldCgnYXV0b1Jlc3RvcmVSZW1vdGUnKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBSb3V0ZXIgdXNlZCB0byBkZWxlZ2F0ZSBmb2N1cyBiYWNrIHRvIHRoZSBwYWdlIGluc3RhbmNlIG9uXG4gICAgICAgICAgICogZXZlcnkgdW5oYW5kbGVkIGtleS4gVGhpcyBpcyBiYXJlbHkgdXNlZnVsbCBpbiBhbnkgc2l0dWF0aW9uXG4gICAgICAgICAgICogc28gZm9yIG5vdyB3ZSBvZmZlciB0aGUgb3B0aW9uIHRvIGV4cGxpY2l0eSB0dXJuIHRoYXQgYmVoYXZpb3VyIG9mZlxuICAgICAgICAgICAqIHNvIHdlIGRvbid0IGRvbid0IGludHJvZHVjZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoIWlzQm9vbGVhbihyZXN0b3JlRm9jdXMpIHx8IHJlc3RvcmVGb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgUm91dGVyLmZvY3VzUGFnZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIF1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gbG9jYXRpb24gd2hlcmUgcGFnZXMgbmVlZCB0byBiZSBzdG9yZWRcbiAgICovXG4gIGdldCBwYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy50YWcoJ1BhZ2VzJylcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxsIHJvdXRlciB3aGVyZSB3aWRnZXRzIGFyZSBzdG9yZWRcbiAgICovXG4gIGdldCB3aWRnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLnRhZygnV2lkZ2V0cycpXG4gIH1cblxuICAvKipcbiAgICogd2UgTVVTVCByZWdpc3RlciBfaGFuZGxlQmFjayBtZXRob2Qgc28gdGhlIFJvdXRlclxuICAgKiBjYW4gb3ZlcnJpZGUgaXRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVCYWNrKCkge31cblxuICAvKipcbiAgICogV2UgTVVTVCByZXR1cm4gUm91dGVyLmFjdGl2ZVBhZ2UoKSBzbyB0aGUgbmV3IFBhZ2VcbiAgICogY2FuIGxpc3RlbiB0byB0aGUgcmVtb3RlLWNvbnRyb2wuXG4gICAqL1xuICBfZ2V0Rm9jdXNlZCgpIHtcbiAgICByZXR1cm4gUm91dGVyLmdldEFjdGl2ZVBhZ2UoKVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBpc0Z1bmN0aW9uLFxuICBpc1BhZ2UsXG4gIGlzT2JqZWN0LFxuICBpc0Jvb2xlYW4sXG4gIGlzU3RyaW5nLFxuICBnZXRRdWVyeVN0cmluZ1BhcmFtcyxcbiAgc3ltYm9scyxcbiAgY2xlYW5IYXNoLFxufSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnXG5cbmltcG9ydCB7XG4gIGJvb3RSb3V0ZXIsXG4gIHJvdXRlRXhpc3RzLFxuICBnZXRSb290SGFzaCxcbiAgZ2V0Qm9vdFJlcXVlc3QsXG4gIG11c3RVcGRhdGVMb2NhdGlvbkhhc2gsXG4gIGdldENvbXBvbmVudCxcbiAgc3RvcmVDb21wb25lbnQsXG4gIHN0YWdlLFxuICBhcHAsXG4gIHJvdXRlckNvbmZpZyxcbiAgc2V0TGFzdEhhc2gsXG4gIGdldEFjdGl2ZVBhZ2UsXG4gIGJlZm9yZUVhY2hSb3V0ZSxcbiAgZ2V0QWN0aXZlSGFzaCxcbiAgZ2V0QWN0aXZlUm91dGUsXG59IGZyb20gJy4vdXRpbHMvcm91dGVyJ1xuXG5pbXBvcnQgeyBmb2N1c1dpZGdldCwgZ2V0QWN0aXZlV2lkZ2V0LCByZXN0b3JlRm9jdXMgfSBmcm9tICcuL3V0aWxzL3dpZGdldHMnXG5pbXBvcnQgeyBnZXRIaXN0b3J5LCBzZXRIaXN0b3J5LCBnZXRIaXN0b3J5U3RhdGUsIHJlcGxhY2VIaXN0b3J5U3RhdGUgfSBmcm9tICcuL3V0aWxzL2hpc3RvcnknXG5pbXBvcnQge1xuICBjcmVhdGVSZXF1ZXN0LFxuICBnZXRSb3V0ZUJ5SGFzaCxcbiAgZ2V0VmFsdWVzRnJvbUhhc2gsXG4gIGdldEZsb29yLFxuICBnZXRIYXNoQnlOYW1lLFxuICBrZWVwQWN0aXZlUGFnZUFsaXZlLFxufSBmcm9tICcuL3V0aWxzL3JvdXRlJ1xuaW1wb3J0IHsgbG9hZCB9IGZyb20gJy4vdXRpbHMvbG9hZGVyJ1xuaW1wb3J0IHsgc3RyaXBSZWdleCwgaXNXaWxkY2FyZCB9IGZyb20gJy4vdXRpbHMvcmVnZXgnXG5pbXBvcnQgeyBSb3V0ZWRBcHAgfSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgUmVnaXN0cnkgZnJvbSAnLi4vUmVnaXN0cnknXG5cbi8qXG5yb3VUaG9yID09W3hdXG4gKi9cbmV4cG9ydCBsZXQgbmF2aWdhdGVRdWV1ZSA9IG5ldyBNYXAoKVxubGV0IGZvcmNlZEhhc2ggPSAnJ1xubGV0IHJlc3VtZUhhc2ggPSAnJ1xuXG4vKipcbiAqIFN0YXJ0IHJvdXRpbmcgdGhlIGFwcFxuICogQHBhcmFtIGNvbmZpZyAtIHJvdXRlIGNvbmZpZyBvYmplY3RcbiAqIEBwYXJhbSBpbnN0YW5jZSAtIGluc3RhbmNlIG9mIHRoZSBhcHBcbiAqL1xuY29uc3Qgc3RhcnRSb3V0ZXIgPSAoY29uZmlnLCBpbnN0YW5jZSkgPT4ge1xuICBib290Um91dGVyKGNvbmZpZywgaW5zdGFuY2UpXG4gIHJlZ2lzdGVyTGlzdGVuZXIoKVxuICBzdGFydCgpXG59XG5cbi8vIHN0YXJ0IHRyYW5zbGF0aW5nIHVybFxuY29uc3Qgc3RhcnQgPSAoKSA9PiB7XG4gIGxldCBoYXNoID0gKGdldEhhc2goKSB8fCAnJykucmVwbGFjZSgvXiMvLCAnJylcbiAgY29uc3QgYm9vdEtleSA9ICckJ1xuICBjb25zdCBwYXJhbXMgPSBnZXRRdWVyeVN0cmluZ1BhcmFtcyhoYXNoKVxuICBjb25zdCBib290UmVxdWVzdCA9IGdldEJvb3RSZXF1ZXN0KClcbiAgY29uc3Qgcm9vdEhhc2ggPSBnZXRSb290SGFzaCgpXG4gIGNvbnN0IGlzRGlyZWN0TG9hZCA9IGhhc2guaW5kZXhPZihib290S2V5KSAhPT0gLTFcblxuICAvLyBwcmV2ZW50IGRpcmVjdCByZWxvYWQgb2Ygd2lsZGNhcmQgcm91dGVzXG4gIC8vIGV4cGVjdCBib290Q29tcG9uZW50XG4gIGlmIChpc1dpbGRjYXJkLnRlc3QoaGFzaCkgJiYgaGFzaCAhPT0gYm9vdEtleSkge1xuICAgIGhhc2ggPSAnJ1xuICB9XG5cbiAgLy8gc3RvcmUgcmVzdW1lIHBvaW50IGZvciBtYW51YWwgcmVzdW1lXG4gIHJlc3VtZUhhc2ggPSBpc0RpcmVjdExvYWQgPyByb290SGFzaCA6IGhhc2ggfHwgcm9vdEhhc2hcblxuICBjb25zdCByZWFkeSA9ICgpID0+IHtcbiAgICBpZiAoIWhhc2ggJiYgcm9vdEhhc2gpIHtcbiAgICAgIGlmIChpc1N0cmluZyhyb290SGFzaCkpIHtcbiAgICAgICAgbmF2aWdhdGUocm9vdEhhc2gpXG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocm9vdEhhc2gpKSB7XG4gICAgICAgIHJvb3RIYXNoKCkudGhlbihyZXMgPT4ge1xuICAgICAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgICAgICBuYXZpZ2F0ZShyZXMucGF0aCwgcmVzLnBhcmFtcylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmF2aWdhdGUocmVzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWUoaGFzaClcbiAgICAgIGhhbmRsZUhhc2hDaGFuZ2UoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpZiAocm91dGVFeGlzdHMoYm9vdEtleSkpIHtcbiAgICBpZiAoaGFzaCAmJiAhaXNEaXJlY3RMb2FkKSB7XG4gICAgICBpZiAoIWdldFJvdXRlQnlIYXNoKGhhc2gpKSB7XG4gICAgICAgIG5hdmlnYXRlKCcqJywgeyBmYWlsZWRIYXNoOiBoYXNoIH0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZShcbiAgICAgIGJvb3RLZXksXG4gICAgICB7XG4gICAgICAgIHJlc3VtZTogcmVzdW1lSGFzaCxcbiAgICAgICAgcmVsb2FkOiBib290S2V5ID09PSBoYXNoLFxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24oYm9vdFJlcXVlc3QpKSB7XG4gICAgYm9vdFJlcXVlc3QocGFyYW1zKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZWFkeSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICBoYW5kbGVCb290RXJyb3IoZSlcbiAgICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgcmVhZHkoKVxuICB9XG59XG5cbmNvbnN0IGhhbmRsZUJvb3RFcnJvciA9IGUgPT4ge1xuICBpZiAocm91dGVFeGlzdHMoJyEnKSkge1xuICAgIG5hdmlnYXRlKCchJywgeyByZXF1ZXN0OiB7IGVycm9yOiBlIH0gfSlcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGUpXG4gIH1cbn1cblxuLyoqXG4gKiBzdGFydCBhIG5ldyByZXF1ZXN0XG4gKiBAcGFyYW0gdXJsXG4gKiBAcGFyYW0gYXJnc1xuICogQHBhcmFtIHN0b3JlXG4gKi9cbmV4cG9ydCBjb25zdCBuYXZpZ2F0ZSA9ICh1cmwsIGFyZ3MgPSB7fSwgc3RvcmUpID0+IHtcbiAgaWYgKGlzT2JqZWN0KHVybCkpIHtcbiAgICB1cmwgPSBnZXRIYXNoQnlOYW1lKHVybClcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgbGV0IGhhc2ggPSBnZXRIYXNoKClcbiAgaWYgKCFtdXN0VXBkYXRlTG9jYXRpb25IYXNoKCkgJiYgZm9yY2VkSGFzaCkge1xuICAgIGhhc2ggPSBmb3JjZWRIYXNoXG4gIH1cbiAgaWYgKGhhc2gucmVwbGFjZSgvXiMvLCAnJykgIT09IHVybCkge1xuICAgIC8vIHB1c2ggcmVxdWVzdCBpbiB0aGUgcXVldWVcbiAgICBxdWV1ZSh1cmwsIGFyZ3MsIHN0b3JlKVxuXG4gICAgc2V0SGFzaCh1cmwpXG4gICAgaWYgKCFtdXN0VXBkYXRlTG9jYXRpb25IYXNoKCkpIHtcbiAgICAgIGZvcmNlZEhhc2ggPSB1cmxcbiAgICAgIGhhbmRsZUhhc2hDaGFuZ2UodXJsKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJncy5yZWxvYWQpIHtcbiAgICAvLyBwdXNoIHJlcXVlc3QgaW4gdGhlIHF1ZXVlXG4gICAgcXVldWUodXJsLCBhcmdzLCBzdG9yZSlcblxuICAgIGhhbmRsZUhhc2hDaGFuZ2UodXJsKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBhcHAuX3JlZm9jdXMoKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgfSlcbiAgfVxufVxuXG5jb25zdCBxdWV1ZSA9IChoYXNoLCBhcmdzID0ge30sIHN0b3JlKSA9PiB7XG4gIGhhc2ggPSBjbGVhbkhhc2goaGFzaClcbiAgaWYgKCFuYXZpZ2F0ZVF1ZXVlLmhhcyhoYXNoKSkge1xuICAgIGZvciAobGV0IHJlcXVlc3Qgb2YgbmF2aWdhdGVRdWV1ZS52YWx1ZXMoKSkge1xuICAgICAgcmVxdWVzdC5jYW5jZWwoKVxuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChoYXNoLCBhcmdzLCBzdG9yZSlcbiAgICBuYXZpZ2F0ZVF1ZXVlLnNldChkZWNvZGVVUklDb21wb25lbnQoaGFzaCksIHJlcXVlc3QpXG5cbiAgICByZXR1cm4gcmVxdWVzdFxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEhhbmRsZSBjaGFuZ2Ugb2YgaGFzaFxuICogQHBhcmFtIG92ZXJyaWRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3QgaGFuZGxlSGFzaENoYW5nZSA9IGFzeW5jIG92ZXJyaWRlID0+IHtcbiAgY29uc3QgaGFzaCA9IGNsZWFuSGFzaChvdmVycmlkZSB8fCBnZXRIYXNoKCkpXG4gIGNvbnN0IHF1ZXVlSWQgPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaClcbiAgbGV0IHJlcXVlc3QgPSBuYXZpZ2F0ZVF1ZXVlLmdldChxdWV1ZUlkKVxuXG4gIC8vIGhhbmRsZSBoYXNoIHVwZGF0ZWQgbWFudWFsbHlcbiAgaWYgKCFyZXF1ZXN0ICYmICFuYXZpZ2F0ZVF1ZXVlLnNpemUpIHtcbiAgICByZXF1ZXN0ID0gcXVldWUoaGFzaClcbiAgfVxuXG4gIGNvbnN0IHJvdXRlID0gZ2V0Um91dGVCeUhhc2goaGFzaClcblxuICBpZiAoIXJvdXRlKSB7XG4gICAgaWYgKHJvdXRlRXhpc3RzKCcqJykpIHtcbiAgICAgIG5hdmlnYXRlKCcqJywgeyBmYWlsZWRIYXNoOiBoYXNoIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFVuYWJsZSB0byBuYXZpZ2F0ZSB0bzogJHtoYXNofWApXG4gICAgfVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gdXBkYXRlIGN1cnJlbnQgcHJvY2Vzc2VkIHJlcXVlc3RcbiAgcmVxdWVzdC5oYXNoID0gaGFzaFxuICByZXF1ZXN0LnJvdXRlID0gcm91dGVcblxuICBsZXQgcmVzdWx0ID0gYXdhaXQgYmVmb3JlRWFjaFJvdXRlKGdldEFjdGl2ZUhhc2goKSwgcmVxdWVzdClcblxuICAvLyB0ZXN0IGlmIGEgbG9jYWwgaG9vayBpcyBjb25maWd1cmVkIGZvciB0aGUgcm91dGVcbiAgaWYgKHJvdXRlLmJlZm9yZU5hdmlnYXRlKSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgcm91dGUuYmVmb3JlTmF2aWdhdGUoZ2V0QWN0aXZlSGFzaCgpLCByZXF1ZXN0KVxuICB9XG5cbiAgaWYgKGlzQm9vbGVhbihyZXN1bHQpKSB7XG4gICAgLy8gb25seSBpZiByZXNvbHZlIHZhbHVlIGlzIGV4cGxpY2l0bHkgdHJ1ZVxuICAgIC8vIHdlIGNvbnRpbnVlIHRoZSBjdXJyZW50IHJvdXRlIHJlcXVlc3RcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZUhhc2hDaGFuZ2UocmVxdWVzdClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgbmF2aWdhdGlvbiBndWFyZCBkaWRuJ3QgcmV0dXJuIHRydWVcbiAgICAvLyB3ZSBjYW5jZWwgdGhlIGN1cnJlbnQgcmVxdWVzdFxuICAgIHJlcXVlc3QuY2FuY2VsKClcbiAgICBuYXZpZ2F0ZVF1ZXVlLmRlbGV0ZShxdWV1ZUlkKVxuXG4gICAgaWYgKGlzU3RyaW5nKHJlc3VsdCkpIHtcbiAgICAgIG5hdmlnYXRlKHJlc3VsdClcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBzdG9yZSA9IHRydWVcbiAgICAgIGlmIChpc0Jvb2xlYW4ocmVzdWx0LnN0b3JlKSkge1xuICAgICAgICBzdG9yZSA9IHJlc3VsdC5zdG9yZVxuICAgICAgfVxuICAgICAgbmF2aWdhdGUocmVzdWx0LnBhdGgsIHJlc3VsdC5wYXJhbXMsIHN0b3JlKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbnRpbnVlIHByb2Nlc3NpbmcgdGhlIGhhc2ggY2hhbmdlIGlmIG5vdCBibG9ja2VkXG4gKiBieSBnbG9iYWwgb3IgbG9jYWwgaG9va1xuICogQHBhcmFtIHJlcXVlc3QgLSB7fVxuICovXG5jb25zdCByZXNvbHZlSGFzaENoYW5nZSA9IHJlcXVlc3QgPT4ge1xuICBjb25zdCBoYXNoID0gcmVxdWVzdC5oYXNoXG4gIGNvbnN0IHJvdXRlID0gcmVxdWVzdC5yb3V0ZVxuICBjb25zdCBxdWV1ZUlkID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpXG4gIC8vIHN0b3JlIGxhc3QgcmVxdWVzdGVkIGhhc2ggc28gd2UgY2FuXG4gIC8vIHByZXZlbnQgYSByb3V0ZSB0aGF0IHJlc29sdmVkIGxhdGVyXG4gIC8vIGZyb20gZGlzcGxheWluZyBpdHNlbGZcbiAgc2V0TGFzdEhhc2goaGFzaClcblxuICBpZiAocm91dGUucGF0aCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldENvbXBvbmVudChyb3V0ZS5wYXRoKVxuICAgIC8vIGlmIGEgaG9vayBpcyBwcm92aWRlZCBmb3IgdGhlIGN1cnJlbnQgcm91dGVcbiAgICBpZiAoaXNGdW5jdGlvbihyb3V0ZS5ob29rKSkge1xuICAgICAgY29uc3QgdXJsUGFyYW1zID0gZ2V0VmFsdWVzRnJvbUhhc2goaGFzaCwgcm91dGUucGF0aClcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHt9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB1cmxQYXJhbXMua2V5cygpKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gdXJsUGFyYW1zLmdldChrZXkpXG4gICAgICB9XG4gICAgICByb3V0ZS5ob29rKGFwcCwgeyAuLi5wYXJhbXMgfSlcbiAgICB9XG4gICAgLy8gaWYgdGhlcmUgaXMgYSBjb21wb25lbnQgYXR0YWNoZWQgdG8gdGhlIHJvdXRlXG4gICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgLy8gZm9yY2UgcGFnZSB0byByb290IHN0YXRlIHRvIHByZXZlbnQgc2hhcmVkIHN0YXRlIGlzc3Vlc1xuICAgICAgY29uc3QgYWN0aXZlUGFnZSA9IGdldEFjdGl2ZVBhZ2UoKVxuICAgICAgaWYgKGFjdGl2ZVBhZ2UpIHtcbiAgICAgICAgY29uc3Qga2VlcEFsaXZlID0ga2VlcEFjdGl2ZVBhZ2VBbGl2ZShnZXRBY3RpdmVSb3V0ZSgpLCByZXF1ZXN0KVxuICAgICAgICBpZiAoYWN0aXZlUGFnZSAmJiByb3V0ZS5wYXRoID09PSBnZXRBY3RpdmVSb3V0ZSgpICYmICFrZWVwQWxpdmUpIHtcbiAgICAgICAgICBhY3RpdmVQYWdlLl9zZXRTdGF0ZSgnJylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNQYWdlKGNvbXBvbmVudCwgc3RhZ2UpKSB7XG4gICAgICAgIGxvYWQocmVxdWVzdCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgICBuYXZpZ2F0ZVF1ZXVlLmRlbGV0ZShxdWV1ZUlkKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb2YgdGhlIGNvbXBvbmVudCBpcyBub3QgYSBjb25zdHJ1Y3RvclxuICAgICAgICAvLyBvciBhIENvbXBvbmVudCBpbnN0YW5jZSB3ZSBjYW4gYXNzdW1lXG4gICAgICAgIC8vIHRoYXQgaXQncyBhIGR5bmFtaWMgaW1wb3J0XG4gICAgICAgIGNvbXBvbmVudCgpXG4gICAgICAgICAgLnRoZW4oY29udGVudHMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRzLmRlZmF1bHRcbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKG1vZHVsZSA9PiB7XG4gICAgICAgICAgICBzdG9yZUNvbXBvbmVudChyb3V0ZS5wYXRoLCBtb2R1bGUpXG4gICAgICAgICAgICByZXR1cm4gbG9hZChyZXF1ZXN0KVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgYXBwLl9yZWZvY3VzKClcbiAgICAgICAgICAgIG5hdmlnYXRlUXVldWUuZGVsZXRlKHF1ZXVlSWQpXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbmF2aWdhdGVRdWV1ZS5kZWxldGUocXVldWVJZClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXJlY3Rpb25hbCBzdGVwIGluIGhpc3RvcnlcbiAqIEBwYXJhbSBkaXJlY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHN0ZXAgPSAobGV2ZWwgPSAwKSA9PiB7XG4gIGlmICghbGV2ZWwgfHwgaXNOYU4obGV2ZWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgY29uc3QgaGlzdG9yeSA9IGdldEhpc3RvcnkoKVxuICAvLyBmb3Igbm93IHdlIG9ubHkgc3VwcG9ydCBuZWdhdGl2ZSBudW1iZXJzXG4gIGxldmVsID0gTWF0aC5hYnMobGV2ZWwpXG5cbiAgLy8gd2UgY2FuJ3Qgc3RlcCBiYWNrIHBhc3QgdGhlIGFtb3VudFxuICAvLyBvZiBoaXN0b3J5IGVudHJpZXNcbiAgaWYgKGxldmVsID4gaGlzdG9yeS5sZW5ndGgpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihhcHAuX2hhbmRsZUFwcENsb3NlKSkge1xuICAgICAgcmV0dXJuIGFwcC5faGFuZGxlQXBwQ2xvc2UoKVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChoaXN0b3J5Lmxlbmd0aCkge1xuICAgIC8vIGZvciBub3cgd2Ugb25seSBzdXBwb3J0IGhpc3RvcnkgYmFja1xuICAgIGNvbnN0IHJvdXRlID0gaGlzdG9yeS5zcGxpY2UoaGlzdG9yeS5sZW5ndGggLSBsZXZlbCwgbGV2ZWwpWzBdXG4gICAgLy8gc3RvcmUgY2hhbmdlZCBoaXN0b3J5XG4gICAgc2V0SGlzdG9yeShoaXN0b3J5KVxuICAgIHJldHVybiBuYXZpZ2F0ZShcbiAgICAgIHJvdXRlLmhhc2gsXG4gICAgICB7XG4gICAgICAgIFtzeW1ib2xzLmJhY2t0cmFja106IHRydWUsXG4gICAgICAgIFtzeW1ib2xzLmhpc3RvcnlTdGF0ZV06IHJvdXRlLnN0YXRlLFxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKVxuICB9IGVsc2UgaWYgKHJvdXRlckNvbmZpZy5nZXQoJ2JhY2t0cmFjaycpKSB7XG4gICAgY29uc3QgaGFzaExhc3RQYXJ0ID0gLyhcXC86P1tcXHclXFxzLV0rKSQvXG4gICAgbGV0IGhhc2ggPSBzdHJpcFJlZ2V4KGdldEhhc2goKSlcbiAgICBsZXQgZmxvb3IgPSBnZXRGbG9vcihoYXNoKVxuXG4gICAgLy8gdGVzdCBpZiB3ZSBnb3QgZGVlcC1saW5rZWRcbiAgICBpZiAoZmxvb3IgPiAxKSB7XG4gICAgICB3aGlsZSAoZmxvb3ItLSkge1xuICAgICAgICAvLyBzdHJpcCBvZiBsYXN0IHBhcnRcbiAgICAgICAgaGFzaCA9IGhhc2gucmVwbGFjZShoYXNoTGFzdFBhcnQsICcnKVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY29uZmlndXJlZCByb3V0ZVxuICAgICAgICAvLyB3ZSBuYXZpZ2F0ZSB0byBpdFxuICAgICAgICBpZiAoZ2V0Um91dGVCeUhhc2goaGFzaCkpIHtcbiAgICAgICAgICByZXR1cm4gbmF2aWdhdGUoaGFzaCwgeyBbc3ltYm9scy5iYWNrdHJhY2tdOiB0cnVlIH0sIGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFJlc3VtZSBSb3V0ZXIncyBwYWdlIGxvYWRpbmcgcHJvY2VzcyBhZnRlclxuICogdGhlIEJvb3RDb21wb25lbnQgYmVjYW1lIHZpc2libGU7XG4gKi9cbmNvbnN0IHJlc3VtZSA9ICgpID0+IHtcbiAgaWYgKGlzU3RyaW5nKHJlc3VtZUhhc2gpKSB7XG4gICAgbmF2aWdhdGUocmVzdW1lSGFzaCwgZmFsc2UpXG4gICAgcmVzdW1lSGFzaCA9ICcnXG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihyZXN1bWVIYXNoKSkge1xuICAgIHJlc3VtZUhhc2goKS50aGVuKHJlcyA9PiB7XG4gICAgICByZXN1bWVIYXNoID0gJydcbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIG5hdmlnYXRlKHJlcy5wYXRoLCByZXMucGFyYW1zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmF2aWdhdGUocmVzKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdbUm91dGVyXTogcmVzdW1lKCkgY2FsbGVkIGJ1dCBubyBoYXNoIGZvdW5kJylcbiAgfVxufVxuXG4vKipcbiAqIEZvcmNlIHJlbG9hZCBhY3RpdmUgaGFzaFxuICovXG5jb25zdCByZWxvYWQgPSAoKSA9PiB7XG4gIGlmICghaXNOYXZpZ2F0aW5nKCkpIHtcbiAgICBjb25zdCBoYXNoID0gZ2V0QWN0aXZlSGFzaCgpXG4gICAgbmF2aWdhdGUoaGFzaCwgeyByZWxvYWQ6IHRydWUgfSwgZmFsc2UpXG4gIH1cbn1cblxuLyoqXG4gKiBRdWVyeSBpZiB0aGUgUm91dGVyIGlzIHN0aWxsIHByb2Nlc3NpbmcgYSBSZXF1ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNOYXZpZ2F0aW5nID0gKCkgPT4ge1xuICBpZiAobmF2aWdhdGVRdWV1ZS5zaXplKSB7XG4gICAgbGV0IGlzUHJvY2Vzc2luZyA9IGZhbHNlXG4gICAgZm9yIChsZXQgcmVxdWVzdCBvZiBuYXZpZ2F0ZVF1ZXVlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoIXJlcXVlc3QuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNQcm9jZXNzaW5nXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRSZXN1bWVIYXNoID0gKCkgPT4ge1xuICByZXR1cm4gcmVzdW1lSGFzaFxufVxuXG4vKipcbiAqIEJ5IGRlZmF1bHQgd2UgcmV0dXJuIHRoZSBsb2NhdGlvbiBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5sZXQgZ2V0SGFzaCA9ICgpID0+IHtcbiAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhhc2hcbn1cblxuLyoqXG4gKiBVcGRhdGUgbG9jYXRpb24gaGFzaFxuICogQHBhcmFtIHVybFxuICovXG5sZXQgc2V0SGFzaCA9IHVybCA9PiB7XG4gIGRvY3VtZW50LmxvY2F0aW9uLmhhc2ggPSB1cmxcbn1cblxuLyoqXG4gKiBUaGlzIGNhbiBiZSBjYWxsZWQgZnJvbSB0aGUgcGxhdGZvcm0gLyBib290c3RyYXBwZXIgdG8gb3ZlcnJpZGVcbiAqIHRoZSBkZWZhdWx0IGdldHRpbmcgYW5kIHNldHRpbmcgb2YgdGhlIGhhc2hcbiAqIEBwYXJhbSBjb25maWdcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRSb3V0ZXIgPSBjb25maWcgPT4ge1xuICBpZiAoY29uZmlnLmdldEhhc2gpIHtcbiAgICBnZXRIYXNoID0gY29uZmlnLmdldEhhc2hcbiAgfVxuICBpZiAoY29uZmlnLnNldEhhc2gpIHtcbiAgICBzZXRIYXNoID0gY29uZmlnLnNldEhhc2hcbiAgfVxufVxuXG4vKipcbiAqIE9uIGhhc2ggY2hhbmdlIHdlIHN0YXJ0IHByb2Nlc3NpbmdcbiAqL1xuY29uc3QgcmVnaXN0ZXJMaXN0ZW5lciA9ICgpID0+IHtcbiAgUmVnaXN0cnkuYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csICdoYXNoY2hhbmdlJywgYXN5bmMgKCkgPT4ge1xuICAgIGlmIChtdXN0VXBkYXRlTG9jYXRpb25IYXNoKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUhhc2hDaGFuZ2UoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIE5hdmlnYXRlIHRvIHJvb3QgaGFzaFxuICovXG5jb25zdCByb290ID0gKCkgPT4ge1xuICBjb25zdCByb290SGFzaCA9IGdldFJvb3RIYXNoKClcbiAgaWYgKGlzU3RyaW5nKHJvb3RIYXNoKSkge1xuICAgIG5hdmlnYXRlKHJvb3RIYXNoKVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocm9vdEhhc2gpKSB7XG4gICAgcm9vdEhhc2goKS50aGVuKHJlcyA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICBuYXZpZ2F0ZShyZXMucGF0aCwgcmVzLnBhcmFtcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hdmlnYXRlKHJlcylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8vIGV4cG9ydCBBUElcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc3RhcnRSb3V0ZXIsXG4gIG5hdmlnYXRlLFxuICByZXN1bWUsXG4gIHN0ZXAsXG4gIGdvOiBzdGVwLFxuICBiYWNrOiBzdGVwLmJpbmQobnVsbCwgLTEpLFxuICBhY3RpdmVQYWdlOiBnZXRBY3RpdmVQYWdlLFxuICBnZXRBY3RpdmVQYWdlKCkge1xuICAgIC8vIHdhcm5pbmdcbiAgICByZXR1cm4gZ2V0QWN0aXZlUGFnZSgpXG4gIH0sXG4gIGdldEFjdGl2ZVJvdXRlLFxuICBnZXRBY3RpdmVIYXNoLFxuICBmb2N1c1dpZGdldCxcbiAgZ2V0QWN0aXZlV2lkZ2V0LFxuICByZXN0b3JlRm9jdXMsXG4gIGlzTmF2aWdhdGluZyxcbiAgZ2V0SGlzdG9yeSxcbiAgc2V0SGlzdG9yeSxcbiAgZ2V0SGlzdG9yeVN0YXRlLFxuICByZXBsYWNlSGlzdG9yeVN0YXRlLFxuICBnZXRRdWVyeVN0cmluZ1BhcmFtcyxcbiAgcmVsb2FkLFxuICBzeW1ib2xzLFxuICBBcHA6IFJvdXRlZEFwcCxcbiAgLy8ga2VlcCBiYWNrd2FyZHMgY29tcGF0aWJsZVxuICBmb2N1c1BhZ2U6IHJlc3RvcmVGb2N1cyxcbiAgcm9vdDogcm9vdCxcbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgYXBpIG1ldGhvZHNcbiAgICovXG4gIHNldHVwUm91dGVzKCkge1xuICAgIGNvbnNvbGUud2FybignUm91dGVyOiBzZXR1cFJvdXRlcyBpcyBkZXByZWNhdGVkLCBjb25zb2xpZGF0ZSB5b3VyIGNvbmZpZ3VyYXRpb24nKVxuICAgIGNvbnNvbGUud2FybignaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9yb3V0ZXIvY29uZmlndXJhdGlvbicpXG4gIH0sXG4gIG9uKCkge1xuICAgIGNvbnNvbGUud2FybignUm91dGVyLm9uKCkgaXMgZGVwcmVjYXRlZCwgY29uc29saWRhdGUgeW91ciBjb25maWd1cmF0aW9uJylcbiAgICBjb25zb2xlLndhcm4oJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvcm91dGVyL2NvbmZpZ3VyYXRpb24nKVxuICB9LFxuICBiZWZvcmUoKSB7XG4gICAgY29uc29sZS53YXJuKCdSb3V0ZXIuYmVmb3JlKCkgaXMgZGVwcmVjYXRlZCwgY29uc29saWRhdGUgeW91ciBjb25maWd1cmF0aW9uJylcbiAgICBjb25zb2xlLndhcm4oJ2h0dHBzOi8vcmRrY2VudHJhbC5naXRodWIuaW8vTGlnaHRuaW5nLVNESy8jL3BsdWdpbnMvcm91dGVyL2NvbmZpZ3VyYXRpb24nKVxuICB9LFxuICBhZnRlcigpIHtcbiAgICBjb25zb2xlLndhcm4oJ1JvdXRlci5hZnRlcigpIGlzIGRlcHJlY2F0ZWQsIGNvbnNvbGlkYXRlIHlvdXIgY29uZmlndXJhdGlvbicpXG4gICAgY29uc29sZS53YXJuKCdodHRwczovL3Jka2NlbnRyYWwuZ2l0aHViLmlvL0xpZ2h0bmluZy1TREsvIy9wbHVnaW5zL3JvdXRlci9jb25maWd1cmF0aW9uJylcbiAgfSxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNPYmplY3QsIHN5bWJvbHMgfSBmcm9tICcuLi91dGlscy9oZWxwZXJzJ1xuaW1wb3J0IHsgY3JlYXRlUmVnaXN0ZXIgfSBmcm9tICcuLi91dGlscy9yZWdpc3RlcidcbmltcG9ydCBMb2cgZnJvbSAnLi4vLi4vTG9nJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IoaGFzaCA9ICcnLCBuYXZBcmdzLCBzdG9yZUNhbGxlcikge1xuICAgIC8qKlxuICAgICAqIEhhc2ggd2UgbmF2aWdhdGUgdG9cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faGFzaCA9IGhhc2hcblxuICAgIC8qKlxuICAgICAqIERvIHdlIHN0b3JlIHByZXZpb3VzIGhhc2ggaW4gaGlzdG9yeVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmVDYWxsZXIgPSBzdG9yZUNhbGxlclxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhbmQgbmF2aWdhdGUgZGF0YVxuICAgICAqIEB0eXBlIHtNYXB9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZWdpc3RlciA9IG5ldyBNYXAoKVxuXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB0aGUgaW5zdGFuY2UgaXMgY3JlYXRlZCBkdWUgdG9cbiAgICAgKiB0aGlzIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzQ3JlYXRlZCA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBGbGFnIGlmIHRoZSBpbnN0YW5jZSBpcyBzaGFyZWQgYmV0d2VlblxuICAgICAqIHByZXZpb3VzIGFuZCBjdXJyZW50IHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2lzU2hhcmVkSW5zdGFuY2UgPSBmYWxzZVxuXG4gICAgLyoqXG4gICAgICogRmxhZyBpZiB0aGUgcmVxdWVzdCBoYXMgYmVlbiBjYW5jZWxsZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NhbmNlbGxlZCA9IGZhbHNlXG5cbiAgICAvKipcbiAgICAgKiBpZiBpbnN0YW5jZSBpcyBzaGFyZWQgYmV0d2VlbiByZXF1ZXN0cyB3ZSBjb3B5IHN0YXRlIG9iamVjdFxuICAgICAqIGZyb20gaW5zdGFuY2UgYmVmb3JlIHRoZSBuZXcgcmVxdWVzdCBvdmVycmlkZXMgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NvcGllZEhpc3RvcnlTdGF0ZSA9IG51bGxcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBhcmd1bWVudHMgYXR0YWNoZWQgdG8gbmF2aWdhdGUoKVxuICAgIC8vIHdlIHN0b3JlIHRoZW0gaW4gbmV3IHJlcXVlc3RcbiAgICBpZiAoaXNPYmplY3QobmF2QXJncykpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyID0gY3JlYXRlUmVnaXN0ZXIobmF2QXJncylcbiAgICB9IGVsc2UgaWYgKGlzQm9vbGVhbihuYXZBcmdzKSkge1xuICAgICAgLy8gaWYgc2Vjb25kIG5hdmlnYXRlKCkgYXJndW1lbnQgaXMgZXhwbGljaXRseVxuICAgICAgLy8gc2V0IHRvIGZhbHNlIHdlIHByZXZlbnQgdGhlIGNhbGxpbmcgcGFnZVxuICAgICAgLy8gZnJvbSBlbmRpbmcgdXAgaW4gaGlzdG9yeVxuICAgICAgdGhpcy5fc3RvcmVDYWxsZXIgPSBuYXZBcmdzXG4gICAgfVxuICAgIC8vIEB0b2RvOiByZW1vdmUgYmVjYXVzZSB3ZSBjYW4gc2ltcGx5IGNoZWNrXG4gICAgLy8gLl9zdG9yZUNhbGxlciBwcm9wZXJ0eVxuICAgIHRoaXMuX3JlZ2lzdGVyLnNldChzeW1ib2xzLnN0b3JlLCB0aGlzLl9zdG9yZUNhbGxlcilcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBMb2cuZGVidWcoJ1tyb3V0ZXJdOicsIGBjYW5jZWxsZWQgJHt0aGlzLl9oYXNofWApXG4gICAgdGhpcy5fY2FuY2VsbGVkID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzaFxuICB9XG5cbiAgZ2V0IHJlZ2lzdGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWdpc3RlclxuICB9XG5cbiAgZ2V0IGhhc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc2hcbiAgfVxuXG4gIHNldCBoYXNoKGFyZ3MpIHtcbiAgICB0aGlzLl9oYXNoID0gYXJnc1xuICB9XG5cbiAgZ2V0IHJvdXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3V0ZVxuICB9XG5cbiAgc2V0IHJvdXRlKGFyZ3MpIHtcbiAgICB0aGlzLl9yb3V0ZSA9IGFyZ3NcbiAgfVxuXG4gIGdldCBwcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJcbiAgfVxuXG4gIHNldCBwcm92aWRlcihhcmdzKSB7XG4gICAgdGhpcy5fcHJvdmlkZXIgPSBhcmdzXG4gIH1cblxuICBnZXQgcHJvdmlkZXJUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm92aWRlclR5cGVcbiAgfVxuXG4gIHNldCBwcm92aWRlclR5cGUoYXJncykge1xuICAgIHRoaXMuX3Byb3ZpZGVyVHlwZSA9IGFyZ3NcbiAgfVxuXG4gIHNldCBwYWdlKGFyZ3MpIHtcbiAgICB0aGlzLl9wYWdlID0gYXJnc1xuICB9XG5cbiAgZ2V0IHBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VcbiAgfVxuXG4gIHNldCBpc0NyZWF0ZWQoYXJncykge1xuICAgIHRoaXMuX2lzQ3JlYXRlZCA9IGFyZ3NcbiAgfVxuXG4gIGdldCBpc0NyZWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzQ3JlYXRlZFxuICB9XG5cbiAgZ2V0IGlzU2hhcmVkSW5zdGFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hhcmVkSW5zdGFuY2VcbiAgfVxuXG4gIHNldCBpc1NoYXJlZEluc3RhbmNlKGFyZ3MpIHtcbiAgICB0aGlzLl9pc1NoYXJlZEluc3RhbmNlID0gYXJnc1xuICB9XG5cbiAgZ2V0IGlzQ2FuY2VsbGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW5jZWxsZWRcbiAgfVxuXG4gIHNldCBjb3BpZWRIaXN0b3J5U3RhdGUodikge1xuICAgIHRoaXMuX2NvcGllZEhpc3RvcnlTdGF0ZSA9IHZcbiAgfVxuXG4gIGdldCBjb3BpZWRIaXN0b3J5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvcGllZEhpc3RvcnlTdGF0ZVxuICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvaGVscGVycydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUm91dGUge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIC8vIGtlZXAgYmFja3dhcmRzIGNvbXBhdGlibGVcbiAgICBsZXQgdHlwZSA9IFsnb24nLCAnYmVmb3JlJywgJ2FmdGVyJ10ucmVkdWNlKChhY2MsIHR5cGUpID0+IHtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZ1t0eXBlXSkgPyB0eXBlIDogYWNjXG4gICAgfSwgdW5kZWZpbmVkKVxuXG4gICAgdGhpcy5fY2ZnID0gY29uZmlnXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHRoaXMuX3Byb3ZpZGVyID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICByZXF1ZXN0OiBjb25maWdbdHlwZV0sXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NmZy5wYXRoXG4gIH1cblxuICBnZXQgY29tcG9uZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuY29tcG9uZW50XG4gIH1cblxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2ZnLm9wdGlvbnNcbiAgfVxuXG4gIGdldCB3aWRnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcud2lkZ2V0c1xuICB9XG5cbiAgZ2V0IGNhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuY2FjaGVcbiAgfVxuXG4gIGdldCBob29rKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuaG9va1xuICB9XG5cbiAgZ2V0IGJlZm9yZU5hdmlnYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jZmcuYmVmb3JlTmF2aWdhdGVcbiAgfVxuXG4gIGdldCBwcm92aWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvdmlkZXJcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY29uc3QgZmFkZSA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBpLnBhdGNoKHtcbiAgICAgIGFscGhhOiAwLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIHNtb290aDoge1xuICAgICAgICBhbHBoYTogWzEsIHsgZHVyYXRpb246IDAuNSwgZGVsYXk6IDAuMSB9XSxcbiAgICAgIH0sXG4gICAgfSlcbiAgICAvLyByZXNvbHZlIG9uIHkgZmluaXNoXG4gICAgaS50cmFuc2l0aW9uKCdhbHBoYScpLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBpZiAobykge1xuICAgICAgICBvLnZpc2libGUgPSBmYWxzZVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpXG4gICAgfSlcbiAgfSlcbn1cblxuY29uc3QgY3Jvc3NGYWRlID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGkucGF0Y2goe1xuICAgICAgYWxwaGE6IDAsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIGFscGhhOiBbMSwgeyBkdXJhdGlvbjogMC41LCBkZWxheTogMC4xIH1dLFxuICAgICAgfSxcbiAgICB9KVxuICAgIGlmIChvKSB7XG4gICAgICBvLnBhdGNoKHtcbiAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgYWxwaGE6IFswLCB7IGR1cmF0aW9uOiAwLjUsIGRlbGF5OiAwLjMgfV0sXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cbiAgICAvLyByZXNvbHZlIG9uIHkgZmluaXNoXG4gICAgaS50cmFuc2l0aW9uKCdhbHBoYScpLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxufVxuXG5jb25zdCBtb3ZlT25BeGVzID0gKGF4aXMsIGRpcmVjdGlvbiwgaSwgbykgPT4ge1xuICBjb25zdCBib3VuZHMgPSBheGlzID09PSAneCcgPyAxOTIwIDogMTA4MFxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgaS5wYXRjaCh7XG4gICAgICBbYCR7YXhpc31gXTogZGlyZWN0aW9uID8gYm91bmRzICogLTEgOiBib3VuZHMsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgc21vb3RoOiB7XG4gICAgICAgIFtgJHtheGlzfWBdOiBbMCwgeyBkdXJhdGlvbjogMC40LCBkZWxheTogMC4yIH1dLFxuICAgICAgfSxcbiAgICB9KVxuICAgIC8vIG91dCBpcyBvcHRpb25hbFxuICAgIGlmIChvKSB7XG4gICAgICBvLnBhdGNoKHtcbiAgICAgICAgW2Ake2F4aXN9YF06IDAsXG4gICAgICAgIHNtb290aDoge1xuICAgICAgICAgIFtgJHtheGlzfWBdOiBbZGlyZWN0aW9uID8gYm91bmRzIDogYm91bmRzICogLTEsIHsgZHVyYXRpb246IDAuNCwgZGVsYXk6IDAuMiB9XSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfVxuICAgIC8vIHJlc29sdmUgb24geSBmaW5pc2hcbiAgICBpLnRyYW5zaXRpb24oYXhpcykub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gIH0pXG59XG5cbmNvbnN0IHVwID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG1vdmVPbkF4ZXMoJ3knLCAwLCBpLCBvKVxufVxuXG5jb25zdCBkb3duID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG1vdmVPbkF4ZXMoJ3knLCAxLCBpLCBvKVxufVxuXG5jb25zdCBsZWZ0ID0gKGksIG8pID0+IHtcbiAgcmV0dXJuIG1vdmVPbkF4ZXMoJ3gnLCAwLCBpLCBvKVxufVxuXG5jb25zdCByaWdodCA9IChpLCBvKSA9PiB7XG4gIHJldHVybiBtb3ZlT25BeGVzKCd4JywgMSwgaSwgbylcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBmYWRlLFxuICBjcm9zc0ZhZGUsXG4gIHVwLFxuICBkb3duLFxuICBsZWZ0LFxuICByaWdodCxcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldFJlZmVyZW5jZXMgfSBmcm9tICcuL3dpZGdldHMnXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVDb21wb25lbnQgPSAoc3RhZ2UsIHR5cGUpID0+IHtcbiAgcmV0dXJuIHN0YWdlLmMoe1xuICAgIHR5cGUsXG4gICAgdmlzaWJsZTogZmFsc2UsXG4gICAgd2lkZ2V0czogZ2V0UmVmZXJlbmNlcygpLFxuICB9KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNBcnJheSwgaXNGdW5jdGlvbiwgdWNmaXJzdCB9IGZyb20gJy4vaGVscGVycydcblxuZXhwb3J0IGRlZmF1bHQgKHBhZ2UsIGV2ZW50cyA9IFtdLCBwYXJhbXMgPSB7fSkgPT4ge1xuICBpZiAoIWlzQXJyYXkoZXZlbnRzKSkge1xuICAgIGV2ZW50cyA9IFtldmVudHNdXG4gIH1cbiAgZXZlbnRzLmZvckVhY2goZSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBgX29uJHt1Y2ZpcnN0KGUpfWBcbiAgICBpZiAoaXNGdW5jdGlvbihwYWdlW2V2ZW50XSkpIHtcbiAgICAgIHBhZ2VbZXZlbnRdKHBhcmFtcylcbiAgICB9XG4gIH0pXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGlnaHRuaW5nIGZyb20gJy4uLy4uL0xpZ2h0bmluZydcbmltcG9ydCBTZXR0aW5ncyBmcm9tICcuLi8uLi9TZXR0aW5ncydcbmltcG9ydCB7IGdldEFjdGl2ZUhhc2ggfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IGdldFJlc3VtZUhhc2ggfSBmcm9tICcuLi9pbmRleCdcblxuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSB2ID0+IHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nXG59XG5cbmV4cG9ydCBjb25zdCBpc09iamVjdCA9IHYgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdvYmplY3QnICYmIHYgIT09IG51bGxcbn1cblxuZXhwb3J0IGNvbnN0IGlzQm9vbGVhbiA9IHYgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdib29sZWFuJ1xufVxuXG5leHBvcnQgY29uc3QgaXNQYWdlID0gdiA9PiB7XG4gIGlmICh2IGluc3RhbmNlb2YgTGlnaHRuaW5nLkVsZW1lbnQgfHwgaXNDb21wb25lbnRDb25zdHJ1Y3Rvcih2KSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBpc0NvbXBvbmVudENvbnN0cnVjdG9yID0gdHlwZSA9PiB7XG4gIHJldHVybiB0eXBlLnByb3RvdHlwZSAmJiAnaXNDb21wb25lbnQnIGluIHR5cGUucHJvdG90eXBlXG59XG5cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gdiA9PiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHYpXG59XG5cbmV4cG9ydCBjb25zdCB1Y2ZpcnN0ID0gdiA9PiB7XG4gIHJldHVybiBgJHt2LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7di5zbGljZSgxKX1gXG59XG5cbmV4cG9ydCBjb25zdCBpc1N0cmluZyA9IHYgPT4ge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXG59XG5cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSBtZXRob2QgPT4ge1xuICBsZXQgcmVzdWx0XG4gIGlmIChpc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KG51bGwpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBtZXRob2RcbiAgfVxuICByZXR1cm4gaXNPYmplY3QocmVzdWx0KSAmJiBpc0Z1bmN0aW9uKHJlc3VsdC50aGVuKVxufVxuXG5leHBvcnQgY29uc3QgY2xlYW5IYXNoID0gKGhhc2ggPSAnJykgPT4ge1xuICByZXR1cm4gaGFzaC5yZXBsYWNlKC9eIy8sICcnKS5yZXBsYWNlKC9cXC8rJC8sICcnKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29uZmlnTWFwID0gKCkgPT4ge1xuICBjb25zdCByb3V0ZXJTZXR0aW5ncyA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAncm91dGVyJylcbiAgY29uc3QgaXNPYmogPSBpc09iamVjdChyb3V0ZXJTZXR0aW5ncylcbiAgcmV0dXJuIFtcbiAgICAnYmFja3RyYWNrJyxcbiAgICAnZ2NPblVubG9hZCcsXG4gICAgJ2Rlc3Ryb3lPbkhpc3RvcnlCYWNrJyxcbiAgICAnbGF6eUNyZWF0ZScsXG4gICAgJ2xhenlEZXN0cm95JyxcbiAgICAncmV1c2VJbnN0YW5jZScsXG4gICAgJ2F1dG9SZXN0b3JlUmVtb3RlJyxcbiAgICAnbnVtYmVyTmF2aWdhdGlvbicsXG4gICAgJ3VwZGF0ZUhhc2gnLFxuICAgICdzdG9yZVNhbWVIYXNoJyxcbiAgXS5yZWR1Y2UoKGNvbmZpZywga2V5KSA9PiB7XG4gICAgY29uZmlnLnNldChrZXksIGlzT2JqID8gcm91dGVyU2V0dGluZ3Nba2V5XSA6IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCBrZXkpKVxuICAgIHJldHVybiBjb25maWdcbiAgfSwgbmV3IE1hcCgpKVxufVxuXG5leHBvcnQgY29uc3QgaW5jb3JyZWN0UGFyYW1zID0gKGNiLCByb3V0ZSkgPT4ge1xuICBjb25zdCBpc0luY29ycmVjdCA9IC9eXFx3Kj9cXHM/XFwoXFxzP1xcey4qP1xcfVxccz9cXCkvaVxuICBpZiAoaXNJbmNvcnJlY3QudGVzdChjYi50b1N0cmluZygpKSkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIFtcbiAgICAgICAgYERFUFJFQ0FUSU9OOiBUaGUgZGF0YS1wcm92aWRlciBmb3Igcm91dGU6ICR7cm91dGV9IGlzIG5vdCBjb3JyZWN0LmAsXG4gICAgICAgICdcInBhZ2VcIiBpcyBubyBsb25nZXIgYSBwcm9wZXJ0eSBvZiB0aGUgcGFyYW1zIG9iamVjdCBidXQgaXMgbm93IHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXI6ICcsXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vcmRrY2VudHJhbC9MaWdodG5pbmctU0RLL2Jsb2IvZmVhdHVyZS9yb3V0ZXIvZG9jcy9wbHVnaW5zL3JvdXRlci9kYXRhcHJvdmlkaW5nLm1kI2RhdGEtcHJvdmlkaW5nJyxcbiAgICAgICAgXCJJdCdzIHN1cHBvcnRlZCBmb3Igbm93IGJ1dCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIixcbiAgICAgIF0uam9pbignXFxuJylcbiAgICApXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGNvbnN0IGdldFF1ZXJ5U3RyaW5nUGFyYW1zID0gKGhhc2ggPSBnZXRBY3RpdmVIYXNoKCkpID0+IHtcbiAgY29uc3QgcmVzdW1lSGFzaCA9IGdldFJlc3VtZUhhc2goKVxuICBpZiAoKGhhc2ggPT09ICckJyB8fCAhaGFzaCkgJiYgcmVzdW1lSGFzaCkge1xuICAgIGlmIChpc1N0cmluZyhyZXN1bWVIYXNoKSkge1xuICAgICAgaGFzaCA9IHJlc3VtZUhhc2hcbiAgICB9XG4gIH1cblxuICBsZXQgcGFyc2UgPSAnJ1xuICBjb25zdCBnZXRRdWVyeSA9IC8oWz8mXS4qKS9cbiAgY29uc3QgbWF0Y2hlcyA9IGdldFF1ZXJ5LmV4ZWMoaGFzaClcbiAgY29uc3QgcGFyYW1zID0ge31cblxuICBpZiAoZG9jdW1lbnQubG9jYXRpb24gJiYgZG9jdW1lbnQubG9jYXRpb24uc2VhcmNoKSB7XG4gICAgcGFyc2UgPSBkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2hcbiAgfVxuXG4gIGlmIChtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgbGV0IGhhc2hQYXJhbXMgPSBtYXRjaGVzWzFdXG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICAvLyBpZiBsb2NhdGlvbi5zZWFyY2ggaXMgbm90IGVtcHR5IHdlXG4gICAgICAvLyByZW1vdmUgdGhlIGxlYWRpbmcgPyB0byBjcmVhdGUgYVxuICAgICAgLy8gdmFsaWQgc3RyaW5nXG4gICAgICBoYXNoUGFyYW1zID0gaGFzaFBhcmFtcy5yZXBsYWNlKC9eXFw/LywgJycpXG4gICAgICAvLyB3ZSBwYXJzZSBoYXNoIHBhcmFtcyBsYXN0IHNvIHRoZXkgd2UgY2FuIGFsd2F5c1xuICAgICAgLy8gb3ZlcnJpZGUgc2VhcmNoIHBhcmFtcyB3aXRoIGhhc2ggcGFyYW1zXG4gICAgICBwYXJzZSA9IGAke3BhcnNlfSYke2hhc2hQYXJhbXN9YFxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZSA9IGhhc2hQYXJhbXNcbiAgICB9XG4gIH1cblxuICBpZiAocGFyc2UpIHtcbiAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcnNlKVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHVybFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICAgIHBhcmFtc1trZXldID0gdmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvYmplY3RUb1F1ZXJ5U3RyaW5nID0gb2JqID0+IHtcbiAgaWYgKCFpc09iamVjdChvYmopKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgcmV0dXJuIChcbiAgICAnPycgK1xuICAgIE9iamVjdC5rZXlzKG9iailcbiAgICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgICAgcmV0dXJuIGAke2tleX09JHtvYmpba2V5XX1gXG4gICAgICB9KVxuICAgICAgLmpvaW4oJyYnKVxuICApXG59XG5cbmV4cG9ydCBjb25zdCBzeW1ib2xzID0ge1xuICByb3V0ZTogU3ltYm9sKCdyb3V0ZScpLFxuICBoYXNoOiBTeW1ib2woJ2hhc2gnKSxcbiAgc3RvcmU6IFN5bWJvbCgnc3RvcmUnKSxcbiAgZnJvbUhpc3Rvcnk6IFN5bWJvbCgnZnJvbUhpc3RvcnknKSxcbiAgZXhwaXJlczogU3ltYm9sKCdleHBpcmVzJyksXG4gIHJlc3VtZTogU3ltYm9sKCdyZXN1bWUnKSxcbiAgYmFja3RyYWNrOiBTeW1ib2woJ2JhY2t0cmFjaycpLFxuICBoaXN0b3J5U3RhdGU6IFN5bWJvbCgnaGlzdG9yeVN0YXRlJyksXG4gIHF1ZXJ5UGFyYW1zOiBTeW1ib2woJ3F1ZXJ5UGFyYW1zJyksXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBnZXRBY3RpdmVIYXNoLCBnZXRBY3RpdmVQYWdlIH0gZnJvbSAnLi9yb3V0ZXInXG5pbXBvcnQgeyBnZXRPcHRpb24sIGdldFJvdXRlQnlIYXNoIH0gZnJvbSAnLi9yb3V0ZSdcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc0FycmF5LCBpc0Jvb2xlYW4sIHN5bWJvbHMgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBnZXRSb3V0ZXJDb25maWcgfSBmcm9tICcuL3JvdXRlcidcblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBhcnJheSB0aGF0IGhvbGRzIHRoZSB2aXNpdGVkIGhhc2hlcyArIHN0YXRlIE9iamVjdFxuICogc28gdGhlIHJvdXRlciBjYW4gbmF2aWdhdGUgYmFjayB0byB0aGVtXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbmxldCBoaXN0b3J5ID0gW11cblxuZXhwb3J0IGNvbnN0IHVwZGF0ZUhpc3RvcnkgPSByZXF1ZXN0ID0+IHtcbiAgY29uc3QgaGFzaCA9IGdldEFjdGl2ZUhhc2goKVxuICBpZiAoIWhhc2gpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIG5hdmlnYXRlIHN0b3JhZ2UgZmxhZ1xuICBjb25zdCByZWdpc3RlciA9IHJlcXVlc3QucmVnaXN0ZXJcbiAgY29uc3QgZm9yY2VOYXZpZ2F0ZVN0b3JlID0gcmVnaXN0ZXIuZ2V0KHN5bWJvbHMuc3RvcmUpXG5cbiAgLy8gdGVzdCBwcmV2ZW50U3RvcmFnZSBvbiByb3V0ZSBjb25maWd1cmF0aW9uXG4gIGNvbnN0IGFjdGl2ZVJvdXRlID0gZ2V0Um91dGVCeUhhc2goaGFzaClcbiAgY29uc3QgcHJldmVudFN0b3JhZ2UgPSBnZXRPcHRpb24oYWN0aXZlUm91dGUub3B0aW9ucywgJ3ByZXZlbnRTdG9yYWdlJylcblxuICAvLyB3ZSBnaXZlIHByaW8gdG8gbmF2aWdhdGUgc3RvcmFnZSBmbGFnXG4gIGxldCBzdG9yZSA9IGlzQm9vbGVhbihmb3JjZU5hdmlnYXRlU3RvcmUpID8gZm9yY2VOYXZpZ2F0ZVN0b3JlIDogIXByZXZlbnRTdG9yYWdlXG5cbiAgaWYgKHN0b3JlKSB7XG4gICAgY29uc3QgdG9TdG9yZSA9IGhhc2gucmVwbGFjZSgvXlxcLy8sICcnKVxuICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRpb25Jbkhpc3RvcnkodG9TdG9yZSlcbiAgICBjb25zdCBzdGF0ZU9iamVjdCA9IGdldFN0YXRlT2JqZWN0KGdldEFjdGl2ZVBhZ2UoKSwgcmVxdWVzdClcbiAgICBjb25zdCByb3V0ZXJDb25maWcgPSBnZXRSb3V0ZXJDb25maWcoKVxuXG4gICAgLy8gc3RvcmUgaGFzaCBpZiBpdCdzIG5vdCBhIHBhcnQgb2YgaGlzdG9yeSBvciBmbGFnIGZvclxuICAgIC8vIHN0b3JhZ2Ugb2Ygc2FtZSBoYXNoIGlzIHRydWVcbiAgICBpZiAobG9jYXRpb24gPT09IC0xIHx8IHJvdXRlckNvbmZpZy5nZXQoJ3N0b3JlU2FtZUhhc2gnKSkge1xuICAgICAgaGlzdG9yeS5wdXNoKHsgaGFzaDogdG9TdG9yZSwgc3RhdGU6IHN0YXRlT2JqZWN0IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHdlIHZpc2l0IHRoZSBzYW1lIHJvdXRlIHdlIHdhbnQgdG8gc3luYyBoaXN0b3J5XG4gICAgICBjb25zdCBwcmV2ID0gaGlzdG9yeS5zcGxpY2UobG9jYXRpb24sIDEpWzBdXG4gICAgICBoaXN0b3J5LnB1c2goeyBoYXNoOiBwcmV2Lmhhc2gsIHN0YXRlOiBzdGF0ZU9iamVjdCB9KVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBsb2NhdGlvbkluSGlzdG9yeSA9IGhhc2ggPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhpc3RvcnkubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaGlzdG9yeVtpXS5oYXNoID09PSBoYXNoKSB7XG4gICAgICByZXR1cm4gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTFcbn1cblxuZXhwb3J0IGNvbnN0IGdldEhpc3RvcnlTdGF0ZSA9IGhhc2ggPT4ge1xuICBsZXQgc3RhdGUgPSBudWxsXG4gIGlmIChoaXN0b3J5Lmxlbmd0aCkge1xuICAgIC8vIGlmIG5vIGhhc2ggaXMgcHJvdmlkZWQgd2UgZ2V0IHRoZSBsYXN0XG4gICAgLy8gcHVzaGVkIGhpc3RvcnkgcmVjb3JkXG4gICAgaWYgKCFoYXNoKSB7XG4gICAgICBjb25zdCByZWNvcmQgPSBoaXN0b3J5W2hpc3RvcnkubGVuZ3RoIC0gMV1cbiAgICAgIC8vIGNvdWxkIGJlIG51bGxcbiAgICAgIHN0YXRlID0gcmVjb3JkLnN0YXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChsb2NhdGlvbkluSGlzdG9yeShoYXNoKSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gaGlzdG9yeVtsb2NhdGlvbkluSGlzdG9yeShoYXNoKV1cbiAgICAgICAgc3RhdGUgPSByZWNvcmQuc3RhdGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCByZXBsYWNlSGlzdG9yeVN0YXRlID0gKHN0YXRlID0gbnVsbCwgaGFzaCkgPT4ge1xuICBpZiAoIWhpc3RvcnkubGVuZ3RoKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgbG9jYXRpb24gPSBoYXNoID8gbG9jYXRpb25Jbkhpc3RvcnkoaGFzaCkgOiBoaXN0b3J5Lmxlbmd0aCAtIDFcbiAgaWYgKGxvY2F0aW9uICE9PSAtMSAmJiBpc09iamVjdChzdGF0ZSkpIHtcbiAgICBoaXN0b3J5W2xvY2F0aW9uXS5zdGF0ZSA9IHN0YXRlXG4gIH1cbn1cblxuY29uc3QgZ2V0U3RhdGVPYmplY3QgPSAocGFnZSwgcmVxdWVzdCkgPT4ge1xuICAvLyBpZiB0aGUgbmV3IHJlcXVlc3Qgc2hhcmVkIGluc3RhbmNlIHdpdGggdGhlXG4gIC8vIHByZXZpb3VzIHJlcXVlc3Qgd2UgdXNlZCB0aGUgY29waWVkIHN0YXRlIG9iamVjdFxuICBpZiAocmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlKSB7XG4gICAgaWYgKHJlcXVlc3QuY29waWVkSGlzdG9yeVN0YXRlKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdC5jb3BpZWRIaXN0b3J5U3RhdGVcbiAgICB9XG4gIH0gZWxzZSBpZiAocGFnZSAmJiBpc0Z1bmN0aW9uKHBhZ2UuaGlzdG9yeVN0YXRlKSkge1xuICAgIHJldHVybiBwYWdlLmhpc3RvcnlTdGF0ZSgpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZXhwb3J0IGNvbnN0IGdldEhpc3RvcnkgPSAoKSA9PiB7XG4gIHJldHVybiBoaXN0b3J5LnNsaWNlKDApXG59XG5cbmV4cG9ydCBjb25zdCBzZXRIaXN0b3J5ID0gKGFyciA9IFtdKSA9PiB7XG4gIGlmIChpc0FycmF5KGFycikpIHtcbiAgICBoaXN0b3J5ID0gYXJyXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIGFwcCxcbiAgZ2V0Q29tcG9uZW50LFxuICBvblJlcXVlc3RSZXNvbHZlZCxcbiAgZ2V0TGFzdEhhc2gsXG4gIHBhZ2VzSG9zdCxcbiAgc3RhZ2UsXG4gIGdldFByZXZpb3VzU3RhdGUsXG4gIGdldEFjdGl2ZVBhZ2UsXG4gIHJvdXRlckNvbmZpZyxcbiAgcm91dGVFeGlzdHMsXG59IGZyb20gJy4vcm91dGVyJ1xuXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL0xvZydcbmltcG9ydCB7IGlzQm9vbGVhbiwgaXNDb21wb25lbnRDb25zdHJ1Y3RvciwgaXNGdW5jdGlvbiwgc3ltYm9scyB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCB7IGdldFByb3ZpZGVyLCBoYXNQcm92aWRlciwgaXNQYWdlRXhwaXJlZCwgZGF0YUhvb2tzLCBhZGRQZXJzaXN0RGF0YSB9IGZyb20gJy4vcHJvdmlkZXInXG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMnXG5pbXBvcnQgeyBleGVjdXRlVHJhbnNpdGlvbiB9IGZyb20gJy4vdHJhbnNpdGlvbidcbmltcG9ydCB7IGdldEFjdGl2ZVdpZGdldCB9IGZyb20gJy4vd2lkZ2V0cydcbmltcG9ydCBlbWl0IGZyb20gJy4vZW1pdCdcbmltcG9ydCB7IGdldE9wdGlvbiB9IGZyb20gJy4vcm91dGUnXG5pbXBvcnQgeyBuYXZpZ2F0ZSB9IGZyb20gJy4uL2luZGV4J1xuaW1wb3J0IHsgc2V0SGlzdG9yeSwgdXBkYXRlSGlzdG9yeSB9IGZyb20gJy4vaGlzdG9yeSdcbmltcG9ydCB7IGlzV2lsZGNhcmQgfSBmcm9tICcuL3JlZ2V4J1xuXG4vKipcbiAqIFRoZSBhY3R1YWwgbG9hZGluZyBvZiB0aGUgY29tcG9uZW50XG4gKiAqL1xuZXhwb3J0IGNvbnN0IGxvYWQgPSBhc3luYyByZXF1ZXN0ID0+IHtcbiAgbGV0IGV4cGlyZWQgPSBmYWxzZVxuICB0cnkge1xuICAgIHJlcXVlc3QgPSBhd2FpdCBsb2FkZXIocmVxdWVzdClcbiAgICBpZiAocmVxdWVzdCAmJiAhcmVxdWVzdC5pc0NhbmNlbGxlZCkge1xuICAgICAgLy8gaW4gY2FzZSBvZiBvbigpIHByb3ZpZGluZyB3ZSBuZWVkIHRvIHJlc2V0XG4gICAgICAvLyBhcHAgc3RhdGU7XG4gICAgICBpZiAoYXBwLnN0YXRlID09PSAnTG9hZGluZycpIHtcbiAgICAgICAgaWYgKGdldFByZXZpb3VzU3RhdGUoKSA9PT0gJ1dpZGdldHMnKSB7XG4gICAgICAgICAgYXBwLl9zZXRTdGF0ZSgnV2lkZ2V0cycsIFtnZXRBY3RpdmVXaWRnZXQoKV0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwLl9zZXRTdGF0ZSgnJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG8gcGFnZSB0cmFuc2l0aW9uIGlmIGluc3RhbmNlXG4gICAgICAvLyBpcyBub3Qgc2hhcmVkIGJldHdlZW4gdGhlIHJvdXRlc1xuICAgICAgaWYgKCFyZXF1ZXN0LmlzU2hhcmVkSW5zdGFuY2UgJiYgIXJlcXVlc3QuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgYXdhaXQgZXhlY3V0ZVRyYW5zaXRpb24ocmVxdWVzdC5wYWdlLCBnZXRBY3RpdmVQYWdlKCkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyZWQgPSB0cnVlXG4gICAgfVxuICAgIC8vIG9uIGV4cGlyZWQgd2Ugb25seSBjbGVhbnVwXG4gICAgaWYgKGV4cGlyZWQgfHwgcmVxdWVzdC5pc0NhbmNlbGxlZCkge1xuICAgICAgTG9nLmRlYnVnKCdbcm91dGVyXTonLCBgUmVqZWN0ZWQgJHtyZXF1ZXN0Lmhhc2h9IGJlY2F1c2Ugcm91dGUgdG8gJHtnZXRMYXN0SGFzaCgpfSBzdGFydGVkYClcbiAgICAgIGlmIChyZXF1ZXN0LmlzQ3JlYXRlZCAmJiAhcmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBmcm9tIHJlbmRlci10cmVlXG4gICAgICAgIHBhZ2VzSG9zdC5yZW1vdmUocmVxdWVzdC5wYWdlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvblJlcXVlc3RSZXNvbHZlZChyZXF1ZXN0KVxuICAgICAgLy8gcmVzb2x2ZSBwcm9taXNlXG4gICAgICByZXR1cm4gcmVxdWVzdC5wYWdlXG4gICAgfVxuICB9IGNhdGNoIChyZXF1ZXN0KSB7XG4gICAgaWYgKCFyZXF1ZXN0LnJvdXRlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHJlcXVlc3QpXG4gICAgfSBlbHNlIGlmICghZXhwaXJlZCkge1xuICAgICAgLy8gQHRvZG86IHJldmlzaXRcbiAgICAgIGNvbnN0IHsgcm91dGUgfSA9IHJlcXVlc3RcbiAgICAgIC8vIGNsZWFuIHVwIGhpc3RvcnkgaWYgbW9kaWZpZXIgaXMgc2V0XG4gICAgICBpZiAoZ2V0T3B0aW9uKHJvdXRlLm9wdGlvbnMsICdjbGVhckhpc3RvcnknKSkge1xuICAgICAgICBzZXRIaXN0b3J5KFtdKVxuICAgICAgfSBlbHNlIGlmICghaXNXaWxkY2FyZC50ZXN0KHJvdXRlLnBhdGgpKSB7XG4gICAgICAgIHVwZGF0ZUhpc3RvcnkocmVxdWVzdClcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3QuaXNDcmVhdGVkICYmICFyZXF1ZXN0LmlzU2hhcmVkSW5zdGFuY2UpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gcmVuZGVyLXRyZWVcbiAgICAgICAgcGFnZXNIb3N0LnJlbW92ZShyZXF1ZXN0LnBhZ2UpXG4gICAgICB9XG4gICAgICBoYW5kbGVFcnJvcihyZXF1ZXN0KVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBsb2FkZXIgPSBhc3luYyByZXF1ZXN0ID0+IHtcbiAgY29uc3Qgcm91dGUgPSByZXF1ZXN0LnJvdXRlXG4gIGNvbnN0IGhhc2ggPSByZXF1ZXN0Lmhhc2hcbiAgY29uc3QgcmVnaXN0ZXIgPSByZXF1ZXN0LnJlZ2lzdGVyXG5cbiAgLy8gdG9kbzogZ3JhYiBmcm9tIFJvdXRlIGluc3RhbmNlXG4gIGxldCB0eXBlID0gZ2V0Q29tcG9uZW50KHJvdXRlLnBhdGgpXG4gIGxldCBpc0NvbnN0cnVjdCA9IGlzQ29tcG9uZW50Q29uc3RydWN0b3IodHlwZSlcbiAgbGV0IHByb3ZpZGUgPSBmYWxzZVxuXG4gIC8vIGlmIGl0J3MgYW4gaW5zdGFuY2UgYnQgd2UncmUgbm90IGNvbWluZyBiYWNrIGZyb21cbiAgLy8gaGlzdG9yeSB3ZSB0ZXN0IGlmIHdlIGNhbiByZS11c2UgdGhpcyBpbnN0YW5jZVxuICBpZiAoIWlzQ29uc3RydWN0ICYmICFyZWdpc3Rlci5nZXQoc3ltYm9scy5iYWNrdHJhY2spKSB7XG4gICAgaWYgKCFtdXN0UmV1c2Uocm91dGUpKSB7XG4gICAgICB0eXBlID0gdHlwZS5jb25zdHJ1Y3RvclxuICAgICAgaXNDb25zdHJ1Y3QgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgcGFnZSBpcyBMaWdodG5pbmcgQ29tcG9uZW50IGluc3RhbmNlXG4gIGlmICghaXNDb25zdHJ1Y3QpIHtcbiAgICByZXF1ZXN0LnBhZ2UgPSB0eXBlXG4gICAgLy8gaWYgd2UgaGF2ZSBoYXZlIGEgZGF0YSByb3V0ZSBmb3IgY3VycmVudCBwYWdlXG4gICAgaWYgKGhhc1Byb3ZpZGVyKHJvdXRlLnBhdGgpKSB7XG4gICAgICBpZiAoaXNQYWdlRXhwaXJlZCh0eXBlKSB8fCB0eXBlW3N5bWJvbHMuaGFzaF0gIT09IGhhc2gpIHtcbiAgICAgICAgcHJvdmlkZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGN1cnJlbnRSb3V0ZSA9IGdldEFjdGl2ZVBhZ2UoKSAmJiBnZXRBY3RpdmVQYWdlKClbc3ltYm9scy5yb3V0ZV1cbiAgICAvLyBpZiB0aGUgbmV3IHJvdXRlIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IHJvdXRlIGl0IG1lYW5zIHRoYXQgYm90aFxuICAgIC8vIHJvdXRlIHNoYXJlIHRoZSBDb21wb25lbnQgaW5zdGFuY2UgYW5kIHN0YWNrIGxvY2F0aW9uIC8gc2luY2UgdGhpcyBjYXNlXG4gICAgLy8gaXMgY29uZmxpY3Rpbmcgd2l0aCB0aGUgd2F5IGJlZm9yZSgpIGFuZCBhZnRlcigpIGxvYWRpbmcgd29ya3Mgd2UgZmxhZyBpdCxcbiAgICAvLyBhbmQgY2hlY2sgcGxhdGZvcm0gc2V0dGluZ3MgaW4gd2Ugd2FudCB0byByZS11c2UgaW5zdGFuY2VcbiAgICBpZiAocm91dGUucGF0aCA9PT0gY3VycmVudFJvdXRlKSB7XG4gICAgICByZXF1ZXN0LmlzU2hhcmVkSW5zdGFuY2UgPSB0cnVlXG4gICAgICAvLyBzaW5jZSB3ZSdyZSByZS11c2luZyB0aGUgaW5zdGFuY2Ugd2UgbXVzdCBhdHRhY2hcbiAgICAgIC8vIGhpc3RvcnlTdGF0ZSB0byB0aGUgcmVxdWVzdCB0byBwcmV2ZW50IGl0IGZyb21cbiAgICAgIC8vIGJlaW5nIG92ZXJyaWRkZW4uXG4gICAgICBpZiAoaXNGdW5jdGlvbihyZXF1ZXN0LnBhZ2UuaGlzdG9yeVN0YXRlKSkge1xuICAgICAgICByZXF1ZXN0LmNvcGllZEhpc3RvcnlTdGF0ZSA9IHJlcXVlc3QucGFnZS5oaXN0b3J5U3RhdGUoKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LnBhZ2UgPSBjcmVhdGVDb21wb25lbnQoc3RhZ2UsIHR5cGUpXG4gICAgcGFnZXNIb3N0LmEocmVxdWVzdC5wYWdlKVxuICAgIC8vIHRlc3QgaWYgbmVlZCB0byByZXF1ZXN0IGRhdGEgcHJvdmlkZXJcbiAgICBpZiAoaGFzUHJvdmlkZXIocm91dGUucGF0aCkpIHtcbiAgICAgIHByb3ZpZGUgPSB0cnVlXG4gICAgfVxuICAgIHJlcXVlc3QuaXNDcmVhdGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gd2Ugc3RvcmUgaGFzaCBhbmQgcm91dGUgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFnZSBpbnN0YW5jZVxuICAvLyB0aGF0IHdheSB3ZSBjYW4gZWFzaWx5IGNhbGN1bGF0ZSBuZXcgYmVoYXZpb3VyIG9uIHBhZ2UgcmVsb2FkXG4gIHJlcXVlc3QucGFnZVtzeW1ib2xzLmhhc2hdID0gaGFzaFxuICByZXF1ZXN0LnBhZ2Vbc3ltYm9scy5yb3V0ZV0gPSByb3V0ZS5wYXRoXG5cbiAgdHJ5IHtcbiAgICBpZiAocHJvdmlkZSkge1xuICAgICAgLy8gZXh0cmFjdCBhdHRhY2hlZCBkYXRhLXByb3ZpZGVyIGZvciByb3V0ZVxuICAgICAgLy8gd2UncmUgcHJvY2Vzc2luZ1xuICAgICAgY29uc3QgeyB0eXBlOiBsb2FkVHlwZSwgcHJvdmlkZXIgfSA9IGdldFByb3ZpZGVyKHJvdXRlKVxuXG4gICAgICAvLyB1cGRhdGUgcnVubmluZyByZXF1ZXN0XG4gICAgICByZXF1ZXN0LnByb3ZpZGVyID0gcHJvdmlkZXJcbiAgICAgIHJlcXVlc3QucHJvdmlkZXJUeXBlID0gbG9hZFR5cGVcblxuICAgICAgYXdhaXQgZGF0YUhvb2tzW2xvYWRUeXBlXShyZXF1ZXN0KVxuXG4gICAgICAvLyB3ZSBlYXJseSBleGl0IGlmIHRoZSBjdXJyZW50IHJlcXVlc3QgaXMgZXhwaXJlZFxuICAgICAgaWYgKGhhc2ggIT09IGdldExhc3RIYXNoKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVxdWVzdC5wcm92aWRlclR5cGUgIT09ICdhZnRlcicpIHtcbiAgICAgICAgICBlbWl0KHJlcXVlc3QucGFnZSwgJ2RhdGFQcm92aWRlZCcpXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBwcm9taXNlXG4gICAgICAgIHJldHVybiByZXF1ZXN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFBlcnNpc3REYXRhKHJlcXVlc3QpXG4gICAgICByZXR1cm4gcmVxdWVzdFxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlcXVlc3QuZXJyb3IgPSBlXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlcXVlc3QpXG4gIH1cbn1cblxuY29uc3QgaGFuZGxlRXJyb3IgPSByZXF1ZXN0ID0+IHtcbiAgaWYgKHJlcXVlc3QgJiYgcmVxdWVzdC5lcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IocmVxdWVzdC5lcnJvcilcbiAgfSBlbHNlIGlmIChyZXF1ZXN0KSB7XG4gICAgTG9nLmVycm9yKHJlcXVlc3QpXG4gIH1cblxuICBpZiAocmVxdWVzdC5wYWdlICYmIHJvdXRlRXhpc3RzKCchJykpIHtcbiAgICBuYXZpZ2F0ZSgnIScsIHsgcmVxdWVzdCB9LCBmYWxzZSlcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbXVzdFJldXNlID0gcm91dGUgPT4ge1xuICBjb25zdCBvcHQgPSBnZXRPcHRpb24ocm91dGUub3B0aW9ucywgJ3JldXNlSW5zdGFuY2UnKVxuICBjb25zdCBjb25maWcgPSByb3V0ZXJDb25maWcuZ2V0KCdyZXVzZUluc3RhbmNlJylcblxuICAvLyByb3V0ZSBhbHdheXMgaGFzIGZpbmFsIGRlY2lzaW9uXG4gIGlmIChpc0Jvb2xlYW4ob3B0KSkge1xuICAgIHJldHVybiBvcHRcbiAgfVxuICByZXR1cm4gIShpc0Jvb2xlYW4oY29uZmlnKSAmJiBjb25maWcgPT09IGZhbHNlKVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgc3ltYm9scywgZ2V0UXVlcnlTdHJpbmdQYXJhbXMgfSBmcm9tICcuL2hlbHBlcnMnXG5pbXBvcnQgeyBhcHAsIHJvdXRlcywgcm91dGVFeGlzdHMgfSBmcm9tICcuL3JvdXRlcidcbmltcG9ydCB7IGdldFZhbHVlc0Zyb21IYXNoIH0gZnJvbSAnLi9yb3V0ZSdcbmltcG9ydCBlbWl0IGZyb20gJy4vZW1pdCdcblxuZXhwb3J0IGxldCBwcmV2aW91c1N0YXRlXG5cbmV4cG9ydCBjb25zdCBkYXRhSG9va3MgPSB7XG4gIG9uOiByZXF1ZXN0ID0+IHtcbiAgICBwcmV2aW91c1N0YXRlID0gYXBwLnN0YXRlIHx8ICcnXG4gICAgYXBwLl9zZXRTdGF0ZSgnTG9hZGluZycpXG4gICAgcmV0dXJuIGV4ZWNQcm92aWRlcihyZXF1ZXN0KVxuICB9LFxuICBiZWZvcmU6IHJlcXVlc3QgPT4ge1xuICAgIHJldHVybiBleGVjUHJvdmlkZXIocmVxdWVzdClcbiAgfSxcbiAgYWZ0ZXI6IHJlcXVlc3QgPT4ge1xuICAgIHRyeSB7XG4gICAgICBleGVjUHJvdmlkZXIocmVxdWVzdCwgdHJ1ZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBmb3Igbm93IHdlIGZhaWwgc2lsZW50bHlcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gIH0sXG59XG5cbmNvbnN0IGV4ZWNQcm92aWRlciA9IChyZXF1ZXN0LCBlbWl0UHJvdmlkZWQpID0+IHtcbiAgY29uc3Qgcm91dGUgPSByZXF1ZXN0LnJvdXRlXG4gIGNvbnN0IHByb3ZpZGVyID0gcm91dGUucHJvdmlkZXJcbiAgY29uc3QgZXhwaXJlcyA9IHJvdXRlLmNhY2hlID8gcm91dGUuY2FjaGUgKiAxMDAwIDogMFxuICBjb25zdCBwYXJhbXMgPSBhZGRQZXJzaXN0RGF0YShyZXF1ZXN0KVxuICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdChyZXF1ZXN0LnBhZ2UsIHsgLi4ucGFyYW1zIH0pLnRoZW4oKCkgPT4ge1xuICAgIHJlcXVlc3QucGFnZVtzeW1ib2xzLmV4cGlyZXNdID0gRGF0ZS5ub3coKSArIGV4cGlyZXNcbiAgICBpZiAoZW1pdFByb3ZpZGVkKSB7XG4gICAgICBlbWl0KHJlcXVlc3QucGFnZSwgJ2RhdGFQcm92aWRlZCcpXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgYWRkUGVyc2lzdERhdGEgPSAoeyBwYWdlLCByb3V0ZSwgaGFzaCwgcmVnaXN0ZXIgPSBuZXcgTWFwKCkgfSkgPT4ge1xuICBjb25zdCB1cmxWYWx1ZXMgPSBnZXRWYWx1ZXNGcm9tSGFzaChoYXNoLCByb3V0ZS5wYXRoKVxuICBjb25zdCBxdWVyeVBhcmFtcyA9IGdldFF1ZXJ5U3RyaW5nUGFyYW1zKGhhc2gpXG4gIGNvbnN0IHBhZ2VEYXRhID0gbmV3IE1hcChbLi4udXJsVmFsdWVzLCAuLi5yZWdpc3Rlcl0pXG4gIGNvbnN0IHBhcmFtcyA9IHt9XG5cbiAgLy8gbWFrZSBkeW5hbWljIHVybCBkYXRhIGF2YWlsYWJsZSB0byB0aGUgcGFnZVxuICAvLyBhcyBpbnN0YW5jZSBwcm9wZXJ0aWVzXG4gIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgcGFnZURhdGEpIHtcbiAgICBwYXJhbXNbbmFtZV0gPSB2YWx1ZVxuICB9XG5cbiAgaWYgKHF1ZXJ5UGFyYW1zKSB7XG4gICAgcGFyYW1zW3N5bWJvbHMucXVlcnlQYXJhbXNdID0gcXVlcnlQYXJhbXNcbiAgfVxuXG4gIC8vIGNoZWNrIG5hdmlnYXRpb24gcmVnaXN0ZXIgZm9yIHBlcnNpc3RlbnQgZGF0YVxuICBpZiAocmVnaXN0ZXIuc2l6ZSkge1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHJlZ2lzdGVyKSB7XG4gICAgICBvYmpba10gPSB2XG4gICAgfVxuICAgIHBhZ2UucGVyc2lzdCA9IG9ialxuICB9XG5cbiAgLy8gbWFrZSB1cmwgZGF0YSBhbmQgcGVyc2lzdCBkYXRhIGF2YWlsYWJsZVxuICAvLyB2aWEgcGFyYW1zIHByb3BlcnR5XG4gIHBhZ2UucGFyYW1zID0gcGFyYW1zXG4gIGVtaXQocGFnZSwgWyd1cmxQYXJhbXMnXSwgcGFyYW1zKVxuXG4gIHJldHVybiBwYXJhbXNcbn1cblxuLyoqXG4gKiBUZXN0IGlmIHBhZ2UgcGFzc2VkIGNhY2hlLXRpbWVcbiAqIEBwYXJhbSBwYWdlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzUGFnZUV4cGlyZWQgPSBwYWdlID0+IHtcbiAgaWYgKCFwYWdlW3N5bWJvbHMuZXhwaXJlc10pIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGNvbnN0IGV4cGlyZXMgPSBwYWdlW3N5bWJvbHMuZXhwaXJlc11cbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKVxuXG4gIHJldHVybiBub3cgPj0gZXhwaXJlc1xufVxuXG5leHBvcnQgY29uc3QgaGFzUHJvdmlkZXIgPSBwYXRoID0+IHtcbiAgaWYgKHJvdXRlRXhpc3RzKHBhdGgpKSB7XG4gICAgY29uc3QgcmVjb3JkID0gcm91dGVzLmdldChwYXRoKVxuICAgIHJldHVybiAhIXJlY29yZC5wcm92aWRlclxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UHJvdmlkZXIgPSByb3V0ZSA9PiB7XG4gIC8vIEB0b2RvOiBmaXgsIHJvdXRlIGFscmVhZHkgaXMgcGFzc2VkIGluXG4gIGlmIChyb3V0ZUV4aXN0cyhyb3V0ZS5wYXRoKSkge1xuICAgIGNvbnN0IHsgcHJvdmlkZXIgfSA9IHJvdXRlcy5nZXQocm91dGUucGF0aClcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogcHJvdmlkZXIudHlwZSxcbiAgICAgIHByb3ZpZGVyOiBwcm92aWRlci5yZXF1ZXN0LFxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGhhc1JlZ2V4ID0gL1xce1xcLyguKj8pXFwvKFtpZ21dezAsM30pXFx9L2dcbmV4cG9ydCBjb25zdCBpc1dpbGRjYXJkID0gL15bISokXSQvXG5leHBvcnQgY29uc3QgaGFzTG9va3VwSWQgPSAvXFwvOlxcdys/QEAoWzAtOV0rPylAQC9cbmV4cG9ydCBjb25zdCBpc05hbWVkR3JvdXAgPSAvXlxcLzovXG5cbi8qKlxuICogVGVzdCBpZiBhIHJvdXRlIGlzIHBhcnQgcmVndWxhciBleHByZXNzZWRcbiAqIGFuZCByZXBsYWNlIGl0IGZvciBhIHNpbXBsZSBjaGFyYWN0ZXJcbiAqIEBwYXJhbSByb3V0ZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpcFJlZ2V4ID0gKHJvdXRlLCBjaGFyID0gJ1InKSA9PiB7XG4gIC8vIGlmIHJvdXRlIGlzIHBhcnQgcmVndWxhciBleHByZXNzZWQgd2UgcmVwbGFjZVxuICAvLyB0aGUgcmVndWxhciBleHByZXNzaW9uIGZvciBhIGNoYXJhY3RlciB0b1xuICAvLyBzaW1wbGlmeSBmbG9vciBjYWxjdWxhdGlvbiBhbmQgYmFja3RyYWNraW5nXG4gIGlmIChoYXNSZWdleC50ZXN0KHJvdXRlKSkge1xuICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShoYXNSZWdleCwgY2hhcilcbiAgfVxuICByZXR1cm4gcm91dGVcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbG9jYWwgcmVxdWVzdCByZWdpc3RlclxuICogQHBhcmFtIGZsYWdzXG4gKiBAcmV0dXJucyB7TWFwPGFueSwgYW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlZ2lzdGVyID0gZmxhZ3MgPT4ge1xuICBjb25zdCByZWcgPSBuZXcgTWFwKClcbiAgLy8gc3RvcmUgdXNlciBkZWZpbmVkIGFuZCByb3V0ZXJcbiAgLy8gZGVmaW5lZCBmbGFncyBpbiByZWdpc3RlclxuICA7Wy4uLk9iamVjdC5rZXlzKGZsYWdzKSwgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhmbGFncyldLmZvckVhY2goa2V5ID0+IHtcbiAgICByZWcuc2V0KGtleSwgZmxhZ3Nba2V5XSlcbiAgfSlcbiAgcmV0dXJuIHJlZ1xufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaGFzUmVnZXgsIGhhc0xvb2t1cElkLCBpc05hbWVkR3JvdXAsIHN0cmlwUmVnZXggfSBmcm9tICcuL3JlZ2V4J1xuaW1wb3J0IHsgcm91dGVzLCByb3V0ZUV4aXN0cywgYm9vdFJlcXVlc3QsIGdldFJvdXRlcyB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IFJlcXVlc3QgZnJvbSAnLi4vbW9kZWwvUmVxdWVzdCdcbmltcG9ydCBSb3V0ZSBmcm9tICcuLi9tb2RlbC9Sb3V0ZSdcbmltcG9ydCB7IG9iamVjdFRvUXVlcnlTdHJpbmcsIGlzT2JqZWN0LCBpc1N0cmluZyB9IGZyb20gJy4vaGVscGVycydcblxuLyoqXG4gKiBTaW1wbGUgcm91dGUgbGVuZ3RoIGNhbGN1bGF0aW9uXG4gKiBAcGFyYW0gcm91dGUge3N0cmluZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9IC0gZmxvb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEZsb29yID0gcm91dGUgPT4ge1xuICByZXR1cm4gc3RyaXBSZWdleChyb3V0ZSkuc3BsaXQoJy8nKS5sZW5ndGhcbn1cblxuLyoqXG4gKiByZXR1cm4gYWxsIHN0b3JlZCByb3V0ZXMgdGhhdCBsaXZlIG9uIHRoZSBzYW1lIGZsb29yXG4gKiBAcGFyYW0gZmxvb3JcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuY29uc3QgZ2V0Um91dGVzQnlGbG9vciA9IGZsb29yID0+IHtcbiAgY29uc3QgbWF0Y2hlcyA9IFtdXG4gIC8vIHNpbXBsZSBmaWx0ZXIgb2YgbGV2ZWwgY2FuZGlkYXRlc1xuICBmb3IgKGxldCBbcm91dGVdIG9mIHJvdXRlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAoZ2V0Rmxvb3Iocm91dGUpID09PSBmbG9vcikge1xuICAgICAgbWF0Y2hlcy5wdXNoKHJvdXRlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF0Y2hlc1xufVxuXG4vKipcbiAqIHJldHVybiBhIG1hdGNoaW5nIHJvdXRlIGJ5IHByb3ZpZGVkIGhhc2hcbiAqIGhhc2g6IGhvbWUvYnJvd3NlLzEyIHdpbGwgbWF0Y2g6XG4gKiByb3V0ZTogaG9tZS9icm93c2UvOmNhdGVnb3J5SWRcbiAqIEBwYXJhbSBoYXNoIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7Ym9vbGVhbnx7fX0gLSByb3V0ZVxuICovXG5leHBvcnQgY29uc3QgZ2V0Um91dGVCeUhhc2ggPSBoYXNoID0+IHtcbiAgLy8gQHRvZG86IGNsZWFuIHVwIG9uIGhhbmRsZUhhc2hcbiAgaGFzaCA9IGhhc2gucmVwbGFjZSgvXiMvLCAnJylcblxuICBjb25zdCBnZXRVcmxQYXJ0cyA9IC8oXFwvPzo/W14vXSspL2dcbiAgLy8gZ3JhYiBwb3NzaWJsZSBjYW5kaWRhdGVzIGZyb20gc3RvcmVkIHJvdXRlc1xuICBjb25zdCBjYW5kaWRhdGVzID0gZ2V0Um91dGVzQnlGbG9vcihnZXRGbG9vcihoYXNoKSlcbiAgLy8gYnJlYWsgaGFzaCBkb3duIGluIGNodW5rc1xuICBjb25zdCBoYXNoUGFydHMgPSBoYXNoLm1hdGNoKGdldFVybFBhcnRzKSB8fCBbXVxuXG4gIC8vIHRvIHNpbXBsaWZ5IHRoZSByb3V0ZSBtYXRjaGluZyBhbmQgcHJldmVudCBsb29rIGFyb3VuZFxuICAvLyBpbiBvdXIgZ2V0VXJsUGFydHMgcmVnZXggd2UgZ2V0IHRoZSByZWdleCBwYXJ0IGZyb21cbiAgLy8gcm91dGUgY2FuZGlkYXRlIGFuZCBzdG9yZSB0aGVtIHNvIHRoYXQgd2UgY2FuIHJlZmVyZW5jZVxuICAvLyB0aGVtIHdoZW4gd2UgcGVyZm9ybSB0aGUgYWN0dWFsIHJlZ2V4IGFnYWluc3QgaGFzaFxuICBsZXQgcmVnZXhTdG9yZSA9IFtdXG5cbiAgbGV0IG1hdGNoZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihyb3V0ZSA9PiB7XG4gICAgbGV0IGlzTWF0Y2hpbmcgPSB0cnVlXG4gICAgLy8gcmVwbGFjZSByZWdleCBpbiByb3V0ZSB3aXRoIGxvb2t1cCBpZCA9PiBAQHtzdG9yZUlkfUBAXG4gICAgaWYgKGhhc1JlZ2V4LnRlc3Qocm91dGUpKSB7XG4gICAgICBjb25zdCByZWdNYXRjaGVzID0gcm91dGUubWF0Y2goaGFzUmVnZXgpXG4gICAgICBpZiAocmVnTWF0Y2hlcyAmJiByZWdNYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICByb3V0ZSA9IHJlZ01hdGNoZXMucmVkdWNlKChmdWxsUm91dGUsIHJlZ2V4KSA9PiB7XG4gICAgICAgICAgY29uc3QgbG9va3VwSWQgPSByZWdleFN0b3JlLmxlbmd0aFxuICAgICAgICAgIGZ1bGxSb3V0ZSA9IGZ1bGxSb3V0ZS5yZXBsYWNlKHJlZ2V4LCBgQEAke2xvb2t1cElkfUBAYClcbiAgICAgICAgICByZWdleFN0b3JlLnB1c2gocmVnZXguc3Vic3RyaW5nKDEsIHJlZ2V4Lmxlbmd0aCAtIDEpKVxuICAgICAgICAgIHJldHVybiBmdWxsUm91dGVcbiAgICAgICAgfSwgcm91dGUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgcm91dGVQYXJ0cyA9IHJvdXRlLm1hdGNoKGdldFVybFBhcnRzKSB8fCBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSByb3V0ZVBhcnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgY29uc3Qgcm91dGVQYXJ0ID0gcm91dGVQYXJ0c1tpXVxuICAgICAgY29uc3QgaGFzaFBhcnQgPSBoYXNoUGFydHNbaV1cblxuICAgICAgLy8gU2luY2Ugd2Ugc3VwcG9ydCBjYXRjaC1hbGwgYW5kIHJlZ2V4IGRyaXZlbiBuYW1lIGdyb3Vwc1xuICAgICAgLy8gd2UgZmlyc3QgdGVzdCBmb3IgcmVnZXggbG9va3VwIGlkIGFuZCBzZWUgaWYgdGhlIHJlZ2V4XG4gICAgICAvLyBtYXRjaGVzIHRoZSB2YWx1ZSBmcm9tIHRoZSBoYXNoXG4gICAgICBpZiAoaGFzTG9va3VwSWQudGVzdChyb3V0ZVBhcnQpKSB7XG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2hlcyA9IGhhc0xvb2t1cElkLmV4ZWMocm91dGVQYXJ0KVxuICAgICAgICBjb25zdCBzdG9yZUlkID0gcm91dGVNYXRjaGVzWzFdXG4gICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSByZWdleFN0b3JlW3N0b3JlSWRdXG5cbiAgICAgICAgLy8gc3BsaXQgcmVnZXggYW5kIG1vZGlmaWVycyBzbyB3ZSBjYW4gdXNlIGJvdGhcbiAgICAgICAgLy8gdG8gY3JlYXRlIGEgbmV3IFJlZ0V4cFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgICAgICBjb25zdCByZWdNYXRjaGVzID0gL1xcLyhbXlxcL10rKVxcLyhbaWdtXXswLDN9KS8uZXhlYyhyb3V0ZVJlZ2V4KVxuXG4gICAgICAgIGlmIChyZWdNYXRjaGVzICYmIHJlZ01hdGNoZXMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHJlZ01hdGNoZXNbMV1cbiAgICAgICAgICBjb25zdCBtb2RpZmllcnMgPSByZWdNYXRjaGVzWzJdXG5cbiAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4vJHtleHByZXNzaW9ufSRgLCBtb2RpZmllcnMpXG5cbiAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaGFzaFBhcnQpKSB7XG4gICAgICAgICAgICBpc01hdGNoaW5nID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNOYW1lZEdyb3VwLnRlc3Qocm91dGVQYXJ0KSkge1xuICAgICAgICAvLyB3ZSBraW5kbHkgc2tpcCBuYW1lZEdyb3VwcyBiZWNhdXNlIHRoaXMgaXMgZHluYW1pY1xuICAgICAgICAvLyB3ZSBvbmx5IG5lZWQgdG8gdGhlIHN0YXRpYyBhbmQgcmVnZXggZHJpdmUgcGFydHNcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZiAoaGFzaFBhcnQgJiYgcm91dGVQYXJ0LnRvTG93ZXJDYXNlKCkgIT09IGhhc2hQYXJ0LnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgaXNNYXRjaGluZyA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc01hdGNoaW5nXG4gIH0pXG5cbiAgaWYgKG1hdGNoZXMubGVuZ3RoKSB7XG4gICAgaWYgKG1hdGNoZXMuaW5kZXhPZihoYXNoKSAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmluZGV4T2YoaGFzaCldXG4gICAgICByZXR1cm4gcm91dGVzLmdldChtYXRjaClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZ2l2ZSBwcmlvIHRvIHN0YXRpYyByb3V0ZXMgb3ZlciBkeW5hbWljXG4gICAgICBtYXRjaGVzID0gbWF0Y2hlcy5zb3J0KGEgPT4ge1xuICAgICAgICByZXR1cm4gaXNOYW1lZEdyb3VwLnRlc3QoYSkgPyAtMSA6IDFcbiAgICAgIH0pXG4gICAgICAvLyB3b3VsZCBiZSBzdHJhbmdlIGlmIHRoaXMgZmFpbHNcbiAgICAgIC8vIGJ1dCBzdGlsbCB3ZSB0ZXN0XG4gICAgICBpZiAocm91dGVFeGlzdHMobWF0Y2hlc1swXSkpIHtcbiAgICAgICAgcmV0dXJuIHJvdXRlcy5nZXQobWF0Y2hlc1swXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBnZXRWYWx1ZXNGcm9tSGFzaCA9IChoYXNoID0gJycsIHBhdGgpID0+IHtcbiAgLy8gcmVwbGFjZSB0aGUgcmVnZXggZGVmaW5pdGlvbiBmcm9tIHRoZSByb3V0ZSBiZWNhdXNlXG4gIC8vIHdlIGFscmVhZHkgZGlkIHRoZSBtYXRjaGluZyBwYXJ0XG4gIHBhdGggPSBzdHJpcFJlZ2V4KHBhdGgsICcnKVxuXG4gIGNvbnN0IGdldFVybFBhcnRzID0gLyhcXC8/Oj9bXFx3JVxcczouLV0rKS9nXG4gIGNvbnN0IGhhc2hQYXJ0cyA9IGhhc2gubWF0Y2goZ2V0VXJsUGFydHMpIHx8IFtdXG4gIGNvbnN0IHJvdXRlUGFydHMgPSBwYXRoLm1hdGNoKGdldFVybFBhcnRzKSB8fCBbXVxuICBjb25zdCBnZXROYW1lZEdyb3VwID0gL15cXC86KFtcXHctXSspXFwvPy9cblxuICByZXR1cm4gcm91dGVQYXJ0cy5yZWR1Y2UoKHN0b3JhZ2UsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gZ2V0TmFtZWRHcm91cC5leGVjKHZhbHVlKVxuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5sZW5ndGgpIHtcbiAgICAgIHN0b3JhZ2Uuc2V0KG1hdGNoWzFdLCBkZWNvZGVVUklDb21wb25lbnQoaGFzaFBhcnRzW2luZGV4XS5yZXBsYWNlKC9eXFwvLywgJycpKSlcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JhZ2VcbiAgfSwgbmV3IE1hcCgpKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0T3B0aW9uID0gKHN0YWNrLCBwcm9wKSA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGlmKHN0YWNrICYmIHN0YWNrLmhhc093blByb3BlcnR5KHByb3ApKXtcbiAgICByZXR1cm4gc3RhY2tbcHJvcF1cbiAgfVxuICAvLyB3ZSBleHBsaWNpdGx5IHJldHVybiB1bmRlZmluZWQgc2luY2Ugd2UncmUgdGVzdGluZ1xuICAvLyBmb3IgZXhwbGljaXQgdGVzdCB2YWx1ZXNcbn1cblxuLyoqXG4gKiBjcmVhdGUgYW5kIHJldHVybiBuZXcgUm91dGUgaW5zdGFuY2VcbiAqIEBwYXJhbSBjb25maWdcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJvdXRlID0gY29uZmlnID0+IHtcbiAgLy8gd2UgbmVlZCB0byBwcm92aWRlIGEgYml0IG9mIGFkZGl0aW9uYWwgbG9naWNcbiAgLy8gZm9yIHRoZSBib290Q29tcG9uZW50XG4gIGlmIChjb25maWcucGF0aCA9PT0gJyQnKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB7XG4gICAgICBwcmV2ZW50U3RvcmFnZTogdHJ1ZSxcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGNvbmZpZy5vcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4uY29uZmlnLm9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB9XG4gICAgfVxuICAgIGNvbmZpZy5vcHRpb25zID0gb3B0aW9uc1xuICAgIC8vIGlmIGNvbmZpZ3VyZWQgYWRkIHJlZmVyZW5jZSB0byBib290UmVxdWVzdFxuICAgIC8vIGFzIHJvdXRlciBhZnRlciBwcm92aWRlclxuICAgIGlmIChib290UmVxdWVzdCkge1xuICAgICAgY29uZmlnLmFmdGVyID0gYm9vdFJlcXVlc3RcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSb3V0ZShjb25maWcpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFJvdXRlciByZXF1ZXN0IG9iamVjdFxuICogQHBhcmFtIHVybFxuICogQHBhcmFtIGFyZ3NcbiAqIEBwYXJhbSBzdG9yZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXF1ZXN0ID0gKHVybCwgYXJncywgc3RvcmUpID0+IHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgYXJncywgc3RvcmUpXG59XG5cbmV4cG9ydCBjb25zdCBnZXRIYXNoQnlOYW1lID0gb2JqID0+IHtcbiAgaWYgKCFvYmoudG8gJiYgIW9iai5uYW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgY29uc3Qgcm91dGUgPSBnZXRSb3V0ZUJ5TmFtZShvYmoudG8gfHwgb2JqLm5hbWUpXG4gIGNvbnN0IGhhc0R5bmFtaWNHcm91cCA9IC9cXC86KFtcXHctXSspXFwvPy9cbiAgbGV0IGhhc2ggPSByb3V0ZVxuXG4gIC8vIGlmIHJvdXRlIGNvbnRhaW5zIGR5bmFtaWMgZ3JvdXBcbiAgLy8gd2UgcmVwbGFjZSB0aGVtIHdpdGggdGhlIHByb3ZpZGVkIHBhcmFtc1xuICBpZiAoaGFzRHluYW1pY0dyb3VwLnRlc3Qocm91dGUpKSB7XG4gICAgaWYgKG9iai5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmoucGFyYW1zKVxuICAgICAgaGFzaCA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gYWNjLnJlcGxhY2UoYDoke2tleX1gLCBvYmoucGFyYW1zW2tleV0pXG4gICAgICB9LCByb3V0ZSlcbiAgICB9XG4gICAgaWYgKG9iai5xdWVyeSkge1xuICAgICAgcmV0dXJuIGAke2hhc2h9JHtvYmplY3RUb1F1ZXJ5U3RyaW5nKG9iai5xdWVyeSl9YFxuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzaFxufVxuXG5jb25zdCBnZXRSb3V0ZUJ5TmFtZSA9IG5hbWUgPT4ge1xuICBmb3IgKGxldCBbcGF0aCwgcm91dGVdIG9mIHJvdXRlcy5lbnRyaWVzKCkpIHtcbiAgICBpZiAocm91dGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgcmV0dXJuIHBhdGhcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBjb25zdCBrZWVwQWN0aXZlUGFnZUFsaXZlID0gKHJvdXRlLCByZXF1ZXN0KSA9PiB7XG4gIGlmIChpc1N0cmluZyhyb3V0ZSkpIHtcbiAgICBjb25zdCByb3V0ZXMgPSBnZXRSb3V0ZXMoKVxuICAgIGlmIChyb3V0ZXMuaGFzKHJvdXRlKSkge1xuICAgICAgcm91dGUgPSByb3V0ZXMuZ2V0KHJvdXRlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICBjb25zdCByZWdpc3RlciA9IHJlcXVlc3QucmVnaXN0ZXJcbiAgY29uc3Qgcm91dGVPcHRpb25zID0gcm91dGUub3B0aW9uc1xuXG4gIGlmIChyZWdpc3Rlci5oYXMoJ2tlZXBBbGl2ZScpKSB7XG4gICAgcmV0dXJuIHJlZ2lzdGVyLmdldCgna2VlcEFsaXZlJylcbiAgfSBlbHNlIGlmIChyb3V0ZU9wdGlvbnMgJiYgcm91dGVPcHRpb25zLmtlZXBBbGl2ZSkge1xuICAgIHJldHVybiByb3V0ZU9wdGlvbnMua2VlcEFsaXZlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIGdldENvbmZpZ01hcCxcbiAgaXNBcnJheSxcbiAgaXNCb29sZWFuLFxuICBpc0NvbXBvbmVudENvbnN0cnVjdG9yLFxuICBpc0Z1bmN0aW9uLFxuICBpc1BhZ2UsXG4gIHN5bWJvbHMsXG4gIGNsZWFuSGFzaCxcbn0gZnJvbSAnLi9oZWxwZXJzJ1xuaW1wb3J0IHsgc3RlcCwgbmF2aWdhdGVRdWV1ZSB9IGZyb20gJy4uL2luZGV4J1xuaW1wb3J0IHsgY3JlYXRlUm91dGUsIGdldE9wdGlvbiB9IGZyb20gJy4vcm91dGUnXG5pbXBvcnQgeyBjcmVhdGVDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMnXG5pbXBvcnQgTG9nIGZyb20gJy4uLy4uL0xvZydcbmltcG9ydCB7IGlzV2lsZGNhcmQgfSBmcm9tICcuL3JlZ2V4J1xuaW1wb3J0IGVtaXQgZnJvbSAnLi9lbWl0J1xuaW1wb3J0IHsgdXBkYXRlV2lkZ2V0cyB9IGZyb20gJy4vd2lkZ2V0cydcbmltcG9ydCB7IHNldEhpc3RvcnksIHVwZGF0ZUhpc3RvcnkgfSBmcm9tICcuL2hpc3RvcnknXG5pbXBvcnQgeyBBcHBJbnN0YW5jZSB9IGZyb20gJy4uLy4uL0FwcGxpY2F0aW9uJ1xuXG4vKipcbiAqIEB0eXBlIHtMaWdodG5pbmcuQXBwbGljYXRpb259XG4gKi9cbmV4cG9ydCBsZXQgYXBwbGljYXRpb25cblxuLyoqXG4gKiBBY3R1YWwgaW5zdGFuY2Ugb2YgdGhlIGFwcFxuICogQHR5cGUge0xpZ2h0bmluZy5Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBsZXQgYXBwXG5cbi8qKlxuICogQ29tcG9uZW50IHRoYXQgaG9zdHMgYWxsIHJvdXRlZCBwYWdlc1xuICogQHR5cGUge0xpZ2h0bmluZy5Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBsZXQgcGFnZXNIb3N0XG5cbi8qKlxuICogQHR5cGUge0xpZ2h0bmluZy5TdGFnZX1cbiAqL1xuZXhwb3J0IGxldCBzdGFnZVxuXG4vKipcbiAqIFBsYXRmb3JtIGRyaXZlbiBSb3V0ZXIgY29uZmlndXJhdGlvblxuICogQHR5cGUge01hcDxzdHJpbmc+fVxuICovXG5leHBvcnQgbGV0IHJvdXRlckNvbmZpZ1xuXG4vKipcbiAqIENvbXBvbmVudCB0aGF0IGhvc3RzIGFsbCBhdHRhY2hlZCB3aWRnZXRzXG4gKiBAdHlwZSB7TGlnaHRuaW5nLkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGxldCB3aWRnZXRzSG9zdFxuXG4vKipcbiAqIEhhc2ggd2UgcG9pbnQgdGhlIGJyb3dzZXIgdG8gd2hlbiB3ZSBib290IHRoZSBhcHBcbiAqIGFuZCB0aGVyZSBpcyBubyBkZWVwLWxpbmsgcHJvdmlkZWRcbiAqIEB0eXBlIHtzdHJpbmd8RnVuY3Rpb259XG4gKi9cbmxldCByb290SGFzaFxuXG4vKipcbiAqIEJvb3QgcmVxdWVzdCB3aWxsIGZpcmUgYmVmb3JlIGFwcCBzdGFydFxuICogY2FuIGJlIHVzZWQgdG8gZXhlY3V0ZSBzb21lIGdsb2JhbCBsb2dpY1xuICogYW5kIGNhbiBiZSBjb25maWd1cmVkXG4gKi9cbmV4cG9ydCBsZXQgYm9vdFJlcXVlc3RcblxuLyoqXG4gKiBGbGFnIGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBicm93c2VyIGxvY2F0aW9uIGhhc2guXG4gKiBSb3V0ZXIgY2FuIHdvcmsgd2l0aG91dC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5leHBvcnQgbGV0IHVwZGF0ZUhhc2ggPSB0cnVlXG5cbi8qKlxuICogV2lsbCBiZSBjYWxsZWQgYmVmb3JlIGEgcm91dGUgc3RhcnRzLCBjYW4gYmUgb3ZlcnJpZGRlblxuICogdmlhIHJvdXRlcyBjb25maWdcbiAqIEBwYXJhbSBmcm9tIC0gcm91dGUgd2UgY2FtZSBmcm9tXG4gKiBAcGFyYW0gdG8gLSByb3V0ZSB3ZSBuYXZpZ2F0ZSB0b1xuICogQHJldHVybnMge1Byb21pc2U8Kj59XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuZXhwb3J0IGxldCBiZWZvcmVFYWNoUm91dGUgPSBhc3luYyAoZnJvbSwgdG8pPT57XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogICogV2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYSBuYXZpZ2F0ZSBzdWNjZXNzZnVsbHkgcmVzb2x2ZWQsXG4gKiBjYW4gYmUgb3ZlcnJpZGRlbiB2aWEgcm91dGVzIGNvbmZpZ1xuICovXG5leHBvcnQgbGV0IGFmdGVyRWFjaFJvdXRlID0gKCkgPT4ge31cblxuLyoqXG4gKiBBbGwgY29uZmlndXJlZCByb3V0ZXNcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLCBvYmplY3Q+fVxuICovXG5leHBvcnQgbGV0IHJvdXRlcyA9IG5ldyBNYXAoKVxuXG4vKipcbiAqIFN0b3JlIGFsbCBwYWdlIGNvbXBvbmVudHMgcGVyIHJvdXRlXG4gKiBAdHlwZSB7TWFwPHN0cmluZywgb2JqZWN0Pn1cbiAqL1xuZXhwb3J0IGxldCBjb21wb25lbnRzID0gbmV3IE1hcCgpXG5cbi8qKlxuICogRmxhZyBpZiByb3V0ZXIgaGFzIGJlZW4gaW5pdGlhbGlzZWRcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5sZXQgaW5pdGlhbGlzZWQgPSBmYWxzZVxuXG4vKipcbiAqIEN1cnJlbnQgcGFnZSBiZWluZyByZW5kZXJlZCBvbiBzY3JlZW5cbiAqIEB0eXBlIHtudWxsfVxuICovXG5sZXQgYWN0aXZlUGFnZSA9IG51bGxcbmxldCBhY3RpdmVIYXNoXG5sZXQgYWN0aXZlUm91dGVcblxuLyoqXG4gKiAgRHVyaW5nIHRoZSBwcm9jZXNzIG9mIGEgbmF2aWdhdGlvbiByZXF1ZXN0IGEgbmV3XG4gKiAgcmVxdWVzdCBjYW4gc3RhcnQsIHRvIHByZXZlbnQgdW53YW50ZWQgYmVoYXZpb3VyXG4gKiAgdGhlIG5hdmlnYXRlKCktbWV0aG9kIHN0b3JlcyB0aGUgbGFzdCBhY2NlcHRlZCBoYXNoXG4gKiAgc28gd2UgY2FuIGludmFsaWRhdGUgYW55IHByaW9yIHJlcXVlc3RzXG4gKi9cbmxldCBsYXN0QWNjZXB0ZWRIYXNoXG5cbi8qKlxuICogV2l0aCBvbigpLWRhdGEgcHJvdmlkaW5nIGJlaGF2aW91ciB0aGUgUm91dGVyIGZvcmNlZCB0aGUgQXBwXG4gKiBpbiBhIExvYWRpbmcgc3RhdGUuIFdoZW4gdGhlIGRhdGEtcHJvdmlkZXIgcmVzb2x2ZXMgd2Ugd2FudCB0b1xuICogY2hhbmdlIHRoZSBzdGF0ZSBiYWNrIHRvIHdoZXJlIHdlIGNhbWUgZnJvbVxuICovXG5sZXQgcHJldmlvdXNTdGF0ZVxuXG5jb25zdCBtaXhpbiA9IGFwcCA9PiB7XG4gIC8vIGJ5IGRlZmF1bHQgdGhlIFJvdXRlciBCYXNlY2xhc3MgcHJvdmlkZXMgdGhlIGNvbXBvbmVudFxuICAvLyByZWZlcmVuY2UgaW4gd2hpY2ggd2Ugc3RvcmUgb3VyIHBhZ2VzXG4gIGlmIChhcHAucGFnZXMpIHtcbiAgICBwYWdlc0hvc3QgPSBhcHAucGFnZXMuY2hpbGRMaXN0XG4gIH1cbiAgLy8gaWYgdGhlIGFwcCBpcyB1c2luZyB3aWRnZXRzIHdlIGdyYWIgcmVmc1xuICAvLyBhbmQgaGlkZSBhbGwgdGhlIHdpZGdldHNcbiAgaWYgKGFwcC53aWRnZXRzICYmIGFwcC53aWRnZXRzLmNoaWxkcmVuKSB7XG4gICAgd2lkZ2V0c0hvc3QgPSBhcHAud2lkZ2V0cy5jaGlsZExpc3RcbiAgICAvLyBoaWRlIGFsbCB3aWRnZXRzIG9uIGJvb3RcbiAgICB3aWRnZXRzSG9zdC5mb3JFYWNoKHcgPT4gKHcudmlzaWJsZSA9IGZhbHNlKSlcbiAgfVxuICBhcHAuX2hhbmRsZUJhY2sgPSBlID0+IHtcbiAgICBzdGVwKC0xKVxuICAgIGUucHJldmVudERlZmF1bHQoKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBib290Um91dGVyID0gKGNvbmZpZywgaW5zdGFuY2UpID0+IHtcbiAgbGV0IHsgYXBwSW5zdGFuY2UsIHJvdXRlcyB9ID0gY29uZmlnXG5cbiAgLy8gaWYgaW5zdGFuY2UgaXMgcHJvdmlkZWQgYW5kIGl0J3MgYW5kIExpZ2h0bmluZyBDb21wb25lbnQgaW5zdGFuY2VcbiAgaWYgKGluc3RhbmNlICYmIGlzUGFnZShpbnN0YW5jZSkpIHtcbiAgICBhcHAgPSBpbnN0YW5jZVxuICB9XG4gIGlmICghYXBwKSB7XG4gICAgYXBwID0gYXBwSW5zdGFuY2UgfHwgQXBwSW5zdGFuY2VcbiAgfVxuXG4gIGFwcGxpY2F0aW9uID0gYXBwLmFwcGxpY2F0aW9uXG4gIHBhZ2VzSG9zdCA9IGFwcGxpY2F0aW9uLmNoaWxkTGlzdFxuICBzdGFnZSA9IGFwcC5zdGFnZVxuICByb3V0ZXJDb25maWcgPSBnZXRDb25maWdNYXAoKVxuXG4gIG1peGluKGFwcClcblxuICBpZiAoaXNBcnJheShyb3V0ZXMpKSB7XG4gICAgc2V0dXAoY29uZmlnKVxuICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocm91dGVzKSkge1xuICAgIGNvbnNvbGUud2FybignW1JvdXRlcl06IENhbGxpbmcgUm91dGVyLnJvdXRlKCkgZGlyZWN0bHkgaXMgZGVwcmVjYXRlZC4nKVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdVc2Ugb2JqZWN0IGNvbmZpZzogaHR0cHM6Ly9yZGtjZW50cmFsLmdpdGh1Yi5pby9MaWdodG5pbmctU0RLLyMvcGx1Z2lucy9yb3V0ZXIvY29uZmlndXJhdGlvbidcbiAgICApXG4gIH1cbn1cblxuY29uc3Qgc2V0dXAgPSBjb25maWcgPT4ge1xuICBpZiAoIWluaXRpYWxpc2VkKSB7XG4gICAgaW5pdChjb25maWcpXG4gIH1cbiAgY29uZmlnLnJvdXRlcy5mb3JFYWNoKHIgPT4ge1xuICAgIGNvbnN0IHBhdGggPSBjbGVhbkhhc2goci5wYXRoKVxuICAgIGlmICghcm91dGVFeGlzdHMocGF0aCkpIHtcbiAgICAgIGNvbnN0IHJvdXRlID0gY3JlYXRlUm91dGUocilcbiAgICAgIHJvdXRlcy5zZXQocGF0aCwgcm91dGUpXG4gICAgICAvLyBpZiByb3V0ZSBoYXMgYSBjb25maWd1cmVkIGNvbXBvbmVudCBwcm9wZXJ0eVxuICAgICAgLy8gd2Ugc3RvcmUgaXQgaW4gYSBkaWZmZXJlbnQgbWFwIHRvIHNpbXBsaWZ5XG4gICAgICAvLyB0aGUgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgcGVyIHJvdXRlXG4gICAgICBpZiAocm91dGUuY29tcG9uZW50KSB7XG4gICAgICAgIGxldCB0eXBlID0gcm91dGUuY29tcG9uZW50XG4gICAgICAgIGlmIChpc0NvbXBvbmVudENvbnN0cnVjdG9yKHR5cGUpKSB7XG4gICAgICAgICAgaWYgKCFyb3V0ZXJDb25maWcuZ2V0KCdsYXp5Q3JlYXRlJykpIHtcbiAgICAgICAgICAgIHR5cGUgPSBjcmVhdGVDb21wb25lbnQoc3RhZ2UsIHR5cGUpXG4gICAgICAgICAgICBwYWdlc0hvc3QuYSh0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRzLnNldChwYXRoLCB0eXBlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGAke3BhdGh9IGFscmVhZHkgZXhpc3RzIGluIHJvdXRlcyBjb25maWd1cmF0aW9uYClcbiAgICB9XG4gIH0pXG59XG5cbmNvbnN0IGluaXQgPSBjb25maWcgPT4ge1xuICByb290SGFzaCA9IGNvbmZpZy5yb290XG4gIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5ib290KSkge1xuICAgIGJvb3RSZXF1ZXN0ID0gY29uZmlnLmJvb3RcbiAgfVxuICBpZiAoaXNCb29sZWFuKGNvbmZpZy51cGRhdGVIYXNoKSkge1xuICAgIHVwZGF0ZUhhc2ggPSBjb25maWcudXBkYXRlSGFzaFxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5iZWZvcmVFYWNoUm91dGUpKSB7XG4gICAgYmVmb3JlRWFjaFJvdXRlID0gY29uZmlnLmJlZm9yZUVhY2hSb3V0ZVxuICB9XG4gIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5hZnRlckVhY2hSb3V0ZSkpIHtcbiAgICBhZnRlckVhY2hSb3V0ZSA9IGNvbmZpZy5hZnRlckVhY2hSb3V0ZVxuICB9XG4gIGlmIChjb25maWcuYm9vdENvbXBvbmVudCkge1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdbUm91dGVyXTogQm9vdCBDb21wb25lbnQgaXMgbm93IGF2YWlsYWJsZSBhcyBhIHNwZWNpYWwgcm91dGVyOiBodHRwczovL3Jka2NlbnRyYWwuZ2l0aHViLmlvL0xpZ2h0bmluZy1TREsvIy9wbHVnaW5zL3JvdXRlci9jb25maWd1cmF0aW9uP2lkPXNwZWNpYWwtcm91dGVzJ1xuICAgIClcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnW1JvdXRlcl06IHNldHRpbmcgeyBib290Q29tcG9uZW50IH0gcHJvcGVydHkgd2lsbCBiZSBkZXByZWNhdGVkIGluIGEgZnV0dXJlIHJlbGVhc2UnXG4gICAgKVxuICAgIGlmIChpc1BhZ2UoY29uZmlnLmJvb3RDb21wb25lbnQpKSB7XG4gICAgICBjb25maWcucm91dGVzLnB1c2goe1xuICAgICAgICBwYXRoOiAnJCcsXG4gICAgICAgIGNvbXBvbmVudDogY29uZmlnLmJvb3RDb21wb25lbnQsXG4gICAgICAgIC8vIHdlIHRyeSB0byBhc3NpZ24gdGhlIGJvb3RSZXF1ZXN0IGFzIGFmdGVyIGRhdGEtcHJvdmlkZXJcbiAgICAgICAgLy8gc28gaXQgd2lsbCBiZWhhdmUgYXMgYW55IG90aGVyIGNvbXBvbmVudFxuICAgICAgICBhZnRlcjogYm9vdFJlcXVlc3QgfHwgbnVsbCxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIHByZXZlbnRTdG9yYWdlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgW1JvdXRlcl06ICR7Y29uZmlnLmJvb3RDb21wb25lbnR9IGlzIG5vdCBhIHZhbGlkIGJvb3QgY29tcG9uZW50YClcbiAgICB9XG4gIH1cbiAgaW5pdGlhbGlzZWQgPSB0cnVlXG59XG5cbmV4cG9ydCBjb25zdCBzdG9yZUNvbXBvbmVudCA9IChyb3V0ZSwgdHlwZSkgPT4ge1xuICBpZiAoY29tcG9uZW50cy5oYXMocm91dGUpKSB7XG4gICAgY29tcG9uZW50cy5zZXQocm91dGUsIHR5cGUpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdldENvbXBvbmVudCA9IHJvdXRlID0+IHtcbiAgaWYgKGNvbXBvbmVudHMuaGFzKHJvdXRlKSkge1xuICAgIHJldHVybiBjb21wb25lbnRzLmdldChyb3V0ZSlcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuLyoqXG4gKiBUZXN0IGlmIHJvdXRlciBuZWVkcyB0byB1cGRhdGUgYnJvd3NlciBsb2NhdGlvbiBoYXNoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IG11c3RVcGRhdGVMb2NhdGlvbkhhc2ggPSAoKSA9PiB7XG4gIGlmICghcm91dGVyQ29uZmlnIHx8ICFyb3V0ZXJDb25maWcuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIC8vIHdlIG5lZWQgc3VwcG9ydCB0byBlaXRoZXIgdHVybiBjaGFuZ2UgaGFzaCBvZmZcbiAgLy8gcGVyIHBsYXRmb3JtIG9yIHBlciBhcHBcbiAgY29uc3QgdXBkYXRlQ29uZmlnID0gcm91dGVyQ29uZmlnLmdldCgndXBkYXRlSGFzaCcpXG4gIHJldHVybiAhKChpc0Jvb2xlYW4odXBkYXRlQ29uZmlnKSAmJiAhdXBkYXRlQ29uZmlnKSB8fCAoaXNCb29sZWFuKHVwZGF0ZUhhc2gpICYmICF1cGRhdGVIYXNoKSlcbn1cblxuLyoqXG4gKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgbmV3IG5hdmlnYXRlKCkgcmVxdWVzdCBoYXMgY29tcGxldGVkXG4gKiBhbmQgaGFzIG5vdCBiZWVuIGV4cGlyZWQgZHVlIHRvIGl0J3MgYXN5bmMgbmF0dXJlXG4gKiBAcGFyYW0gcmVxdWVzdFxuICovXG5leHBvcnQgY29uc3Qgb25SZXF1ZXN0UmVzb2x2ZWQgPSByZXF1ZXN0ID0+IHtcbiAgY29uc3QgaGFzaCA9IHJlcXVlc3QuaGFzaFxuICBjb25zdCByb3V0ZSA9IHJlcXVlc3Qucm91dGVcbiAgY29uc3QgcmVnaXN0ZXIgPSByZXF1ZXN0LnJlZ2lzdGVyXG4gIGNvbnN0IHBhZ2UgPSByZXF1ZXN0LnBhZ2VcblxuICAvLyBjbGVhbiB1cCBoaXN0b3J5IGlmIG1vZGlmaWVyIGlzIHNldFxuICBpZiAoZ2V0T3B0aW9uKHJvdXRlLm9wdGlvbnMsICdjbGVhckhpc3RvcnknKSkge1xuICAgIHNldEhpc3RvcnkoW10pXG4gIH0gZWxzZSBpZiAoaGFzaCAmJiAhaXNXaWxkY2FyZC50ZXN0KHJvdXRlLnBhdGgpKSB7XG4gICAgdXBkYXRlSGlzdG9yeShyZXF1ZXN0KVxuICB9XG5cbiAgLy8gd2Ugb25seSB1cGRhdGUgdGhlIHN0YWNrTG9jYXRpb24gaWYgYSByb3V0ZVxuICAvLyBpcyBub3QgZXhwaXJlZCBiZWZvcmUgaXQgcmVzb2x2ZXNcbiAgc3RvcmVDb21wb25lbnQocm91dGUucGF0aCwgcGFnZSlcblxuICBpZiAocmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlIHx8ICFyZXF1ZXN0LmlzQ3JlYXRlZCkge1xuICAgIGVtaXQocGFnZSwgJ2NoYW5nZWQnKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QuaXNDcmVhdGVkKSB7XG4gICAgZW1pdChwYWdlLCAnbW91bnRlZCcpXG4gIH1cblxuICAvLyBvbmx5IHVwZGF0ZSB3aWRnZXRzIGlmIHdlIGhhdmUgYSBob3N0XG4gIGlmICh3aWRnZXRzSG9zdCkge1xuICAgIHVwZGF0ZVdpZGdldHMocm91dGUud2lkZ2V0cywgcGFnZSlcbiAgfVxuXG4gIC8vIHdlIHdhbnQgdG8gY2xlYW4gdXAgaWYgdGhlcmUgaXMgYW5cbiAgLy8gYWN0aXZlIHBhZ2UgdGhhdCBpcyBub3QgYmVpbmcgc2hhcmVkXG4gIC8vIGJldHdlZW4gY3VycmVudCBhbmQgcHJldmlvdXMgcm91dGVcbiAgaWYgKGdldEFjdGl2ZVBhZ2UoKSAmJiAhcmVxdWVzdC5pc1NoYXJlZEluc3RhbmNlKSB7XG4gICAgY2xlYW5VcChhY3RpdmVQYWdlLCByZXF1ZXN0KVxuICB9XG5cbiAgLy8gcHJvdmlkZSBoaXN0b3J5IG9iamVjdCB0byBhY3RpdmUgcGFnZVxuICBpZiAocmVnaXN0ZXIuZ2V0KHN5bWJvbHMuaGlzdG9yeVN0YXRlKSAmJiBpc0Z1bmN0aW9uKHBhZ2UuaGlzdG9yeVN0YXRlKSkge1xuICAgIHBhZ2UuaGlzdG9yeVN0YXRlKHJlZ2lzdGVyLmdldChzeW1ib2xzLmhpc3RvcnlTdGF0ZSkpXG4gIH1cblxuICBzZXRBY3RpdmVQYWdlKHBhZ2UpXG5cbiAgYWN0aXZlSGFzaCA9IHJlcXVlc3QuaGFzaFxuICBhY3RpdmVSb3V0ZSA9IHJvdXRlLnBhdGhcblxuICAvLyBjbGVhbnVwIGFsbCBjYW5jZWxsZWQgcmVxdWVzdHNcbiAgZm9yIChsZXQgcmVxdWVzdCBvZiBuYXZpZ2F0ZVF1ZXVlLnZhbHVlcygpKSB7XG4gICAgaWYgKHJlcXVlc3QuaXNDYW5jZWxsZWQgJiYgcmVxdWVzdC5oYXNoKSB7XG4gICAgICBuYXZpZ2F0ZVF1ZXVlLmRlbGV0ZShyZXF1ZXN0Lmhhc2gpXG4gICAgfVxuICB9XG5cbiAgYWZ0ZXJFYWNoUm91dGUocmVxdWVzdClcblxuICBMb2cuaW5mbygnW3JvdXRlXTonLCByb3V0ZS5wYXRoKVxuICBMb2cuaW5mbygnW2hhc2hdOicsIGhhc2gpXG59XG5cbmNvbnN0IGNsZWFuVXAgPSAocGFnZSwgcmVxdWVzdCkgPT4ge1xuICBjb25zdCByb3V0ZSA9IGFjdGl2ZVJvdXRlXG4gIGNvbnN0IHJlZ2lzdGVyID0gcmVxdWVzdC5yZWdpc3RlclxuICBjb25zdCBsYXp5RGVzdHJveSA9IHJvdXRlckNvbmZpZy5nZXQoJ2xhenlEZXN0cm95JylcbiAgY29uc3QgZGVzdHJveU9uQmFjayA9IHJvdXRlckNvbmZpZy5nZXQoJ2Rlc3Ryb3lPbkhpc3RvcnlCYWNrJylcbiAgY29uc3Qga2VlcEFsaXZlID0gcmVnaXN0ZXIuZ2V0KCdrZWVwQWxpdmUnKVxuICBjb25zdCBpc0Zyb21IaXN0b3J5ID0gcmVnaXN0ZXIuZ2V0KHN5bWJvbHMuYmFja3RyYWNrKVxuXG4gIGxldCBkb0NsZWFudXAgPSBmYWxzZVxuXG4gIC8vIGlmIHRoaXMgcmVxdWVzdCBpcyBleGVjdXRlZCBkdWUgdG8gYSBzdGVwIGJhY2sgaW4gaGlzdG9yeVxuICAvLyBhbmQgd2UgaGF2ZSBjb25maWd1cmVkIHRvIGRlc3Ryb3kgYWN0aXZlIHBhZ2Ugd2hlbiB3ZSBnbyBiYWNrXG4gIC8vIGluIGhpc3Rvcnkgb3IgbGF6eURlc3RvcnkgaXMgZW5hYmxlZFxuICBpZiAoaXNGcm9tSGlzdG9yeSAmJiAoZGVzdHJveU9uQmFjayB8fCBsYXp5RGVzdHJveSkpIHtcbiAgICBkb0NsZWFudXAgPSB0cnVlXG4gIH1cblxuICAvLyBjbGVhbiB1cCBpZiBsYXp5RGVzdHJveSBpcyBlbmFibGVkIGFuZCB0aGUga2VlcEFsaXZlIGZsYWdcbiAgLy8gaW4gbmF2aWdhdGlvbiByZWdpc3RlciBpcyBmYWxzZVxuICBpZiAobGF6eURlc3Ryb3kgJiYgIWtlZXBBbGl2ZSkge1xuICAgIGRvQ2xlYW51cCA9IHRydWVcbiAgfVxuXG4gIC8vIGlmIHRoZSBjdXJyZW50IGFuZCBuZXcgcmVxdWVzdCBzaGFyZSB0aGUgc2FtZSByb3V0ZSBibHVlcHJpbnRcbiAgaWYgKGFjdGl2ZVJvdXRlID09PSByZXF1ZXN0LnJvdXRlLnBhdGgpIHtcbiAgICBkb0NsZWFudXAgPSB0cnVlXG4gIH1cblxuICBpZiAoZG9DbGVhbnVwKSB7XG4gICAgLy8gZ3JhYiBvcmlnaW5hbCBjbGFzcyBjb25zdHJ1Y3RvciBpZlxuICAgIC8vIHN0YXRlbWFjaGluZSByb3V0ZWQgZWxzZSBzdG9yZSBjb25zdHJ1Y3RvclxuICAgIHN0b3JlQ29tcG9uZW50KHJvdXRlLCBwYWdlLl9yb3V0ZWRUeXBlIHx8IHBhZ2UuY29uc3RydWN0b3IpXG5cbiAgICAvLyBhY3R1YWwgcmVtb3ZlIG9mIHBhZ2UgZnJvbSBtZW1vcnlcbiAgICBwYWdlc0hvc3QucmVtb3ZlKHBhZ2UpXG5cbiAgICAvLyBmb3JjZSB0ZXh0dXJlIGdjKCkgaWYgY29uZmlndXJlZFxuICAgIC8vIHNvIHdlIGNhbiBjbGVhbnVwIHRleHR1cmVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICBpZiAocm91dGVyQ29uZmlnLmdldCgnZ2NPblVubG9hZCcpKSB7XG4gICAgICBzdGFnZS5nYygpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlJ3JlIG5vdCByZW1vdmluZyB0aGUgcGFnZSB3ZSBuZWVkIHRvXG4gICAgLy8gcmVzZXQgaXQncyBwcm9wZXJ0aWVzXG4gICAgcGFnZS5wYXRjaCh7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgYWxwaGE6IDEsXG4gICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBnZXRBY3RpdmVIYXNoID0gKCkgPT4ge1xuICByZXR1cm4gYWN0aXZlSGFzaFxufVxuXG5leHBvcnQgY29uc3Qgc2V0QWN0aXZlSGFzaCA9IGhhc2ggPT4ge1xuICBhY3RpdmVIYXNoID0gaGFzaFxufVxuXG5leHBvcnQgY29uc3Qgc2V0QWN0aXZlUGFnZSA9IHBhZ2UgPT4ge1xuICBhY3RpdmVQYWdlID0gcGFnZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZlUGFnZSA9ICgpID0+IHtcbiAgcmV0dXJuIGFjdGl2ZVBhZ2Vcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFjdGl2ZVJvdXRlID0gKCkgPT4ge1xuICByZXR1cm4gYWN0aXZlUm91dGVcbn1cblxuZXhwb3J0IGNvbnN0IGdldExhc3RIYXNoID0gKCkgPT4ge1xuICByZXR1cm4gbGFzdEFjY2VwdGVkSGFzaFxufVxuXG5leHBvcnQgY29uc3Qgc2V0TGFzdEhhc2ggPSBoYXNoID0+IHtcbiAgbGFzdEFjY2VwdGVkSGFzaCA9IGhhc2hcbn1cblxuZXhwb3J0IGNvbnN0IHNldFByZXZpb3VzU3RhdGUgPSBzdGF0ZSA9PiB7XG4gIHByZXZpb3VzU3RhdGUgPSBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3QgZ2V0UHJldmlvdXNTdGF0ZSA9ICgpID0+IHtcbiAgcmV0dXJuIHByZXZpb3VzU3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IHJvdXRlRXhpc3RzID0ga2V5ID0+IHtcbiAgcmV0dXJuIHJvdXRlcy5oYXMoa2V5KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0Um9vdEhhc2ggPSAoKSA9PiB7XG4gIHJldHVybiByb290SGFzaFxufVxuXG5leHBvcnQgY29uc3QgZ2V0Qm9vdFJlcXVlc3QgPSAoKSA9PiB7XG4gIHJldHVybiBib290UmVxdWVzdFxufVxuXG5leHBvcnQgY29uc3QgZ2V0Um91dGVyQ29uZmlnID0gKCkgPT4ge1xuICByZXR1cm4gcm91dGVyQ29uZmlnXG59XG5cbmV4cG9ydCBjb25zdCBnZXRSb3V0ZXMgPSAoKSA9PiB7XG4gIHJldHVybiByb3V0ZXNcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IGdldFJvdXRlckNvbmZpZyB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgaXNQcm9taXNlLCBpc1N0cmluZyB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCBUcmFuc2l0aW9ucyBmcm9tICcuLi90cmFuc2l0aW9ucydcblxuLyoqXG4gKiBleGVjdXRlIHRyYW5zaXRpb24gYmV0d2VlbiBuZXcgLyBvbGQgcGFnZSBhbmRcbiAqIHRvZ2dsZSB0aGUgZGVmaW5lZCB3aWRnZXRzXG4gKiBAdG9kbzogcGxhdGZvcm0gb3ZlcnJpZGUgZGVmYXVsdCB0cmFuc2l0aW9uXG4gKiBAcGFyYW0gcGFnZUluXG4gKiBAcGFyYW0gcGFnZU91dFxuICovXG5leHBvcnQgY29uc3QgZXhlY3V0ZVRyYW5zaXRpb24gPSAocGFnZUluLCBwYWdlT3V0ID0gbnVsbCkgPT4ge1xuICBjb25zdCB0cmFuc2l0aW9uID0gcGFnZUluLnBhZ2VUcmFuc2l0aW9uIHx8IHBhZ2VJbi5lYXNpbmdcbiAgY29uc3QgaGFzQ3VzdG9tVHJhbnNpdGlvbnMgPSAhIShwYWdlSW4uc21vb3RoSW4gfHwgcGFnZUluLnNtb290aEluT3V0IHx8IHRyYW5zaXRpb24pXG4gIGNvbnN0IHRyYW5zaXRpb25zRGlzYWJsZWQgPSBnZXRSb3V0ZXJDb25maWcoKS5nZXQoJ2Rpc2FibGVUcmFuc2l0aW9ucycpXG5cbiAgaWYgKHBhZ2VJbi5lYXNpbmcpIHtcbiAgICBjb25zb2xlLndhcm4oJ2Vhc2luZygpIG1ldGhvZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQuIFVzZSBwYWdlVHJhbnNpdGlvbigpJylcbiAgfVxuXG4gIC8vIGRlZmF1bHQgYmVoYXZpb3VyIGlzIGEgdmlzaWJpbGl0eSB0b2dnbGVcbiAgaWYgKCFoYXNDdXN0b21UcmFuc2l0aW9ucyB8fCB0cmFuc2l0aW9uc0Rpc2FibGVkKSB7XG4gICAgcGFnZUluLnZpc2libGUgPSB0cnVlXG4gICAgaWYgKHBhZ2VPdXQpIHtcbiAgICAgIHBhZ2VPdXQudmlzaWJsZSA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICBsZXQgdHlwZVxuICAgIHRyeSB7XG4gICAgICB0eXBlID0gdHJhbnNpdGlvbi5jYWxsKHBhZ2VJbiwgcGFnZUluLCBwYWdlT3V0KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHR5cGUgPSAnY3Jvc3NGYWRlJ1xuICAgIH1cblxuICAgIGlmIChpc1Byb21pc2UodHlwZSkpIHtcbiAgICAgIHJldHVybiB0eXBlXG4gICAgfVxuXG4gICAgaWYgKGlzU3RyaW5nKHR5cGUpKSB7XG4gICAgICBjb25zdCBmbiA9IFRyYW5zaXRpb25zW3R5cGVdXG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKHBhZ2VJbiwgcGFnZU91dClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBrZWVwIGJhY2t3YXJkcyBjb21wYXRpYmxlIGZvciBub3dcbiAgICBpZiAocGFnZUluLnNtb290aEluKSB7XG4gICAgICAvLyBwcm92aWRlIGEgc21vb3RoIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgaXRzZWxmXG4gICAgICAvLyBvbiB0cmFuc2l0aW9uIGZpbmlzaFxuICAgICAgY29uc3Qgc21vb3RoID0gKHAsIHYsIGFyZ3MgPSB7fSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgcGFnZUluLnZpc2libGUgPSB0cnVlXG4gICAgICAgICAgcGFnZUluLnNldFNtb290aChwLCB2LCBhcmdzKVxuICAgICAgICAgIHBhZ2VJbi50cmFuc2l0aW9uKHApLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKClcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhZ2VJbi5zbW9vdGhJbih7IHBhZ2VJbiwgc21vb3RoIH0pXG4gICAgfVxuICB9XG4gIHJldHVybiBUcmFuc2l0aW9ucy5jcm9zc0ZhZGUocGFnZUluLCBwYWdlT3V0KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYXBwLCB3aWRnZXRzSG9zdCB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgdWNmaXJzdCB9IGZyb20gJy4vaGVscGVycydcbmltcG9ydCBlbWl0IGZyb20gJy4vZW1pdCdcblxubGV0IGFjdGl2ZVdpZGdldCA9IG51bGxcblxuZXhwb3J0IGNvbnN0IGdldFJlZmVyZW5jZXMgPSAoKSA9PiB7XG4gIGlmICghd2lkZ2V0c0hvc3QpIHtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gd2lkZ2V0c0hvc3QuZ2V0KCkucmVkdWNlKChzdG9yYWdlLCB3aWRnZXQpID0+IHtcbiAgICBjb25zdCBrZXkgPSB3aWRnZXQucmVmLnRvTG93ZXJDYXNlKClcbiAgICBzdG9yYWdlW2tleV0gPSB3aWRnZXRcbiAgICByZXR1cm4gc3RvcmFnZVxuICB9LCB7fSlcbn1cblxuLyoqXG4gKiB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGF2YWlsYWJsZSB3aWRnZXRzXG4gKiBmb3IgdGhlIGN1cnJlbnQgcGFnZSAvIHJvdXRlXG4gKiBAcGFyYW0gcGFnZVxuICovXG5leHBvcnQgY29uc3QgdXBkYXRlV2lkZ2V0cyA9ICh3aWRnZXRzLCBwYWdlKSA9PiB7XG4gIC8vIGZvcmNlIGxvd2VyY2FzZSBsb29rdXBcbiAgY29uc3QgY29uZmlndXJlZCA9ICh3aWRnZXRzIHx8IFtdKS5tYXAocmVmID0+IHJlZi50b0xvd2VyQ2FzZSgpKVxuXG4gIHdpZGdldHNIb3N0LmZvckVhY2god2lkZ2V0ID0+IHtcbiAgICB3aWRnZXQudmlzaWJsZSA9IGNvbmZpZ3VyZWQuaW5kZXhPZih3aWRnZXQucmVmLnRvTG93ZXJDYXNlKCkpICE9PSAtMVxuICAgIGlmICh3aWRnZXQudmlzaWJsZSkge1xuICAgICAgZW1pdCh3aWRnZXQsIFsnYWN0aXZhdGVkJ10sIHBhZ2UpXG4gICAgfVxuICB9KVxuICBpZiAoYXBwLnN0YXRlID09PSAnV2lkZ2V0cycgJiYgYWN0aXZlV2lkZ2V0ICYmICFhY3RpdmVXaWRnZXQudmlzaWJsZSkge1xuICAgIGFwcC5fc2V0U3RhdGUoJycpXG4gIH1cbn1cblxuY29uc3QgZ2V0V2lkZ2V0QnlOYW1lID0gbmFtZSA9PiB7XG4gIG5hbWUgPSB1Y2ZpcnN0KG5hbWUpXG4gIHJldHVybiB3aWRnZXRzSG9zdC5nZXRCeVJlZihuYW1lKSB8fCBmYWxzZVxufVxuXG4vKipcbiAqIGRlbGVnYXRlIGFwcCBmb2N1cyB0byBhIG9uLXNjcmVlbiB3aWRnZXRcbiAqIEBwYXJhbSBuYW1lIC0ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGZvY3VzV2lkZ2V0ID0gbmFtZSA9PiB7XG4gIGNvbnN0IHdpZGdldCA9IGdldFdpZGdldEJ5TmFtZShuYW1lKVxuICBpZiAod2lkZ2V0KSB7XG4gICAgc2V0QWN0aXZlV2lkZ2V0KHdpZGdldClcblxuICAgIC8vIGlmIGFwcCBpcyBhbHJlYWR5IGluICdXaWRnZXRzJyBzdGF0ZSB3ZSBjYW4gYXNzdW1lIHRoYXRcbiAgICAvLyBmb2N1cyBoYXMgYmVlbiBkZWxlZ2F0ZWQgZnJvbSBvbmUgd2lkZ2V0IHRvIGFub3RoZXIgc29cbiAgICAvLyB3ZSBuZWVkIHRvIHNldCB0aGUgbmV3IHdpZGdldCByZWZlcmVuY2UgYW5kIHRyaWdnZXIgYVxuICAgIC8vIG5ldyBmb2N1cyBjYWxjdWxhdGlvbiBvZiBMaWdodG5pbmcncyBmb2N1c3BhdGhcbiAgICBpZiAoYXBwLnN0YXRlID09PSAnV2lkZ2V0cycpIHtcbiAgICAgIGFwcC5yZWxvYWQoYWN0aXZlV2lkZ2V0KVxuICAgIH0gZWxzZSB7XG4gICAgICBhcHAuX3NldFN0YXRlKCdXaWRnZXRzJywgW2FjdGl2ZVdpZGdldF0pXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBoYW5kbGVSZW1vdGUgPSAodHlwZSwgbmFtZSkgPT4ge1xuICBpZiAodHlwZSA9PT0gJ3dpZGdldCcpIHtcbiAgICBmb2N1c1dpZGdldChuYW1lKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdwYWdlJykge1xuICAgIHJlc3RvcmVGb2N1cygpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHJlc3RvcmVGb2N1cyA9ICgpID0+IHtcbiAgYWN0aXZlV2lkZ2V0ID0gbnVsbFxuICBhcHAuX3NldFN0YXRlKCcnKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0QWN0aXZlV2lkZ2V0ID0gKCkgPT4ge1xuICByZXR1cm4gYWN0aXZlV2lkZ2V0XG59XG5cbmV4cG9ydCBjb25zdCBzZXRBY3RpdmVXaWRnZXQgPSBpbnN0YW5jZSA9PiB7XG4gIGFjdGl2ZVdpZGdldCA9IGluc3RhbmNlXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBzZXR0aW5ncyA9IHt9XG5jb25zdCBzdWJzY3JpYmVycyA9IHt9XG5cbmV4cG9ydCBjb25zdCBpbml0U2V0dGluZ3MgPSAoYXBwU2V0dGluZ3MsIHBsYXRmb3JtU2V0dGluZ3MpID0+IHtcbiAgc2V0dGluZ3NbJ2FwcCddID0gYXBwU2V0dGluZ3NcbiAgc2V0dGluZ3NbJ3BsYXRmb3JtJ10gPSBwbGF0Zm9ybVNldHRpbmdzXG4gIHNldHRpbmdzWyd1c2VyJ10gPSB7fVxufVxuXG5jb25zdCBwdWJsaXNoID0gKGtleSwgdmFsdWUpID0+IHtcbiAgc3Vic2NyaWJlcnNba2V5XSAmJiBzdWJzY3JpYmVyc1trZXldLmZvckVhY2goc3Vic2NyaWJlciA9PiBzdWJzY3JpYmVyKHZhbHVlKSlcbn1cblxuY29uc3QgZG90R3JhYiA9IChvYmogPSB7fSwga2V5KSA9PiB7XG4gIGlmIChvYmogPT09IG51bGwpIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9iaiA9IG9ialtrZXlzW2ldXSA9IG9ialtrZXlzW2ldXSAhPT0gdW5kZWZpbmVkID8gb2JqW2tleXNbaV1dIDoge31cbiAgfVxuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsID8gKE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID8gb2JqIDogdW5kZWZpbmVkKSA6IG9ialxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldCh0eXBlLCBrZXksIGZhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgdmFsID0gZG90R3JhYihzZXR0aW5nc1t0eXBlXSwga2V5KVxuICAgIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/IHZhbCA6IGZhbGxiYWNrXG4gIH0sXG4gIGhhcyh0eXBlLCBrZXkpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldCh0eXBlLCBrZXkpXG4gIH0sXG4gIHNldChrZXksIHZhbHVlKSB7XG4gICAgc2V0dGluZ3NbJ3VzZXInXVtrZXldID0gdmFsdWVcbiAgICBwdWJsaXNoKGtleSwgdmFsdWUpXG4gIH0sXG4gIHN1YnNjcmliZShrZXksIGNhbGxiYWNrKSB7XG4gICAgc3Vic2NyaWJlcnNba2V5XSA9IHN1YnNjcmliZXJzW2tleV0gfHwgW11cbiAgICBzdWJzY3JpYmVyc1trZXldLnB1c2goY2FsbGJhY2spXG4gIH0sXG4gIHVuc3Vic2NyaWJlKGtleSwgY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gc3Vic2NyaWJlcnNba2V5XSAmJiBzdWJzY3JpYmVyc1trZXldLmZpbmRJbmRleChjYiA9PiBjYiA9PT0gY2FsbGJhY2spXG4gICAgICBpbmRleCA+IC0xICYmIHN1YnNjcmliZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoa2V5IGluIHN1YnNjcmliZXJzKSB7XG4gICAgICAgIHN1YnNjcmliZXJzW2tleV0gPSBbXVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY2xlYXJTdWJzY3JpYmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdWJzY3JpYmVycykpIHtcbiAgICAgIGRlbGV0ZSBzdWJzY3JpYmVyc1trZXldXG4gICAgfVxuICB9LFxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uL1NldHRpbmdzJ1xuaW1wb3J0IGxvY2FsQ29va2llIGZyb20gJ2xvY2FsQ29va2llL21vZHVsZS9sb2NhbENvb2tpZS5qcydcblxubGV0IG5hbWVzcGFjZVxubGV0IGxjXG5cbmV4cG9ydCBjb25zdCBpbml0U3RvcmFnZSA9ICgpID0+IHtcbiAgbmFtZXNwYWNlID0gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdpZCcpXG4gIC8vIHRvZG86IHBhc3Mgb3B0aW9ucyAoZm9yIGV4YW1wbGUgdG8gZm9yY2UgdGhlIHVzZSBvZiBjb29raWVzKVxuICBsYyA9IG5ldyBsb2NhbENvb2tpZSgpXG59XG5cbmNvbnN0IG5hbWVzcGFjZWRLZXkgPSBrZXkgPT4gKG5hbWVzcGFjZSA/IFtuYW1lc3BhY2UsIGtleV0uam9pbignLicpIDoga2V5KVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldChrZXkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UobGMuZ2V0SXRlbShuYW1lc3BhY2VkS2V5KGtleSkpKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LFxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICBsYy5zZXRJdGVtKG5hbWVzcGFjZWRLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0sXG4gIHJlbW92ZShrZXkpIHtcbiAgICBsYy5yZW1vdmVJdGVtKG5hbWVzcGFjZWRLZXkoa2V5KSlcbiAgfSxcbiAgY2xlYXIoKSB7XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgbGMua2V5cygpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBpdGVtIGlmIGluIHRoZSBuYW1lc3BhY2VcbiAgICAgICAga2V5LmluZGV4T2YobmFtZXNwYWNlICsgJy4nKSA9PT0gMCA/IGxjLnJlbW92ZUl0ZW0oa2V5KSA6IG51bGxcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxjLmNsZWFyKClcbiAgICB9XG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5cbmNvbnN0IGRlZmF1bHRDaGFubmVscyA9IFtcbiAge1xuICAgIG51bWJlcjogMSxcbiAgICBuYW1lOiAnTWV0cm8gTmV3cyAxJyxcbiAgICBkZXNjcmlwdGlvbjogJ05ldyBZb3JrIENhYmxlIE5ld3MgQ2hhbm5lbCcsXG4gICAgZW50aXRsZWQ6IHRydWUsXG4gICAgcHJvZ3JhbToge1xuICAgICAgdGl0bGU6ICdUaGUgTW9ybmluZyBTaG93JyxcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk5ldyBZb3JrJ3MgYmVzdCBtb3JuaW5nIHNob3dcIixcbiAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUobmV3IERhdGUoKSAtIDYwICogNSAqIDEwMDApLnRvVVRDU3RyaW5nKCksIC8vIHN0YXJ0ZWQgNSBtaW51dGVzIGFnb1xuICAgICAgZHVyYXRpb246IDYwICogMzAsIC8vIDMwIG1pbnV0ZXNcbiAgICAgIGFnZVJhdGluZzogMCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgbnVtYmVyOiAyLFxuICAgIG5hbWU6ICdNVFYnLFxuICAgIGRlc2NyaXB0aW9uOiAnTXVzaWMgVGVsZXZpc2lvbicsXG4gICAgZW50aXRsZWQ6IHRydWUsXG4gICAgcHJvZ3JhbToge1xuICAgICAgdGl0bGU6ICdCZWF2aXMgYW5kIEJ1dHRoZWFkJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQW1lcmljYW4gYWR1bHQgYW5pbWF0ZWQgc2l0Y29tIGNyZWF0ZWQgYnkgTWlrZSBKdWRnZScsXG4gICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKG5ldyBEYXRlKCkgLSA2MCAqIDIwICogMTAwMCkudG9VVENTdHJpbmcoKSwgLy8gc3RhcnRlZCAyMCBtaW51dGVzIGFnb1xuICAgICAgZHVyYXRpb246IDYwICogNDUsIC8vIDQ1IG1pbnV0ZXNcbiAgICAgIGFnZVJhdGluZzogMTgsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIG51bWJlcjogMyxcbiAgICBuYW1lOiAnTkJDJyxcbiAgICBkZXNjcmlwdGlvbjogJ05CQyBUViBOZXR3b3JrJyxcbiAgICBlbnRpdGxlZDogZmFsc2UsXG4gICAgcHJvZ3JhbToge1xuICAgICAgdGl0bGU6ICdUaGUgVG9uaWdodCBTaG93IFN0YXJyaW5nIEppbW15IEZhbGxvbicsXG4gICAgICBkZXNjcmlwdGlvbjogJ0xhdGUtbmlnaHQgdGFsayBzaG93IGhvc3RlZCBieSBKaW1teSBGYWxsb24gb24gTkJDJyxcbiAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUobmV3IERhdGUoKSAtIDYwICogMTAgKiAxMDAwKS50b1VUQ1N0cmluZygpLCAvLyBzdGFydGVkIDEwIG1pbnV0ZXMgYWdvXG4gICAgICBkdXJhdGlvbjogNjAgKiA2MCwgLy8gMSBob3VyXG4gICAgICBhZ2VSYXRpbmc6IDEwLFxuICAgIH0sXG4gIH0sXG5dXG5cbmV4cG9ydCBjb25zdCBjaGFubmVscyA9ICgpID0+IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAndHYnLCBkZWZhdWx0Q2hhbm5lbHMpXG5cbmV4cG9ydCBjb25zdCByYW5kb21DaGFubmVsID0gKCkgPT4gY2hhbm5lbHMoKVt+fihjaGFubmVscy5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKV1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuXG5pbXBvcnQgeyBjaGFubmVscywgcmFuZG9tQ2hhbm5lbCB9IGZyb20gJy4vZGVmYXVsdHMnXG5cbmxldCBjdXJyZW50Q2hhbm5lbFxuY29uc3QgY2FsbGJhY2tzID0ge31cblxuY29uc3QgZW1pdCA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICBjYWxsYmFja3NbZXZlbnRdICYmXG4gICAgY2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKGNiID0+IHtcbiAgICAgIGNiLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgfSlcbn1cblxuLy8gbG9jYWwgbW9jayBtZXRob2RzXG5sZXQgbWV0aG9kcyA9IHtcbiAgZ2V0Q2hhbm5lbCgpIHtcbiAgICBpZiAoIWN1cnJlbnRDaGFubmVsKSBjdXJyZW50Q2hhbm5lbCA9IHJhbmRvbUNoYW5uZWwoKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoY3VycmVudENoYW5uZWwpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHsgLi4uY3VycmVudENoYW5uZWwgfVxuICAgICAgICBkZWxldGUgY2hhbm5lbC5wcm9ncmFtXG4gICAgICAgIHJlc29sdmUoY2hhbm5lbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdCgnTm8gY2hhbm5lbCBmb3VuZCcpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgZ2V0UHJvZ3JhbSgpIHtcbiAgICBpZiAoIWN1cnJlbnRDaGFubmVsKSBjdXJyZW50Q2hhbm5lbCA9IHJhbmRvbUNoYW5uZWwoKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjdXJyZW50Q2hhbm5lbC5wcm9ncmFtID8gcmVzb2x2ZShjdXJyZW50Q2hhbm5lbC5wcm9ncmFtKSA6IHJlamVjdCgnTm8gcHJvZ3JhbSBmb3VuZCcpXG4gICAgfSlcbiAgfSxcbiAgc2V0Q2hhbm5lbChudW1iZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKG51bWJlcikge1xuICAgICAgICBjb25zdCBuZXdDaGFubmVsID0gY2hhbm5lbHMoKS5maW5kKGMgPT4gYy5udW1iZXIgPT09IG51bWJlcilcbiAgICAgICAgaWYgKG5ld0NoYW5uZWwpIHtcbiAgICAgICAgICBjdXJyZW50Q2hhbm5lbCA9IG5ld0NoYW5uZWxcbiAgICAgICAgICBjb25zdCBjaGFubmVsID0geyAuLi5jdXJyZW50Q2hhbm5lbCB9XG4gICAgICAgICAgZGVsZXRlIGNoYW5uZWwucHJvZ3JhbVxuICAgICAgICAgIGVtaXQoJ2NoYW5uZWxDaGFuZ2UnLCBjaGFubmVsKVxuICAgICAgICAgIHJlc29sdmUoY2hhbm5lbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoJ0NoYW5uZWwgbm90IGZvdW5kJylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KCdObyBjaGFubmVsIG51bWJlciBzdXBwbGllZCcpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbn1cblxuZXhwb3J0IGNvbnN0IGluaXRUViA9IGNvbmZpZyA9PiB7XG4gIG1ldGhvZHMgPSB7fVxuICBpZiAoY29uZmlnLmdldENoYW5uZWwgJiYgdHlwZW9mIGNvbmZpZy5nZXRDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWV0aG9kcy5nZXRDaGFubmVsID0gY29uZmlnLmdldENoYW5uZWxcbiAgfVxuICBpZiAoY29uZmlnLmdldFByb2dyYW0gJiYgdHlwZW9mIGNvbmZpZy5nZXRQcm9ncmFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWV0aG9kcy5nZXRQcm9ncmFtID0gY29uZmlnLmdldFByb2dyYW1cbiAgfVxuICBpZiAoY29uZmlnLnNldENoYW5uZWwgJiYgdHlwZW9mIGNvbmZpZy5zZXRDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbWV0aG9kcy5zZXRDaGFubmVsID0gY29uZmlnLnNldENoYW5uZWxcbiAgfVxuICBpZiAoY29uZmlnLmVtaXQgJiYgdHlwZW9mIGNvbmZpZy5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uZmlnLmVtaXQoZW1pdClcbiAgfVxufVxuXG4vLyBwdWJsaWMgQVBJXG5leHBvcnQgZGVmYXVsdCB7XG4gIGNoYW5uZWwobnVtYmVyID0gbnVsbCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBjYWxsIHNldENoYW5uZWwgd2hlbiBudW1iZXIgYXJndW1lbnQgaXMgcGFzc2VkLCBvdGhlcndpc2UgZ2V0Q2hhbm5lbFxuICAgICAgICBtZXRob2RzW251bWJlciA/ICdzZXRDaGFubmVsJyA6ICdnZXRDaGFubmVsJ10obnVtYmVyKVxuICAgICAgICAgIC50aGVuKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgLy8gdG8gZG86IGVuc3VyZSBjb25zaXN0ZW50IGZvcm1hdHRpbmcgb2YgY2hhbm5lbCBpbmZvIGhlcmU/XG4gICAgICAgICAgICByZXNvbHZlKGNoYW5uZWwpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBwcm9ncmFtKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBtZXRob2RzXG4gICAgICAgICAgLmdldFByb2dyYW0oKVxuICAgICAgICAgIC50aGVuKHByb2dyYW0gPT4ge1xuICAgICAgICAgICAgLy8gdG8gZG86IGVuc3VyZSBjb25zaXN0ZW50IGZvcm1hdHRpbmcgb2YgcHJvZ3JhbSBpbmZvIGhlcmU/XG4gICAgICAgICAgICByZXNvbHZlKHByb2dyYW0pXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBlbnRpdGxlZCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbWV0aG9kc1xuICAgICAgICAgIC5nZXRDaGFubmVsKClcbiAgICAgICAgICAudGhlbihjaGFubmVsID0+IHtcbiAgICAgICAgICAgICdlbnRpdGxlZCcgaW4gY2hhbm5lbCA/IHJlc29sdmUoISFjaGFubmVsLmVudGl0bGVkKSA6IHJlamVjdCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2gocmVqZWN0KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSlcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBhZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYikge1xuICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrc1tldmVudF0gPSBjYWxsYmFja3NbZXZlbnRdIHx8IFtdXG4gICAgICBjYWxsYmFja3NbZXZlbnRdLnB1c2goY2IpXG4gICAgfSBlbHNlIHtcbiAgICAgIExvZy5lcnJvcignUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiBhcyBhIGNhbGxiYWNrJylcbiAgICB9XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNiID0gZmFsc2UpIHtcbiAgICBpZiAoY2FsbGJhY2tzW2V2ZW50XSAmJiBjYWxsYmFja3NbZXZlbnRdLmxlbmd0aCkge1xuICAgICAgY2FsbGJhY2tzW2V2ZW50XSA9IGNiID8gY2FsbGJhY2tzW2V2ZW50XS5maWx0ZXIoX2NiID0+IF9jYiA9PT0gY2IpIDogW11cbiAgICB9XG4gIH0sXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5sZXQgYmFzZVBhdGhcbmxldCBwcm94eVVybFxuXG5leHBvcnQgY29uc3QgaW5pdFV0aWxzID0gY29uZmlnID0+IHtcbiAgYmFzZVBhdGggPSBlbnN1cmVVcmxXaXRoUHJvdG9jb2wobWFrZUZ1bGxTdGF0aWNQYXRoKHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSwgY29uZmlnLnBhdGggfHwgJy8nKSlcblxuICBpZiAoY29uZmlnLnByb3h5VXJsKSB7XG4gICAgcHJveHlVcmwgPSBlbnN1cmVVcmxXaXRoUHJvdG9jb2woY29uZmlnLnByb3h5VXJsKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYXNzZXQocmVsUGF0aCkge1xuICAgIHJldHVybiBiYXNlUGF0aCArIHJlbFBhdGhcbiAgfSxcbiAgcHJveHlVcmwodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gcHJveHlVcmwgPyBwcm94eVVybCArICc/JyArIG1ha2VRdWVyeVN0cmluZyh1cmwsIG9wdGlvbnMpIDogdXJsXG4gIH0sXG4gIG1ha2VRdWVyeVN0cmluZygpIHtcbiAgICByZXR1cm4gbWFrZVF1ZXJ5U3RyaW5nKC4uLmFyZ3VtZW50cylcbiAgfSxcbiAgLy8gc2luY2UgaW1hZ2V3b3JrZXJzIGRvbid0IHdvcmsgd2l0aG91dCBwcm90b2NvbFxuICBlbnN1cmVVcmxXaXRoUHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIGVuc3VyZVVybFdpdGhQcm90b2NvbCguLi5hcmd1bWVudHMpXG4gIH0sXG59XG5cbmV4cG9ydCBjb25zdCBlbnN1cmVVcmxXaXRoUHJvdG9jb2wgPSB1cmwgPT4ge1xuICBpZiAoL15cXC9cXC8vLnRlc3QodXJsKSkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyB1cmxcbiAgfVxuICBpZiAoIS9eKD86aHR0cHM/OikvaS50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHVybFxuICB9XG4gIHJldHVybiB1cmxcbn1cblxuZXhwb3J0IGNvbnN0IG1ha2VGdWxsU3RhdGljUGF0aCA9IChwYXRobmFtZSA9ICcvJywgcGF0aCkgPT4ge1xuICAvLyBlbnN1cmUgcGF0aCBoYXMgdHJhbGluZyBzbGFzaFxuICBwYXRoID0gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSAhPT0gJy8nID8gcGF0aCArICcvJyA6IHBhdGhcblxuICAvLyBpZiBwYXRoIGlzIFVSTCwgd2UgYXNzdW1lIGl0J3MgYWxyZWFkeSB0aGUgZnVsbCBzdGF0aWMgcGF0aCwgc28gd2UganVzdCByZXR1cm4gaXRcbiAgaWYgKC9eKD86aHR0cHM/Oik/KD86XFwvXFwvKS8udGVzdChwYXRoKSkge1xuICAgIHJldHVybiBwYXRoXG4gIH1cblxuICBpZiAocGF0aC5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgIHJldHVybiBwYXRoXG4gIH0gZWxzZSB7XG4gICAgLy8gY2xlYW51cCB0aGUgcGF0aG5hbWUgKGkuZS4gcmVtb3ZlIHBvc3NpYmxlIGluZGV4Lmh0bWwpXG4gICAgcGF0aG5hbWUgPSBjbGVhblVwUGF0aE5hbWUocGF0aG5hbWUpXG5cbiAgICAvLyByZW1vdmUgcG9zc2libGUgbGVhZGluZyBkb3QgZnJvbSBwYXRoXG4gICAgcGF0aCA9IHBhdGguY2hhckF0KDApID09PSAnLicgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGhcbiAgICAvLyBlbnN1cmUgcGF0aCBoYXMgbGVhZGluZyBzbGFzaFxuICAgIHBhdGggPSBwYXRoLmNoYXJBdCgwKSAhPT0gJy8nID8gJy8nICsgcGF0aCA6IHBhdGhcbiAgICByZXR1cm4gcGF0aG5hbWUgKyBwYXRoXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNsZWFuVXBQYXRoTmFtZSA9IHBhdGhuYW1lID0+IHtcbiAgaWYgKHBhdGhuYW1lLnNsaWNlKC0xKSA9PT0gJy8nKSByZXR1cm4gcGF0aG5hbWUuc2xpY2UoMCwgLTEpXG4gIGNvbnN0IHBhcnRzID0gcGF0aG5hbWUuc3BsaXQoJy8nKVxuICBpZiAocGFydHNbcGFydHMubGVuZ3RoIC0gMV0uaW5kZXhPZignLicpID4gLTEpIHBhcnRzLnBvcCgpXG4gIHJldHVybiBwYXJ0cy5qb2luKCcvJylcbn1cblxuY29uc3QgbWFrZVF1ZXJ5U3RyaW5nID0gKHVybCwgb3B0aW9ucyA9IHt9LCB0eXBlID0gJ3VybCcpID0+IHtcbiAgLy8gYWRkIG9wZXJhdG9yIGFzIGFuIG9wdGlvblxuICBvcHRpb25zLm9wZXJhdG9yID0gJ21ldHJvbG9naWNhbCcgLy8gVG9kbzogbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZSAodmlhIHVybD8pXG4gIC8vIGFkZCB0eXBlICg9IHVybCBvciBxcikgYXMgYW4gb3B0aW9uLCB3aXRoIHVybCBhcyB0aGUgdmFsdWVcbiAgb3B0aW9uc1t0eXBlXSA9IHVybFxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgIC5tYXAoa2V5ID0+IHtcbiAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCgnJyArIG9wdGlvbnNba2V5XSlcbiAgICB9KVxuICAgIC5qb2luKCcmJylcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBMaWdodG5pbmcgZnJvbSAnLi4vTGlnaHRuaW5nJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJzaW9uTGFiZWwgZXh0ZW5kcyBMaWdodG5pbmcuQ29tcG9uZW50IHtcbiAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgIGNvbG9yOiAweGJiMDA3OGFjLFxuICAgICAgaDogNDAsXG4gICAgICB3OiAxMDAsXG4gICAgICB4OiB3ID0+IHcgLSA1MCxcbiAgICAgIHk6IGggPT4gaCAtIDUwLFxuICAgICAgbW91bnQ6IDEsXG4gICAgICBUZXh0OiB7XG4gICAgICAgIHc6IHcgPT4gdyxcbiAgICAgICAgaDogaCA9PiBoLFxuICAgICAgICB5OiA1LFxuICAgICAgICB4OiAyMCxcbiAgICAgICAgdGV4dDoge1xuICAgICAgICAgIGZvbnRTaXplOiAyMixcbiAgICAgICAgICBsaW5lSGVpZ2h0OiAyNixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgX2ZpcnN0QWN0aXZlKCkge1xuICAgIHRoaXMudGFnKCdUZXh0JykudGV4dCA9IGBBUFAgLSB2JHt0aGlzLnZlcnNpb259XFxuU0RLIC0gdiR7dGhpcy5zZGtWZXJzaW9ufWBcbiAgICB0aGlzLnRhZygnVGV4dCcpLmxvYWRUZXh0dXJlKClcbiAgICB0aGlzLncgPSB0aGlzLnRhZygnVGV4dCcpLnJlbmRlcldpZHRoICsgNDBcbiAgICB0aGlzLmggPSB0aGlzLnRhZygnVGV4dCcpLnJlbmRlckhlaWdodCArIDVcbiAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IExpZ2h0bmluZyBmcm9tICcuLi9MaWdodG5pbmcnXG5pbXBvcnQgTG9nIGZyb20gJy4uL0xvZydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlkZW9UZXh0dXJlIGV4dGVuZHMgTGlnaHRuaW5nLkNvbXBvbmVudCB7XG4gIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFZpZGVvOiB7XG4gICAgICAgIGFscGhhOiAxLFxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgcGl2b3Q6IDAuNSxcbiAgICAgICAgdGV4dHVyZTogeyB0eXBlOiBMaWdodG5pbmcudGV4dHVyZXMuU3RhdGljVGV4dHVyZSwgb3B0aW9uczoge30gfSxcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgc2V0IHZpZGVvRWwodikge1xuICAgIHRoaXMuX3ZpZGVvRWwgPSB2XG4gIH1cblxuICBnZXQgdmlkZW9FbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlkZW9FbFxuICB9XG5cbiAgZ2V0IHZpZGVvVmlldygpIHtcbiAgICByZXR1cm4gdGhpcy50YWcoJ1ZpZGVvJylcbiAgfVxuXG4gIGdldCB2aWRlb1RleHR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9WaWV3LnRleHR1cmVcbiAgfVxuXG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9WaWV3LmFscGhhID09PSAxICYmIHRoaXMudmlkZW9WaWV3LnZpc2libGUgPT09IHRydWVcbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2NyZWF0ZVZpZGVvVGV4dHVyZSgpXG4gIH1cblxuICBfY3JlYXRlVmlkZW9UZXh0dXJlKCkge1xuICAgIGNvbnN0IHN0YWdlID0gdGhpcy5zdGFnZVxuXG4gICAgY29uc3QgZ2wgPSBzdGFnZS5nbFxuICAgIGNvbnN0IGdsVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGdsVGV4dHVyZSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKVxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKVxuICAgIHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMgPSB7IHNvdXJjZTogZ2xUZXh0dXJlLCB3OiB0aGlzLnZpZGVvRWwud2lkdGgsIGg6IHRoaXMudmlkZW9FbC5oZWlnaHQgfVxuXG4gICAgdGhpcy52aWRlb1ZpZXcudyA9IHRoaXMudmlkZW9FbC53aWR0aCAvIHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKClcbiAgICB0aGlzLnZpZGVvVmlldy5oID0gdGhpcy52aWRlb0VsLmhlaWdodCAvIHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKClcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGNvbnN0IHN0YWdlID0gdGhpcy5zdGFnZVxuICAgIHRoaXMuX2xhc3RUaW1lID0gMFxuICAgIGlmICghdGhpcy5fdXBkYXRlVmlkZW9UZXh0dXJlKSB7XG4gICAgICB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLnNvdXJjZSAmJiB0aGlzLnZpZGVvRWwudmlkZW9XaWR0aCAmJiB0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgIGNvbnN0IGdsID0gc3RhZ2UuZ2xcblxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICBjb25zdCBnZXRWaWRlb1BsYXliYWNrUXVhbGl0eSA9IHRoaXMudmlkZW9FbC5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpXG5cbiAgICAgICAgICAvLyBXaGVuIEJSMl9QQUNLQUdFX0dTVDFfUExVR0lOU19CQURfUExVR0lOX0RFQlVHVVRJTFMgaXMgbm90IHNldCBpbiBXUEUsIHdlYmtpdERlY29kZWRGcmFtZUNvdW50IHdpbGwgbm90IGJlIGF2YWlsYWJsZS5cbiAgICAgICAgICAvLyBXZSdsbCBmYWxsYmFjayB0byBmaXhlZCAzMGZwcyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgLy8gQXMgJ3dlYmtpdERlY29kZWRGcmFtZUNvdW50JyBpcyBhYm91dCB0byBkZXByZWNhdGUsIGNoZWNrIGZvciB0aGUgJ3RvdGFsVmlkZW9GcmFtZXMnXG4gICAgICAgICAgY29uc3QgZnJhbWVDb3VudCA9IGdldFZpZGVvUGxheWJhY2tRdWFsaXR5XG4gICAgICAgICAgICA/IGdldFZpZGVvUGxheWJhY2tRdWFsaXR5LnRvdGFsVmlkZW9GcmFtZXNcbiAgICAgICAgICAgIDogdGhpcy52aWRlb0VsLndlYmtpdERlY29kZWRGcmFtZUNvdW50XG5cbiAgICAgICAgICBjb25zdCBtdXN0VXBkYXRlID0gZnJhbWVDb3VudFxuICAgICAgICAgICAgPyB0aGlzLl9sYXN0RnJhbWUgIT09IGZyYW1lQ291bnRcbiAgICAgICAgICAgIDogdGhpcy5fbGFzdFRpbWUgPCBjdXJyZW50VGltZSAtIDMwXG5cbiAgICAgICAgICBpZiAobXVzdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSBjdXJyZW50VGltZVxuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gZnJhbWVDb3VudFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5zb3VyY2UpXG4gICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZmFsc2UpXG4gICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy52aWRlb0VsKVxuICAgICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLnZpZGVvRWwud2Via2l0RGVjb2RlZEZyYW1lQ291bnRcbiAgICAgICAgICAgICAgdGhpcy52aWRlb1ZpZXcudmlzaWJsZSA9IHRydWVcblxuICAgICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLncgPSB0aGlzLnZpZGVvRWwud2lkdGhcbiAgICAgICAgICAgICAgdGhpcy52aWRlb1RleHR1cmUub3B0aW9ucy5oID0gdGhpcy52aWRlb0VsLmhlaWdodFxuICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEFzcGVjdFJhdGlvID0gdGhpcy52aWRlb1ZpZXcudyAvIHRoaXMudmlkZW9WaWV3LmhcbiAgICAgICAgICAgICAgY29uc3QgcmVhbEFzcGVjdFJhdGlvID0gdGhpcy52aWRlb0VsLndpZHRoIC8gdGhpcy52aWRlb0VsLmhlaWdodFxuXG4gICAgICAgICAgICAgIGlmIChleHBlY3RlZEFzcGVjdFJhdGlvID4gcmVhbEFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1ZpZXcuc2NhbGVYID0gcmVhbEFzcGVjdFJhdGlvIC8gZXhwZWN0ZWRBc3BlY3RSYXRpb1xuICAgICAgICAgICAgICAgIHRoaXMudmlkZW9WaWV3LnNjYWxlWSA9IDFcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZGVvVmlldy5zY2FsZVkgPSBleHBlY3RlZEFzcGVjdFJhdGlvIC8gcmVhbEFzcGVjdFJhdGlvXG4gICAgICAgICAgICAgICAgdGhpcy52aWRlb1ZpZXcuc2NhbGVYID0gMVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIExvZy5lcnJvcigndGV4SW1hZ2UyZCB2aWRlbycsIGUpXG4gICAgICAgICAgICAgIHRoaXMuc3RvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZGVvVGV4dHVyZS5zb3VyY2UuZm9yY2VSZW5kZXJVcGRhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlKSB7XG4gICAgICBzdGFnZS5vbignZnJhbWVTdGFydCcsIHRoaXMuX3VwZGF0ZVZpZGVvVGV4dHVyZSlcbiAgICAgIHRoaXMuX3VwZGF0aW5nVmlkZW9UZXh0dXJlID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgY29uc3Qgc3RhZ2UgPSB0aGlzLnN0YWdlXG4gICAgc3RhZ2UucmVtb3ZlTGlzdGVuZXIoJ2ZyYW1lU3RhcnQnLCB0aGlzLl91cGRhdGVWaWRlb1RleHR1cmUpXG4gICAgdGhpcy5fdXBkYXRpbmdWaWRlb1RleHR1cmUgPSBmYWxzZVxuICAgIHRoaXMudmlkZW9WaWV3LnZpc2libGUgPSBmYWxzZVxuXG4gICAgaWYgKHRoaXMudmlkZW9UZXh0dXJlLm9wdGlvbnMuc291cmNlKSB7XG4gICAgICBjb25zdCBnbCA9IHN0YWdlLmdsXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnZpZGVvVGV4dHVyZS5vcHRpb25zLnNvdXJjZSlcbiAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMSlcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXG4gICAgfVxuICB9XG5cbiAgcG9zaXRpb24odG9wLCBsZWZ0KSB7XG4gICAgdGhpcy52aWRlb1ZpZXcucGF0Y2goe1xuICAgICAgc21vb3RoOiB7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IHRvcCxcbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudmlkZW9WaWV3LnBhdGNoKHtcbiAgICAgIHNtb290aDoge1xuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0LFxuICAgICAgfSxcbiAgICB9KVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICB0aGlzLnZpZGVvVmlldy5zZXRTbW9vdGgoJ2FscGhhJywgMSlcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgdGhpcy52aWRlb1ZpZXcuc2V0U21vb3RoKCdhbHBoYScsIDApXG4gIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgYWJvcnQ6ICdBYm9ydCcsXG4gIGNhbnBsYXk6ICdDYW5QbGF5JyxcbiAgY2FucGxheXRocm91Z2g6ICdDYW5QbGF5VGhyb3VnaCcsXG4gIGR1cmF0aW9uY2hhbmdlOiAnRHVyYXRpb25DaGFuZ2UnLFxuICBlbXB0aWVkOiAnRW1wdGllZCcsXG4gIGVuY3J5cHRlZDogJ0VuY3J5cHRlZCcsXG4gIGVuZGVkOiAnRW5kZWQnLFxuICBlcnJvcjogJ0Vycm9yJyxcbiAgaW50ZXJydXB0YmVnaW46ICdJbnRlcnJ1cHRCZWdpbicsXG4gIGludGVycnVwdGVuZDogJ0ludGVycnVwdEVuZCcsXG4gIGxvYWRlZGRhdGE6ICdMb2FkZWREYXRhJyxcbiAgbG9hZGVkbWV0YWRhdGE6ICdMb2FkZWRNZXRhZGF0YScsXG4gIGxvYWRzdGFydDogJ0xvYWRTdGFydCcsXG4gIHBhdXNlOiAnUGF1c2UnLFxuICBwbGF5OiAnUGxheScsXG4gIHBsYXlpbmc6ICdQbGF5aW5nJyxcbiAgcHJvZ3Jlc3M6ICdQcm9ncmVzcycsXG4gIHJhdGVjaGFuZ2U6ICdSYXRlY2hhbmdlJyxcbiAgc2Vla2VkOiAnU2Vla2VkJyxcbiAgc2Vla2luZzogJ1NlZWtpbmcnLFxuICBzdGFsbGVkOiAnU3RhbGxlZCcsXG4gIC8vIHN1c3BlbmQ6ICdTdXNwZW5kJywgLy8gdGhpcyBvbmUgaXMgY2FsbGVkIGEgbG9vb29vdCBmb3Igc29tZSB2aWRlb3NcbiAgdGltZXVwZGF0ZTogJ1RpbWVVcGRhdGUnLFxuICB2b2x1bWVjaGFuZ2U6ICdWb2x1bWVDaGFuZ2UnLFxuICB3YWl0aW5nOiAnV2FpdGluZycsXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgZXhlY3V0ZUFzUHJvbWlzZSBmcm9tICdAbWljaGllbGpzL2V4ZWN1dGUtYXMtcHJvbWlzZSdcblxuaW1wb3J0IE1ldHJpY3MgZnJvbSAnLi4vTWV0cmljcydcbmltcG9ydCBMb2cgZnJvbSAnLi4vTG9nJ1xuaW1wb3J0IEFkcyBmcm9tICcuLi9BZHMnXG5cbmltcG9ydCBldmVudHMgZnJvbSAnLi9ldmVudHMnXG5pbXBvcnQgYXV0b1NldHVwTWl4aW4gZnJvbSAnLi4vaGVscGVycy9hdXRvU2V0dXBNaXhpbidcbmltcG9ydCBlYXNlRXhlY3V0aW9uIGZyb20gJy4uL2hlbHBlcnMvZWFzZUV4ZWN1dGlvbidcbmltcG9ydCB7IEFwcGxpY2F0aW9uSW5zdGFuY2UgfSBmcm9tICcuLi9MYXVuY2gnXG5pbXBvcnQgU2V0dGluZ3MgZnJvbSAnLi4vU2V0dGluZ3MnXG5pbXBvcnQgVmlkZW9UZXh0dXJlIGZyb20gJy4vVmlkZW9UZXh0dXJlJ1xuXG5leHBvcnQgbGV0IG1lZGlhVXJsID0gdXJsID0+IHVybFxubGV0IHZpZGVvRWxcbmxldCB2aWRlb1RleHR1cmVcbmxldCBtZXRyaWNzXG5sZXQgY29uc3VtZXJcbmxldCBwcmVjaXNpb24gPSAxXG5sZXQgdGV4dHVyZU1vZGUgPSBmYWxzZVxuXG5leHBvcnQgY29uc3QgaW5pdFZpZGVvUGxheWVyID0gY29uZmlnID0+IHtcbiAgaWYgKGNvbmZpZy5tZWRpYVVybCkge1xuICAgIG1lZGlhVXJsID0gY29uZmlnLm1lZGlhVXJsXG4gIH1cbn1cblxuLy8gdG9kbzogYWRkIHRoaXMgaW4gYSAnUmVnaXN0cnknIHBsdWdpblxuLy8gdG8gYmUgYWJsZSB0byBhbHdheXMgY2xlYW4gdGhpcyB1cCBvbiBhcHAgY2xvc2VcbmxldCBldmVudEhhbmRsZXJzID0ge31cblxuY29uc3Qgc3RhdGUgPSB7XG4gIGFkc0VuYWJsZWQ6IGZhbHNlLFxuICBwbGF5aW5nOiBmYWxzZSxcbiAgX3BsYXlpbmdBZHM6IGZhbHNlLFxuICBnZXQgcGxheWluZ0FkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGxheWluZ0Fkc1xuICB9LFxuICBzZXQgcGxheWluZ0Fkcyh2YWwpIHtcbiAgICBpZiAodGhpcy5fcGxheWluZ0FkcyAhPT0gdmFsKSB7XG4gICAgICB0aGlzLl9wbGF5aW5nQWRzID0gdmFsXG4gICAgICBmaXJlT25Db25zdW1lcih2YWwgPT09IHRydWUgPyAnQWRTdGFydCcgOiAnQWRFbmQnKVxuICAgIH1cbiAgfSxcbiAgc2tpcFRpbWU6IGZhbHNlLFxuICBwbGF5QWZ0ZXJTZWVrOiBudWxsLFxufVxuXG5jb25zdCBob29rcyA9IHtcbiAgcGxheSgpIHtcbiAgICBzdGF0ZS5wbGF5aW5nID0gdHJ1ZVxuICB9LFxuICBwYXVzZSgpIHtcbiAgICBzdGF0ZS5wbGF5aW5nID0gZmFsc2VcbiAgfSxcbiAgc2Vla2VkKCkge1xuICAgIHN0YXRlLnBsYXlBZnRlclNlZWsgPT09IHRydWUgJiYgdmlkZW9QbGF5ZXJQbHVnaW4ucGxheSgpXG4gICAgc3RhdGUucGxheUFmdGVyU2VlayA9IG51bGxcbiAgfSxcbiAgYWJvcnQoKSB7XG4gICAgZGVyZWdpc3RlckV2ZW50TGlzdGVuZXJzKClcbiAgfSxcbn1cblxuY29uc3Qgd2l0aFByZWNpc2lvbiA9IHZhbCA9PiBNYXRoLnJvdW5kKHByZWNpc2lvbiAqIHZhbCkgKyAncHgnXG5cbmNvbnN0IGZpcmVPbkNvbnN1bWVyID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gIGlmIChjb25zdW1lcikge1xuICAgIGNvbnN1bWVyLmZpcmUoJyR2aWRlb1BsYXllcicgKyBldmVudCwgYXJncywgdmlkZW9FbC5jdXJyZW50VGltZSlcbiAgICBjb25zdW1lci5maXJlKCckdmlkZW9QbGF5ZXJFdmVudCcsIGV2ZW50LCBhcmdzLCB2aWRlb0VsLmN1cnJlbnRUaW1lKVxuICB9XG59XG5cbmNvbnN0IGZpcmVIb29rID0gKGV2ZW50LCBhcmdzKSA9PiB7XG4gIGhvb2tzW2V2ZW50XSAmJiB0eXBlb2YgaG9va3NbZXZlbnRdID09PSAnZnVuY3Rpb24nICYmIGhvb2tzW2V2ZW50XS5jYWxsKG51bGwsIGV2ZW50LCBhcmdzKVxufVxuXG5sZXQgY3VzdG9tTG9hZGVyID0gbnVsbFxubGV0IGN1c3RvbVVubG9hZGVyID0gbnVsbFxuXG5jb25zdCBsb2FkZXIgPSAodXJsLCB2aWRlb0VsLCBjb25maWcpID0+IHtcbiAgcmV0dXJuIGN1c3RvbUxvYWRlciAmJiB0eXBlb2YgY3VzdG9tTG9hZGVyID09PSAnZnVuY3Rpb24nXG4gICAgPyBjdXN0b21Mb2FkZXIodXJsLCB2aWRlb0VsLCBjb25maWcpXG4gICAgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdXJsID0gbWVkaWFVcmwodXJsKVxuICAgICAgICB2aWRlb0VsLnNldEF0dHJpYnV0ZSgnc3JjJywgdXJsKVxuICAgICAgICB2aWRlb0VsLmxvYWQoKVxuICAgICAgICByZXNvbHZlKClcbiAgICAgIH0pXG59XG5cbmNvbnN0IHVubG9hZGVyID0gdmlkZW9FbCA9PiB7XG4gIHJldHVybiBjdXN0b21VbmxvYWRlciAmJiB0eXBlb2YgY3VzdG9tVW5sb2FkZXIgPT09ICdmdW5jdGlvbidcbiAgICA/IGN1c3RvbVVubG9hZGVyKHZpZGVvRWwpXG4gICAgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdmlkZW9FbC5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICAgIHZpZGVvRWwubG9hZCgpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHNldHVwVmlkZW9UYWcgPSAoKSA9PiB7XG4gIGNvbnN0IHZpZGVvRWxzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3ZpZGVvJylcbiAgaWYgKHZpZGVvRWxzICYmIHZpZGVvRWxzLmxlbmd0aCkge1xuICAgIHJldHVybiB2aWRlb0Vsc1swXVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpZGVvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpXG4gICAgY29uc3QgcGxhdGZvcm1TZXR0aW5nc1dpZHRoID0gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICd3aWR0aCcpXG4gICAgICA/IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnd2lkdGgnKVxuICAgICAgOiAxOTIwXG4gICAgY29uc3QgcGxhdGZvcm1TZXR0aW5nc0hlaWdodCA9IFNldHRpbmdzLmdldCgncGxhdGZvcm0nLCAnaGVpZ2h0JylcbiAgICAgID8gU2V0dGluZ3MuZ2V0KCdwbGF0Zm9ybScsICdoZWlnaHQnKVxuICAgICAgOiAxMDgwXG4gICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3ZpZGVvLXBsYXllcicpXG4gICAgdmlkZW9FbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2l0aFByZWNpc2lvbihwbGF0Zm9ybVNldHRpbmdzV2lkdGgpKVxuICAgIHZpZGVvRWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB3aXRoUHJlY2lzaW9uKHBsYXRmb3JtU2V0dGluZ3NIZWlnaHQpKVxuICAgIHZpZGVvRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgdmlkZW9FbC5zdHlsZS56SW5kZXggPSAnMSdcbiAgICB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICB2aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgIHZpZGVvRWwuc3R5bGUudG9wID0gd2l0aFByZWNpc2lvbigwKVxuICAgIHZpZGVvRWwuc3R5bGUubGVmdCA9IHdpdGhQcmVjaXNpb24oMClcbiAgICB2aWRlb0VsLnN0eWxlLndpZHRoID0gd2l0aFByZWNpc2lvbihwbGF0Zm9ybVNldHRpbmdzV2lkdGgpXG4gICAgdmlkZW9FbC5zdHlsZS5oZWlnaHQgPSB3aXRoUHJlY2lzaW9uKHBsYXRmb3JtU2V0dGluZ3NIZWlnaHQpXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh2aWRlb0VsKVxuICAgIHJldHVybiB2aWRlb0VsXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHNldFVwVmlkZW9UZXh0dXJlID0gKCkgPT4ge1xuICBpZiAoIUFwcGxpY2F0aW9uSW5zdGFuY2UudGFnKCdWaWRlb1RleHR1cmUnKSkge1xuICAgIGNvbnN0IGVsID0gQXBwbGljYXRpb25JbnN0YW5jZS5zdGFnZS5jKHtcbiAgICAgIHR5cGU6IFZpZGVvVGV4dHVyZSxcbiAgICAgIHJlZjogJ1ZpZGVvVGV4dHVyZScsXG4gICAgICB6SW5kZXg6IDAsXG4gICAgICB2aWRlb0VsLFxuICAgIH0pXG4gICAgQXBwbGljYXRpb25JbnN0YW5jZS5jaGlsZExpc3QuYWRkQXQoZWwsIDApXG4gIH1cbiAgcmV0dXJuIEFwcGxpY2F0aW9uSW5zdGFuY2UudGFnKCdWaWRlb1RleHR1cmUnKVxufVxuXG5jb25zdCByZWdpc3RlckV2ZW50TGlzdGVuZXJzID0gKCkgPT4ge1xuICBMb2cuaW5mbygnVmlkZW9QbGF5ZXInLCAnUmVnaXN0ZXJpbmcgZXZlbnQgbGlzdGVuZXJzJylcbiAgT2JqZWN0LmtleXMoZXZlbnRzKS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gZSA9PiB7XG4gICAgICAvLyBGaXJlIGEgbWV0cmljIGZvciBlYWNoIGV2ZW50IChpZiBpdCBleGlzdHMgb24gdGhlIG1ldHJpY3Mgb2JqZWN0KVxuICAgICAgaWYgKG1ldHJpY3MgJiYgbWV0cmljc1tldmVudF0gJiYgdHlwZW9mIG1ldHJpY3NbZXZlbnRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1ldHJpY3NbZXZlbnRdKHsgY3VycmVudFRpbWU6IHZpZGVvRWwuY3VycmVudFRpbWUgfSlcbiAgICAgIH1cbiAgICAgIC8vIGZpcmUgYW4gaW50ZXJuYWwgaG9va1xuICAgICAgZmlyZUhvb2soZXZlbnQsIHsgdmlkZW9FbGVtZW50OiB2aWRlb0VsLCBldmVudDogZSB9KVxuXG4gICAgICAvLyBmaXJlIHRoZSBldmVudCAod2l0aCBodW1hbiBmcmllbmRseSBldmVudCBuYW1lKSB0byB0aGUgY29uc3VtZXIgb2YgdGhlIFZpZGVvUGxheWVyXG4gICAgICBmaXJlT25Db25zdW1lcihldmVudHNbZXZlbnRdLCB7IHZpZGVvRWxlbWVudDogdmlkZW9FbCwgZXZlbnQ6IGUgfSlcbiAgICB9XG5cbiAgICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJcbiAgICB2aWRlb0VsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpXG4gIH0pXG59XG5cbmNvbnN0IGRlcmVnaXN0ZXJFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgTG9nLmluZm8oJ1ZpZGVvUGxheWVyJywgJ0RlcmVnaXN0ZXJpbmcgZXZlbnQgbGlzdGVuZXJzJylcbiAgT2JqZWN0LmtleXMoZXZlbnRIYW5kbGVycykuZm9yRWFjaChldmVudCA9PiB7XG4gICAgdmlkZW9FbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBldmVudEhhbmRsZXJzW2V2ZW50XSlcbiAgfSlcbiAgZXZlbnRIYW5kbGVycyA9IHt9XG59XG5cbmNvbnN0IHZpZGVvUGxheWVyUGx1Z2luID0ge1xuICBjb25zdW1lcihjb21wb25lbnQpIHtcbiAgICBjb25zdW1lciA9IGNvbXBvbmVudFxuICB9LFxuXG4gIGxvYWRlcihsb2FkZXJGbikge1xuICAgIGN1c3RvbUxvYWRlciA9IGxvYWRlckZuXG4gIH0sXG5cbiAgdW5sb2FkZXIodW5sb2FkZXJGbikge1xuICAgIGN1c3RvbVVubG9hZGVyID0gdW5sb2FkZXJGblxuICB9LFxuXG4gIHBvc2l0aW9uKHRvcCA9IDAsIGxlZnQgPSAwKSB7XG4gICAgdmlkZW9FbC5zdHlsZS5sZWZ0ID0gd2l0aFByZWNpc2lvbihsZWZ0KVxuICAgIHZpZGVvRWwuc3R5bGUudG9wID0gd2l0aFByZWNpc2lvbih0b3ApXG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB7XG4gICAgICB2aWRlb1RleHR1cmUucG9zaXRpb24odG9wLCBsZWZ0KVxuICAgIH1cbiAgfSxcblxuICBzaXplKHdpZHRoID0gMTkyMCwgaGVpZ2h0ID0gMTA4MCkge1xuICAgIHZpZGVvRWwuc3R5bGUud2lkdGggPSB3aXRoUHJlY2lzaW9uKHdpZHRoKVxuICAgIHZpZGVvRWwuc3R5bGUuaGVpZ2h0ID0gd2l0aFByZWNpc2lvbihoZWlnaHQpXG4gICAgdmlkZW9FbC53aWR0aCA9IHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS53aWR0aClcbiAgICB2aWRlb0VsLmhlaWdodCA9IHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS5oZWlnaHQpXG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB7XG4gICAgICB2aWRlb1RleHR1cmUuc2l6ZSh3aWR0aCwgaGVpZ2h0KVxuICAgIH1cbiAgfSxcblxuICBhcmVhKHRvcCA9IDAsIHJpZ2h0ID0gMTkyMCwgYm90dG9tID0gMTA4MCwgbGVmdCA9IDApIHtcbiAgICB0aGlzLnBvc2l0aW9uKHRvcCwgbGVmdClcbiAgICB0aGlzLnNpemUocmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApXG4gIH0sXG5cbiAgb3Blbih1cmwsIGNvbmZpZyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICBtZXRyaWNzID0gTWV0cmljcy5tZWRpYSh1cmwpXG5cbiAgICB0aGlzLmhpZGUoKVxuICAgIGRlcmVnaXN0ZXJFdmVudExpc3RlbmVycygpXG5cbiAgICBpZiAodGhpcy5zcmMgPT0gdXJsKSB7XG4gICAgICB0aGlzLmNsZWFyKCkudGhlbih0aGlzLm9wZW4odXJsLCBjb25maWcpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhZENvbmZpZyA9IHsgZW5hYmxlZDogc3RhdGUuYWRzRW5hYmxlZCwgZHVyYXRpb246IDMwMCB9XG4gICAgICBpZiAoY29uZmlnLnZpZGVvSWQpIHtcbiAgICAgICAgYWRDb25maWcuY2FpZCA9IGNvbmZpZy52aWRlb0lkXG4gICAgICB9XG4gICAgICBBZHMuZ2V0KGFkQ29uZmlnLCBjb25zdW1lcikudGhlbihhZHMgPT4ge1xuICAgICAgICBzdGF0ZS5wbGF5aW5nQWRzID0gdHJ1ZVxuICAgICAgICBhZHMucHJlcm9sbHMoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBzdGF0ZS5wbGF5aW5nQWRzID0gZmFsc2VcbiAgICAgICAgICBsb2FkZXIodXJsLCB2aWRlb0VsLCBjb25maWcpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyRXZlbnRMaXN0ZW5lcnMoKVxuICAgICAgICAgICAgICB0aGlzLnNob3coKVxuICAgICAgICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgZmlyZU9uQ29uc3VtZXIoJ2Vycm9yJywgeyB2aWRlb0VsZW1lbnQ6IHZpZGVvRWwsIGV2ZW50OiBlIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgcmVsb2FkKCkge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgY29uc3QgdXJsID0gdmlkZW9FbC5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgdGhpcy5jbG9zZSgpXG4gICAgdGhpcy5vcGVuKHVybClcbiAgfSxcblxuICBjbG9zZSgpIHtcbiAgICBBZHMuY2FuY2VsKClcbiAgICBpZiAoc3RhdGUucGxheWluZ0Fkcykge1xuICAgICAgc3RhdGUucGxheWluZ0FkcyA9IGZhbHNlXG4gICAgICBBZHMuc3RvcCgpXG4gICAgICAvLyBjYWxsIHNlbGYgaW4gbmV4dCB0aWNrXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHRoaXMuY2xlYXIoKVxuICAgIHRoaXMuaGlkZSgpXG4gICAgZGVyZWdpc3RlckV2ZW50TGlzdGVuZXJzKClcbiAgfSxcblxuICBjbGVhcigpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIC8vIHBhdXNlIHRoZSB2aWRlbyBmaXJzdCB0byBkaXNhYmxlIHNvdW5kXG4gICAgdGhpcy5wYXVzZSgpXG4gICAgaWYgKHRleHR1cmVNb2RlID09PSB0cnVlKSB2aWRlb1RleHR1cmUuc3RvcCgpXG4gICAgcmV0dXJuIHVubG9hZGVyKHZpZGVvRWwpLnRoZW4oKCkgPT4ge1xuICAgICAgZmlyZU9uQ29uc3VtZXIoJ0NsZWFyJywgeyB2aWRlb0VsZW1lbnQ6IHZpZGVvRWwgfSlcbiAgICB9KVxuICB9LFxuXG4gIHBsYXkoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkludGVyYWN0KSByZXR1cm5cbiAgICBpZiAodGV4dHVyZU1vZGUgPT09IHRydWUpIHZpZGVvVGV4dHVyZS5zdGFydCgpXG4gICAgZXhlY3V0ZUFzUHJvbWlzZSh2aWRlb0VsLnBsYXksIG51bGwsIHZpZGVvRWwpLmNhdGNoKGUgPT4ge1xuICAgICAgZmlyZU9uQ29uc3VtZXIoJ2Vycm9yJywgeyB2aWRlb0VsZW1lbnQ6IHZpZGVvRWwsIGV2ZW50OiBlIH0pXG4gICAgfSlcbiAgfSxcblxuICBwYXVzZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHZpZGVvRWwucGF1c2UoKVxuICB9LFxuXG4gIHBsYXlQYXVzZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHRoaXMucGxheWluZyA9PT0gdHJ1ZSA/IHRoaXMucGF1c2UoKSA6IHRoaXMucGxheSgpXG4gIH0sXG5cbiAgbXV0ZShtdXRlZCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIHZpZGVvRWwubXV0ZWQgPSBtdXRlZFxuICB9LFxuXG4gIGxvb3AobG9vcGVkID0gdHJ1ZSkge1xuICAgIHZpZGVvRWwubG9vcCA9IGxvb3BlZFxuICB9LFxuXG4gIHNlZWsodGltZSkge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnNyYykgcmV0dXJuXG4gICAgLy8gZGVmaW5lIHdoZXRoZXIgc2hvdWxkIGNvbnRpbnVlIHRvIHBsYXkgYWZ0ZXIgc2VlayBpcyBjb21wbGV0ZSAoaW4gc2Vla2VkIGhvb2spXG4gICAgaWYgKHN0YXRlLnBsYXlBZnRlclNlZWsgPT09IG51bGwpIHtcbiAgICAgIHN0YXRlLnBsYXlBZnRlclNlZWsgPSAhIXN0YXRlLnBsYXlpbmdcbiAgICB9XG4gICAgLy8gcGF1c2UgYmVmb3JlIGFjdHVhbGx5IHNlZWtpbmdcbiAgICB0aGlzLnBhdXNlKClcbiAgICAvLyBjdXJyZW50VGltZSBhbHdheXMgYmV0d2VlbiAwIGFuZCB0aGUgZHVyYXRpb24gb2YgdGhlIHZpZGVvIChtaW51cyAwLjFzIHRvIG5vdCBzZXQgdG8gdGhlIGZpbmFsIGZyYW1lIGFuZCBzdGFsbCB0aGUgdmlkZW8pXG4gICAgdmlkZW9FbC5jdXJyZW50VGltZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRpbWUsIHRoaXMuZHVyYXRpb24gLSAwLjEpKVxuICB9LFxuXG4gIHNraXAoc2Vjb25kcykge1xuICAgIGlmICghdGhpcy5jYW5JbnRlcmFjdCkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnNyYykgcmV0dXJuXG5cbiAgICBzdGF0ZS5za2lwVGltZSA9IChzdGF0ZS5za2lwVGltZSB8fCB2aWRlb0VsLmN1cnJlbnRUaW1lKSArIHNlY29uZHNcbiAgICBlYXNlRXhlY3V0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuc2VlayhzdGF0ZS5za2lwVGltZSlcbiAgICAgIHN0YXRlLnNraXBUaW1lID0gZmFsc2VcbiAgICB9LCAzMDApXG4gIH0sXG5cbiAgc2hvdygpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdmlkZW9UZXh0dXJlLnNob3coKVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICB2aWRlb0VsLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICB9XG4gIH0sXG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuY2FuSW50ZXJhY3QpIHJldHVyblxuICAgIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgdmlkZW9UZXh0dXJlLmhpZGUoKVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0VsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgIHZpZGVvRWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgfVxuICB9LFxuXG4gIGVuYWJsZUFkcyhlbmFibGVkID0gdHJ1ZSkge1xuICAgIHN0YXRlLmFkc0VuYWJsZWQgPSBlbmFibGVkXG4gIH0sXG5cbiAgLyogUHVibGljIGdldHRlcnMgKi9cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIChpc05hTih2aWRlb0VsLmR1cmF0aW9uKSA/IEluZmluaXR5IDogdmlkZW9FbC5kdXJhdGlvbilcbiAgfSxcblxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgdmlkZW9FbC5jdXJyZW50VGltZVxuICB9LFxuXG4gIGdldCBtdXRlZCgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiB2aWRlb0VsLm11dGVkXG4gIH0sXG5cbiAgZ2V0IGxvb3BlZCgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiB2aWRlb0VsLmxvb3BcbiAgfSxcblxuICBnZXQgc3JjKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHZpZGVvRWwuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICB9LFxuXG4gIGdldCBwbGF5aW5nKCkge1xuICAgIHJldHVybiBzdGF0ZS5wbGF5aW5nXG4gIH0sXG5cbiAgZ2V0IHBsYXlpbmdBZHMoKSB7XG4gICAgcmV0dXJuIHN0YXRlLnBsYXlpbmdBZHNcbiAgfSxcblxuICBnZXQgY2FuSW50ZXJhY3QoKSB7XG4gICAgLy8gdG9kbzogcGVyaGFwcyBhZGQgYW4gZXh0cmEgZmxhZyB3ZXRoZXIgd2UgYWxsb3cgaW50ZXJhY3Rpb25zIChpLmUuIHBhdXplLCBtdXRlLCBldGMuKSBkdXJpbmcgYWQgcGxheWJhY2tcbiAgICByZXR1cm4gc3RhdGUucGxheWluZ0FkcyA9PT0gZmFsc2VcbiAgfSxcblxuICBnZXQgdG9wKCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS50b3ApXG4gIH0sXG5cbiAgZ2V0IGxlZnQoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgcGFyc2VGbG9hdCh2aWRlb0VsLnN0eWxlLmxlZnQpXG4gIH0sXG5cbiAgZ2V0IGJvdHRvbSgpIHtcbiAgICByZXR1cm4gdmlkZW9FbCAmJiBwYXJzZUZsb2F0KHZpZGVvRWwuc3R5bGUudG9wIC0gdmlkZW9FbC5zdHlsZS5oZWlnaHQpXG4gIH0sXG5cbiAgZ2V0IHJpZ2h0KCkge1xuICAgIHJldHVybiB2aWRlb0VsICYmIHBhcnNlRmxvYXQodmlkZW9FbC5zdHlsZS5sZWZ0IC0gdmlkZW9FbC5zdHlsZS53aWR0aClcbiAgfSxcblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgcGFyc2VGbG9hdCh2aWRlb0VsLnN0eWxlLndpZHRoKVxuICB9LFxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHZpZGVvRWwgJiYgcGFyc2VGbG9hdCh2aWRlb0VsLnN0eWxlLmhlaWdodClcbiAgfSxcblxuICBnZXQgdmlzaWJsZSgpIHtcbiAgICBpZiAodGV4dHVyZU1vZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiB2aWRlb1RleHR1cmUuaXNWaXNpYmxlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2aWRlb0VsICYmIHZpZGVvRWwuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJ1xuICAgIH1cbiAgfSxcblxuICBnZXQgYWRzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gc3RhdGUuYWRzRW5hYmxlZFxuICB9LFxuXG4gIC8vIHByZWZpeGVkIHdpdGggdW5kZXJzY29yZSB0byBpbmRpY2F0ZSAnc2VtaS1wcml2YXRlJ1xuICAvLyBiZWNhdXNlIGl0J3Mgbm90IHJlY29tbWVuZGVkIHRvIGludGVyYWN0IGRpcmVjdGx5IHdpdGggdGhlIHZpZGVvIGVsZW1lbnRcbiAgZ2V0IF92aWRlb0VsKCkge1xuICAgIHJldHVybiB2aWRlb0VsXG4gIH0sXG5cbiAgZ2V0IF9jb25zdW1lcigpIHtcbiAgICByZXR1cm4gY29uc3VtZXJcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXV0b1NldHVwTWl4aW4odmlkZW9QbGF5ZXJQbHVnaW4sICgpID0+IHtcbiAgcHJlY2lzaW9uID1cbiAgICAoQXBwbGljYXRpb25JbnN0YW5jZSAmJlxuICAgICAgQXBwbGljYXRpb25JbnN0YW5jZS5zdGFnZSAmJlxuICAgICAgQXBwbGljYXRpb25JbnN0YW5jZS5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKSkgfHxcbiAgICBwcmVjaXNpb25cblxuICB2aWRlb0VsID0gc2V0dXBWaWRlb1RhZygpXG5cbiAgdGV4dHVyZU1vZGUgPSBTZXR0aW5ncy5nZXQoJ3BsYXRmb3JtJywgJ3RleHR1cmVNb2RlJywgZmFsc2UpXG4gIGlmICh0ZXh0dXJlTW9kZSA9PT0gdHJ1ZSkge1xuICAgIHZpZGVvRWwuc2V0QXR0cmlidXRlKCdjcm9zc29yaWdpbicsICdhbm9ueW1vdXMnKVxuICAgIHZpZGVvVGV4dHVyZSA9IHNldFVwVmlkZW9UZXh0dXJlKClcbiAgfVxufSlcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IChzb3VyY2VPYmplY3QsIHNldHVwID0gKCkgPT4ge30pID0+IHtcbiAgbGV0IHJlYWR5ID0gZmFsc2VcblxuICBjb25zdCBkb1NldHVwID0gKCkgPT4ge1xuICAgIGlmIChyZWFkeSA9PT0gZmFsc2UpIHtcbiAgICAgIHNldHVwKClcbiAgICAgIHJlYWR5ID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2VPYmplY3QpLnJlZHVjZSgob2JqLCBrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZU9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvYmpba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkb1NldHVwKClcbiAgICAgICAgcmV0dXJuIHNvdXJjZU9iamVjdFtrZXldLmFwcGx5KHNvdXJjZU9iamVjdCwgYXJndW1lbnRzKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlT2JqZWN0LCBrZXkpLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb2JqLl9fZGVmaW5lR2V0dGVyX18oa2V5LCBmdW5jdGlvbigpIHtcbiAgICAgICAgZG9TZXR1cCgpXG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZU9iamVjdCwga2V5KS5nZXQuYXBwbHkoc291cmNlT2JqZWN0KVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZU9iamVjdCwga2V5KS5zZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9iai5fX2RlZmluZVNldHRlcl9fKGtleSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGRvU2V0dXAoKVxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VPYmplY3QsIGtleSkuc2V0LnNvdXJjZU9iamVjdFtrZXldLmFwcGx5KFxuICAgICAgICAgIHNvdXJjZU9iamVjdCxcbiAgICAgICAgICBhcmd1bWVudHNcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tleV0gPSBzb3VyY2VPYmplY3Rba2V5XVxuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH0sIHt9KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxubGV0IHRpbWVvdXQgPSBudWxsXG5cbmV4cG9ydCBkZWZhdWx0IChjYiwgZGVsYXkpID0+IHtcbiAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBjYigpXG4gIH0sIGRlbGF5KVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgc3RlcHMgPT4ge1xuICByZXR1cm4gc3RlcHMucmVkdWNlKChwcm9taXNlLCBtZXRob2QpID0+IHtcbiAgICByZXR1cm4gcHJvbWlzZVxuICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtZXRob2QoLi4uYXJndW1lbnRzKVxuICAgICAgfSlcbiAgICAgIC5jYXRjaChlID0+IFByb21pc2UucmVqZWN0KGUpKVxuICB9LCBQcm9taXNlLnJlc29sdmUobnVsbCkpXG59XG4iLCJleHBvcnQgZGVmYXVsdCAobWV0aG9kLCBhcmdzID0gbnVsbCwgY29udGV4dCA9IG51bGwpID0+IHtcbiAgbGV0IHJlc3VsdFxuICBpZiAobWV0aG9kICYmIHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmVzdWx0ID0gZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBtZXRob2RcbiAgfVxuXG4gIC8vIGlmIGl0IGxvb2tzIGxpa2UgYSBkdWNrIC4uIGVobSAuLi4gcHJvbWlzZSBhbmQgdGFsa3MgbGlrZSBhIHByb21pc2UsIGxldCdzIGFzc3VtZSBpdCdzIGEgcHJvbWlzZVxuICBpZiAoXG4gICAgcmVzdWx0ICE9PSBudWxsICYmXG4gICAgdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiZcbiAgICByZXN1bHQudGhlbiAmJlxuICAgIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cbiAgLy8gb3RoZXJ3aXNlIG1ha2UgaXQgaW50byBhIHByb21pc2VcbiAgZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZWplY3QocmVzdWx0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNNZXJnZWFibGVPYmplY3QgPSBmdW5jdGlvbiBpc01lcmdlYWJsZU9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gaXNOb25OdWxsT2JqZWN0KHZhbHVlKVxuXHRcdCYmICFpc1NwZWNpYWwodmFsdWUpXG59O1xuXG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0J1xufVxuXG5mdW5jdGlvbiBpc1NwZWNpYWwodmFsdWUpIHtcblx0dmFyIHN0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuXHRyZXR1cm4gc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdFx0fHwgc3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IERhdGVdJ1xuXHRcdHx8IGlzUmVhY3RFbGVtZW50KHZhbHVlKVxufVxuXG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvYjVhYzk2M2ZiNzkxZDEyOThlN2YzOTYyMzYzODNiYzk1NWY5MTZjMS9zcmMvaXNvbW9ycGhpYy9jbGFzc2ljL2VsZW1lbnQvUmVhY3RFbGVtZW50LmpzI0wyMS1MMjVcbnZhciBjYW5Vc2VTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gY2FuVXNlU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xuXG5mdW5jdGlvbiBpc1JlYWN0RWxlbWVudCh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxufVxuXG5mdW5jdGlvbiBlbXB0eVRhcmdldCh2YWwpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsKSA/IFtdIDoge31cbn1cblxuZnVuY3Rpb24gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodmFsdWUsIG9wdGlvbnMpIHtcblx0cmV0dXJuIChvcHRpb25zLmNsb25lICE9PSBmYWxzZSAmJiBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSlcblx0XHQ/IGRlZXBtZXJnZShlbXB0eVRhcmdldCh2YWx1ZSksIHZhbHVlLCBvcHRpb25zKVxuXHRcdDogdmFsdWVcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcblx0cmV0dXJuIHRhcmdldC5jb25jYXQoc291cmNlKS5tYXAoZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChlbGVtZW50LCBvcHRpb25zKVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykge1xuXHRpZiAoIW9wdGlvbnMuY3VzdG9tTWVyZ2UpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlXG5cdH1cblx0dmFyIGN1c3RvbU1lcmdlID0gb3B0aW9ucy5jdXN0b21NZXJnZShrZXkpO1xuXHRyZXR1cm4gdHlwZW9mIGN1c3RvbU1lcmdlID09PSAnZnVuY3Rpb24nID8gY3VzdG9tTWVyZ2UgOiBkZWVwbWVyZ2Vcbn1cblxuZnVuY3Rpb24gZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHNcblx0XHQ/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KS5maWx0ZXIoZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnByb3BlcnR5SXNFbnVtZXJhYmxlKHN5bWJvbClcblx0XHR9KVxuXHRcdDogW11cbn1cblxuZnVuY3Rpb24gZ2V0S2V5cyh0YXJnZXQpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldCkuY29uY2F0KGdldEVudW1lcmFibGVPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSlcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlJc09uT2JqZWN0KG9iamVjdCwgcHJvcGVydHkpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gcHJvcGVydHkgaW4gb2JqZWN0XG5cdH0gY2F0Y2goXykge1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG59XG5cbi8vIFByb3RlY3RzIGZyb20gcHJvdG90eXBlIHBvaXNvbmluZyBhbmQgdW5leHBlY3RlZCBtZXJnaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4uXG5mdW5jdGlvbiBwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSB7XG5cdHJldHVybiBwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpIC8vIFByb3BlcnRpZXMgYXJlIHNhZmUgdG8gbWVyZ2UgaWYgdGhleSBkb24ndCBleGlzdCBpbiB0aGUgdGFyZ2V0IHlldCxcblx0XHQmJiAhKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSAvLyB1bnNhZmUgaWYgdGhleSBleGlzdCB1cCB0aGUgcHJvdG90eXBlIGNoYWluLFxuXHRcdFx0JiYgT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGFyZ2V0LCBrZXkpKSAvLyBhbmQgYWxzbyB1bnNhZmUgaWYgdGhleSdyZSBub25lbnVtZXJhYmxlLlxufVxuXG5mdW5jdGlvbiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHR2YXIgZGVzdGluYXRpb24gPSB7fTtcblx0aWYgKG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodGFyZ2V0KSkge1xuXHRcdGdldEtleXModGFyZ2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHRhcmdldFtrZXldLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fVxuXHRnZXRLZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRpZiAocHJvcGVydHlJc1Vuc2FmZSh0YXJnZXQsIGtleSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdGlmIChwcm9wZXJ0eUlzT25PYmplY3QodGFyZ2V0LCBrZXkpICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3Qoc291cmNlW2tleV0pKSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gZ2V0TWVyZ2VGdW5jdGlvbihrZXksIG9wdGlvbnMpKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2Vba2V5XSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbmZ1bmN0aW9uIGRlZXBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0b3B0aW9ucy5hcnJheU1lcmdlID0gb3B0aW9ucy5hcnJheU1lcmdlIHx8IGRlZmF1bHRBcnJheU1lcmdlO1xuXHRvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0ID0gb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCB8fCBpc01lcmdlYWJsZU9iamVjdDtcblx0Ly8gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgaXMgYWRkZWQgdG8gYG9wdGlvbnNgIHNvIHRoYXQgY3VzdG9tIGFycmF5TWVyZ2UoKVxuXHQvLyBpbXBsZW1lbnRhdGlvbnMgY2FuIHVzZSBpdC4gVGhlIGNhbGxlciBtYXkgbm90IHJlcGxhY2UgaXQuXG5cdG9wdGlvbnMuY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQgPSBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZDtcblxuXHR2YXIgc291cmNlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlKTtcblx0dmFyIHRhcmdldElzQXJyYXkgPSBBcnJheS5pc0FycmF5KHRhcmdldCk7XG5cdHZhciBzb3VyY2VBbmRUYXJnZXRUeXBlc01hdGNoID0gc291cmNlSXNBcnJheSA9PT0gdGFyZ2V0SXNBcnJheTtcblxuXHRpZiAoIXNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2gpIHtcblx0XHRyZXR1cm4gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQoc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2UgaWYgKHNvdXJjZUlzQXJyYXkpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5hcnJheU1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBtZXJnZU9iamVjdCh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucylcblx0fVxufVxuXG5kZWVwbWVyZ2UuYWxsID0gZnVuY3Rpb24gZGVlcG1lcmdlQWxsKGFycmF5LCBvcHRpb25zKSB7XG5cdGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheScpXG5cdH1cblxuXHRyZXR1cm4gYXJyYXkucmVkdWNlKGZ1bmN0aW9uKHByZXYsIG5leHQpIHtcblx0XHRyZXR1cm4gZGVlcG1lcmdlKHByZXYsIG5leHQsIG9wdGlvbnMpXG5cdH0sIHt9KVxufTtcblxudmFyIGRlZXBtZXJnZV8xID0gZGVlcG1lcmdlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBtZXJnZV8xO1xuIiwiY2xhc3MgbG9jYWxDb29raWV7Y29uc3RydWN0b3IoZSl7cmV0dXJuIGU9ZXx8e30sdGhpcy5mb3JjZUNvb2tpZXM9ZS5mb3JjZUNvb2tpZXN8fCExLCEwPT09dGhpcy5fY2hlY2tJZkxvY2FsU3RvcmFnZVdvcmtzKCkmJiEwIT09ZS5mb3JjZUNvb2tpZXM/e2dldEl0ZW06dGhpcy5fZ2V0SXRlbUxvY2FsU3RvcmFnZSxzZXRJdGVtOnRoaXMuX3NldEl0ZW1Mb2NhbFN0b3JhZ2UscmVtb3ZlSXRlbTp0aGlzLl9yZW1vdmVJdGVtTG9jYWxTdG9yYWdlLGNsZWFyOnRoaXMuX2NsZWFyTG9jYWxTdG9yYWdlfTp7Z2V0SXRlbTp0aGlzLl9nZXRJdGVtQ29va2llLHNldEl0ZW06dGhpcy5fc2V0SXRlbUNvb2tpZSxyZW1vdmVJdGVtOnRoaXMuX3JlbW92ZUl0ZW1Db29raWUsY2xlYXI6dGhpcy5fY2xlYXJDb29raWVzfX1fY2hlY2tJZkxvY2FsU3RvcmFnZVdvcmtzKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGxvY2FsU3RvcmFnZSlyZXR1cm4hMTt0cnl7cmV0dXJuIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiZmVhdHVyZV90ZXN0XCIsXCJ5ZXNcIiksXCJ5ZXNcIj09PWxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiZmVhdHVyZV90ZXN0XCIpJiYobG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJmZWF0dXJlX3Rlc3RcIiksITApfWNhdGNoKGUpe3JldHVybiExfX1fZ2V0SXRlbUxvY2FsU3RvcmFnZShlKXtyZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGUpfV9zZXRJdGVtTG9jYWxTdG9yYWdlKGUsdCl7cmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShlLHQpfV9yZW1vdmVJdGVtTG9jYWxTdG9yYWdlKGUpe3JldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZSl9X2NsZWFyTG9jYWxTdG9yYWdlKCl7cmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuY2xlYXIoKX1fZ2V0SXRlbUNvb2tpZShlKXt2YXIgdD1kb2N1bWVudC5jb29raWUubWF0Y2goUmVnRXhwKFwiKD86Xnw7XFxcXHMqKVwiK2Z1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbLiorP1xcXiR7fSgpfFxcW1xcXVxcL1xcXFxdKS9nLFwiXFxcXCQxXCIpfShlKStcIj0oW147XSopXCIpKTtyZXR1cm4gdCYmXCJcIj09PXRbMV0mJih0WzFdPW51bGwpLHQ/dFsxXTpudWxsfV9zZXRJdGVtQ29va2llKGUsdCl7dmFyIG89bmV3IERhdGUscj1uZXcgRGF0ZShvLmdldFRpbWUoKSsxNTc2OGU3KTtkb2N1bWVudC5jb29raWU9YCR7ZX09JHt0fTsgZXhwaXJlcz0ke3IudG9VVENTdHJpbmcoKX07YH1fcmVtb3ZlSXRlbUNvb2tpZShlKXtkb2N1bWVudC5jb29raWU9YCR7ZX09O01heC1BZ2U9LTk5OTk5OTk5O2B9X2NsZWFyQ29va2llcygpe2RvY3VtZW50LmNvb2tpZS5zcGxpdChcIjtcIikuZm9yRWFjaChlPT57ZG9jdW1lbnQuY29va2llPWUucmVwbGFjZSgvXiArLyxcIlwiKS5yZXBsYWNlKC89LiovLFwiPTtleHBpcmVzPU1heC1BZ2U9LTk5OTk5OTk5XCIpfSl9fWV4cG9ydCBkZWZhdWx0IGxvY2FsQ29va2llO1xuIiwiaW1wb3J0IHsgTGlnaHRuaW5nLCBVdGlscywgTG9nIH0gZnJvbSBcIkBsaWdodG5pbmdqcy9zZGtcIjtcbmltcG9ydCB7IERldmljZSwgTG9jYWxpemF0aW9uLE1ldHJpY3MgfSBmcm9tIFwiQGZpcmVib2x0LWpzL3Nka1wiO1xuLy9pbXBvcnQgeyBXaWZpIH0gZnJvbSAnQGZpcmVib2x0LWpzL21hbmFnZS1zZGsnO1xuLy9pbXBvcnQge0J1dHRvbn0gZnJvbSAnLi9idXR0b24uanMnO1xuaW1wb3J0IHsgTXlCdXR0b24gfSBmcm9tIFwiLi9NeUJ1dHRvblwiO1xuXG5cbi8vIGNvbnN0IHZpZGVvVXJsTGlzdCA9IFsnaHR0cHM6Ly9hbXNzYW1wbGVzLnN0cmVhbWluZy5tZWRpYXNlcnZpY2VzLndpbmRvd3MubmV0LzY4M2Y3ZTQ3LWJkODMtNDQyNy1iMGEzLTI2YTZjNDU0Nzc4Mi9CaWdCdWNrQnVubnkuaXNtL21hbmlmZXN0KGZvcm1hdD1tcGQtdGltZS1jc2YpJyxcbi8vICdodHRwczovL2Rhc2guYWthbWFpemVkLm5ldC9kYXNoMjY0L1Rlc3RDYXNlc0hFVkMvMWEvMi9CQkJfT25EZW1hbmRfSEVWQ19NdWx0aVJhdGUubXBkJyxcbi8vICdodHRwczovL2xpdmVzaW0uZGFzaGlmLm9yZy9saXZlc2ltL211cF8zMDAvdHNiZF81MDAvdGVzdHBpY18ycy9NYW5pZmVzdC5tcGQnXVxuXG4vLyBjb25zdCBMaWZlY3ljbGVDb2xvcnMgPSB7XG4vLyAgIC8vIEJMVUVcbi8vICAgQk9PVDogXCIweGZmMDAwMGZmXCIsXG4vLyAgIC8vIFJFRFxuLy8gICBJTkFDVElWRTogXCIweGZmZmYwMDAwXCIsXG4vLyAgIC8vIE9SQU5HRVxuLy8gICBCQUNLR1JPVU5EOiBcIjB4ZmZFNjk3MzhcIixcbi8vICAgLy8gR1JFRU5cbi8vICAgRk9SRUdST1VORDogXCIweGZmMDBhYTAwXCIsXG4vLyB9O1xuXG5leHBvcnQgIGNsYXNzIEFwcCBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgZ2V0Rm9udHMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgZmFtaWx5OiBcIlJlZ3VsYXJcIiwgdXJsOiBVdGlscy5hc3NldChcImZvbnRzL1JvYm90by1SZWd1bGFyLnR0ZlwiKSB9LFxuICAgIF07XG4gIH1cblxuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBIZWxsb1dvcmxkOiB7XG4gICAgICAgIHc6IDE5MjAsXG4gICAgICAgIGg6IDEwODAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHJlY3Q6IHRydWUsXG4gICAgICAgIGNvbG9yOiAweGZmZmZmZmZmLFxuICAgICAgICBzcmM6IFV0aWxzLmFzc2V0KCdpbWFnZXMvZGFyazkuanBnJyksXG4gICAgICAgIFxuICAgICAgICBGaXJlYm9sdFN0YXR1czoge1xuICAgICAgICAgIC8vIExpZmVjeWNsZToge1xuICAgICAgICAgIC8vICAgbW91bnRYOiAwLjUsXG4gICAgICAgICAgLy8gICB4OiA5NjAsXG4gICAgICAgICAgLy8gICB5OiAxMDAsXG4gICAgICAgICAgLy8gICB0ZXh0OiB7XG4gICAgICAgICAgLy8gICAgIHRleHQ6IFwiTGlmZWN5Y2xlIG5vdCBSZWFkeSFcIixcbiAgICAgICAgICAvLyAgICAgZm9udEZhY2U6IFwiUmVndWxhclwiLFxuICAgICAgICAgIC8vICAgICBmb250U2l6ZTogNTAsXG4gICAgICAgICAgLy8gICB9LFxuICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgUmRrbG9nbzoge1xuICAgICAgICAgICAgeDogNzAsXG4gICAgICAgICAgICB5OiA1MCxcbiAgICAgICAgICAgIHc6IDMwMCxcbiAgICAgICAgICAgIGg6IDEwMCxcbiAgICAgICAgICAgIHpJbmRleDogMTAsXG4gICAgICAgICAgICBzaGFkb3dDb2xvcjogMHhmZmZmMDBmZixcbiAgICAgICAgICAgIHNyYzogVXRpbHMuYXNzZXQoXCJpbWFnZXMvcmRrLWxvZ28uZ2lmXCIpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgQWxleGFsb2dvOiB7XG4gICAgICAgICAgICB4OiAxMDUwLFxuICAgICAgICAgICAgeTogNSxcbiAgICAgICAgICAgIHc6IDE1MCxcbiAgICAgICAgICAgIGg6IDE1MCxcbiAgICAgICAgICAgIHNyYzogVXRpbHMuYXNzZXQoXCJpbWFnZXMvYWxleGEucG5nXCIpLFxuICAgICAgICAgIH0sXG4gICAgICAgICBcbiAgICAgICAgICBCZWxsbG9nbzoge1xuICAgICAgICAgICAgeDogMTI1MCxcbiAgICAgICAgICAgIHk6IDMwLFxuICAgICAgICAgICAgdzogMTAwLFxuICAgICAgICAgICAgaDogMTAwLFxuICAgICAgICAgICAgc3JjOiBVdGlscy5hc3NldChcImltYWdlcy9zZXR0LnBuZ1wiKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIE5vdGlmaWxvZ286IHtcbiAgICAgICAgICAgIHg6IDE0NTAsXG4gICAgICAgICAgICB5OiAzMCxcbiAgICAgICAgICAgIHc6IDEwMCxcbiAgICAgICAgICAgIGg6IDEwMCxcbiAgICAgICAgICAgIHNyYzogVXRpbHMuYXNzZXQoXCJpbWFnZXMvbm90aS5wbmdcIiksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBDdXJyZW50VGltZToge1xuICAgICAgICAgICAgbW91bnRYOiAwLjUsXG4gICAgICAgICAgICB4OiAxNzAwLFxuICAgICAgICAgICAgeTogNDAsXG4gICAgICAgICAgICB3OiAyMDAsXG4gICAgICAgICAgICBoOiAxMDAsLy8gQWRqdXN0IHRoZSBZIHBvc2l0aW9uIGFzIG5lZWRlZFxuICAgICAgICAgICAgdGV4dDoge1xuICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICBmb250RmFjZTogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiA3MCxcbiAgICAgICAgICAgICAgdGV4dENvbG9yOiAweGZmMDlmNjc2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIERldmljZToge1xuICAgICAgICAgICAgbW91bnRYOiAwLjUsXG4gICAgICAgICAgICB4OiA5NjAsXG4gICAgICAgICAgICB5OiA5MDAsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIHRleHQ6IFwiRGV2aWNlIG5vdCBSZWFkeSFcIixcblxuICAgICAgICAgICAgICBmb250RmFjZTogXCJSZWd1bGFyXCIsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAzNSxcbiAgICAgICAgICAgICAgdGV4dENvbG9yOiAweGZmMDlmNjc2LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIExvY2FsaXphdGlvbjoge1xuICAgICAgICAgICAgbW91bnRYOiAwLjUsXG4gICAgICAgICAgICB4OiA5NjAsXG4gICAgICAgICAgICB5OiA5NTAsXG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIHRleHQ6IFwibG9hY2xpemF0aW9uIEFQSSA9PT4gXCIsXG4gICAgICAgICAgICAgIGZvbnRGYWNlOiBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgICAgZm9udFNpemU6IDM1LFxuICAgICAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmYwOWY2NzYsXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBNZXRyaWNzOntcbiAgICAgICAgICBtb3VudFg6IDAuNSxcbiAgICAgICAgICB4OiA5NjAsXG4gICAgICAgICAgeTogMTAwMCxcbiAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICB0ZXh0OiBcIk1ldHJpY3MgQVBJID09PiBcIixcbiAgICAgICAgICAgIGZvbnRGYWNlOiBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIGZvbnRTaXplOiAzNSxcbiAgICAgICAgICAgIHRleHRDb2xvcjogMHhmZjA5ZjY3NixcblxuICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICAgUGxheWJ1dHRvbjoge1xuICAgICAgICAgIHR5cGU6IE15QnV0dG9uLFxuICAgICAgICAgIG1vdW50OiAwLjUsXG4gICAgICAgICAgeDogMTUwLFxuICAgICAgICAgIHk6IDEzMCxcbiAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICB0ZXh0OiBcIkV4cGxvcmVcIixcbiAgICAgICAgICAgIGZvbnRGYWNlOiAnUmVndWxhcicsXG4gICAgICAgICAgICBmb250U2l6ZTogMjUsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IDB4ZmZmZmZmZmYsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaWduYWxzOiB7XG4gICAgICAgICAgICBvbkNsaWNrOiBcIiRvbkl0ZW1TZWxlY3Qob2JqKVwiLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgU2xpZGVyOiB7XG4gICAgICAgIHc6IDgwMCxcbiAgICAgICAgaDogMzUwLFxuICAgICAgICB4OiA0ODAsXG4gICAgICAgIHk6IDM1MCxcbiAgICAgICAgbW91bnQ6IDAuNSxcbiAgICAgICAgV3JhcHBlcjoge1xuICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgIH0sXG4gICAgICBWaWRlb1NlY3Rpb246IHtcbiAgICAgICAgYWxwaGE6IDEsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IDE5MjAsXG4gICAgICAgIGg6IDEwODAsXG4gICAgICAgIGNvbG9yOiBcIjB4ZmYwMDAwMDBcIixcbiAgICAgICAgcmVjdDogdHJ1ZSxcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgIEhlbHBNc2c6IHtcbiAgICAgICAgICB4OiA4MCxcbiAgICAgICAgICB5OiA1MCxcbiAgICAgICAgICB3OiAxOTIwLFxuICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgIHRleHQ6IFwiUGxheSB0aGUgVmlkZW8gdXNpbmcgQUFNUCBQbGF5ZXJcIixcbiAgICAgICAgICAgIGZvbnRTaXplOiA0MCxcbiAgICAgICAgICAgIGZvbnRGYWNlOiBcIlJlZ3VsYXJcIixcbiAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDUwLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29sb3I6IFwiMHhmZmZmZmZmZlwiLFxuICAgICAgICAgIGFscGhhOiAxLFxuICAgICAgICB9LFxuICAgICAgICBWaWRlbzoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMCxcbiAgICAgICAgICB3OiAxOTIwLCAvLyBTZXQgdG8geW91ciBkZXNpcmVkIHdpZHRoXG4gICAgICAgICAgaDogMTA4MCwgLy8gU2V0IHRvIHlvdXIgZGVzaXJlZCBoZWlnaHRcbiAgICAgICAgICB0eXBlOiBMaWdodG5pbmcuY29tcG9uZW50cy5WaWRlb0l0ZW0sIC8vIFVzZSB0aGUgYXBwcm9wcmlhdGUgTGlnaHRuaW5nIHZpZGVvXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgX2dldEZvY3VzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFnKFwiUGxheWJ1dHRvblwiKTtcbiAgfVxuXG4gIF9pbml0KCkge1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuZGF0YUxlbmd0aCA9IDU7XG4gICAgY29uc3QgYnV0dG9ucyA9IFtdO1xuICAgIC8vIHRoaXMuX3BsYXllciA9IG5ldyBBQU1QTWVkaWFQbGF5ZXIoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1dHRvbnMucHVzaChcbiAgICAgICAgeyB0eXBlOiBNeUJ1dHRvbiwgeDogaSAqICgzMDAgKyAzMCksIGl0ZW06IHsgbGFiZWw6IGBUcmFpbmAsIHNyYzogVXRpbHMuYXNzZXQoYGltYWdlcy9jYXJkSW1hZ2Uke2kgKyAxfS5qcGdgKX0gfSwgXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMudGFnKCdXcmFwcGVyJykuY2hpbGRyZW4gPSBidXR0b25zO1xuICAgIHRoaXMuX3VwZGF0ZUN1cnJlbnRUaW1lKCk7XG5cbiAgLy8gVXBkYXRlIHRoZSB0aW1lIGV2ZXJ5IHNlY29uZCAoMTAwMCBtaWxsaXNlY29uZHMpXG4gIHNldEludGVydmFsKCgpID0+IHtcbiAgICB0aGlzLl91cGRhdGVDdXJyZW50VGltZSgpO1xuICB9LCAxMDAwKTtcbiAgICBcbiAgfVxuXG4gICRvbkl0ZW1TZWxlY3Qob2JqKSB7XG4gICBcbiAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9hbXNzYW1wbGVzLnN0cmVhbWluZy5tZWRpYXNlcnZpY2VzLndpbmRvd3MubmV0LzY4M2Y3ZTQ3LWJkODMtNDQyNy1iMGEzLTI2YTZjNDU0Nzc4Mi9CaWdCdWNrQnVubnkuaXNtL21hbmlmZXN0KGZvcm1hdD1tcGQtdGltZS1jc2YpJztcbiAgICB0aGlzLl9wbGF5ZXIgPSBuZXcgQUFNUE1lZGlhUGxheWVyKCk7XG4gICAgdGhpcy5fcGxheWVyLmxvYWQodXJsKTtcbiAgICB0aGlzLl9zZXRTdGF0ZShcIlZpZGVvUGxheVwiKTtcblxuXG4gIH1cbiAgXG5cbiAgX3VwZGF0ZUN1cnJlbnRUaW1lKCkge1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBob3VycyA9IGN1cnJlbnRUaW1lLmdldEhvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIik7XG4gICAgY29uc3QgbWludXRlcyA9IGN1cnJlbnRUaW1lLmdldE1pbnV0ZXMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbiAgICBjb25zdCBzZWNvbmRzID0gY3VycmVudFRpbWUuZ2V0U2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIGNvbnN0IGZvcm1hdHRlZFRpbWUgPSBgJHtob3Vyc306JHttaW51dGVzfWA7XG4gICAgdGhpcy50YWcoXCJDdXJyZW50VGltZVwiKS50ZXh0LnRleHQgPSBgJHtmb3JtYXR0ZWRUaW1lfWA7XG4gIH1cbiAgXG4gIHJlcG9zaXRpb25XcmFwcGVyKCkge1xuICAgIGNvbnN0IHdyYXBwZXIgPSB0aGlzLnRhZygnV3JhcHBlcicpO1xuICAgIGNvbnN0IHNsaWRlclcgPSB0aGlzLnRhZygnU2xpZGVyJykudztcbiAgICBjb25zdCBjdXJyZW50V3JhcHBlclggPSB3cmFwcGVyLnRyYW5zaXRpb24oJ3gnKS50YXJnZXR2YWx1ZSB8fCB3cmFwcGVyLng7XG4gICAgY29uc3QgY3VycmVudEZvY3VzID0gd3JhcHBlci5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICBjb25zdCBjdXJyZW50Rm9jdXNYID0gY3VycmVudEZvY3VzLnggKyBjdXJyZW50V3JhcHBlclg7XG4gICAgY29uc3QgY3VycmVudEZvY3VzT3V0ZXJXaWR0aCA9IGN1cnJlbnRGb2N1cy54ICsgY3VycmVudEZvY3VzLnc7XG5cbiAgICBpZiAoY3VycmVudEZvY3VzWCA8IDApIHtcbiAgICAgIHdyYXBwZXIuc2V0U21vb3RoKCd4JywgLSBjdXJyZW50Rm9jdXMueCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN1cnJlbnRGb2N1c091dGVyV2lkdGggPiBzbGlkZXJXKSB7XG4gICAgICB3cmFwcGVyLnNldFNtb290aCgneCcsIHNsaWRlclcgLSAoY3VycmVudEZvY3VzT3V0ZXJXaWR0aCkpO1xuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVMZWZ0KCkge1xuICAgIGlmICh0aGlzLmluZGV4ID09PSAwKSB7XG4gICAgICB0aGlzLmluZGV4ID0gdGhpcy5kYXRhTGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmluZGV4IC09IDE7XG4gICAgfVxuICAgIHRoaXMucmVwb3NpdGlvbldyYXBwZXIoKTtcbiAgfVxuXG4gIF9oYW5kbGVSaWdodCgpIHtcbiAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5kYXRhTGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5pbmRleCArPSAxO1xuICAgIH1cbiAgICB0aGlzLnJlcG9zaXRpb25XcmFwcGVyKCk7XG4gIH1cblxuXG4gIF9nZXRTbGlkZXJGb2N1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLnRhZygnU2xpZGVyLldyYXBwZXInKS5jaGlsZHJlblt0aGlzLmluZGV4XTtcbiAgICB9XG4gIFxuXG4gIC8vIGluaXRpYXRlUGxheWVyKCkge1xuICAvLyAgIGNvbnN0IHVybCA9XG4gIC8vICAgICBcImh0dHBzOi8vYW1zc2FtcGxlcy5zdHJlYW1pbmcubWVkaWFzZXJ2aWNlcy53aW5kb3dzLm5ldC82ODNmN2U0Ny1iZDgzLTQ0MjctYjBhMy0yNmE2YzQ1NDc3ODIvQmlnQnVja0J1bm55LmlzbS9tYW5pZmVzdChmb3JtYXQ9bXBkLXRpbWUtY3NmKVwiO1xuICAvLyAgIHRoaXMuX3BsYXllciA9IG5ldyBBQU1QTWVkaWFQbGF5ZXIoKTtcbiAgLy8gICB0aGlzLl9wbGF5ZXIubG9hZCh1cmwpO1xuICAvLyB9XG5cbiAgc3RhdGljIF9zdGF0ZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNsYXNzIExhdW5jaFZpZXcgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgX2dldEZvY3VzZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFnKFwiUGxheWJ1dHRvblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGVCdXR0b25FbnRlcigpIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZyhcIkVudGVyIGZpcmVkXCIpO1xuICAgICAgICAvLyAgIHRoaXMuaW5pdGlhdGVQbGF5ZXIoKTtcbiAgICAgICAgLy8gICB0aGlzLl9zZXRTdGF0ZShcIlZpZGVvUGxheVwiKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBfZ2V0Rm9jdXNlZCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U2xpZGVyRm9jdXNlZCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbGFzcyBWaWRlb1BsYXkgZXh0ZW5kcyB0aGlzIHtcbiAgICAgICAgX2dldEZvY3VzZWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFnKFwiVmlkZW9cIik7XG4gICAgICAgIH1cbiAgICAgICAgJGVudGVyKCkge1xuICAgICAgICAgIHRoaXMudGFnKFwiVmlkZW9cIikudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy50YWcoXCJIZWxsb1dvcmxkXCIpLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRhZyhcIlNsaWRlclwiKS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgX2hhbmRsZUJhY2soKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJiYWNrIHRvIGxhdW5jaFZpZXdcIik7XG4gICAgICAgICAgdGhpcy50YWcoXCJWaWRlb1wiKS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICBcbiAgICAgICAgICB0aGlzLnRhZyhcIkhlbGxvV29ybGRcIikudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy50YWcoXCJTbGlkZXJcIikudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5fc2V0U3RhdGUoXCJMYXVuY2hWaWV3XCIpO1xuICAgICAgICAgIGlmICh0aGlzLl9wbGF5ZXIpIHtcblxuICAgICAgICAgICAgdGhpcy5fcGxheWVyLnN0b3AoKTtcblxuICAgICAgICAgICAgdGhpcy5fcGxheWVyID0gbnVsbDtcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICBdO1xuICB9XG5cbiAgX2FjdGl2ZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcImFjdGl2ZSBzZXQgc3RhdGUgdG8gbGF1bmNoVmlld1wiKTtcbiAgICB0aGlzLl9zZXRTdGF0ZShcIkxhdW5jaFZpZXdcIik7XG5cbiAgICAvLyBEZXZpY2UuYXVkaW8oKS50aGVuKChzdXBwb3J0ZWRBdWRpb1Byb2ZpbGVzKSA9PiB7XG4gICAgLy8gICBjb25zdCBuZXdBdWRpbyA9IFwiYXVkaW8gcHJvZmlsZSAqKlwiICsgc3VwcG9ydGVkQXVkaW9Qcm9maWxlcy5zdGVyZW87XG4gICAgLy8gICAvL0xvZy5pbmZvKHN1cHBvcnRlZEF1ZGlvUHJvZmlsZXMuc3RlcmVvKTtcbiAgICAvLyAgIExvZy5pbmZvKFwiRGV2aWNlXCIsIG5ld0F1ZGlvKTtcbiAgICAvLyAgIC8vdGhpcy50YWcoJ0RldmljZScpLnRleHQudGV4dCA9IG5ld0F1ZGlvICsgJyA6OiAnO1xuICAgIC8vICAgdGhpcy50YWcoXCJEZXZpY2VcIikudGV4dC50ZXh0ID0gc3VwcG9ydGVkQXVkaW9Qcm9maWxlcyArIFwiIDo6IFwiO1xuICAgIC8vICAgLy9jb25zb2xlLmxvZyhcIklzIHN0ZXJlbyBzdXBwb3J0ZWRcIixzdXBwb3J0ZWRBdWRpb1Byb2ZpbGVzLnN0ZXJlbyk7XG4gICAgLy8gICBjb25zb2xlLmxvZyhcIklzIHN0ZXJlbyBzdXBwb3J0ZWRcIiwgc3VwcG9ydGVkQXVkaW9Qcm9maWxlcy5zdGVyZW8pO1xuICAgIC8vIH0pO1xuICAgXG4gICAgRGV2aWNlLmRpc3RyaWJ1dG9yKCkudGhlbigoZGlzdHJpYnV0b3IpID0+IHtcbiAgICAgIGNvbnN0IGRldmljZURpc3RyaWJ1dG9yID0gXCJkaXN0cmlidXRvcjpcIiArIGRpc3RyaWJ1dG9yO1xuICAgICAgTG9nLmluZm8oZGV2aWNlRGlzdHJpYnV0b3IpO1xuICAgICAgdGhpcy50YWcoXCJEZXZpY2VcIikudGV4dC50ZXh0ID0gZGV2aWNlRGlzdHJpYnV0b3IgKyBcIiA6OiBcIjtcbiAgICB9KTtcblxuICAgIERldmljZS5wbGF0Zm9ybSgpLnRoZW4oKHBsYXRmb3JtKSA9PiB7XG4gICAgICBjb25zdCBkZXZpY2VQbGF0Zm9ybSA9IFwicGxhdGZvcm06XCIgKyBwbGF0Zm9ybTtcbiAgICAgIExvZy5pbmZvKGRldmljZVBsYXRmb3JtKTtcbiAgICAgIHRoaXMudGFnKFwiRGV2aWNlXCIpLnRleHQudGV4dCArPSBkZXZpY2VQbGF0Zm9ybSArIFwiIDo6IFwiO1xuICAgIH0pO1xuXG4gICAgRGV2aWNlLnZlcnNpb24oKS50aGVuKCh2ZXJzaW9uKSA9PiB7XG4gICAgICBjb25zdCBkZXZpY2VWZXJzaW9uID1cbiAgICAgICAgXCJ2ZXJzaW9uOlwiICtcbiAgICAgICAgdmVyc2lvbi5zZGsucmVhZGFibGUgK1xuICAgICAgICBcIiA6IHZcIiArXG4gICAgICAgIHZlcnNpb24uc2RrLm1ham9yICtcbiAgICAgICAgXCIuXCIgK1xuICAgICAgICB2ZXJzaW9uLnNkay5taW5vciArXG4gICAgICAgIFwiLlwiICtcbiAgICAgICAgdmVyc2lvbi5zZGsucGF0Y2g7XG4gICAgICBMb2cuaW5mbyhkZXZpY2VWZXJzaW9uKTtcbiAgICAgIHRoaXMudGFnKFwiRGV2aWNlXCIpLnRleHQudGV4dCArPSBkZXZpY2VWZXJzaW9uO1xuICAgIH0pO1xuICAgIExvY2FsaXphdGlvbi5sYW5ndWFnZSgpLnRoZW4obGFuZyA9PiB7XG4gICAgICBjb25zdCBsYW5ndSA9IFwibGFuZ3VhZ2U6XCIgKyBsYW5nO1xuICAgICAgTG9nLmluZm8obGFuZ3UpO1xuICAgICAgdGhpcy50YWcoXCJMb2NhbGl6YXRpb25cIikudGV4dC50ZXh0ICs9IGxhbmd1ICsgXCIgOjpcIjtcbiAgICAgICBcbiAgICB9KVxuICAgIExvY2FsaXphdGlvbi5jb3VudHJ5Q29kZSgpLnRoZW4oY29kZSA9PiB7XG4gICAgICBjb25zdCBDX0NvZGUgPSBcIiBDb3VudHJ5X0NvZGU6XCIgKyBjb2RlO1xuICAgICAgTG9nLmluZm8oQ19Db2RlKTtcbiAgICAgIHRoaXMudGFnKFwiTG9jYWxpemF0aW9uXCIpLnRleHQudGV4dCArPSBDX0NvZGUgKyBcIiBcIjtcbiAgICAgICAgY29uc29sZS5sb2coY29kZSlcbiAgICB9KVxuXG4gICAgTWV0cmljcy5hY3Rpb24oXCJ1c2VyXCIsIFwiVGhlIHVzZXIgZGlkIGZvb1wiLCBudWxsKS50aGVuKHN1Y2Nlc3MgPT4ge1xuICAgICAgY29uc3QgbWV0X2FjdCA9IFwiIGFjdGlvbiA6IFwiICsgc3VjY2VzcztcbiAgICAgIExvZy5pbmZvKG1ldF9hY3QpO1xuICAgICAgdGhpcy50YWcoXCJNZXRyaWNzXCIpLnRleHQudGV4dCArPSBtZXRfYWN0ICsgXCIgXCI7XG4gICAgICAgXG4gICAgfSlcbiAgfVxufSIsImltcG9ydCB7IExpZ2h0bmluZyB9IGZyb20gXCJAbGlnaHRuaW5nanMvc2RrXCI7XG5cbmV4cG9ydCBjbGFzcyBNeUJ1dHRvbiBleHRlbmRzIExpZ2h0bmluZy5Db21wb25lbnQge1xuICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3OiAzMDAsXG4gICAgICBoOiA0NTAsXG4gICAgICBcbiAgICAgIHk6IDE4MCxcbiAgICAgIEltYWdlOiB7XG4gICAgICAgIHg6IDgwLFxuICAgICAgICB3OiB3ID0+IHcsXG4gICAgICAgIGg6IGggPT4gaCAtIDUwLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cblxuXG4gIHNldCBpdGVtKG9iaikge1xuICAgIGNvbnN0IHsgbGFiZWwsIHNyYywgdmlkZW9VcmwgfSA9IG9iajtcbiAgICB0aGlzLl92aWRlb1VybCA9IHZpZGVvVXJsO1xuICAgIHRoaXMucGF0Y2goe1xuICAgICAgSW1hZ2U6IHsgc3JjIH0sXG4gICAgfSk7XG4gIH1cblxuICBfaGFuZGxlRW50ZXIoKSB7XG4gICAgY29uc29sZS5sb2coJ0VudGVyIHByZXNzZWQnKTtcbiAgICAvLyB0aGlzLnNpZ25hbChcIm9uQ2xpY2tcIik7XG4gICAgdGhpcy5maXJlQW5jZXN0b3JzKCckb25JdGVtU2VsZWN0Jywge1xuICAgICAvLyB2aWRlb1VybDogdGhpcy5fdmlkZW9VcmxcbiAgICAgIC8vIGl0ZW06IHRoaXMuX2l0ZW0sXG5cbiAgICB9KVxuXG4gIH1cblxuICBfZm9jdXMoKSB7XG4gICAgY29uc29sZS5sb2coJ0J1dHRvbiBGb2N1cycpO1xuICAgIHRoaXMucGF0Y2goe1xuICAgICAgc21vb3RoOiB7IGNvbG9yOiAweGZmMDA1NTAwLCBzY2FsZTogMS4xIH0sXG4gICAgICBzaGFkZXI6IHsgdHlwZTogTGlnaHRuaW5nLnNoYWRlcnMuT3V0bGluZSwgc3Ryb2tlOiAxLjEsIGNvbG9yOiAweGZmMDlmNjc2IH0sXG4gICAgfSk7XG4gIH1cblxuXG4gIF91bmZvY3VzKCkge1xuICAgIGNvbnNvbGUubG9nKCdCdXR0b24gVW5mb2N1cycpO1xuICAgIHRoaXMucGF0Y2goe1xuICAgICAgc21vb3RoOiB7IGNvbG9yOiAweGZmZmZmZmZmLCBzY2FsZTogMS4wIH0sXG4gICAgICBzaGFkZXI6IHsgdHlwZTogTGlnaHRuaW5nLnNoYWRlcnMuT3V0bGluZSwgc3Ryb2tlOiAwLCBjb2xvcjogMHgwMDAwMDAwIH0sXG4gICAgfSk7XG4gIH1cbn0iLCJcbmltcG9ydCBwa2cgZnJvbSAnLi4vcGFja2FnZS5qc29uJztcblxuY29uc3QgaXNEZXZlbG9wbWVudCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnO1xuXG5leHBvcnQgY29uc3QgYXBwRGF0YSA9IHt9O1xuXG5leHBvcnQgY29uc3QgYXBwU2V0dGluZ3MgPSB7XG4gIHZlcnNpb246IHBrZy52ZXJzaW9uLFxuICBzdGFnZToge1xuICAgIGNsZWFyQ29sb3I6ICcweDAwMDAwMCcsXG4gIH0sXG4gIGRlYnVnOiBmYWxzZSxcbiAgXG59O1xuXG5leHBvcnQgY29uc3QgcGxhdGZvcm1TZXR0aW5ncyA9IHtcbiAgbG9nOiB0cnVlLFxuICBwYXRoOiBcIi4vc3RhdGljXCIsXG4gIHNob3dWZXJzaW9uOiBmYWxzZSxcbiAgXG59O1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIGEgcGFydGlhbCAoYW5kIG1vcmUgZWZmaWNpZW50KSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZXZlbnQgZW1pdHRlci5cbiAqIEl0IGF0dGVtcHRzIHRvIG1haW50YWluIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gZXZlbnRzIGFuZCBsaXN0ZW5lcnMsIHNraXBwaW5nIGFuIGFycmF5IGxvb2t1cC5cbiAqIE9ubHkgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGxpc3RlbmVycywgdGhleSBhcmUgY29tYmluZWQgaW4gYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50RW1pdHRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBzZXQgKGFuZCBrZXB0KSB0byB0cnVlIHdoZW4gZXZlbnRzIGFyZSB1c2VkIGF0IGFsbC5cbiAgICAgICAgdGhpcy5faGFzRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBvbihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEZ1bmN0aW9uID0ge31cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzID0ge31cbiAgICAgICAgICAgIHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdO1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0gPSBsaXN0ZW5lcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdICE9PSBFdmVudEVtaXR0ZXIuY29tYmluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXSA9IFt0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdLCBsaXN0ZW5lcl07XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSA9IEV2ZW50RW1pdHRlci5jb21iaW5lcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbmNlKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoYXJnMSwgYXJnMiwgYXJnMykgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgICAgICB0aGlzLm9mZihuYW1lLCB3cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVyLl9fb3JpZ2luYWxGdW5jID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMub24obmFtZSwgd3JhcHBlcik7XG4gICAgfVxuXG4gICAgaGFzKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV07XG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBFdmVudEVtaXR0ZXIuY29tYmluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbCBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsID09PSBsaXN0ZW5lciB8fCBsLl9fb3JpZ2luYWxGdW5jID09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0gPT09IGxpc3RlbmVyIHx8IHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV0uX19vcmlnaW5hbEZ1bmMgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb2ZmKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV07XG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBFdmVudEVtaXR0ZXIuY29tYmluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbGlzdGVuZXJzLm1hcCgobCkgPT4gbC5fX29yaWdpbmFsRnVuYykuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXSA9IGxpc3RlbmVyc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdID09PSBsaXN0ZW5lciB8fCB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdLl9fb3JpZ2luYWxGdW5jID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudEZ1bmN0aW9uW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZUxpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMub2ZmKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBlbWl0KG5hbWUsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXTtcbiAgICAgICAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bmMgPT09IEV2ZW50RW1pdHRlci5jb21iaW5lcikge1xuICAgICAgICAgICAgICAgICAgICBmdW5jKHRoaXMsIG5hbWUsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGlzdGVuZXJDb3VudChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuX2V2ZW50RnVuY3Rpb25bbmFtZV07XG4gICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jID09PSBFdmVudEVtaXR0ZXIuY29tYmluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50TGlzdGVuZXJzW25hbWVdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZXZlbnRGdW5jdGlvbltuYW1lXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudExpc3RlbmVyc1tuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5FdmVudEVtaXR0ZXIuY29tYmluZXIgPSBmdW5jdGlvbihvYmplY3QsIG5hbWUsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSBvYmplY3QuX2V2ZW50TGlzdGVuZXJzW25hbWVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLyogQmVjYXVzZSBsaXN0ZW5lciBtYXkgZGV0YWNoIGl0c2VsZiB3aGlsZSBiZWluZyBpbnZva2VkIGFuZCB0aGVyZWZvcmUgaW52YWxpZGF0ZSB0aGUgaXRlcmF0b3IsXG4gICAgICAgICAgIHdlIG5lZWQgdG8gY3JlYXRlIGEgY29weSB0byBsb29wIG92ZXIgaXQgKi9cbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBbLi4ubGlzdGVuZXJzXSkge1xuICAgICAgICAgICAgbGlzdGVuZXIoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkV2ZW50RW1pdHRlci5hZGRBc01peGluID0gZnVuY3Rpb24oY2xzKSB7XG4gICAgY2xzLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG4gICAgY2xzLnByb3RvdHlwZS5vbmNlID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlO1xuICAgIGNscy5wcm90b3R5cGUuaGFzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXM7XG4gICAgY2xzLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZjtcbiAgICBjbHMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbiAgICBjbHMucHJvdG90eXBlLmVtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG4gICAgY2xzLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50O1xuICAgIGNscy5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM7XG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50RW1pdHRlci5tanNcIjtcbmltcG9ydCBBbmltYXRpb25TZXR0aW5ncyBmcm9tIFwiLi9BbmltYXRpb25TZXR0aW5ncy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNldHRpbmdzLCBlbGVtZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcblxuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5JRExFO1xuXG4gICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSAwO1xuICAgICAgICB0aGlzLl9yZXBlYXRzTGVmdCA9IDA7XG5cbiAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCA9IDA7XG4gICAgICAgIHRoaXMuX3N0b3BQID0gMDtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5fZWxlbWVudC5hdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSB0aGlzLnNldHRpbmdzLmRlbGF5O1xuICAgICAgICAgICAgdGhpcy5fcmVwZWF0c0xlZnQgPSB0aGlzLnNldHRpbmdzLnJlcGVhdDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0FjdGl2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gRWxlbWVudCBtdXN0IGJlIGF0dGFjaGVkIGJlZm9yZSBzdGFydGluZyBhbmltYXRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuUEFVU0VEKSB7XG4gICAgICAgICAgICAvLyBDb250aW51ZS47XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORztcbiAgICAgICAgICAgIHRoaXMuY2hlY2tBY3RpdmUoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgPT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORyAmJiB0aGlzLnNldHRpbmdzLnN0b3BNZXRob2QgPT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLlJFVkVSU0UpIHtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlLjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wQ29udGludWUnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkcgJiYgdGhpcy5fc3RhdGUgIT0gQW5pbWF0aW9uLlNUQVRFUy5GSU5JU0hFRCkge1xuICAgICAgICAgICAgLy8gUmVzdGFydC47XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlBMQVlJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5QQVVTRUQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PSBBbmltYXRpb24uU1RBVEVTLkZJTklTSEVEKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNraXBEZWxheSgpIHtcbiAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCA9IDA7XG4gICAgfVxuXG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORykge1xuICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQgfHwgdGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuSURMRSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgPSB0aGlzLnNldHRpbmdzLnN0b3BEZWxheSB8fCAwO1xuXG4gICAgICAgIGlmICgoKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLklNTUVESUFURSkgJiYgIXRoaXMuX3N0b3BEZWxheUxlZnQpIHx8IHRoaXMuX2RlbGF5TGVmdCA+IDApIHtcbiAgICAgICAgICAgIC8vIFN0b3AgdXBvbiBuZXh0IHByb2dyZXNzLjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PT0gQW5pbWF0aW9uU2V0dGluZ3MuU1RPUF9NRVRIT0RTLkZBREUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wUCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja0FjdGl2ZSgpO1xuICAgIH1cblxuICAgIHN0b3BOb3coKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEIHx8IHRoaXMuX3N0YXRlICE9PSBBbmltYXRpb24uU1RBVEVTLklETEUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUElORztcbiAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcEZpbmlzaCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNQYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gQW5pbWF0aW9uLlNUQVRFUy5QQVVTRUQ7XG4gICAgfVxuXG4gICAgaXNQbGF5aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORztcbiAgICB9XG5cbiAgICBpc1N0b3BwaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkc7XG4gICAgfVxuXG4gICAgaXNGaW5pc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlID09PSBBbmltYXRpb24uU1RBVEVTLkZJTklTSEVEO1xuICAgIH1cblxuICAgIGNoZWNrQWN0aXZlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuYWRkQWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNBY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fc3RhdGUgPT0gQW5pbWF0aW9uLlNUQVRFUy5QTEFZSU5HIHx8IHRoaXMuX3N0YXRlID09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkcpICYmIHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5fZWxlbWVudC5hdHRhY2hlZDtcbiAgICB9XG5cbiAgICBwcm9ncmVzcyhkdCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHJldHVybjtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3MoZHQpO1xuICAgICAgICB0aGlzLmFwcGx5KCk7XG4gICAgfVxuXG4gICAgX3Byb2dyZXNzKGR0KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PSBBbmltYXRpb24uU1RBVEVTLlNUT1BQSU5HKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wUHJvZ3Jlc3MoZHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9IEFuaW1hdGlvbi5TVEFURVMuUExBWUlORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2RlbGF5TGVmdCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCAtPSBkdDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGF5TGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICBkdCA9IC10aGlzLl9kZWxheUxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gMDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVsYXlFbmQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wICs9IGR0IC8gdGhpcy5zZXR0aW5ncy5kdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcCA+PSAxKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2hlZCE7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5yZXBlYXQgPT0gLTEgfHwgdGhpcy5fcmVwZWF0c0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdHNMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXBlYXRzTGVmdC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wID0gdGhpcy5zZXR0aW5ncy5yZXBlYXRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMuX3ApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnJlcGVhdERlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IHRoaXMuc2V0dGluZ3MucmVwZWF0RGVsYXk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXBlYXQnLCB0aGlzLl9yZXBlYXRzTGVmdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncHJvZ3Jlc3MnLCB0aGlzLl9wKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuRklOSVNIRUQ7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hdXRvc3RvcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdGhpcy5fcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgX3N0b3BQcm9ncmVzcyhkdCkge1xuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLl9nZXRTdG9wRHVyYXRpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5fc3RvcERlbGF5TGVmdCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgLT0gZHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wRGVsYXlMZWZ0IDwgMCkge1xuICAgICAgICAgICAgICAgIGR0ID0gLXRoaXMuX3N0b3BEZWxheUxlZnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcERlbGF5TGVmdCA9IDA7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BEZWxheUVuZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuSU1NRURJQVRFKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcEZpbmlzaCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuUkVWRVJTRSkge1xuICAgICAgICAgICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgLT0gZHQgLyBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3AgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcEZpbmlzaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuRkFERSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NTdG9wVHJhbnNpdGlvbihkdCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcFAgPj0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcEZpbmlzaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuT05FVE9UV08pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wIDwgMikge1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wID0gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3AgKz0gZHQgLyB0aGlzLnNldHRpbmdzLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCArPSBkdCAvIGR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3BGaW5pc2gnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdGhpcy5fcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3Muc3RvcE1ldGhvZCA9PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuRk9SV0FSRCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3AgPCAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuZHVyYXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wICs9IGR0IC8gdGhpcy5zZXR0aW5ncy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3AgPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5GT1JXQVJEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gQW5pbWF0aW9uLlNUQVRFUy5TVE9QUEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRmluaXNoJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVwZWF0c0xlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVwZWF0c0xlZnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlcGVhdCcsIHRoaXMuX3JlcGVhdHNMZWZ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBBbmltYXRpb24uU1RBVEVTLlNUT1BQRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdG9wRmluaXNoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2dyZXNzJywgdGhpcy5fcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cbiAgICBcbiAgICBfcHJvZ3Jlc3NTdG9wVHJhbnNpdGlvbihkdCkge1xuICAgICAgICBpZiAodGhpcy5fc3RvcFAgPCAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RvcERlbGF5TGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wRGVsYXlMZWZ0IC09IGR0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0b3BEZWxheUxlZnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGR0ID0gLXRoaXMuX3N0b3BEZWxheUxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BEZWxheUxlZnQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGVsYXlFbmQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2dldFN0b3BEdXJhdGlvbigpO1xuXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BQID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RvcFAgKz0gZHQgLyBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wUCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluaXNoZWQhO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BQID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRTdG9wRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLnN0b3BEdXJhdGlvbiB8fCB0aGlzLnNldHRpbmdzLmR1cmF0aW9uO1xuICAgIH1cblxuICAgIGFwcGx5KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBFRCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZhY3RvciA9IDE7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEFuaW1hdGlvbi5TVEFURVMuU1RPUFBJTkcgJiYgdGhpcy5zZXR0aW5ncy5zdG9wTWV0aG9kID09PSBBbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMuRkFERSkge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9ICgxIC0gdGhpcy5zZXR0aW5ncy5zdG9wVGltaW5nRnVuY3Rpb25JbXBsKHRoaXMuX3N0b3BQKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXR0aW5ncy5hcHBseSh0aGlzLl9lbGVtZW50LCB0aGlzLl9wLCBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnJlc2V0KHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cblxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cblxuICAgIGdldCBwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcDtcbiAgICB9XG5cbiAgICBnZXQgZGVsYXlMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVsYXlMZWZ0O1xuICAgIH1cblxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcbiAgICB9XG5cbiAgICBnZXQgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3AgKiB0aGlzLl9zZXR0aW5ncy5kdXJhdGlvbiAqIDYwKTtcbiAgICB9XG5cbiAgICBnZXQgc2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG5cbn1cblxuQW5pbWF0aW9uLlNUQVRFUyA9IHtcbiAgICBJRExFOiAwLFxuICAgIFBMQVlJTkc6IDEsXG4gICAgU1RPUFBJTkc6IDIsXG4gICAgU1RPUFBFRDogMyxcbiAgICBGSU5JU0hFRDogNCxcbiAgICBQQVVTRUQ6IDVcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvbkFjdGlvblNldHRpbmdzIHtcblxuICAgIGNvbnN0cnVjdG9yKGFuaW1hdGlvblNldHRpbmdzKSB7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25TZXR0aW5ncyA9IGFuaW1hdGlvblNldHRpbmdzO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc2VsZWN0b3IgdGhhdCBzZWxlY3RzIHRoZSBlbGVtZW50cy5cbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhbHVlIGl0ZW1zLCBvcmRlcmVkIGJ5IHByb2dyZXNzIG9mZnNldC5cbiAgICAgICAgICogQHR5cGUge011bHRpU3BsaW5lfVxuICAgICAgICAgKiBAcHJpdmF0ZTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbmV3IE11bHRpU3BsaW5lKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhZmZlY3RlZCBwcm9wZXJ0aWVzIChwYXRocykuXG4gICAgICAgICAqIEBwcml2YXRlO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJvcHMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydHkgc2V0dGVycywgaW5kZXhlZCBhY2NvcmRpbmcgdG8gcHJvcHMuXG4gICAgICAgICAqIEBwcml2YXRlO1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJvcFNldHRlcnMgPSBbXTtcblxuICAgICAgICB0aGlzLl9yZXNldFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9oYXNSZXNldFZhbHVlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5faGFzQ29sb3JQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBnZXRSZXNldFZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUmVzZXRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2V0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuZ2V0VmFsdWUoMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhcHBseShlbGVtZW50LCBwLCBmYWN0b3IpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmdldEFuaW1hdGVkRWxlbWVudHMoZWxlbWVudCk7XG5cbiAgICAgICAgbGV0IHYgPSB0aGlzLl9pdGVtcy5nZXRWYWx1ZShwKTtcblxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmYWN0b3IgIT09IDEpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgZmFjdG9yLjtcbiAgICAgICAgICAgIGxldCBzdiA9IHRoaXMuZ2V0UmVzZXRWYWx1ZSgpO1xuXG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIodikgJiYgVXRpbHMuaXNOdW1iZXIoc3YpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ29sb3JQcm9wZXJ0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBTdGFnZVV0aWxzLm1lcmdlQ29sb3JzKHYsIHN2LCBmYWN0b3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSBTdGFnZVV0aWxzLm1lcmdlTnVtYmVycyh2LCBzdiwgZmFjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBseSB0cmFuc2Zvcm1hdGlvbiB0byBhbGwgY29tcG9uZW50cy47XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9wcm9wU2V0dGVycy5sZW5ndGg7XG5cbiAgICAgICAgY29uc3QgbSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcFNldHRlcnNbaV0oZWxlbWVudHNbal0sIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGdldEFuaW1hdGVkRWxlbWVudHMoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5zZWxlY3QodGhpcy5fc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHJlc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmdldEFuaW1hdGVkRWxlbWVudHMoZWxlbWVudCk7XG5cbiAgICAgICAgbGV0IHYgPSB0aGlzLmdldFJlc2V0VmFsdWUoKTtcblxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8ICFlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGx5IHRyYW5zZm9ybWF0aW9uIHRvIGFsbCBjb21wb25lbnRzLlxuICAgICAgICBjb25zdCBuID0gdGhpcy5fcHJvcFNldHRlcnMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IG0gPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BTZXR0ZXJzW2ldKGVsZW1lbnRzW2pdLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBzZXQgc2VsZWN0b3Iodikge1xuICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHY7XG4gICAgfVxuXG4gICAgc2V0IHQodikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcmVzZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2V0VmFsdWU7XG4gICAgfVxuICAgIFxuICAgIHNldCByZXNldFZhbHVlKHYpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRWYWx1ZSA9IHY7XG4gICAgICAgIHRoaXMuX2hhc1Jlc2V0VmFsdWUgPSAodiAhPT0gdW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICBzZXQgcnYodikge1xuICAgICAgICB0aGlzLnJlc2V0VmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2KSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zLnBhcnNlKHRoaXMuaGFzQ29sb3JQcm9wZXJ0eSgpLCB2KTtcbiAgICB9XG5cbiAgICBzZXQgdih2KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2O1xuICAgIH1cblxuICAgIHNldCBwcm9wZXJ0aWVzKHYpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICB2ID0gW3ZdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJvcHMgPSBbXTtcblxuICAgICAgICB2LmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9wU2V0dGVycy5wdXNoKEVsZW1lbnQuZ2V0U2V0dGVyKHByb3ApKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0IHByb3BlcnR5KHYpIHtcbiAgICAgICAgdGhpcy5faGFzQ29sb3JQcm9wZXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gdjtcbiAgICB9XG5cbiAgICBzZXQgcCh2KSB7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IHY7XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgaGFzQ29sb3JQcm9wZXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc0NvbG9yUHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5faGFzQ29sb3JQcm9wZXJ0eSA9IHRoaXMuX3Byb3BzLmxlbmd0aCA/IEVsZW1lbnQuaXNDb2xvclByb3BlcnR5KHRoaXMuX3Byb3BzWzBdKSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNDb2xvclByb3BlcnR5O1xuICAgIH1cbn1cblxuQW5pbWF0aW9uQWN0aW9uU2V0dGluZ3MucHJvdG90eXBlLmlzQW5pbWF0aW9uQWN0aW9uU2V0dGluZ3MgPSB0cnVlO1xuXG5pbXBvcnQgTXVsdGlTcGxpbmUgZnJvbSBcIi4uL3Rvb2xzL011bHRpU3BsaW5lLm1qc1wiO1xuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4uL3RyZWUvRWxlbWVudC5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5pbWF0aW9uTWFuYWdlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG5cbiAgICAgICAgdGhpcy5zdGFnZS5vbignZnJhbWVTdGFydCcsICgpID0+IHRoaXMucHJvZ3Jlc3MoKSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBydW5uaW5nIGFuaW1hdGlvbnMgb24gYXR0YWNoZWQgc3ViamVjdHMuXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8QW5pbWF0aW9uPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIHByb2dyZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGR0ID0gdGhpcy5zdGFnZS5kdDtcblxuICAgICAgICAgICAgbGV0IGZpbHRlciA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGEuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBhLnByb2dyZXNzKGR0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBuZXcgU2V0KFsuLi50aGlzLmFjdGl2ZV0uZmlsdGVyKHQgPT4gdC5pc0FjdGl2ZSgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVBbmltYXRpb24oZWxlbWVudCwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcGxhaW4gb2JqZWN0IHRvIHByb3BlciBzZXR0aW5ncyBvYmplY3QuXG4gICAgICAgICAgICBzZXR0aW5ncyA9IHRoaXMuY3JlYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgY3JlYXRlU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uU2V0dGluZ3MgPSBuZXcgQW5pbWF0aW9uU2V0dGluZ3MoKTtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdChhbmltYXRpb25TZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgYWRkQWN0aXZlKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUuYWRkKHRyYW5zaXRpb24pO1xuICAgIH1cbn1cblxuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcbmltcG9ydCBBbmltYXRpb25TZXR0aW5ncyBmcm9tIFwiLi9BbmltYXRpb25TZXR0aW5ncy5tanNcIjtcbmltcG9ydCBBbmltYXRpb24gZnJvbSBcIi4vQW5pbWF0aW9uLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBBbmltYXRpb25BY3Rpb25TZXR0aW5ncyBmcm9tIFwiLi9BbmltYXRpb25BY3Rpb25TZXR0aW5ncy5tanNcIjtcbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGlvblNldHRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBbmltYXRpb25BY3Rpb25TZXR0aW5nc1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMTtcblxuICAgICAgICB0aGlzLnJlcGVhdCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0T2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5yZXBlYXREZWxheSA9IDA7XG5cbiAgICAgICAgdGhpcy5hdXRvc3RvcCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc3RvcE1ldGhvZCA9IEFuaW1hdGlvblNldHRpbmdzLlNUT1BfTUVUSE9EUy5GQURFO1xuICAgICAgICB0aGlzLl9zdG9wVGltaW5nRnVuY3Rpb24gPSAnZWFzZSc7XG4gICAgICAgIHRoaXMuX3N0b3BUaW1pbmdGdW5jdGlvbkltcGwgPSBTdGFnZVV0aWxzLmdldFRpbWluZ0Z1bmN0aW9uKHRoaXMuX3N0b3BUaW1pbmdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuc3RvcER1cmF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5zdG9wRGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGdldCBhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucztcbiAgICB9XG5cbiAgICBzZXQgYWN0aW9ucyh2KSB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB2Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZSA9IHZbaV07XG4gICAgICAgICAgICBpZiAoIWUuaXNBbmltYXRpb25BY3Rpb25TZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFhcyA9IG5ldyBBbmltYXRpb25BY3Rpb25TZXR0aW5ncyh0aGlzKTtcbiAgICAgICAgICAgICAgICBhYXMucGF0Y2goZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFhcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbnMucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGFuaW1hdGlvbiB0byB0aGUgc3BlY2lmaWVkIGVsZW1lbnQsIGZvciB0aGUgc3BlY2lmaWVkIHByb2dyZXNzIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQ7XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHA7XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvcjtcbiAgICAgKi9cbiAgICBhcHBseShlbGVtZW50LCBwLCBmYWN0b3IgPSAxKSB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgIGFjdGlvbi5hcHBseShlbGVtZW50LCBwLCBmYWN0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGFuaW1hdGlvbiB0byB0aGUgcmVzZXQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudDtcbiAgICAgKi9cbiAgICByZXNldChlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihhY3Rpb24pIHtcbiAgICAgICAgICAgIGFjdGlvbi5yZXNldChlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0IHN0b3BUaW1pbmdGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BUaW1pbmdGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgc3RvcFRpbWluZ0Z1bmN0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fc3RvcFRpbWluZ0Z1bmN0aW9uID0gdjtcbiAgICAgICAgdGhpcy5fc3RvcFRpbWluZ0Z1bmN0aW9uSW1wbCA9IFN0YWdlVXRpbHMuZ2V0VGltaW5nRnVuY3Rpb24odik7XG4gICAgfVxuXG4gICAgZ2V0IHN0b3BUaW1pbmdGdW5jdGlvbkltcGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltaW5nRnVuY3Rpb25JbXBsO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxufVxuXG5BbmltYXRpb25TZXR0aW5ncy5TVE9QX01FVEhPRFMgPSB7XG4gICAgRkFERTogJ2ZhZGUnLFxuICAgIFJFVkVSU0U6ICdyZXZlcnNlJyxcbiAgICBGT1JXQVJEOiAnZm9yd2FyZCcsXG4gICAgSU1NRURJQVRFOiAnaW1tZWRpYXRlJyxcbiAgICBPTkVUT1RXTzogJ29uZXRvdHdvJ1xufTtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiLi4vRXZlbnRFbWl0dGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc2l0aW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNldHRpbmdzLCBlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG5cbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblxuICAgICAgICB0aGlzLl9nZXR0ZXIgPSBlbGVtZW50LmNvbnN0cnVjdG9yLmdldEdldHRlcihwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuX3NldHRlciA9IGVsZW1lbnQuY29uc3RydWN0b3IuZ2V0U2V0dGVyKHByb3BlcnR5KTtcblxuICAgICAgICB0aGlzLl9tZXJnZXIgPSBzZXR0aW5ncy5tZXJnZXI7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tZXJnZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21lcmdlciA9IGVsZW1lbnQuY29uc3RydWN0b3IuZ2V0TWVyZ2VyKHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLl9nZXR0ZXIodGhpcy5fZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGhpcy5fc3RhcnRWYWx1ZTtcblxuICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gMDtcbiAgICB9XG5cbiAgICBzdGFydCh0YXJnZXRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgdHJhbnNpdGlvbnMgb24gbm9uLWF0dGFjaGVkIGVsZW1lbnRzLiBKdXN0IHNldCB2YWx1ZSB3aXRob3V0IGludm9raW5nIGxpc3RlbmVycy5cbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9wID0gMTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURyYXdWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRhcmdldFZhbHVlID09PSB0aGlzLl9zdGFydFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCh0YXJnZXRWYWx1ZSwgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVsYXlMZWZ0ID0gdGhpcy5fc2V0dGluZ3MuZGVsYXk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdzdGFydCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9wIDwgMSkge1xuICAgICAgICAgICAgLy8gVmFsdWUgc2V0dGluZyBhbmQgd2lsbCBtdXN0IGJlIGludm9rZWQgKGFzeW5jKSB1cG9uIG5leHQgdHJhbnNpdGlvbiBjeWNsZS5cbiAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgLy8gSnVzdCBzdG9wIHdoZXJlIHRoZSB0cmFuc2l0aW9uIGlzIGF0LlxuICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLnJlbW92ZUFjdGl2ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgfVxuXG4gICAgcGxheSgpIHtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLmFkZEFjdGl2ZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXNldCh0YXJnZXRWYWx1ZSwgcCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHRyYW5zaXRpb25zIG9uIG5vbi1hdHRhY2hlZCBlbGVtZW50cy4gSnVzdCBzZXQgdmFsdWUgd2l0aG91dCBpbnZva2luZyBsaXN0ZW5lcnMuXG4gICAgICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3AgPSAxO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRHJhd1ZhbHVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3AgPSBwO1xuICAgICAgICAgICAgdGhpcy5hZGQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVEcmF3VmFsdWUoKSB7XG4gICAgICAgIHRoaXMuX3NldHRlcih0aGlzLl9lbGVtZW50LCB0aGlzLmdldERyYXdWYWx1ZSgpKTtcbiAgICB9XG5cbiAgICBhZGQoKSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5hZGRBY3RpdmUodGhpcyk7XG4gICAgfVxuXG4gICAgaXNBdHRhY2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuYXR0YWNoZWQ7XG4gICAgfVxuXG4gICAgaXNSdW5uaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3AgPCAxLjApO1xuICAgIH1cblxuICAgIHByb2dyZXNzKGR0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIC8vIFNraXAgdG8gZW5kIG9mIHRyYW5zaXRpb24gc28gdGhhdCBpdCBpcyByZW1vdmVkLlxuICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wIDwgMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsYXlMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCAtPSBkdDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlbGF5TGVmdCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHQgPSAtdGhpcy5kZWxheUxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGF5TGVmdCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkZWxheUVuZCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5kdXJhdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3AgKz0gZHQgLyB0aGlzLl9zZXR0aW5ncy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9wID49IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZCE7XG4gICAgICAgICAgICAgICAgdGhpcy5fcCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVEcmF3VmFsdWUoKTtcblxuICAgICAgICB0aGlzLmludm9rZUxpc3RlbmVycygpO1xuICAgIH1cblxuICAgIGludm9rZUxpc3RlbmVycygpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcm9ncmVzcycsIHRoaXMucCk7XG4gICAgICAgIGlmICh0aGlzLnAgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVUYXJnZXRWYWx1ZSh0YXJnZXRWYWx1ZSkge1xuICAgICAgICBsZXQgdCA9IHRoaXMuX3NldHRpbmdzLnRpbWluZ0Z1bmN0aW9uSW1wbCh0aGlzLnApO1xuICAgICAgICBpZiAodCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5fdGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRWYWx1ZSA9IHRhcmdldFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRhcmdldFZhbHVlIC0gKCh0YXJnZXRWYWx1ZSAtIHRoaXMuX3RhcmdldFZhbHVlKSAvICgxIC0gdCkpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0VmFsdWUgPSB0YXJnZXRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldERyYXdWYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucCA+PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB2ID0gdGhpcy5fc2V0dGluZ3MuX3RpbWluZ0Z1bmN0aW9uSW1wbCh0aGlzLnApO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21lcmdlcih0aGlzLnRhcmdldFZhbHVlLCB0aGlzLnN0YXJ0VmFsdWUsIHYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2tpcERlbGF5KCkge1xuICAgICAgICB0aGlzLl9kZWxheUxlZnQgPSAwO1xuICAgIH1cblxuICAgIGdldCBzdGFydFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdGFyZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRWYWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3A7XG4gICAgfVxuXG4gICAgZ2V0IGRlbGF5TGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGF5TGVmdDtcbiAgICB9XG5cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0IHNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgc2V0IHNldHRpbmdzKHYpIHtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSB2O1xuICAgIH1cblxufVxuXG5UcmFuc2l0aW9uLnByb3RvdHlwZS5pc1RyYW5zaXRpb24gPSB0cnVlO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNpdGlvbk1hbmFnZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuXG4gICAgICAgIHRoaXMuc3RhZ2Uub24oJ2ZyYW1lU3RhcnQnLCAoKSA9PiB0aGlzLnByb2dyZXNzKCkpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgdHJhbnNpdGlvbnMgdGhhdCBhcmUgcnVubmluZyBhbmQgYXR0YWNoZWQuXG4gICAgICAgICAqICh3ZSBkb24ndCBzdXBwb3J0IHRyYW5zaXRpb25zIG9uIHVuLWF0dGFjaGVkIGVsZW1lbnRzIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzKVxuICAgICAgICAgKiBAdHlwZSB7U2V0PFRyYW5zaXRpb24+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgdGhpcy5kZWZhdWx0VHJhbnNpdGlvblNldHRpbmdzID0gbmV3IFRyYW5zaXRpb25TZXR0aW5ncyh0aGlzLnN0YWdlKTtcbiAgICB9XG5cbiAgICBwcm9ncmVzcygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlLnNpemUpIHtcbiAgICAgICAgICAgIGxldCBkdCA9IHRoaXMuc3RhZ2UuZHQ7XG5cbiAgICAgICAgICAgIGxldCBmaWx0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgIGEucHJvZ3Jlc3MoZHQpO1xuICAgICAgICAgICAgICAgIGlmICghYS5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBuZXcgU2V0KFsuLi50aGlzLmFjdGl2ZV0uZmlsdGVyKHQgPT4gKHQuaXNSdW5uaW5nKCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjcmVhdGVTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9uU2V0dGluZ3MgPSBuZXcgVHJhbnNpdGlvblNldHRpbmdzKCk7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodHJhbnNpdGlvblNldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiB0cmFuc2l0aW9uU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgYWRkQWN0aXZlKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5hY3RpdmUuYWRkKHRyYW5zaXRpb24pO1xuICAgIH1cblxuICAgIHJlbW92ZUFjdGl2ZSh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlLmRlbGV0ZSh0cmFuc2l0aW9uKTtcbiAgICB9XG59XG5cbmltcG9ydCBCYXNlIGZyb20gXCIuLi90cmVlL0Jhc2UubWpzXCI7XG5pbXBvcnQgVHJhbnNpdGlvblNldHRpbmdzIGZyb20gXCIuL1RyYW5zaXRpb25TZXR0aW5ncy5tanNcIjtcbmltcG9ydCBUcmFuc2l0aW9uIGZyb20gXCIuL1RyYW5zaXRpb24ubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNpdGlvblNldHRpbmdzIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICB0aGlzLnN0YWdlID0gc3RhZ2U7XG4gICAgICAgIHRoaXMuX3RpbWluZ0Z1bmN0aW9uID0gJ2Vhc2UnO1xuICAgICAgICB0aGlzLl90aW1pbmdGdW5jdGlvbkltcGwgPSBTdGFnZVV0aWxzLmdldFRpbWluZ0Z1bmN0aW9uKHRoaXMuX3RpbWluZ0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy5kZWxheSA9IDA7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSAwLjI7XG4gICAgICAgIHRoaXMubWVyZ2VyID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdGltaW5nRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW1pbmdGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBzZXQgdGltaW5nRnVuY3Rpb24odikge1xuICAgICAgICB0aGlzLl90aW1pbmdGdW5jdGlvbiA9IHY7XG4gICAgICAgIHRoaXMuX3RpbWluZ0Z1bmN0aW9uSW1wbCA9IFN0YWdlVXRpbHMuZ2V0VGltaW5nRnVuY3Rpb24odik7XG4gICAgfVxuXG4gICAgZ2V0IHRpbWluZ0Z1bmN0aW9uSW1wbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWluZ0Z1bmN0aW9uSW1wbDtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG59XG5cblRyYW5zaXRpb25TZXR0aW5ncy5wcm90b3R5cGUuaXNUcmFuc2l0aW9uU2V0dGluZ3MgPSB0cnVlO1xuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuL0NvbXBvbmVudC5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwbGljYXRpb24gZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIFNhdmUgb3B0aW9ucyB0ZW1wb3JhcmlseSB0byBhdm9pZCBoYXZpbmcgdG8gcGFzcyBpdCB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgQXBwbGljYXRpb24uX3RlbXBfb3B0aW9ucyA9IG9wdGlvbnM7XG5cbiAgICAgICAgLy8gQm9vdGluZyBmbGFnIGlzIHVzZWQgdG8gcG9zdHBvbmUgdXBkYXRlRm9jdXNTZXR0aW5ncztcbiAgICAgICAgQXBwbGljYXRpb24uYm9vdGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0YWdlID0gbmV3IFN0YWdlKG9wdGlvbnMuc3RhZ2UpO1xuICAgICAgICBzdXBlcihzdGFnZSwgcHJvcGVydGllcyk7XG4gICAgICAgIEFwcGxpY2F0aW9uLmJvb3RpbmcgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9fdXBkYXRlRm9jdXNDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fX2tleXByZXNzVGltZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9faG92ZXJlZENoaWxkID0gbnVsbDtcblxuICAgICAgICAvLyBXZSBtdXN0IGNvbnN0cnVjdCB3aGlsZSB0aGUgYXBwbGljYXRpb24gaXMgbm90IHlldCBhdHRhY2hlZC5cbiAgICAgICAgLy8gVGhhdCdzIHdoeSB3ZSAnaW5pdCcgdGhlIHN0YWdlIGxhdGVyICh3aGljaCBhY3R1YWxseSBlbWl0cyB0aGUgYXR0YWNoIGV2ZW50KS5cbiAgICAgICAgdGhpcy5zdGFnZS5pbml0KCk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGx5LCB0aGUgZm9jdXMgc2V0dGluZ3MgYXJlIHVwZGF0ZWQgYWZ0ZXIgYm90aCB0aGUgc3RhZ2UgYW5kIGFwcGxpY2F0aW9uIGFyZSBjb25zdHJ1Y3RlZC5cbiAgICAgICAgdGhpcy51cGRhdGVGb2N1c1NldHRpbmdzKCk7XG5cbiAgICAgICAgdGhpcy5fX2tleW1hcCA9IHRoaXMuZ2V0T3B0aW9uKCdrZXlzJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX19rZXltYXApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UucGxhdGZvcm0ucmVnaXN0ZXJLZXlkb3duSGFuZGxlcigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVLZXlkb3duKGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuc3RhZ2UucGxhdGZvcm0ucmVnaXN0ZXJLZXl1cEhhbmRsZXIoKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNlaXZlS2V5dXAoZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbihcImVuYWJsZVBvaW50ZXJcIikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UucGxhdGZvcm0ucmVnaXN0ZXJDbGlja0hhbmRsZXIoKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWNlaXZlQ2xpY2soZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5zdGFnZS5wbGF0Zm9ybS5yZWdpc3RlckhvdmVySGFuZGxlcigoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2VpdmVIb3ZlcihlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnN0YWdlLnBsYXRmb3JtLnJlZ2lzdGVyU2Nyb2xsV2hlZWxIYW5kbGVyKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjaWV2ZVNjcm9sbFdoZWVsKGUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19vcHRpb25zW25hbWVdO1xuICAgIH1cblxuICAgIF9zZXRPcHRpb25zKG8pIHtcbiAgICAgICAgdGhpcy5fX29wdGlvbnMgPSB7fTtcblxuICAgICAgICBsZXQgb3B0ID0gKG5hbWUsIGRlZikgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gb1tuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fb3B0aW9uc1tuYW1lXSA9IGRlZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX29wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdCgnZGVidWcnLCBmYWxzZSk7XG4gICAgICAgIG9wdCgna2V5cycsIHtcbiAgICAgICAgICAgIDM4OiBcIlVwXCIsXG4gICAgICAgICAgICA0MDogXCJEb3duXCIsXG4gICAgICAgICAgICAzNzogXCJMZWZ0XCIsXG4gICAgICAgICAgICAzOTogXCJSaWdodFwiLFxuICAgICAgICAgICAgMTM6IFwiRW50ZXJcIixcbiAgICAgICAgICAgIDg6IFwiQmFja1wiLFxuICAgICAgICAgICAgMjc6IFwiRXhpdFwiXG4gICAgICAgIH0pO1xuICAgICAgICBvcHQoJ2VuYWJsZVBvaW50ZXInLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgX19jb25zdHJ1Y3QoKSB7XG4gICAgICAgIHRoaXMuc3RhZ2Uuc2V0QXBwbGljYXRpb24odGhpcyk7XG5cbiAgICAgICAgdGhpcy5fc2V0T3B0aW9ucyhBcHBsaWNhdGlvbi5fdGVtcF9vcHRpb25zKTtcbiAgICAgICAgZGVsZXRlIEFwcGxpY2F0aW9uLl90ZW1wX29wdGlvbnM7XG5cbiAgICAgICAgc3VwZXIuX19jb25zdHJ1Y3QoKTtcbiAgICB9XG5cbiAgICBfX2luaXQoKSB7XG4gICAgICAgIHN1cGVyLl9faW5pdCgpO1xuICAgICAgICB0aGlzLl9fdXBkYXRlRm9jdXMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVGb2N1c1BhdGgoKSB7XG4gICAgICAgIHRoaXMuX191cGRhdGVGb2N1cygpO1xuICAgIH1cblxuICAgIF9fdXBkYXRlRm9jdXMoKSB7XG4gICAgICAgIGNvbnN0IG5vdE92ZXJyaWRkZW4gPSB0aGlzLl9fdXBkYXRlRm9jdXNSZWMoKTtcblxuICAgICAgICBpZiAoIUFwcGxpY2F0aW9uLmJvb3RpbmcgJiYgbm90T3ZlcnJpZGRlbikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb2N1c1NldHRpbmdzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfX3VwZGF0ZUZvY3VzUmVjKCkge1xuICAgICAgICBjb25zdCB1cGRhdGVGb2N1c0lkID0gKyt0aGlzLl9fdXBkYXRlRm9jdXNDb3VudGVyO1xuICAgICAgICB0aGlzLl9fdXBkYXRlRm9jdXNJZCA9IHVwZGF0ZUZvY3VzSWQ7XG5cbiAgICAgICAgY29uc3QgbmV3Rm9jdXNQYXRoID0gdGhpcy5fX2dldEZvY3VzUGF0aCgpO1xuICAgICAgICBjb25zdCBuZXdGb2N1c2VkQ29tcG9uZW50ID0gbmV3Rm9jdXNQYXRoW25ld0ZvY3VzUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcHJldkZvY3VzZWRDb21wb25lbnQgPSB0aGlzLl9mb2N1c1BhdGggPyB0aGlzLl9mb2N1c1BhdGhbdGhpcy5fZm9jdXNQYXRoLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICghcHJldkZvY3VzZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIC8vIEZvY3VzIGV2ZW50cy5cbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzUGF0aCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBuZXdGb2N1c1BhdGgubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoLnB1c2gobmV3Rm9jdXNQYXRoW2ldKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGhbaV0uX2ZvY3VzKG5ld0ZvY3VzZWRDb21wb25lbnQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9jdXNPdmVycmlkZGVuID0gKHRoaXMuX191cGRhdGVGb2N1c0lkICE9PSB1cGRhdGVGb2N1c0lkKTtcbiAgICAgICAgICAgICAgICBpZiAoZm9jdXNPdmVycmlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtID0gTWF0aC5taW4odGhpcy5fZm9jdXNQYXRoLmxlbmd0aCwgbmV3Rm9jdXNQYXRoLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBtOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzUGF0aFtpbmRleF0gIT09IG5ld0ZvY3VzUGF0aFtpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fZm9jdXNQYXRoLmxlbmd0aCAhPT0gbmV3Rm9jdXNQYXRoLmxlbmd0aCB8fCBpbmRleCAhPT0gbmV3Rm9jdXNQYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0T3B0aW9uKCdkZWJ1ZycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbTGlnaHRuaW5nXSBGb2N1cyBjaGFuZ2VkOiAnICsgbmV3Rm9jdXNlZENvbXBvbmVudC5nZXRMb2NhdGlvblN0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVbmZvY3VzIGV2ZW50cy5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZm9jdXNQYXRoLmxlbmd0aCAtIDE7IGkgPj0gaW5kZXg7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmZvY3VzZWRFbGVtZW50ID0gdGhpcy5fZm9jdXNQYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB1bmZvY3VzZWRFbGVtZW50Ll91bmZvY3VzKG5ld0ZvY3VzZWRDb21wb25lbnQsIHByZXZGb2N1c2VkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9jdXNPdmVycmlkZGVuID0gKHRoaXMuX191cGRhdGVGb2N1c0lkICE9PSB1cGRhdGVGb2N1c0lkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzT3ZlcnJpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRm9jdXMgZXZlbnRzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCwgbiA9IG5ld0ZvY3VzUGF0aC5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoLnB1c2gobmV3Rm9jdXNQYXRoW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNQYXRoW2ldLl9mb2N1cyhuZXdGb2N1c2VkQ29tcG9uZW50LCBwcmV2Rm9jdXNlZENvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzT3ZlcnJpZGRlbiA9ICh0aGlzLl9fdXBkYXRlRm9jdXNJZCAhPT0gdXBkYXRlRm9jdXNJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c092ZXJyaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZvY3VzIGNoYW5nZWQgZXZlbnRzLlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGhbaV0uX2ZvY3VzQ2hhbmdlKG5ld0ZvY3VzZWRDb21wb25lbnQsIHByZXZGb2N1c2VkQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB1cGRhdGVGb2N1c1NldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBmb2N1c2VkQ29tcG9uZW50ID0gdGhpcy5fZm9jdXNQYXRoW3RoaXMuX2ZvY3VzUGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICAvLyBHZXQgZm9jdXMgc2V0dGluZ3MuIFRoZXNlIGNhbiBiZSB1c2VkIGZvciBkeW5hbWljIGFwcGxpY2F0aW9uLXdpZGUgc2V0dGluZ3MgdGhhdCBkZXBlbmQgb24gdGhlXG4gICAgICAgIC8vIGZvY3VzIGRpcmVjdGx5IChzdWNoIGFzIHRoZSBhcHBsaWNhdGlvbiBiYWNrZ3JvdW5kKS5cbiAgICAgICAgY29uc3QgZm9jdXNTZXR0aW5ncyA9IHt9O1xuICAgICAgICBjb25zdCBkZWZhdWx0U2V0Rm9jdXNTZXR0aW5ncyA9IENvbXBvbmVudC5wcm90b3R5cGUuX3NldEZvY3VzU2V0dGluZ3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fZm9jdXNQYXRoLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzUGF0aFtpXS5fc2V0Rm9jdXNTZXR0aW5ncyAhPT0gZGVmYXVsdFNldEZvY3VzU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGhbaV0uX3NldEZvY3VzU2V0dGluZ3MoZm9jdXNTZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWZhdWx0SGFuZGxlRm9jdXNTZXR0aW5ncyA9IENvbXBvbmVudC5wcm90b3R5cGUuX2hhbmRsZUZvY3VzU2V0dGluZ3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fZm9jdXNQYXRoLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvY3VzUGF0aFtpXS5faGFuZGxlRm9jdXNTZXR0aW5ncyAhPT0gZGVmYXVsdEhhbmRsZUZvY3VzU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1c1BhdGhbaV0uX2hhbmRsZUZvY3VzU2V0dGluZ3MoZm9jdXNTZXR0aW5ncywgdGhpcy5fX3ByZXZGb2N1c1NldHRpbmdzLCBmb2N1c2VkQ29tcG9uZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19wcmV2Rm9jdXNTZXR0aW5ncyA9IGZvY3VzU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgX2hhbmRsZUZvY3VzU2V0dGluZ3Moc2V0dGluZ3MsIHByZXZTZXR0aW5ncywgZm9jdXNlZCwgcHJldkZvY3VzZWQpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdG8gaGFuZGxlIGZvY3VzLWJhc2VkIHNldHRpbmdzLlxuICAgIH1cblxuICAgIF9fZ2V0Rm9jdXNQYXRoKCkge1xuICAgICAgICBjb25zdCBwYXRoID0gW3RoaXNdO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRGb2N1cyA9IGN1cnJlbnQuX2dldEZvY3VzZWQoKTtcbiAgICAgICAgICAgIGlmICghbmV4dEZvY3VzIHx8IChuZXh0Rm9jdXMgPT09IGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGxldCBwdHIgPSBuZXh0Rm9jdXMuY3BhcmVudDtcbiAgICAgICAgICAgIGlmIChwdHIgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobmV4dEZvY3VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IGFuIGltbWVkaWF0ZSBjaGlsZDogaW5jbHVkZSBmdWxsIHBhdGggdG8gZGVzY2VuZGFudC5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXJ0cyA9IFtuZXh0Rm9jdXNdO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuX3Rocm93RXJyb3IoXCJSZXR1cm4gdmFsdWUgZm9yIF9nZXRGb2N1c2VkIG11c3QgYmUgYW4gYXR0YWNoZWQgZGVzY2VuZGFudCBjb21wb25lbnQgYnV0IGl0cyAnXCIgKyBuZXh0Rm9jdXMuZ2V0TG9jYXRpb25TdHJpbmcoKSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHB0cik7XG4gICAgICAgICAgICAgICAgICAgIHB0ciA9IHB0ci5jcGFyZW50O1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKHB0ciAhPT0gY3VycmVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlbSByZXZlcnNlZC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5ld1BhcnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobmV3UGFydHNbbiAtIGkgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50ID0gbmV4dEZvY3VzO1xuICAgICAgICB9IHdoaWxlKHRydWUpO1xuXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGdldCBmb2N1c1BhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c1BhdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5qZWN0cyBhbiBldmVudCBpbiB0aGUgc3RhdGUgbWFjaGluZXMsIHRvcC1kb3duIGZyb20gYXBwbGljYXRpb24gdG8gZm9jdXNlZCBjb21wb25lbnQuXG4gICAgICovXG4gICAgZm9jdXNUb3BEb3duRXZlbnQoZXZlbnRzLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmZvY3VzUGF0aDtcbiAgICAgICAgY29uc3QgbiA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIC8vIE11bHRpcGxlIGV2ZW50cy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gcGF0aFtpXS5fZ2V0TW9zdFNwZWNpZmljSGFuZGxlZE1lbWJlcihldmVudHMpO1xuICAgICAgICAgICAgaWYgKGV2ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5WYWx1ZSA9IHBhdGhbaV1bZXZlbnRdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluamVjdHMgYW4gZXZlbnQgaW4gdGhlIHN0YXRlIG1hY2hpbmVzLCBib3R0b20tdXAgZnJvbSBmb2N1c2VkIGNvbXBvbmVudCB0byBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBmb2N1c0JvdHRvbVVwRXZlbnQoZXZlbnRzLCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0aGlzLmZvY3VzUGF0aDtcbiAgICAgICAgY29uc3QgbiA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAgIC8vIE11bHRpcGxlIGV2ZW50cy5cbiAgICAgICAgZm9yIChsZXQgaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBwYXRoW2ldLl9nZXRNb3N0U3BlY2lmaWNIYW5kbGVkTWVtYmVyKGV2ZW50cyk7XG4gICAgICAgICAgICBpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0gcGF0aFtpXVtldmVudF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX3JlY2VpdmVLZXlkb3duKGUpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZTtcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleW1hcFtlLmtleUNvZGVdO1xuICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5mb2N1c1BhdGg7XG5cbiAgICAgICAgbGV0IGtleXM7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGtleXMgPSBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzVGltZXIgPSB0aGlzLl9fa2V5cHJlc3NUaW1lcnMuaGFzKGtleXNbaV0pO1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnQgZXZlbnQgZnJvbSBnZXR0aW5nIGZpcmVkIHdoZW4gdGhlIHRpbWVvdXQgaXMgc3RpbGwgYWN0aXZlXG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXS5sb25ncHJlc3MgJiYgaGFzVGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c1RvcERvd25FdmVudChbYF9jYXB0dXJlJHtrZXlzW2ldfWAsIFwiX2NhcHR1cmVLZXlcIl0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c0JvdHRvbVVwRXZlbnQoW2BfaGFuZGxlJHtrZXlzW2ldfWAsIFwiX2hhbmRsZUtleVwiXSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNUb3BEb3duRXZlbnQoW1wiX2NhcHR1cmVLZXlcIl0sIG9iaikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzQm90dG9tVXBFdmVudChbXCJfaGFuZGxlS2V5XCJdLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVGb2N1c1BhdGgoKTtcblxuICAgICAgICBjb25zdCBjb25zdW1lciA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoa2V5cyAmJiBjb25zdW1lci5sb25ncHJlc3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydExvbmdwcmVzc1RpbWVyKGtleXNbaV0sIGNvbnN1bWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtleXVwIGxpc3RlbmVyXG4gICAgICogVG8gdGFrZSBhd2F5IHNvbWUgY29uZnVzaW9uIHdlIGFkZCBgUmVsZWFzZWAgdG8gdGhlIGV2ZW50IHRvIHByZXZlbnQgZW5kaW5nIHVwIHdpdGggbWV0aG9kIG5hbWVzIGxpa2U6XG4gICAgICogIF9oYW5kbGVMZWZ0VXAgLyBfaGFuZGxlVXBVcCAvIF9oYW5kbGVFbnRlclVwIGV0Y1xuICAgICAqXG4gICAgICogQHBhcmFtIGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWNlaXZlS2V5dXAoZSkge1xuICAgICAgICBjb25zdCBvYmogPSBlO1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9fa2V5bWFwW2Uua2V5Q29kZV07XG5cbiAgICAgICAgbGV0IGtleXM7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGtleXMgPSBBcnJheS5pc0FycmF5KGtleSkgPyBrZXkgOiBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZvY3VzVG9wRG93bkV2ZW50KFtgX2NhcHR1cmUke2tleXNbaV19UmVsZWFzZWAsIFwiX2NhcHR1cmVLZXlSZWxlYXNlXCJdLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNCb3R0b21VcEV2ZW50KFtgX2hhbmRsZSR7a2V5c1tpXX1SZWxlYXNlYCwgXCJfaGFuZGxlS2V5UmVsZWFzZVwiXSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNUb3BEb3duRXZlbnQoW1wiX2NhcHR1cmVLZXlSZWxlYXNlXCJdLCBvYmopKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5mb2N1c0JvdHRvbVVwRXZlbnQoW1wiX2hhbmRsZUtleVJlbGVhc2VcIl0sIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUZvY3VzUGF0aCgpO1xuXG4gICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGtleXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19rZXlwcmVzc1RpbWVycy5oYXMoa2V5c1tpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2V5dXAgaGFzIGZpcmVkIGJlZm9yZSBlbmQgb2YgdGltZW91dCBzbyB3ZSBjbGVhciBpdFxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fX2tleXByZXNzVGltZXJzLmdldChrZXlzW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBzbyB3ZSBjYW4gcmVnaXN0ZXIgaXQgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2tleXByZXNzVGltZXJzLmRlbGV0ZShrZXlzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW5kIHN0YXJ0cyBhIHRpbWVyIGZvciB0aGUgcHJlc3NlZCBrZXkuIFRpbWVyIHdpbGwgYmUgY2xlYXJlZCB3aGVuIHRoZSBrZXkgaXMgcmVsZWFzZWRcbiAgICAgKiBiZWZvcmUgdGhlIHRpbWVyIGdvZXMgb2ZmLlxuICAgICAqXG4gICAgICogSWYga2V5IGlzIG5vdCByZWxlYXNlIChrZXl1cCkgdGhlIGxvbmdwcmVzcyBoYW5kbGVyIHdpbGwgYmUgZmlyZWQuXG4gICAgICogQ29uZmlndXJhdGlvbiBjYW4gYmUgdmlhIHRoZSBDb21wb25lbnRzIHRlbXBsYXRlOlxuICAgICAqXG4gICAgICogc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgKiAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICAgIHc6MTAwLCBoOjEwMCxcbiAgICAgKiAgICAgICAgIGxvbmdwcmVzczp7dXA6NzAwLCBkb3duOjUwMH1cbiAgICAgKiAgICAgfVxuICAgICAqIH0gICAgICpcbiAgICAgKiAvLyB0aGlzIHdpbGwgZ2V0IGNhbGxlZCB3aGVuIHVwIGhhcyBiZWVuIHByZXNzZWQgZm9yIDcwMG1zXG4gICAgICogX2hhbmRsZVVwTG9uZygpIHtcbiAgICAgKlxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3N0YXJ0TG9uZ3ByZXNzVGltZXIoa2V5LCBlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGVsZW1lbnQubG9uZ3ByZXNzO1xuICAgICAgICBjb25zdCBsb29rdXAgPSBrZXkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBpZiAoY29uZmlnW2xvb2t1cF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBjb25maWdbbG9va3VwXTtcbiAgICAgICAgICAgIGlmICghVXRpbHMuaXNOdW1iZXIodGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Ll90aHJvd0Vycm9yKFwiY29uZmlnIHZhbHVlIGZvciBsb25ncHJlc3MgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2tleXByZXNzVGltZXJzLnNldChrZXksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNUb3BEb3duRXZlbnQoW2BfY2FwdHVyZSR7a2V5fUxvbmdgLCBcIl9jYXB0dXJlS2V5XCJdLCB7fSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uZm9jdXNCb3R0b21VcEV2ZW50KFtgX2hhbmRsZSR7a2V5fUxvbmdgLCBcIl9oYW5kbGVLZXlcIl0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX19rZXlwcmVzc1RpbWVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0IHx8IDUwMCAvKiBwcmV2ZW50IDBtcyAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfcmVjaWV2ZVNjcm9sbFdoZWVsKGUpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZTtcbiAgICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gb2JqO1xuXG4gICAgICAgIGlmIChjbGllbnRYIDw9IHRoaXMuc3RhZ2UudyAmJiBjbGllbnRZIDw9IHRoaXMuc3RhZ2UuaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpcmVUb3BEb3duU2Nyb2xsV2hlZWxIYW5kbGVyKFwiX2NhcHR1cmVTY3JvbGxcIiwgb2JqKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUJvdHRvbVVwU2Nyb2xsV2hlZWxIYW5kbGVyKFwiX2hhbmRsZVNjcm9sbFwiLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlyZVRvcERvd25TY3JvbGxXaGVlbEhhbmRsZXIoZXZlbnQsIG9iaikge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmNoaWxkcmVuO1xuICAgICAgICBsZXQgYWZmZWN0ZWQgPSB0aGlzLl9maW5kQ2hpbGRyZW4oW10sIGNoaWxkcmVuKS5yZXZlcnNlKCk7XG4gICAgICAgIGxldCBuID0gYWZmZWN0ZWQubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlKG4tLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBhZmZlY3RlZFtuXTtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZFtldmVudF0pIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5fY2FwdHVyZVNjcm9sbChvYmopO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZmlyZUJvdHRvbVVwU2Nyb2xsV2hlZWxIYW5kbGVyKGV2ZW50LCBvYmopIHtcbiAgICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gb2JqO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRUYXJnZXRDaGlsZChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGFyZ2V0O1xuXG4gICAgICAgIC8vIFNlYXJjaCB0cmVlIGJvdHRvbSB1cCBmb3IgYSBoYW5kbGVyXG4gICAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9oYW5kbGVTY3JvbGwob2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfcmVjZWl2ZUNsaWNrKGUpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gZTtcbiAgICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gb2JqO1xuXG4gICAgICAgIGlmIChjbGllbnRYIDw9IHRoaXMuc3RhZ2UudyAmJiBjbGllbnRZIDw9IHRoaXMuc3RhZ2UuaCkge1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hcHBsaWNhdGlvbi5maXJlQm90dG9tVXBDbGlja0hhbmRsZXIob2JqKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpcmVCb3R0b21VcENsaWNrSGFuZGxlcihvYmopIHtcbiAgICAgICAgY29uc3Qge2NsaWVudFgsIGNsaWVudFl9ID0gb2JqO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9nZXRUYXJnZXRDaGlsZChjbGllbnRYLCBjbGllbnRZKTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGFyZ2V0O1xuXG4gICAgICAgIC8vIFNlYXJjaCB0cmVlIGJvdHRvbSB1cCBmb3IgYSBoYW5kbGVyXG4gICAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkW1wiX2hhbmRsZUNsaWNrXCJdKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuX2hhbmRsZUNsaWNrKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLnBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZWNlaXZlSG92ZXIoZSkge1xuICAgICAgICBjb25zdCBvYmogPSBlO1xuICAgICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBvYmo7XG5cbiAgICAgICAgaWYgKGNsaWVudFggPD0gdGhpcy5zdGFnZS53ICYmIGNsaWVudFkgPD0gdGhpcy5zdGFnZS5oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uLmZpcmVCb3R0b21VcEhvdmVySGFuZGxlcihvYmopO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmlyZUJvdHRvbVVwSG92ZXJIYW5kbGVyKG9iaikge1xuICAgICAgICBjb25zdCB7Y2xpZW50WCwgY2xpZW50WX0gPSBvYmo7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldFRhcmdldENoaWxkKGNsaWVudFgsIGNsaWVudFkpO1xuXG4gICAgICAgIC8vIE9ubHkgZmlyZSBoYW5kbGVycyB3aGVuIHBvaW50ZXIgdGFyZ2V0IGNoYW5nZXNcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdGhpcy5fX2hvdmVyZWRDaGlsZCkge1xuXG4gICAgICAgICAgICBsZXQgaG92ZXJlZEJyYW5jaCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGxldCBuZXdIb3ZlcmVkQnJhbmNoID0gbmV3IFNldCgpO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbmV3SG92ZXJlZEJyYW5jaCA9IG5ldyBTZXQodGFyZ2V0LmdldEFuY2VzdG9ycygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX19ob3ZlcmVkQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICBob3ZlcmVkQnJhbmNoID0gbmV3IFNldCh0aGlzLl9faG92ZXJlZENoaWxkLmdldEFuY2VzdG9ycygpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgWy4uLmhvdmVyZWRCcmFuY2hdLmZpbHRlcigoZSkgPT4gIW5ld0hvdmVyZWRCcmFuY2guaGFzKGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjID0gQ29tcG9uZW50LmdldENvbXBvbmVudChlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNbXCJfaGFuZGxlVW5ob3ZlclwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5faGFuZGxlVW5ob3ZlcihlbGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbS5wYXJlbnQgJiYgZWxlbS5wYXJlbnQuY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9IGVsZW0ucGFyZW50LmN1cnNvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2hvdmVyZWRDaGlsZCA9IHRhcmdldDtcblxuICAgICAgICAgICAgY29uc3QgZGlmZkJyYW5jaCA9IFsuLi5uZXdIb3ZlcmVkQnJhbmNoXS5maWx0ZXIoKGUpID0+ICFob3ZlcmVkQnJhbmNoLmhhcyhlKSlcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBkaWZmQnJhbmNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQoZWxlbSk7XG4gICAgICAgICAgICAgICAgaWYgKGNbXCJfaGFuZGxlSG92ZXJcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgYy5faGFuZGxlSG92ZXIoZWxlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBOZXcgZWxlbWVudCBob3ZlciBjdXJzb3JcbiAgICAgICAgICAgIGNvbnN0IGxhc3RFbGVtZW50ID0gZGlmZkJyYW5jaFswXTtcbiAgICAgICAgICAgIGlmIChsYXN0RWxlbWVudCAmJiBsYXN0RWxlbWVudC5jdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmdldENhbnZhcygpLnN0eWxlLmN1cnNvciA9IGxhc3RFbGVtZW50LmN1cnNvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVydW4gX2hhbmRsZUhvdmVyIGZvciB0YXJnZXQgZWxlbWVudCBpbiBjYXNlIGl0J3MgYmVlbiBob3ZlcmVkXG4gICAgICAgICAgICAvLyBiYWNrIGZyb20gaXRzIGNoaWxkXG4gICAgICAgICAgICBpZiAoZGlmZkJyYW5jaC5sZW5ndGggPT09IDAgJiYgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IENvbXBvbmVudC5nZXRDb21wb25lbnQodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoY1tcIl9oYW5kbGVIb3ZlclwiXSkge1xuICAgICAgICAgICAgICAgICAgICBjLl9oYW5kbGVIb3Zlcih0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUYXJnZXRDaGlsZChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuc3RhZ2UuYXBwbGljYXRpb24uY2hpbGRyZW47XG4gICAgICAgIGxldCBhZmZlY3RlZCA9IHRoaXMuX2ZpbmRDaGlsZHJlbihbXSwgY2hpbGRyZW4pO1xuICAgICAgICBsZXQgaG92ZXJhYmxlQ2hpbGRyZW4gPSB0aGlzLl93aXRoaW5DbGlja2FibGVSYW5nZShhZmZlY3RlZCwgY2xpZW50WCwgY2xpZW50WSk7XG5cbiAgICAgICAgaG92ZXJhYmxlQ2hpbGRyZW4uc29ydCgoYSxiKSA9PiB7XG4gICAgICAgICAgICAvLyBTb3J0IGJ5IHpJbmRleCBhbmQgdGhlbiBpZFxuICAgICAgICAgICAgaWYgKGEuekluZGV4ID4gYi56SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYS56SW5kZXggPCBiLnpJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuaWQgPiBiLmlkID8gMTogLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChob3ZlcmFibGVDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSB0YXJnZXQgaGFzIGhpZ2hlc3QgekluZGV4IChpZCB3aGVuIHpJbmRleCBlcXVhbClcbiAgICAgICAgICAgIHJldHVybiBob3ZlcmFibGVDaGlsZHJlbi5zbGljZSgtMSlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9maW5kQ2hpbGRyZW4oYnVja2V0LCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltuXTtcbiAgICAgICAgICAgIC8vIG9ubHkgYWRkIGFjdGl2ZSBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKGNoaWxkLl9fYWN0aXZlICYmIGNoaWxkLmNvbGxpc2lvbikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5jb2xsaXNpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5kQ2hpbGRyZW4oYnVja2V0LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWNrZXQ7XG4gICAgfVxuXG4gICAgX3dpdGhpbkNsaWNrYWJsZVJhbmdlKGFmZmVjdGVkQ2hpbGRyZW4sIGN1cnNvclgsIGN1cnNvclkpIHtcbiAgICAgICAgbGV0IG4gPSBhZmZlY3RlZENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhZmZlY3RlZCBjaGlsZHJlblxuICAgICAgICAvLyBhbmQgcGVyZm9ybSBjb2xsaXNpb24gZGV0ZWN0aW9uXG4gICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gYWZmZWN0ZWRDaGlsZHJlbltuXTtcbiAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjaGlsZC5jb3JlLl93b3JsZENvbnRleHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGN4ID0gY3R4LnB4ICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgY29uc3QgY3kgPSBjdHgucHkgKiBwcmVjaXNpb247XG4gICAgICAgICAgICBjb25zdCBjdyA9IGNoaWxkLmZpbmFsVyAqIGN0eC50YSAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gY2hpbGQuZmluYWxIICogY3R4LnRkICogcHJlY2lzaW9uO1xuXG4gICAgICAgICAgICBpZiAoY3ggPiB0aGlzLnN0YWdlLncgfHwgY3kgPiB0aGlzLnN0YWdlLmgpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudC5jb3JlLl9zY2lzc29yKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Npc3NvciA9IGNoaWxkLnBhcmVudC5jb3JlLl9zY2lzc29yLm1hcCgodikgPT4gdiAqIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXN0Q29sbGlzaW9uKGN1cnNvclgsIGN1cnNvclksIC4uLnNjaXNzb3IpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGVzdENvbGxpc2lvbihjdXJzb3JYLCBjdXJzb3JZLCBjeCwgY3ksIGN3LCBjaCkpIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVzO1xuICAgIH1cblxuICAgIF90ZXN0Q29sbGlzaW9uKHB4LCBweSwgY3gsIGN5LCBjdywgY2gpIHtcbiAgICAgICAgaWYgKHB4ID49IGN4ICYmXG4gICAgICAgICAgICBweCA8PSBjeCArIGN3ICYmXG4gICAgICAgICAgICBweSA+PSBjeSAmJlxuICAgICAgICAgICAgcHkgPD0gY3kgKyBjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVGhpcyBmb3JjZXMgdGhlIF9kZXRhY2gsIF9kaXNhYmxlZCBhbmQgX2FjdGl2ZSBldmVudHMgdG8gYmUgY2FsbGVkLlxuICAgICAgICB0aGlzLnN0YWdlLnNldEFwcGxpY2F0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaGVkRmxhZygpO1xuICAgICAgICB0aGlzLl91cGRhdGVFbmFibGVkRmxhZygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9fa2V5cHJlc3NUaW1lcnMuc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLl9fa2V5cHJlc3NUaW1lcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9fa2V5cHJlc3NUaW1lcnMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENhbnZhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhZ2UuZ2V0Q2FudmFzKCk7XG4gICAgfVxuXG59XG5cbmltcG9ydCBTdGFnZSBmcm9tIFwiLi4vdHJlZS9TdGFnZS5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuLi90cmVlL0VsZW1lbnQubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgU3RhdGVNYWNoaW5lIGZyb20gXCIuL1N0YXRlTWFjaGluZS5tanNcIjtcblxuLyoqXG4gKiBAZXh0ZW5kcyBTdGF0ZU1hY2hpbmVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50IGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSwgcHJvcGVydGllcykge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgLy8gRW5jYXBzdWxhdGUgdGFncyB0byBwcmV2ZW50IGxlYWtpbmcuXG4gICAgICAgIHRoaXMudGFnUm9vdCA9IHRydWU7XG5cbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9fZmlyc3RBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fX2ZpcnN0RW5hYmxlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fX3NpZ25hbHMgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgdGhpcy5fX3Bhc3NTaWduYWxzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuX19jb25zdHJ1Y3QoKTtcblxuICAgICAgICAvLyBRdWljay1hcHBseSB0ZW1wbGF0ZS5cbiAgICAgICAgY29uc3QgZnVuYyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0VGVtcGxhdGVGdW5jKHRoaXMpO1xuICAgICAgICBmdW5jLmYodGhpcywgZnVuYy5hKTtcblxuICAgICAgICB0aGlzLl9idWlsZCgpO1xuICAgIH1cblxuICAgIF9fc3RhcnQoKSB7XG4gICAgICAgIFN0YXRlTWFjaGluZS5zZXR1cFN0YXRlTWFjaGluZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fb25TdGF0ZUNoYW5nZSA9IENvbXBvbmVudC5wcm90b3R5cGUuX19vblN0YXRlQ2hhbmdlO1xuICAgIH1cblxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7XG4gICAgfVxuXG4gICAgX19vblN0YXRlQ2hhbmdlKCkge1xuICAgICAgICAvKiBGSVhNRTogV29ya2Fyb3VuZCBmb3IgY2FzZSwgd2hlcmUgYXBwbGljYXRpb24gd2FzIHNodXQgYnV0IGNvbXBvbmVudCBzdGlsbCBsaXZlcyAqL1xuICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi51cGRhdGVGb2N1c1BhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZWZvY3VzKCkge1xuICAgICAgICAvKiBGSVhNRTogV29ya2Fyb3VuZCBmb3IgY2FzZSwgd2hlcmUgYXBwbGljYXRpb24gd2FzIHNodXQgYnV0IGNvbXBvbmVudCBzdGlsbCBsaXZlcyAqL1xuICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi51cGRhdGVGb2N1c1BhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBiaW5kUHJvcChuYW1lLCBmdW5jID0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge19fcHJvcGVydHlCaW5kaW5nOiB0cnVlLCBfX25hbWU6IG5hbWUsIF9fZnVuYzogZnVuY307XG4gICAgfVxuXG4gICAgX19iaW5kUHJvcGVydHkocHJvcE9iaiwgdGFyZ2V0T2JqLCB0YXJnZXRQcm9wKSB7XG4gICAgICAgIC8vIDEuIGZpbmQgYmluZGluZyBwb3NpdGlvbjogZmluZCBvYmplY3QgYW5kIHByb3BlcnR5IG5hbWUgdG8gYmUgYm91bmRcbiAgICAgICAgY29uc3Qgb2JqID0gdGFyZ2V0T2JqO1xuICAgICAgICBjb25zdCBwcm9wID0gdGFyZ2V0UHJvcDtcbiAgICAgICAgY29uc3QgcHJvcERlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkocHJvcE9iai5fX25hbWUpID8gcHJvcE9iai5fX25hbWUgOiBbcHJvcE9iai5fX25hbWVdO1xuXG4gICAgICAgIC8vIDIuIGNyZWF0ZSBzZXR0ZXJzIGZvciBldmVyeSBnaXZlbiBkZXBlbmRlbmN5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcERlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSBwcm9wRGVwZW5kZW5jaWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IHByb3BPYmouX19mdW5jID8gcHJvcE9iai5fX2Z1bmMgOiAoY29udGV4dCkgPT4gY29udGV4dFtwcm9wTmFtZV07XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2BfX3Byb3BfYmluZGluZ3NfJHtwcm9wTmFtZX1gXSA9IFt7X19vYmo6IG9iaiwgX19wcm9wOiBwcm9wLCBfX2Z1bmM6IGZ1bmN9XTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbYF9fcHJvcF8ke3Byb3BOYW1lfWBdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHtfX29iaiwgX19wcm9wLCBfX2Z1bmN9IG9mIHRoaXNbYF9fcHJvcF9iaW5kaW5nc18ke3Byb3BOYW1lfWBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19vYmpbX19wcm9wXSA9IF9fZnVuYyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB0aGlzW2BfX3Byb3BfJHtwcm9wTmFtZX1gXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW2BfX3Byb3BfYmluZGluZ3NfJHtwcm9wTmFtZX1gXS5wdXNoKHtfX29iajogb2JqLCBfX3Byb3A6IHByb3AsIF9fZnVuYzogZnVuY30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGhpZ2gtcGVyZm9ybWFuY2UgdGVtcGxhdGUgcGF0Y2hlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VGVtcGxhdGVGdW5jKGN0eCkge1xuICAgICAgICAvLyBXZSBuZWVkIGEgZGlmZmVyZW50IHRlbXBsYXRlIGZ1bmN0aW9uIHBlciBwYXRjaCBpZC5cbiAgICAgICAgY29uc3QgbmFtZSA9IFwiX3RlbXBsYXRlRnVuY1wiO1xuXG4gICAgICAgIC8vIEJlIGNhcmVmdWwgd2l0aCBjbGFzcy1iYXNlZCBzdGF0aWMgaW5oZXJpdGFuY2UuXG4gICAgICAgIGNvbnN0IGhhc05hbWUgPSAnX19oYXMnICsgbmFtZTtcbiAgICAgICAgaWYgKHRoaXNbaGFzTmFtZV0gIT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXNbaGFzTmFtZV0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh0aGlzLl90ZW1wbGF0ZShjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tuYW1lXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2VUZW1wbGF0ZShvYmopIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGxvYzogW10sXG4gICAgICAgICAgICBzdG9yZTogW10sXG4gICAgICAgICAgICByaWQ6IDBcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhcnNlVGVtcGxhdGVSZWMob2JqLCBjb250ZXh0LCBcImVsZW1lbnRcIik7XG5cbiAgICAgICAgY29uc3QgY29kZSA9IGNvbnRleHQubG9jLmpvaW4oXCI7XFxuXCIpO1xuICAgICAgICBjb25zdCBmID0gbmV3IEZ1bmN0aW9uKFwiZWxlbWVudFwiLCBcInN0b3JlXCIsIGNvZGUpO1xuICAgICAgICByZXR1cm4ge2Y6IGYsIGE6IGNvbnRleHQuc3RvcmV9O1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZVRlbXBsYXRlUmVjKG9iaiwgY29udGV4dCwgY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gY29udGV4dC5zdG9yZTtcbiAgICAgICAgY29uc3QgbG9jID0gY29udGV4dC5sb2M7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzVWNDaGFyKGtleS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIC8vIFZhbHVlIG11c3QgYmUgZXhwYW5kZWQgYXMgd2VsbC5cbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWYuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3Vyc29yID0gYHIke2tleS5yZXBsYWNlKC9bXmEtejAtOV0vZ2ksIFwiXCIpICsgY29udGV4dC5yaWR9YDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHR5cGUgPSB2YWx1ZS50eXBlID8gdmFsdWUudHlwZSA6IEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgdmFyICR7Y2hpbGRDdXJzb3J9ID0gZWxlbWVudC5zdGFnZS5jcmVhdGVFbGVtZW50KClgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgdmFyICR7Y2hpbGRDdXJzb3J9ID0gbmV3IHN0b3JlWyR7c3RvcmUubGVuZ3RoIC0gMX1dKCR7Y3Vyc29yfS5zdGFnZSlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjaGlsZEN1cnNvcn0ucmVmID0gXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJpZCsrO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVudGVyIHN1Yi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVRlbXBsYXRlUmVjKHZhbHVlLCBjb250ZXh0LCBjaGlsZEN1cnNvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfS5jaGlsZExpc3QuYWRkKCR7Y2hpbGRDdXJzb3J9KWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIER5bmFtaWMgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn0uY2hpbGRMaXN0LmFkZChzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XSlgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BLZXkgPSBjdXJzb3IgKyBcIl9fdGV4dFwiO1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgdmFyICR7cHJvcEtleX0gPSAke2N1cnNvcn0uZW5hYmxlVGV4dFRleHR1cmUoKWApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuX19wcm9wZXJ0eUJpbmRpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGJpbmRpbmcgZW50aXJlIG9iamVjdHMgdG8gdGV4dCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgZWxlbWVudC5fX2JpbmRQcm9wZXJ0eShzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XSwgJHtjdXJzb3J9LCBcIiR7a2V5fVwiKWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVRlbXBsYXRlUHJvcFJlYyh2YWx1ZSwgY29udGV4dCwgcHJvcEtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzaGFkZXJcIiAmJiBVdGlscy5pc09iamVjdExpdGVyYWwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoYWRlckN1cnNvciA9IGAke2N1cnNvcn1bXCJzaGFkZXJcIl1gXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5QmluZGluZ3ModmFsdWUsIGNvbnRleHQsIHNoYWRlckN1cnNvcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwidGV4dHVyZVwiICYmIFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcEtleSA9IGN1cnNvciArIFwiX190ZXh0dXJlXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGB2YXIgJHtwcm9wS2V5fSA9IG5ldyBzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XSgke2N1cnNvcn0uc3RhZ2UpYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVGVtcGxhdGVQcm9wUmVjKHZhbHVlLCBjb250ZXh0LCBwcm9wS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSAke3Byb3BLZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtwcm9wS2V5fSA9ICR7Y3Vyc29yfS50ZXh0dXJlYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlVGVtcGxhdGVQcm9wUmVjKHZhbHVlLCBjb250ZXh0LCBwcm9wS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHZhbHVlKSAmJiB2YWx1ZS5fX3Byb3BlcnR5QmluZGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYGVsZW1lbnQuX19iaW5kUHJvcGVydHkoc3RvcmVbJHtzdG9yZS5sZW5ndGggLSAxfV0sICR7Y3Vyc29yfSwgXCIke2tleX1cIilgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9ICR7dmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jLnB1c2goYCR7Y3Vyc29yfVtcIiR7a2V5fVwiXSA9ICR7dmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdCh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIER5bmFtaWMgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgbGl0ZXJhbCBvYmplY3RzIG1heSBjb250YWluIGR5bmFtaWNzLCB3ZSBzdG9yZSB0aGUgZnVsbCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSBzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XWApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RyaW5nIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHBhcnNlVGVtcGxhdGVQcm9wUmVjKG9iaiwgY29udGV4dCwgY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gY29udGV4dC5zdG9yZTtcbiAgICAgICAgY29uc3QgbG9jID0gY29udGV4dC5sb2M7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSAke3ZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgJHtjdXJzb3J9W1wiJHtrZXl9XCJdID0gJHt2YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwifWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLl9fcHJvcGVydHlCaW5kaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgZWxlbWVudC5fX2JpbmRQcm9wZXJ0eShzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XSwgJHtjdXJzb3J9LCBcIiR7a2V5fVwiKWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIER5bmFtaWMgYXNzaWdubWVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSBsaXRlcmFsIG9iamVjdHMgbWF5IGNvbnRhaW4gZHluYW1pY3MsIHdlIHN0b3JlIHRoZSBmdWxsIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSBzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmluZyBldGMuXG4gICAgICAgICAgICAgICAgICAgIGxvYy5wdXNoKGAke2N1cnNvcn1bXCIke2tleX1cIl0gPSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXJzZVByb3BlcnR5QmluZGluZ3Mob2JqLCBjb250ZXh0LCBjdXJzb3IpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBjb250ZXh0LnN0b3JlO1xuICAgICAgICBjb25zdCBsb2MgPSBjb250ZXh0LmxvYztcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodmFsdWUpICYmIHZhbHVlLl9fcHJvcGVydHlCaW5kaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsb2MucHVzaChgZWxlbWVudC5fX2JpbmRQcm9wZXJ0eShzdG9yZVske3N0b3JlLmxlbmd0aCAtIDF9XSwgJHtjdXJzb3J9LCBcIiR7a2V5fVwiKWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX29uU2V0dXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldHVwKCkge1xuICAgIH1cblxuICAgIF9vbkF0dGFjaCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19pbml0KCk7XG4gICAgICAgICAgICB0aGlzLl9faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXR0YWNoKCk7XG4gICAgfVxuXG4gICAgX2F0dGFjaCgpIHtcbiAgICB9XG5cbiAgICBfb25EZXRhY2goKSB7XG4gICAgICAgIHRoaXMuX2RldGFjaCgpO1xuICAgIH1cblxuICAgIF9kZXRhY2goKSB7XG4gICAgfVxuXG4gICAgX29uRW5hYmxlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZmlyc3RFbmFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0RW5hYmxlKCk7XG4gICAgICAgICAgICB0aGlzLl9fZmlyc3RFbmFibGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZW5hYmxlKCk7XG4gICAgfVxuXG4gICAgX2ZpcnN0RW5hYmxlKCkge1xuICAgIH1cblxuICAgIF9lbmFibGUoKSB7XG4gICAgfVxuXG4gICAgX29uRGlzYWJsZWQoKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGUoKTtcbiAgICB9XG5cbiAgICBfZGlzYWJsZSgpIHtcbiAgICB9XG5cbiAgICBfb25BY3RpdmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2ZpcnN0QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdEFjdGl2ZSgpO1xuICAgICAgICAgICAgdGhpcy5fX2ZpcnN0QWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FjdGl2ZSgpO1xuICAgIH1cblxuICAgIF9maXJzdEFjdGl2ZSgpIHtcbiAgICB9XG5cbiAgICBfYWN0aXZlKCkge1xuICAgIH1cblxuICAgIF9vbkluYWN0aXZlKCkge1xuICAgICAgICB0aGlzLl9pbmFjdGl2ZSgpO1xuICAgIH1cblxuICAgIF9pbmFjdGl2ZSgpIHtcbiAgICB9XG5cbiAgICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWdlLmFwcGxpY2F0aW9uO1xuICAgIH1cblxuICAgIF9fY29uc3RydWN0KCkge1xuICAgICAgICB0aGlzLl9jb25zdHJ1Y3QoKTtcbiAgICB9XG5cbiAgICBfY29uc3RydWN0KCkge1xuICAgIH1cblxuICAgIF9idWlsZCgpIHtcbiAgICB9XG5cbiAgICBfX2luaXQoKSB7XG4gICAgICAgIHRoaXMuX2luaXQoKTtcbiAgICB9XG5cbiAgICBfaW5pdCgpIHtcbiAgICB9XG5cbiAgICBfZm9jdXMobmV3VGFyZ2V0LCBwcmV2VGFyZ2V0KSB7XG4gICAgfVxuXG4gICAgX3VuZm9jdXMobmV3VGFyZ2V0KSB7XG4gICAgfVxuXG4gICAgX2ZvY3VzQ2hhbmdlKHRhcmdldCwgbmV3VGFyZ2V0KSB7XG4gICAgfVxuXG4gICAgX2dldEZvY3VzZWQoKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRvIGRlbGVnYXRlIGZvY3VzIHRvIGNoaWxkIGNvbXBvbmVudHMuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIF9zZXRGb2N1c1NldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRvIGFkZCBjdXN0b20gc2V0dGluZ3MuIFNlZSBBcHBsaWNhdGlvbi5faGFuZGxlRm9jdXNTZXR0aW5ncygpLlxuICAgIH1cblxuICAgIF9oYW5kbGVGb2N1c1NldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRvIHJlYWN0IG9uIGN1c3RvbSBzZXR0aW5ncy4gU2VlIEFwcGxpY2F0aW9uLl9oYW5kbGVGb2N1c1NldHRpbmdzKCkuXG4gICAgfVxuXG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGhhc0ZpbmFsRm9jdXMoKSB7XG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5hcHBsaWNhdGlvbi5fZm9jdXNQYXRoO1xuICAgICAgICByZXR1cm4gcGF0aCAmJiBwYXRoLmxlbmd0aCAmJiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IHRoaXM7XG4gICAgfVxuXG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIGxldCBwYXRoID0gdGhpcy5hcHBsaWNhdGlvbi5fZm9jdXNQYXRoO1xuICAgICAgICByZXR1cm4gcGF0aCAmJiAocGF0aC5pbmRleE9mKHRoaXMpID49IDApO1xuICAgIH1cblxuICAgIGdldCBjcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50LmdldFBhcmVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBzZWVrQW5jZXN0b3JCeVR5cGUodHlwZSkge1xuICAgICAgICBsZXQgYyA9IHRoaXMuY3BhcmVudDtcbiAgICAgICAgd2hpbGUgKGMpIHtcbiAgICAgICAgICAgIGlmIChjLmNvbnN0cnVjdG9yID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjID0gYy5jcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2hhcmVkQW5jZXN0b3JDb21wb25lbnQoZWxlbWVudCkge1xuICAgICAgICBsZXQgYW5jZXN0b3IgPSB0aGlzLmdldFNoYXJlZEFuY2VzdG9yKGVsZW1lbnQpO1xuICAgICAgICB3aGlsZSAoYW5jZXN0b3IgJiYgIWFuY2VzdG9yLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuXG4gICAgZ2V0IHNpZ25hbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fc2lnbmFscztcbiAgICB9XG5cbiAgICBzZXQgc2lnbmFscyh2KSB7XG4gICAgICAgIGlmICghVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiU2lnbmFsczogc3BlY2lmeSBhbiBvYmplY3Qgd2l0aCBzaWduYWwtdG8tZmlyZSBtYXBwaW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fc2lnbmFscyA9IHY7XG4gICAgfVxuXG4gICAgc2V0IGFsdGVyU2lnbmFscyh2KSB7XG4gICAgICAgIGlmICghVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiU2lnbmFsczogc3BlY2lmeSBhbiBvYmplY3Qgd2l0aCBzaWduYWwtdG8tZmlyZSBtYXBwaW5nc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX19zaWduYWxzKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2lnbmFscyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB2KSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdltrZXldO1xuICAgICAgICAgICAgaWYgKGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fc2lnbmFsc1trZXldO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fc2lnbmFsc1trZXldID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwYXNzU2lnbmFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19wYXNzU2lnbmFscyB8fCB7fTtcbiAgICB9XG5cbiAgICBzZXQgcGFzc1NpZ25hbHModikge1xuICAgICAgICB0aGlzLl9fcGFzc1NpZ25hbHMgPSBPYmplY3QuYXNzaWduKHRoaXMuX19wYXNzU2lnbmFscyB8fCB7fSwgdik7XG4gICAgfVxuXG4gICAgc2V0IGFsdGVyUGFzc1NpZ25hbHModikge1xuICAgICAgICBpZiAoIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlNpZ25hbHM6IHNwZWNpZnkgYW4gb2JqZWN0IHdpdGggc2lnbmFsLXRvLWZpcmUgbWFwcGluZ3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9fcGFzc1NpZ25hbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX19wYXNzU2lnbmFscyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB2KSB7XG4gICAgICAgICAgICBjb25zdCBkID0gdltrZXldO1xuICAgICAgICAgICAgaWYgKGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9fcGFzc1NpZ25hbHNba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3Bhc3NTaWduYWxzW2tleV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2lnbmFscyB0aGUgcGFyZW50IG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAgICogQSBwYXJlbnQvYW5jZXN0b3IgdGhhdCB3aXNoZXMgdG8gaGFuZGxlIHRoZSBzaWduYWwgc2hvdWxkIHNldCB0aGUgJ3NpZ25hbHMnIHByb3BlcnR5IG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJnc1xuICAgICAqL1xuICAgIHNpZ25hbChldmVudCwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmFsKGV2ZW50LCBhcmdzKTtcbiAgICB9XG5cbiAgICBfc2lnbmFsKGV2ZW50LCBhcmdzKSB7XG4gICAgICAgIGNvbnN0IHNpZ25hbFBhcmVudCA9IHRoaXMuX2dldFBhcmVudFNpZ25hbEhhbmRsZXIoKTtcbiAgICAgICAgaWYgKHNpZ25hbFBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX19zaWduYWxzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcmVFdmVudCA9IHRoaXMuX19zaWduYWxzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyZUV2ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXZlbnQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpcmVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyZUV2ZW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbihmaXJlRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmlyZUV2ZW50KC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbFBhcmVudC5faGFzTWV0aG9kKGZpcmVFdmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduYWxQYXJlbnRbZmlyZUV2ZW50XSguLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHBhc3NTaWduYWwgPSAodGhpcy5fX3Bhc3NTaWduYWxzICYmIHRoaXMuX19wYXNzU2lnbmFsc1tldmVudF0pO1xuICAgICAgICAgICAgaWYgKHBhc3NTaWduYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBCdWJibGUgdXAuXG4gICAgICAgICAgICAgICAgaWYgKHBhc3NTaWduYWwgJiYgcGFzc1NpZ25hbCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHNpZ25hbCBuYW1lLlxuICAgICAgICAgICAgICAgICAgICBldmVudCA9IHBhc3NTaWduYWw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hbFBhcmVudC5fc2lnbmFsKGV2ZW50LCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRQYXJlbnRTaWduYWxIYW5kbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcGFyZW50ID8gdGhpcy5jcGFyZW50Ll9nZXRTaWduYWxIYW5kbGVyKCkgOiBudWxsO1xuICAgIH1cblxuICAgIF9nZXRTaWduYWxIYW5kbGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fc2lnbmFsUHJveHkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNwYXJlbnQgPyB0aGlzLmNwYXJlbnQuX2dldFNpZ25hbEhhbmRsZXIoKSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZpcmVBbmNlc3RvcnMobmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbmNlc3RvciBldmVudCBuYW1lIG11c3QgYmUgcHJlZml4ZWQgYnkgZG9sbGFyIHNpZ24uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50U2lnbmFsSGFuZGxlcigpO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Ll9kb0ZpcmVBbmNlc3RvcnMobmFtZSwgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZG9GaXJlQW5jZXN0b3JzKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hhc01ldGhvZChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyZShuYW1lLCAuLi5hcmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hbFBhcmVudCA9IHRoaXMuX2dldFBhcmVudFNpZ25hbEhhbmRsZXIoKTtcbiAgICAgICAgICAgIGlmIChzaWduYWxQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmFsUGFyZW50Ll9kb0ZpcmVBbmNlc3RvcnMobmFtZSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY29sbGVjdFN1YkNvbXBvbmVudHMoc3VicywgZWxlbWVudCkge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZExpc3QgPSBlbGVtZW50Ll9fY2hpbGRMaXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjaGlsZExpc3QubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZExpc3QuZ2V0QXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnMucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50LmNvbGxlY3RTdWJDb21wb25lbnRzKHN1YnMsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Q29tcG9uZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIXBhcmVudC5pc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRQYXJlbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gQ29tcG9uZW50LmdldENvbXBvbmVudChlbGVtZW50LnBhcmVudCk7XG4gICAgfVxufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzQ29tcG9uZW50ID0gdHJ1ZTtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlTWFjaGluZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgU3RhdGVNYWNoaW5lLnNldHVwU3RhdGVNYWNoaW5lKHRoaXMpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXR1cFN0YXRlTWFjaGluZSh0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IFN0YXRlTWFjaGluZS5jcmVhdGUodGFyZ2V0Q29uc3RydWN0b3IpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGFyZ2V0LCByb3V0ZXIucHJvdG90eXBlKTtcbiAgICAgICAgdGFyZ2V0LmNvbnN0cnVjdG9yID0gdGFyZ2V0Q29uc3RydWN0b3I7XG4gICAgICAgIHRhcmdldC5faW5pdFN0YXRlTWFjaGluZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGF0ZSBtYWNoaW5lIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEl0IGV4dGVuZHMgdGhlIG9yaWdpbmFsIHR5cGUgYW5kIHNob3VsZCBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgbmV3IGluc3RhbmNlcy5cbiAgICAgKiBUaGUgb3JpZ2luYWwgdHlwZSBpcyBhdmFpbGFibGUgYXMgc3RhdGljIHByb3BlcnR5ICdvcmlnaW5hbCcsIGFuZCBpdCBtdXN0IGJlIHVzZWQgd2hlbiBzdWJjbGFzc2luZyBhcyBmb2xsb3dzOlxuICAgICAqIGNvbnN0IHR5cGUgPSBTdGF0ZU1hY2hpbmUuY3JlYXRlKGNsYXNzIFlvdXJOZXdTdGF0ZU1hY2hpbmVDbGFzcyBleHRlbmRzIFlvdXJCYXNlU3RhdGVNYWNoaW5lQ2xhc3Mub3JpZ2luYWwgeyAgfSlcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSB0eXBlXG4gICAgICogQHJldHVybnMge1N0YXRlTWFjaGluZX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKHR5cGUpIHtcbiAgICAgICAgaWYgKCF0eXBlLmhhc093blByb3BlcnR5KCdfc20nKSkge1xuICAgICAgICAgICAgLy8gT25seSBuZWVkIHRvIHJ1biBvbmNlLlxuICAgICAgICAgICAgY29uc3Qgc3RhdGVNYWNoaW5lVHlwZSA9IG5ldyBTdGF0ZU1hY2hpbmVUeXBlKHR5cGUpO1xuICAgICAgICAgICAgdHlwZS5fc20gPSBzdGF0ZU1hY2hpbmVUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHR5cGUuX3NtLnJvdXRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgc3BlY2lmaWVkIG1ldGhvZCBpZiBpdCBleGlzdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAgICogQHBhcmFtIHsqLi4ufSBhcmdzXG4gICAgICovXG4gICAgZmlyZShldmVudCwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5faGFzTWV0aG9kKGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbZXZlbnRdKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0ZSBwYXRoIChmb3IgZXhhbXBsZSBcIkluaXRpYWxpemVkLkxvYWRpbmdcIikuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2dldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuX19wYXRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZmYgc3RhdGVQYXRoIGlzIChhbiBhbmNlc3RvciBvZikgY3VycmVudFN0YXRlUGF0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGVQYXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRTdGF0ZVBhdGhcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luU3RhdGUoc3RhdGVQYXRoLCBjdXJyZW50U3RhdGVQYXRoID0gdGhpcy5fc3RhdGUuX19wYXRoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc20uZ2V0U3RhdGVCeVBhdGgoc3RhdGVQYXRoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5fc20uZ2V0U3RhdGVCeVBhdGgoY3VycmVudFN0YXRlUGF0aCk7XG4gICAgICAgIGNvbnN0IGxldmVsID0gc3RhdGUuX19sZXZlbDtcbiAgICAgICAgY29uc3Qgc3RhdGVBdExldmVsID0gU3RhdGVNYWNoaW5lLl9nZXRTdGF0ZUF0TGV2ZWwoY3VycmVudFN0YXRlLCBsZXZlbCk7XG4gICAgICAgIHJldHVybiAoc3RhdGVBdExldmVsID09PSBzdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgY2xhc3MgbWVtYmVyIGlzIGRlZmluZWQgZm9yIHRoZSBjdXJyZW50bHkgc2V0IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNNZW1iZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtuYW1lXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBjbGFzcyBtZW1iZXIgaXMgYSBtZXRob2QgZm9yIHRoZSBjdXJyZW50bHkgc2V0IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNNZXRob2QobmFtZSkge1xuICAgICAgICBjb25zdCBtZW1iZXIgPSB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgcmV0dXJuICEhbWVtYmVyICYmICh0eXBlb2YgbWVtYmVyID09PSBcImZ1bmN0aW9uXCIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgdG8gdGhlIHNwZWNpZmllZCBzdGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdGVQYXRoXG4gICAgICogICBTdWJzdGF0ZXMgYXJlIHNlcGVyYXRlZCBieSBhIHVuZGVyc2NvcmVzIChmb3IgZXhhbXBsZSBcIkluaXRpYWxpemVkLkxvYWRpbmdcIikuXG4gICAgICogQHBhcmFtIHsqW119IFthcmdzXVxuICAgICAqICAgQXJncyB0aGF0IGFyZSBzdXBwbGllZCBpbiAkZW50ZXIgYW5kICRleGl0IGV2ZW50cy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldFN0YXRlKHN0YXRlUGF0aCwgYXJncykge1xuICAgICAgICBjb25zdCBzZXRTdGF0ZUlkID0gKyt0aGlzLl9zZXRTdGF0ZUNvdW50ZXI7XG4gICAgICAgIHRoaXMuX3NldFN0YXRlSWQgPSBzZXRTdGF0ZUlkO1xuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5fX3BhdGggIT09IHN0YXRlUGF0aCkge1xuICAgICAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlID0gdGhpcy5fc20uX3N0YXRlTWFwW3N0YXRlUGF0aF07XG4gICAgICAgICAgICBpZiAoIW5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIHN1cGVyIHN0YXRlLlxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpcy5fc20uZ2V0U3RhdGVCeVBhdGgoc3RhdGVQYXRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5fc3RhdGU7XG5cbiAgICAgICAgICAgIGNvbnN0IGhhc0RpZmZlcmVudEVudGVyTWV0aG9kID0gKG5ld1N0YXRlLnByb3RvdHlwZS4kZW50ZXIgIT09IHRoaXMuX3N0YXRlLnByb3RvdHlwZS4kZW50ZXIpO1xuICAgICAgICAgICAgY29uc3QgaGFzRGlmZmVyZW50RXhpdE1ldGhvZCA9IChuZXdTdGF0ZS5wcm90b3R5cGUuJGV4aXQgIT09IHRoaXMuX3N0YXRlLnByb3RvdHlwZS4kZXhpdCk7XG4gICAgICAgICAgICBpZiAoaGFzRGlmZmVyZW50RW50ZXJNZXRob2QgfHwgaGFzRGlmZmVyZW50RXhpdE1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXJlZFN0YXRlID0gU3RhdGVNYWNoaW5lLl9nZXRTaGFyZWRTdGF0ZSh0aGlzLl9zdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlOiBuZXdTdGF0ZS5fX3BhdGgsXG4gICAgICAgICAgICAgICAgICAgIHByZXZTdGF0ZTogcHJldlN0YXRlLl9fcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgc2hhcmVkU3RhdGU6IHNoYXJlZFN0YXRlLl9fcGF0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkTGV2ZWwgPSBzaGFyZWRTdGF0ZS5fX2xldmVsO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0RpZmZlcmVudEV4aXRNZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpdFN0YXRlcyA9IFN0YXRlTWFjaGluZS5fZ2V0U3RhdGVzVW50aWxMZXZlbCh0aGlzLl9zdGF0ZSwgc2hhcmVkTGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGV4aXRTdGF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fc2V0U3RhdGUoZXhpdFN0YXRlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsRXhpdCh0aGlzLl9zdGF0ZSwgYXJncywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZUNoYW5nZU92ZXJyaWRkZW4gPSAodGhpcy5fc2V0U3RhdGVJZCAhPT0gc2V0U3RhdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVDaGFuZ2VPdmVycmlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0RpZmZlcmVudEVudGVyTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudGVyU3RhdGVzID0gU3RhdGVNYWNoaW5lLl9nZXRTdGF0ZXNVbnRpbExldmVsKG5ld1N0YXRlLCBzaGFyZWRMZXZlbCkucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGVudGVyU3RhdGVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3NldFN0YXRlKGVudGVyU3RhdGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxFbnRlcih0aGlzLl9zdGF0ZSwgYXJncywgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZUNoYW5nZU92ZXJyaWRkZW4gPSAodGhpcy5fc2V0U3RhdGVJZCAhPT0gc2V0U3RhdGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVDaGFuZ2VPdmVycmlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX19zZXRTdGF0ZShuZXdTdGF0ZSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBuZXdTdGF0ZTogbmV3U3RhdGUuX19wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwcmV2U3RhdGU6IHByZXZTdGF0ZS5fX3BhdGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFN0YXRlKGNvbnRleHQsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRTdGF0ZShjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vblN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhdGU6IG5ld1N0YXRlLl9fcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcHJldlN0YXRlOiBwcmV2U3RhdGUuX19wYXRoXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN0YXRlQ2hhbmdlKGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsbEVudGVyKHN0YXRlLCBhcmdzID0gW10sIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgaGFzUGFyZW50ID0gISFzdGF0ZS5fX3BhcmVudDtcbiAgICAgICAgaWYgKHN0YXRlLnByb3RvdHlwZS4kZW50ZXIpIHtcbiAgICAgICAgICAgIGlmICghaGFzUGFyZW50IHx8IChzdGF0ZS5fX3BhcmVudC5wcm90b3R5cGUuJGVudGVyICE9PSBzdGF0ZS5wcm90b3R5cGUuJGVudGVyKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnByb3RvdHlwZS4kZW50ZXIuYXBwbHkodGhpcywgW2NvbnRleHQsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYWxsRXhpdChzdGF0ZSwgYXJncyA9IFtdLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGhhc1BhcmVudCA9ICEhc3RhdGUuX19wYXJlbnQ7XG4gICAgICAgIGlmIChzdGF0ZS5wcm90b3R5cGUuJGV4aXQpIHtcbiAgICAgICAgICAgIGlmICghaGFzUGFyZW50IHx8IChzdGF0ZS5fX3BhcmVudC5wcm90b3R5cGUuJGV4aXQgIT09IHN0YXRlLnByb3RvdHlwZS4kZXhpdCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcm90b3R5cGUuJGV4aXQuYXBwbHkodGhpcywgW2NvbnRleHQsIC4uLmFyZ3NdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5fc3RhdGVJbmRleCA9IHN0YXRlLl9faW5kZXg7XG4gICAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBzdGF0ZTtcbiAgICB9XG5cbiAgICBfaW5pdFN0YXRlTWFjaGluZSgpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGF0ZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGVDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc20gPSB0aGlzLl9yb3V0ZWRUeXBlLl9zbTtcbiAgICAgICAgdGhpcy5fX3NldFN0YXRlKHRoaXMuX3NtLmdldFN0YXRlQnlQYXRoKFwiXCIpKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtuZXdTdGF0ZTogXCJcIiwgcHJldlN0YXRlOiB1bmRlZmluZWQsIHNoYXJlZFN0YXRlOiB1bmRlZmluZWR9O1xuICAgICAgICB0aGlzLl9jYWxsRW50ZXIodGhpcy5fc3RhdGUsIFtdLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fb25TdGF0ZUNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCZXR3ZWVuIG11bHRpcGxlIG1lbWJlciBuYW1lcywgc2VsZWN0IHRoZSBvbmUgc3BlY2lmaWVkIGluIHRoZSBkZWVwZXN0IHN0YXRlLlxuICAgICAqIElmIG11bHRpcGxlIG1lbWJlciBuYW1lcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBzYW1lIGRlZXBlc3Qgc3RhdGUsIHRoZSBmaXJzdCBvbmUgaW4gdGhlIGFycmF5IGlzIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG1lbWJlck5hbWVzXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9nZXRNb3N0U3BlY2lmaWNIYW5kbGVkTWVtYmVyKG1lbWJlck5hbWVzKSB7XG4gICAgICAgIGxldCBjdXIgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBtZW1iZXJOYW1lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZW1iZXJOYW1lID0gbWVtYmVyTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFjdXIuX19wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5wcm90b3R5cGVbbWVtYmVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZW1iZXJOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBTdGF0ZU1hY2hpbmVUeXBlLmdldFN0YXRlTWVtYmVyQWxpYXMoY3VyLl9fcGF0aCwgbWVtYmVyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2FsaWFzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lbWJlck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBjdXIuX19wYXJlbnQ7XG4gICAgICAgIH0gd2hpbGUgKGN1cik7XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRTdGF0ZXNVbnRpbExldmVsKHN0YXRlLCBsZXZlbCkge1xuICAgICAgICBjb25zdCBzdGF0ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHN0YXRlLl9fbGV2ZWwgPiBsZXZlbCkge1xuICAgICAgICAgICAgc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS5fX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0U2hhcmVkU3RhdGUoc3RhdGUxLCBzdGF0ZTIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUxQXJyYXkgPSBTdGF0ZU1hY2hpbmUuX2dldEFuY2VzdG9yU3RhdGVzKHN0YXRlMSk7XG4gICAgICAgIGNvbnN0IHN0YXRlMkFycmF5ID0gU3RhdGVNYWNoaW5lLl9nZXRBbmNlc3RvclN0YXRlcyhzdGF0ZTIpO1xuICAgICAgICBjb25zdCBuID0gTWF0aC5taW4oc3RhdGUxQXJyYXkubGVuZ3RoLCBzdGF0ZTJBcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YXRlMUFycmF5W2ldICE9PSBzdGF0ZTJBcnJheVtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTFBcnJheVtpIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlMUFycmF5W24gLSAxXTtcbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldEFuY2VzdG9yU3RhdGVzKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGF0ZSk7XG4gICAgICAgIH0gd2hpbGUoc3RhdGUgPSBzdGF0ZS5fX3BhcmVudCk7XG4gICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0U3RhdGVBdExldmVsKHN0YXRlLCBsZXZlbCkge1xuICAgICAgICBpZiAobGV2ZWwgPiBzdGF0ZS5fX2xldmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUobGV2ZWwgPCBzdGF0ZS5fX2xldmVsKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLl9fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5cbmNsYXNzIFN0YXRlTWFjaGluZVR5cGUge1xuXG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBnZXQgcm91dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91dGVyO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuX3JvdXRlciA9IHRoaXMuX2NyZWF0ZVJvdXRlcigpO1xuXG4gICAgICAgIHRoaXMuX3N0YXRlTWFwID0gdGhpcy5fZ2V0U3RhdGVNYXAoKTtcblxuICAgICAgICB0aGlzLl9hZGRTdGF0ZU1lbWJlckRlbGVnYXRvcnNUb1JvdXRlcigpO1xuXG4gICAgfVxuXG4gICAgX2NyZWF0ZVJvdXRlcigpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuX3R5cGU7XG5cbiAgICAgICAgY29uc3Qgcm91dGVyID0gY2xhc3MgU3RhdGVNYWNoaW5lUm91dGVyIGV4dGVuZHMgdHlwZSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eSgnX2lzUm91dGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbmVlZCB0byBleHRlbmQgJHt0eXBlLm5hbWV9Lm9yaWdpbmFsIGluc3RlYWQgb2YgJHt0eXBlLm5hbWV9LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcm91dGVyLl9pc1JvdXRlciA9IHRydWU7XG4gICAgICAgIHJvdXRlci5wcm90b3R5cGUuX3JvdXRlZFR5cGUgPSB0eXBlO1xuICAgICAgICByb3V0ZXIub3JpZ2luYWwgPSB0eXBlO1xuXG4gICAgICAgIHRoaXMuX21peGluU3RhdGVNYWNoaW5lTWV0aG9kcyhyb3V0ZXIpO1xuXG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfVxuXG4gICAgX21peGluU3RhdGVNYWNoaW5lTWV0aG9kcyhyb3V0ZXIpIHtcbiAgICAgICAgLy8gTWl4aW4gdGhlIHN0YXRlIG1hY2hpbmUgbWV0aG9kcywgc28gdGhhdCB3ZSByZXVzZSB0aGUgbWV0aG9kcyBpbnN0ZWFkIG9mIHJlLWNyZWF0aW5nIHRoZW0uXG4gICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3RhdGVNYWNoaW5lLnByb3RvdHlwZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbmFtZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU3RhdGVNYWNoaW5lLnByb3RvdHlwZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJvdXRlci5wcm90b3R5cGUsIG5hbWUsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FkZFN0YXRlTWVtYmVyRGVsZWdhdG9yc1RvUm91dGVyKCkge1xuICAgICAgICBjb25zdCBtZW1iZXJzID0gdGhpcy5fZ2V0QWxsTWVtYmVyTmFtZXMoKTtcblxuICAgICAgICBtZW1iZXJzLmZvckVhY2gobWVtYmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lbWJlclJvdXRlcihtZW1iZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbm90ZSBXZSBhcmUgZ2VuZXJhdGluZyBjb2RlIGJlY2F1c2UgaXQgeWllbGRzIG11Y2ggYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAqL1xuICAgIF9hZGRNZW1iZXJSb3V0ZXIobWVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlUGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLl9zdGF0ZU1hcCk7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gW107XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSBbXTtcbiAgICAgICAgc3RhdGVQYXRocy5mb3JFYWNoKChzdGF0ZVBhdGgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlTWFwW3N0YXRlUGF0aF07XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5fZ2V0RGVzY3JpcHRvcihzdGF0ZSwgbWVtYmVyKTtcbiAgICAgICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNbaW5kZXhdID0gZGVzY3JpcHRvcjtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBwcm90b3R5cGUuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBTdGF0ZU1hY2hpbmVUeXBlLmdldFN0YXRlTWVtYmVyQWxpYXMoZGVzY3JpcHRvci5fc291cmNlLl9fcGF0aCwgbWVtYmVyKTtcbiAgICAgICAgICAgICAgICBhbGlhc2VzW2luZGV4XSA9IGFsaWFzO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXIucHJvdG90eXBlLmhhc093blByb3BlcnR5KGFsaWFzKSkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5fcm91dGVyLnByb3RvdHlwZSwgYWxpYXMsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBhbGlhc2VzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCB0eXBlID0gdW5kZWZpbmVkO1xuICAgICAgICBkZXNjcmlwdG9ycy5mb3JFYWNoKGRlc2NyaXB0b3IgPT4ge1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjVHlwZSA9IHRoaXMuX2dldERlc2NyaXB0b3JUeXBlKGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlICYmICh0eXBlICE9PSBkZXNjVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbTGlnaHRuaW5nXSBNZW1iZXIgJHttZW1iZXJ9IGluICR7dGhpcy5fdHlwZS5uYW1lfSBoYXMgaW5jb25zaXN0ZW50IHR5cGVzLmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGUgPSBkZXNjVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXRob2RcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRNZXRob2RSb3V0ZXIobWVtYmVyLCBkZXNjcmlwdG9ycywgYWxpYXNlcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0dGVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkR2V0dGVyU2V0dGVyUm91dGVycyhtZW1iZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInByb3BlcnR5XCI6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gRml4ZWQgcHJvcGVydGllcyBhcmUgbm90IHN1cHBvcnRlZDsgcGxlYXNlIHVzZSBhIGdldHRlciBpbnN0ZWFkIVwiKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldERlc2NyaXB0b3Ioc3RhdGUsIG1lbWJlciwgaXNWYWxpZCA9ICgpID0+IHRydWUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSBzdGF0ZTtcbiAgICAgICAgbGV0IGN1clN0YXRlID0gc3RhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodHlwZS5wcm90b3R5cGUsIG1lbWJlcik7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuX3NvdXJjZSA9IGN1clN0YXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHR5cGUpO1xuICAgICAgICAgICAgaWYgKHR5cGUgJiYgdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX19zdGF0ZScpKSB7XG4gICAgICAgICAgICAgICAgY3VyU3RhdGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlKHR5cGUgJiYgdHlwZS5wcm90b3R5cGUpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIF9nZXREZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yKSB7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yLmdldCB8fCBkZXNjcmlwdG9yLnNldCkge1xuICAgICAgICAgICAgcmV0dXJuICdnZXR0ZXInO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ21ldGhvZCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAncHJvcGVydHknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIF9zdXBwb3J0c1NwcmVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19zdXBwb3J0c1NwcmVhZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9fc3VwcG9ydHNTcHJlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuYyA9IG5ldyBGdW5jdGlvbihcInJldHVybiBbXS5jb25jYXQoLi4uYXJndW1lbnRzKTtcIik7XG4gICAgICAgICAgICAgICAgZnVuYygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19zdXBwb3J0c1NwcmVhZCA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdXBwb3J0c1NwcmVhZDtcbiAgICB9XG5cbiAgICBfYWRkTWV0aG9kUm91dGVyKG1lbWJlciwgZGVzY3JpcHRvcnMsIGFsaWFzZXMpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IFtcbiAgICAgICAgICAgIC8vIFRoZSBsaW5lIGVuc3VyZXMgdGhhdCwgd2hpbGUgZGVidWdnaW5nLCB5b3VyIElERSB3b24ndCBvcGVuIG1hbnkgdGFicy5cbiAgICAgICAgICAgIFwiLy9AIHNvdXJjZVVSTD1TdGF0ZU1hY2hpbmVSb3V0ZXIuanNcIixcbiAgICAgICAgICAgIFwidmFyIGkgPSB0aGlzLl9zdGF0ZUluZGV4O1wiXG4gICAgICAgIF07XG4gICAgICAgIGxldCBjdXIgPSBhbGlhc2VzWzBdO1xuICAgICAgICBjb25zdCBzdXBwb3J0c1NwcmVhZCA9IFN0YXRlTWFjaGluZVR5cGUuX3N1cHBvcnRzU3ByZWFkKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBuID0gYWxpYXNlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gYWxpYXNlc1tpXTtcbiAgICAgICAgICAgIGlmIChhbGlhcyAhPT0gY3VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNTcHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChgaWYgKGkgPCAke2l9KSByZXR1cm4gdGhpc1tcIiR7Y3VyfVwiXSguLi5hcmd1bWVudHMpOyBlbHNlYCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2goYGlmIChpIDwgJHtpfSkgcmV0dXJuIHRoaXNbXCIke2N1cn1cIl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsgZWxzZWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGBpZiAoaSA8ICR7aX0pIHJldHVybiA7IGVsc2VgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBhbGlhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTcHJlYWQpIHtcbiAgICAgICAgICAgICAgICBjb2RlLnB1c2goYHJldHVybiB0aGlzW1wiJHtjdXJ9XCJdKC4uLmFyZ3VtZW50cyk7YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUucHVzaChgcmV0dXJuIHRoaXNbXCIke2N1cn1cIl0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUucHVzaChgO2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQm9keSA9IGNvZGUuam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc3Qgcm91dGVyID0gbmV3IEZ1bmN0aW9uKFtdLCBmdW5jdGlvbkJvZHkpO1xuXG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7dmFsdWU6IHJvdXRlcn07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLl9yb3V0ZXIucHJvdG90eXBlLCBtZW1iZXIsIGRlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIF9hZGRHZXR0ZXJTZXR0ZXJSb3V0ZXJzKG1lbWJlcikge1xuICAgICAgICBjb25zdCBnZXR0ZXIgPSB0aGlzLl9nZXRHZXR0ZXJSb3V0ZXIobWVtYmVyKTtcbiAgICAgICAgY29uc3Qgc2V0dGVyID0gdGhpcy5fZ2V0U2V0dGVyUm91dGVyKG1lbWJlcik7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBnZXQ6IGdldHRlcixcbiAgICAgICAgICAgIHNldDogc2V0dGVyXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLl9yb3V0ZXIucHJvdG90eXBlLCBtZW1iZXIsIGRlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIF9nZXRHZXR0ZXJSb3V0ZXIobWVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlUGF0aHMgPSBPYmplY3Qua2V5cyh0aGlzLl9zdGF0ZU1hcCk7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gW107XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSBbXTtcbiAgICAgICAgc3RhdGVQYXRocy5mb3JFYWNoKChzdGF0ZVBhdGgsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlTWFwW3N0YXRlUGF0aF07XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy5fZ2V0RGVzY3JpcHRvcihzdGF0ZSwgbWVtYmVyLCAoZGVzY3JpcHRvciA9PiBkZXNjcmlwdG9yLmdldCkpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1tpbmRleF0gPSBkZXNjcmlwdG9yO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHByb3RvdHlwZS5cbiAgICAgICAgICAgICAgICBjb25zdCBhbGlhcyA9IFN0YXRlTWFjaGluZVR5cGUuZ2V0U3RhdGVNZW1iZXJBbGlhcyhkZXNjcmlwdG9yLl9zb3VyY2UuX19wYXRoLCBtZW1iZXIpO1xuICAgICAgICAgICAgICAgIGFsaWFzZXNbaW5kZXhdID0gYWxpYXM7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3JvdXRlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLl9yb3V0ZXIucHJvdG90eXBlLCBhbGlhcywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgICAgIGFsaWFzZXNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29kZSA9IFtcbiAgICAgICAgICAgIC8vIFRoZSBsaW5lIGVuc3VyZXMgdGhhdCwgd2hpbGUgZGVidWdnaW5nLCB5b3VyIElERSB3b24ndCBvcGVuIG1hbnkgdGFicy5cbiAgICAgICAgICAgIFwiLy9AIHNvdXJjZVVSTD1TdGF0ZU1hY2hpbmVSb3V0ZXIuanNcIixcbiAgICAgICAgICAgIFwidmFyIGkgPSB0aGlzLl9zdGF0ZUluZGV4O1wiXG4gICAgICAgIF07XG4gICAgICAgIGxldCBjdXIgPSBhbGlhc2VzWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMSwgbiA9IGFsaWFzZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhbGlhcyA9IGFsaWFzZXNbaV07XG4gICAgICAgICAgICBpZiAoYWxpYXMgIT09IGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGBpZiAoaSA8ICR7aX0pIHJldHVybiB0aGlzW1wiJHtjdXJ9XCJdOyBlbHNlYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5wdXNoKGBpZiAoaSA8ICR7aX0pIHJldHVybiA7IGVsc2VgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBhbGlhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goYHJldHVybiB0aGlzW1wiJHtjdXJ9XCJdO2ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29kZS5wdXNoKGA7YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25Cb2R5ID0gY29kZS5qb2luKFwiXFxuXCIpO1xuICAgICAgICBjb25zdCByb3V0ZXIgPSBuZXcgRnVuY3Rpb24oW10sIGZ1bmN0aW9uQm9keSk7XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfVxuXG4gICAgX2dldFNldHRlclJvdXRlcihtZW1iZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVQYXRocyA9IE9iamVjdC5rZXlzKHRoaXMuX3N0YXRlTWFwKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxpYXNlcyA9IFtdO1xuICAgICAgICBzdGF0ZVBhdGhzLmZvckVhY2goKHN0YXRlUGF0aCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGVNYXBbc3RhdGVQYXRoXTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLl9nZXREZXNjcmlwdG9yKHN0YXRlLCBtZW1iZXIsIChkZXNjcmlwdG9yID0+IGRlc2NyaXB0b3Iuc2V0KSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzW2luZGV4XSA9IGRlc2NyaXB0b3I7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gcHJvdG90eXBlLlxuICAgICAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gU3RhdGVNYWNoaW5lVHlwZS5nZXRTdGF0ZU1lbWJlckFsaWFzKGRlc2NyaXB0b3IuX3NvdXJjZS5fX3BhdGgsIG1lbWJlcik7XG4gICAgICAgICAgICAgICAgYWxpYXNlc1tpbmRleF0gPSBhbGlhcztcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcm91dGVyLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShhbGlhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuX3JvdXRlci5wcm90b3R5cGUsIGFsaWFzLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3JzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYWxpYXNlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb2RlID0gW1xuICAgICAgICAgICAgLy8gVGhlIGxpbmUgZW5zdXJlcyB0aGF0LCB3aGlsZSBkZWJ1Z2dpbmcsIHlvdXIgSURFIHdvbid0IG9wZW4gbWFueSB0YWJzLlxuICAgICAgICAgICAgXCIvL0Agc291cmNlVVJMPVN0YXRlTWFjaGluZVJvdXRlci5qc1wiLFxuICAgICAgICAgICAgXCJ2YXIgaSA9IHRoaXMuX3N0YXRlSW5kZXg7XCJcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGN1ciA9IGFsaWFzZXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxLCBuID0gYWxpYXNlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFsaWFzID0gYWxpYXNlc1tpXTtcbiAgICAgICAgICAgIGlmIChhbGlhcyAhPT0gY3VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cikge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLnB1c2goYGlmIChpIDwgJHtpfSkgdGhpc1tcIiR7Y3VyfVwiXSA9IGFyZzsgZWxzZWApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUucHVzaChgaWYgKGkgPCAke2l9KSA7IGVsc2VgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBhbGlhcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goYHRoaXNbXCIke2N1cn1cIl0gPSBhcmc7YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goYDtgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbkJvZHkgPSBjb2RlLmpvaW4oXCJcXG5cIik7XG4gICAgICAgIGNvbnN0IHJvdXRlciA9IG5ldyBGdW5jdGlvbihbXCJhcmdcIl0sIGZ1bmN0aW9uQm9keSk7XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFN0YXRlTWVtYmVyQWxpYXMocGF0aCwgbWVtYmVyKSB7XG4gICAgICAgIHJldHVybiBcIiRcIiArIChwYXRoID8gcGF0aCArIFwiLlwiIDogXCJcIikgKyBtZW1iZXI7XG4gICAgfVxuXG4gICAgX2dldEFsbE1lbWJlck5hbWVzKCkge1xuICAgICAgICBjb25zdCBzdGF0ZU1hcCA9IHRoaXMuX3N0YXRlTWFwO1xuICAgICAgICBjb25zdCBtYXAgPSBPYmplY3Qua2V5cyhzdGF0ZU1hcCk7XG4gICAgICAgIGxldCBtZW1iZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBtYXAuZm9yRWFjaChzdGF0ZVBhdGggPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlUGF0aCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIC8vIFJvb3Qgc3RhdGUgY2FuIGJlIHNraXBwZWQ6IGlmIHRoZSBtZXRob2Qgb25seSBvY2N1cnMgaW4gdGhlIHJvb3Qgc3RhdGUsIHdlIGRvbid0IG5lZWQgdG8gcmUtZGVsZWdhdGUgaXQgYmFzZWQgb24gc3RhdGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdGF0ZU1hcFtzdGF0ZVBhdGhdO1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSB0aGlzLl9nZXRTdGF0ZU1lbWJlck5hbWVzKHN0YXRlKTtcbiAgICAgICAgICAgIG5hbWVzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgbWVtYmVycy5hZGQobmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5tZW1iZXJzXTtcbiAgICB9XG5cbiAgICBfZ2V0U3RhdGVNZW1iZXJOYW1lcyhzdGF0ZSkge1xuICAgICAgICBsZXQgdHlwZSA9IHN0YXRlO1xuICAgICAgICBsZXQgbWVtYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgaXNSb290ID0gdGhpcy5fdHlwZSA9PT0gc3RhdGU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5fZ2V0U3RhdGVNZW1iZXJOYW1lc0ZvclR5cGUodHlwZSk7XG4gICAgICAgICAgICBuYW1lcy5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIG1lbWJlcnMuYWRkKG5hbWUpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0eXBlKTtcbiAgICAgICAgfSB3aGlsZSh0eXBlICYmIHR5cGUucHJvdG90eXBlICYmICghdHlwZS5oYXNPd25Qcm9wZXJ0eShcIl9fc3RhdGVcIikgfHwgaXNSb290KSk7XG5cbiAgICAgICAgcmV0dXJuIG1lbWJlcnM7XG4gICAgfVxuXG4gICAgX2dldFN0YXRlTWVtYmVyTmFtZXNGb3JUeXBlKHR5cGUpIHtcbiAgICAgICAgY29uc3QgbWVtYmVyTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0eXBlLnByb3RvdHlwZSk7XG4gICAgICAgIHJldHVybiBtZW1iZXJOYW1lcy5maWx0ZXIobWVtYmVyTmFtZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKG1lbWJlck5hbWUgIT09IFwiY29uc3RydWN0b3JcIikgJiYgIVN0YXRlTWFjaGluZVR5cGUuX2lzU3RhdGVMb2NhbE1lbWJlcihtZW1iZXJOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIF9pc1N0YXRlTG9jYWxNZW1iZXIobWVtYmVyTmFtZSkge1xuICAgICAgICByZXR1cm4gKG1lbWJlck5hbWUgPT09IFwiJGVudGVyXCIpIHx8IChtZW1iZXJOYW1lID09PSBcIiRleGl0XCIpO1xuICAgIH1cblxuICAgIGdldFN0YXRlQnlQYXRoKHN0YXRlUGF0aCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGVNYXBbc3RhdGVQYXRoXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlTWFwW3N0YXRlUGF0aF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWFyY2ggZm9yIGNsb3Nlc3QgbWF0Y2guXG4gICAgICAgIGNvbnN0IHBhcnRzID0gc3RhdGVQYXRoLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgd2hpbGUocGFydHMucG9wKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlUGF0aCA9IHBhcnRzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlTWFwW3N0YXRlUGF0aF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVNYXBbc3RhdGVQYXRoXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRTdGF0ZU1hcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGF0ZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVNYXAgPSB0aGlzLl9jcmVhdGVTdGF0ZU1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZU1hcDtcbiAgICB9XG5cbiAgICBfY3JlYXRlU3RhdGVNYXAoKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlTWFwID0ge307XG4gICAgICAgIHRoaXMuX2FkZFN0YXRlKHRoaXMuX3R5cGUsIG51bGwsIFwiXCIsIHN0YXRlTWFwKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlTWFwO1xuICAgIH1cblxuICAgIF9hZGRTdGF0ZShzdGF0ZSwgcGFyZW50U3RhdGUsIG5hbWUsIHN0YXRlTWFwKSB7XG4gICAgICAgIHN0YXRlLl9fc3RhdGUgPSB0cnVlO1xuICAgICAgICBzdGF0ZS5fX25hbWUgPSBuYW1lO1xuXG4gICAgICAgIHRoaXMuX2FkZFN0YXRpY1N0YXRlUHJvcGVydHkoc3RhdGUsIHBhcmVudFN0YXRlKTtcblxuICAgICAgICBjb25zdCBwYXJlbnRQYXRoID0gKHBhcmVudFN0YXRlID8gcGFyZW50U3RhdGUuX19wYXRoIDogXCJcIik7XG4gICAgICAgIGxldCBwYXRoID0gKHBhcmVudFBhdGggPyBwYXJlbnRQYXRoICsgXCIuXCIgOiBcIlwiKSArIG5hbWU7XG4gICAgICAgIHN0YXRlLl9fcGF0aCA9IHBhdGg7XG4gICAgICAgIHN0YXRlLl9fbGV2ZWwgPSBwYXJlbnRTdGF0ZSA/IHBhcmVudFN0YXRlLl9fbGV2ZWwgKyAxIDogMDtcbiAgICAgICAgc3RhdGUuX19wYXJlbnQgPSBwYXJlbnRTdGF0ZTtcbiAgICAgICAgc3RhdGUuX19pbmRleCA9IE9iamVjdC5rZXlzKHN0YXRlTWFwKS5sZW5ndGg7XG4gICAgICAgIHN0YXRlTWFwW3BhdGhdID0gc3RhdGU7XG5cbiAgICAgICAgY29uc3Qgc3RhdGVzID0gc3RhdGUuX3N0YXRlcztcbiAgICAgICAgaWYgKHN0YXRlcykge1xuICAgICAgICAgICAgY29uc3QgaXNJbmhlcml0ZWRGcm9tUGFyZW50ID0gKHBhcmVudFN0YXRlICYmIHBhcmVudFN0YXRlLl9zdGF0ZXMgPT09IHN0YXRlcyk7XG4gICAgICAgICAgICBpZiAoIWlzSW5oZXJpdGVkRnJvbVBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YlN0YXRlcyA9IHN0YXRlLl9zdGF0ZXMoKTtcbiAgICAgICAgICAgICAgICBzdWJTdGF0ZXMuZm9yRWFjaChzdWJTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlTmFtZSA9IFN0YXRlTWFjaGluZVR5cGUuX2dldFN0YXRlTmFtZShzdWJTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZFN0YXRlKHN1YlN0YXRlLCBzdGF0ZSwgc3RhdGVOYW1lLCBzdGF0ZU1hcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFN0YXRlTmFtZShzdGF0ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gc3RhdGUubmFtZTtcblxuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWUuaW5kZXhPZignJCcpO1xuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAvLyBTdHJpcCBvZmYgcm9sbHVwIG5hbWUgc3VmZml4LlxuICAgICAgICAgICAgcmV0dXJuIG5hbWUuc3Vic3RyKDAsIGluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIF9hZGRTdGF0aWNTdGF0ZVByb3BlcnR5KHN0YXRlLCBwYXJlbnRTdGF0ZSkge1xuICAgICAgICBpZiAocGFyZW50U3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ2xhc3NTdGF0ZUxldmVsID0gcGFyZW50U3RhdGUgJiYgIXBhcmVudFN0YXRlLl9fcGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzQ2xhc3NTdGF0ZUxldmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcm91dGVyW3N0YXRlLl9fbmFtZV0gPSBzdGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyZW50U3RhdGVbc3RhdGUuX19uYW1lXSA9IHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuLi9hcHBsaWNhdGlvbi9Db21wb25lbnQubWpzXCI7XG5pbXBvcnQgTGluZWFyQmx1clNoYWRlciBmcm9tIFwiLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9MaW5lYXJCbHVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEJveEJsdXJTaGFkZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvQm94Qmx1clNoYWRlci5tanNcIjtcbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJsb29tQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICAgIGNvbnN0IG9uVXBkYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgZWxlbWVudENvcmUpIHtcbiAgICAgICAgICAgIGlmICgoZWxlbWVudENvcmUuX3JlY2FsYyAmICgyICsgMTI4KSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gZWxlbWVudENvcmUudztcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gZWxlbWVudENvcmUuaDtcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gZWxlbWVudENvcmU7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBjdXIuX2NoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgICAgICBjdXIuX2VsZW1lbnQudyA9IHc7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5fZWxlbWVudC5oID0gaDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlKGN1ci5fY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBUZXh0d3JhcDoge3J0dDogdHJ1ZSwgZm9yY2VaSW5kZXhDb250ZXh0OiB0cnVlLCByZW5kZXJPZmZzY3JlZW46IHRydWUsXG4gICAgICAgICAgICAgICAgQmxvb21CYXNlOiB7c2hhZGVyOiB7dHlwZTogQmxvb21CYXNlU2hhZGVyfSxcbiAgICAgICAgICAgICAgICAgICAgQ29udGVudDoge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTGF5ZXJzOiB7XG4gICAgICAgICAgICAgICAgTDA6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgc2NhbGU6IDIsIHBpdm90OiAwLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX0sXG4gICAgICAgICAgICAgICAgTDE6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgc2NhbGU6IDQsIHBpdm90OiAwLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX0sXG4gICAgICAgICAgICAgICAgTDI6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgc2NhbGU6IDgsIHBpdm90OiAwLCB2aXNpYmxlOiBmYWxzZSwgQ29udGVudDoge3NoYWRlcjoge3R5cGU6IEJveEJsdXJTaGFkZXJ9fX0sXG4gICAgICAgICAgICAgICAgTDM6IHtydHQ6IHRydWUsIG9uVXBkYXRlOiBvblVwZGF0ZSwgc2NhbGU6IDE2LCBwaXZvdDogMCwgdmlzaWJsZTogZmFsc2UsIENvbnRlbnQ6IHtzaGFkZXI6IHt0eXBlOiBCb3hCbHVyU2hhZGVyfX19XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwID0gdGhpcy5zZWwoXCJUZXh0d3JhcFwiKTtcbiAgICAgICAgdGhpcy5fd3JhcHBlciA9IHRoaXMuc2VsKFwiVGV4dHdyYXAuQ29udGVudFwiKTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gdGhpcy5zZWwoXCJMYXllcnNcIik7XG5cbiAgICAgICAgdGhpcy5fYW1vdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IDA7XG4gICAgfVxuXG4gICAgX2J1aWxkKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXJTaGFkZXJTZXR0aW5ncyA9IFt7eDoxLHk6MCxrZXJuZWxSYWRpdXM6M30se3g6MCx5OjEsa2VybmVsUmFkaXVzOjN9LHt4OjEuNSx5OjAsa2VybmVsUmFkaXVzOjN9LHt4OjAseToxLjUsa2VybmVsUmFkaXVzOjN9XTtcbiAgICAgICAgY29uc3QgZmlsdGVyU2hhZGVycyA9IGZpbHRlclNoYWRlclNldHRpbmdzLm1hcChzID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IHRoaXMuc3RhZ2UuY3JlYXRlU2hhZGVyKE9iamVjdC5hc3NpZ24oe3R5cGU6IExpbmVhckJsdXJTaGFkZXJ9LCBzKSk7XG4gICAgICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDApLCB0aGlzLl90ZXh0d3JhcC5nZXRUZXh0dXJlKCksIFtdKTtcbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygxKSwgdGhpcy5nZXRMYXllcigwKS5nZXRUZXh0dXJlKCksIFtmaWx0ZXJTaGFkZXJzWzBdLCBmaWx0ZXJTaGFkZXJzWzFdXSk7XG5cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgMS41IGZpbHRlcnMgc2hvdWxkIGJlIGFwcGxpZWQgYmVmb3JlIDEuMCBmaWx0ZXJzLlxuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDIpLCB0aGlzLmdldExheWVyKDEpLmdldFRleHR1cmUoKSwgW2ZpbHRlclNoYWRlcnNbMF0sIGZpbHRlclNoYWRlcnNbMV0sIGZpbHRlclNoYWRlcnNbMl0sIGZpbHRlclNoYWRlcnNbM11dKTtcbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygzKSwgdGhpcy5nZXRMYXllcigyKS5nZXRUZXh0dXJlKCksIFtmaWx0ZXJTaGFkZXJzWzBdLCBmaWx0ZXJTaGFkZXJzWzFdLCBmaWx0ZXJTaGFkZXJzWzJdLCBmaWx0ZXJTaGFkZXJzWzNdXSk7XG4gICAgfVxuXG4gICAgX3NldExheWVyVGV4dHVyZShlbGVtZW50LCB0ZXh0dXJlLCBzdGVwcykge1xuICAgICAgICBpZiAoIXN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwcy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudC5zdGFnZS5jKHtydHQ6IHRydWUsIHNoYWRlcjogc3RlcH0pO1xuXG4gICAgICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKGNoaWxkLCB0ZXh0dXJlLCBzdGVwcyk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRMaXN0LmFkZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbCgnVGV4dHdyYXAuQ29udGVudCcpO1xuICAgIH1cblxuICAgIHNldCBjb250ZW50KHYpIHtcbiAgICAgICAgdGhpcy5zZWwoJ1RleHR3cmFwLkNvbnRlbnQnKS5wYXRjaCh2KTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZyh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWCh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1kodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgZ2V0TGF5ZXIoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzLnNlbChcIkxcIiArIGkpO1xuICAgIH1cblxuICAgIGdldExheWVyQ29udGVudHMoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcihpKS5zZWwoXCJDb250ZW50XCIpO1xuICAgIH1cblxuICAgIF9vblJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQmx1clNpemUoKSB7XG4gICAgICAgIGxldCB3ID0gdGhpcy5yZW5kZXJXaWR0aDtcbiAgICAgICAgbGV0IGggPSB0aGlzLnJlbmRlckhlaWdodDtcblxuICAgICAgICBsZXQgcGFkZGluZ1ggPSB0aGlzLl9wYWRkaW5nWDtcbiAgICAgICAgbGV0IHBhZGRpbmdZID0gdGhpcy5fcGFkZGluZ1k7XG5cbiAgICAgICAgbGV0IGZ3ID0gdyArIHBhZGRpbmdYICogMjtcbiAgICAgICAgbGV0IGZoID0gaCArIHBhZGRpbmdZICogMjtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAudyA9IGZ3O1xuICAgICAgICB0aGlzLl93cmFwcGVyLnggPSBwYWRkaW5nWDtcbiAgICAgICAgdGhpcy5nZXRMYXllcigwKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDApLncgPSBmdyAvIDI7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMSkudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygxKS53ID0gZncgLyA0O1xuICAgICAgICB0aGlzLmdldExheWVyKDIpLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMikudyA9IGZ3IC8gODtcbiAgICAgICAgdGhpcy5nZXRMYXllcigzKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDMpLncgPSBmdyAvIDE2O1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC54ID0gLXBhZGRpbmdYO1xuXG4gICAgICAgIHRoaXMuX3RleHR3cmFwLmggPSBmaDtcbiAgICAgICAgdGhpcy5fd3JhcHBlci55ID0gcGFkZGluZ1k7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMCkuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygwKS5oID0gZmggLyAyO1xuICAgICAgICB0aGlzLmdldExheWVyKDEpLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMSkuaCA9IGZoIC8gNDtcbiAgICAgICAgdGhpcy5nZXRMYXllcigyKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDIpLmggPSBmaCAvIDg7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMykuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygzKS5oID0gZmggLyAxNjtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAueSA9IC1wYWRkaW5nWTtcblxuICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICB0aGlzLmggPSBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFtb3VudCBvZiBibHVyLiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgNC4gR29lcyB1cCBleHBvbmVudGlhbGx5IGZvciBibHVyLlxuICAgICAqIEJlc3QgcmVzdWx0cyBmb3Igbm9uLWZyYWN0aW9uYWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB2O1xuICAgICAqL1xuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50O1xuICAgIH1cblxuICAgIF91cGRhdGUoKSB7XG4gICAgICAgIGxldCB2ID0gTWF0aC5taW4oNCwgTWF0aC5tYXgoMCwgdGhpcy5fYW1vdW50KSk7XG4gICAgICAgIGlmICh2ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigwKS52aXNpYmxlID0gKHYgPiAwKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMSkudmlzaWJsZSA9ICh2ID4gMSk7XG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDIpLnZpc2libGUgPSAodiA+IDIpO1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigzKS52aXNpYmxlID0gKHYgPiAzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBzaGFkZXIocykge1xuICAgICAgICBzdXBlci5zaGFkZXIgPSBzO1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBQbGVhc2UgZW5hYmxlIHJlbmRlclRvVGV4dHVyZSB0byB1c2Ugd2l0aCBhIHNoYWRlci5cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZmlyc3RBY3RpdmUoKSB7XG4gICAgICAgIHRoaXMuX2J1aWxkKCk7XG4gICAgfVxuXG59XG5cbmNsYXNzIEJsb29tQmFzZVNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xufVxuXG5CbG9vbUJhc2VTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgICAgICBmbG9hdCBtID0gbWF4KG1heChjb2xvci5yLCBjb2xvci5nKSwgY29sb3IuYik7XG4gICAgICAgIGZsb2F0IGMgPSBtYXgoMC4wLCAobSAtIDAuODApKSAqIDUuMDtcbiAgICAgICAgY29sb3IgPSBjb2xvciAqIGM7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuLi9hcHBsaWNhdGlvbi9Db21wb25lbnQubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvcmRlckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgQ29udGVudDoge30sXG4gICAgICAgICAgICBCb3JkZXJzOiB7XG4gICAgICAgICAgICAgICAgVG9wOiB7cmVjdDogdHJ1ZSwgdmlzaWJsZTogZmFsc2UsIG1vdW50WTogMX0sXG4gICAgICAgICAgICAgICAgUmlnaHQ6IHtyZWN0OiB0cnVlLCB2aXNpYmxlOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAgQm90dG9tOiB7cmVjdDogdHJ1ZSwgdmlzaWJsZTogZmFsc2V9LFxuICAgICAgICAgICAgICAgIExlZnQ6IHtyZWN0OiB0cnVlLCB2aXNpYmxlOiBmYWxzZSwgbW91bnRYOiAxfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLl9ib3JkZXJUb3AgPSB0aGlzLnRhZyhcIlRvcFwiKTtcbiAgICAgICAgdGhpcy5fYm9yZGVyUmlnaHQgPSB0aGlzLnRhZyhcIlJpZ2h0XCIpO1xuICAgICAgICB0aGlzLl9ib3JkZXJCb3R0b20gPSB0aGlzLnRhZyhcIkJvdHRvbVwiKTtcbiAgICAgICAgdGhpcy5fYm9yZGVyTGVmdCA9IHRoaXMudGFnKFwiTGVmdFwiKTtcblxuICAgICAgICB0aGlzLm9uQWZ0ZXJVcGRhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGVsZW1lbnQuY2hpbGRMaXN0LmZpcnN0O1xuICAgICAgICAgICAgbGV0IHcgPSBlbGVtZW50LmNvcmUudyB8fCBjb250ZW50LnJlbmRlcldpZHRoO1xuICAgICAgICAgICAgbGV0IGggPSBlbGVtZW50LmNvcmUuaCB8fCBjb250ZW50LnJlbmRlckhlaWdodDtcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlclRvcC53ID0gdztcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlckJvdHRvbS55ID0gaDtcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlckJvdHRvbS53ID0gdztcbiAgICAgICAgICAgIGVsZW1lbnQuX2JvcmRlckxlZnQuaCA9IGggKyBlbGVtZW50Ll9ib3JkZXJUb3AuaCArIGVsZW1lbnQuX2JvcmRlckJvdHRvbS5oO1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyTGVmdC55ID0gLWVsZW1lbnQuX2JvcmRlclRvcC5oO1xuICAgICAgICAgICAgZWxlbWVudC5fYm9yZGVyUmlnaHQueCA9IHc7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJSaWdodC5oID0gaCArIGVsZW1lbnQuX2JvcmRlclRvcC5oICsgZWxlbWVudC5fYm9yZGVyQm90dG9tLmg7XG4gICAgICAgICAgICBlbGVtZW50Ll9ib3JkZXJSaWdodC55ID0gLWVsZW1lbnQuX2JvcmRlclRvcC5oO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGggPSAxO1xuICAgIH1cblxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWwoJ0NvbnRlbnQnKTtcbiAgICB9XG5cbiAgICBzZXQgY29udGVudCh2KSB7XG4gICAgICAgIHRoaXMuc2VsKCdDb250ZW50JykucGF0Y2godiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlcldpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3JkZXJXaWR0aFRvcDtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyV2lkdGhUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJUb3AuaDtcbiAgICB9XG5cbiAgICBnZXQgYm9yZGVyV2lkdGhSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlclJpZ2h0Lnc7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlcldpZHRoQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyQm90dG9tLmg7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlcldpZHRoTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckxlZnQudztcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyV2lkdGgodikge1xuICAgICAgICB0aGlzLmJvcmRlcldpZHRoVG9wID0gdjtcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aFJpZ2h0ID0gdjtcbiAgICAgICAgdGhpcy5ib3JkZXJXaWR0aEJvdHRvbSA9IHY7XG4gICAgICAgIHRoaXMuYm9yZGVyV2lkdGhMZWZ0ID0gdjtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyV2lkdGhUb3Aodikge1xuICAgICAgICB0aGlzLl9ib3JkZXJUb3AuaCA9IHY7XG4gICAgICAgIHRoaXMuX2JvcmRlclRvcC52aXNpYmxlID0gKHYgPiAwKTtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyV2lkdGhSaWdodCh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlclJpZ2h0LncgPSB2O1xuICAgICAgICB0aGlzLl9ib3JkZXJSaWdodC52aXNpYmxlID0gKHYgPiAwKTtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyV2lkdGhCb3R0b20odikge1xuICAgICAgICB0aGlzLl9ib3JkZXJCb3R0b20uaCA9IHY7XG4gICAgICAgIHRoaXMuX2JvcmRlckJvdHRvbS52aXNpYmxlID0gKHYgPiAwKTtcbiAgICB9XG5cbiAgICBzZXQgYm9yZGVyV2lkdGhMZWZ0KHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyTGVmdC53ID0gdjtcbiAgICAgICAgdGhpcy5fYm9yZGVyTGVmdC52aXNpYmxlID0gKHYgPiAwKTtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCb3JkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yQm9yZGVyVG9wO1xuICAgIH1cblxuICAgIGdldCBjb2xvckJvcmRlclRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlclRvcC5jb2xvcjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCb3JkZXJSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlclJpZ2h0LmNvbG9yO1xuICAgIH1cblxuICAgIGdldCBjb2xvckJvcmRlckJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvcmRlckJvdHRvbS5jb2xvcjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JCb3JkZXJMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyTGVmdC5jb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCb3JkZXIodikge1xuICAgICAgICB0aGlzLmNvbG9yQm9yZGVyVG9wID0gdjtcbiAgICAgICAgdGhpcy5jb2xvckJvcmRlclJpZ2h0ID0gdjtcbiAgICAgICAgdGhpcy5jb2xvckJvcmRlckJvdHRvbSA9IHY7XG4gICAgICAgIHRoaXMuY29sb3JCb3JkZXJMZWZ0ID0gdjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCb3JkZXJUb3Aodikge1xuICAgICAgICB0aGlzLl9ib3JkZXJUb3AuY29sb3IgPSB2O1xuICAgIH1cblxuICAgIHNldCBjb2xvckJvcmRlclJpZ2h0KHYpIHtcbiAgICAgICAgdGhpcy5fYm9yZGVyUmlnaHQuY29sb3IgPSB2O1xuICAgIH1cblxuICAgIHNldCBjb2xvckJvcmRlckJvdHRvbSh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlckJvdHRvbS5jb2xvciA9IHY7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQm9yZGVyTGVmdCh2KSB7XG4gICAgICAgIHRoaXMuX2JvcmRlckxlZnQuY29sb3IgPSB2O1xuICAgIH1cblxuICAgIGdldCBib3JkZXJUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJUb3A7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlclRvcChzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmJvcmRlclRvcC5wYXRjaChzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlclJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9yZGVyUmlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlclJpZ2h0KHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYm9yZGVyUmlnaHQucGF0Y2goc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGdldCBib3JkZXJCb3R0b20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJCb3R0b207XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlckJvdHRvbShzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmJvcmRlckJvdHRvbS5wYXRjaChzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgZ2V0IGJvcmRlckxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3JkZXJMZWZ0O1xuICAgIH1cblxuICAgIHNldCBib3JkZXJMZWZ0KHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuYm9yZGVyTGVmdC5wYXRjaChzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgc2V0IGJvcmRlcnMoc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5ib3JkZXJUb3AgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5ib3JkZXJMZWZ0ID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuYm9yZGVyQm90dG9tID0gc2V0dGluZ3M7XG4gICAgICAgIHRoaXMuYm9yZGVyUmlnaHQgPSBzZXR0aW5ncztcbiAgICB9XG5cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi4vYXBwbGljYXRpb24vQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IExpbmVhckJsdXJTaGFkZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvTGluZWFyQmx1clNoYWRlci5tanNcIjtcbmltcG9ydCBCb3hCbHVyU2hhZGVyIGZyb20gXCIuLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0JveEJsdXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IEMyZEJsdXJTaGFkZXIgZnJvbSBcIi4uL3JlbmRlcmVyL2MyZC9zaGFkZXJzL0JsdXJTaGFkZXIubWpzXCI7XG5pbXBvcnQgU2hhZGVyIGZyb20gXCIuLi90cmVlL1NoYWRlci5tanNcIjtcbmltcG9ydCBNdWx0aVNwbGluZSBmcm9tIFwiLi4vdG9vbHMvTXVsdGlTcGxpbmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhc3RCbHVyQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgICByZXR1cm4ge31cbiAgICB9XG5cbiAgICBnZXQgd3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnKFwiV3JhcFwiKTtcbiAgICB9XG5cbiAgICBzZXQgY29udGVudCh2KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAuY29udGVudCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAuY29udGVudDtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZyh2KSB7XG4gICAgICAgIHRoaXMud3JhcC5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLndyYXAuX3BhZGRpbmdZID0gdjtcbiAgICAgICAgdGhpcy53cmFwLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWCh2KSB7XG4gICAgICAgIHRoaXMud3JhcC5fcGFkZGluZ1ggPSB2O1xuICAgICAgICB0aGlzLndyYXAuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdZKHYpIHtcbiAgICAgICAgdGhpcy53cmFwLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMud3JhcC5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcC5hbW91bnQgPSB2O1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXAuYW1vdW50O1xuICAgIH1cblxuICAgIF9vblJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy53cmFwLncgPSB0aGlzLnJlbmRlcldpZHRoO1xuICAgICAgICB0aGlzLndyYXAuaCA9IHRoaXMucmVuZGVySGVpZ2h0O1xuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9idWlsZCgpIHtcbiAgICAgICAgdGhpcy5wYXRjaCh7XG4gICAgICAgICAgICBXcmFwOiB7dHlwZTogdGhpcy5zdGFnZS5nbCA/IFdlYkdMRmFzdEJsdXJDb21wb25lbnQgOiBDMmRGYXN0Qmx1ckNvbXBvbmVudH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG5cblxuY2xhc3MgQzJkRmFzdEJsdXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuXG4gICAgc3RhdGljIF90ZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcmNlWkluZGV4Q29udGV4dDogdHJ1ZSxcbiAgICAgICAgICAgIHJ0dDogdHJ1ZSxcbiAgICAgICAgICAgIFRleHR3cmFwOiB7c2hhZGVyOiB7dHlwZTogQzJkQmx1clNoYWRlcn0sIENvbnRlbnQ6IHt9fVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcCA9IHRoaXMuc2VsKFwiVGV4dHdyYXBcIik7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIgPSB0aGlzLnNlbChcIlRleHR3cmFwPkNvbnRlbnRcIik7XG5cbiAgICAgICAgdGhpcy5fYW1vdW50ID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1ggPSAwO1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IDA7XG5cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U3BsaW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuX211bHRpU3BsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLl9tdWx0aVNwbGluZSA9IG5ldyBNdWx0aVNwbGluZSgpO1xuICAgICAgICAgICAgdGhpcy5fbXVsdGlTcGxpbmUucGFyc2UoZmFsc2UsIHswOiAwLCAwLjI1OiAxLjUsIDAuNTogNS41LCAwLjc1OiAxOCwgMTogMzl9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbXVsdGlTcGxpbmU7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbCgnVGV4dHdyYXA+Q29udGVudCcpO1xuICAgIH1cblxuICAgIHNldCBjb250ZW50KHYpIHtcbiAgICAgICAgdGhpcy5zZWwoJ1RleHR3cmFwPkNvbnRlbnQnKS5wYXRjaCh2LCB0cnVlKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZyh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWCh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1kodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZUJsdXJTaXplKCkge1xuICAgICAgICBsZXQgdyA9IHRoaXMucmVuZGVyV2lkdGg7XG4gICAgICAgIGxldCBoID0gdGhpcy5yZW5kZXJIZWlnaHQ7XG5cbiAgICAgICAgbGV0IHBhZGRpbmdYID0gdGhpcy5fcGFkZGluZ1g7XG4gICAgICAgIGxldCBwYWRkaW5nWSA9IHRoaXMuX3BhZGRpbmdZO1xuXG4gICAgICAgIHRoaXMuX3dyYXBwZXIueCA9IHBhZGRpbmdYO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC54ID0gLXBhZGRpbmdYO1xuXG4gICAgICAgIHRoaXMuX3dyYXBwZXIueSA9IHBhZGRpbmdZO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC55ID0gLXBhZGRpbmdZO1xuXG4gICAgICAgIHRoaXMuX3RleHR3cmFwLncgPSB3ICsgcGFkZGluZ1ggKiAyO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC5oID0gaCArIHBhZGRpbmdZICogMjtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFtb3VudCBvZiBibHVyLiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgNC4gR29lcyB1cCBleHBvbmVudGlhbGx5IGZvciBibHVyLlxuICAgICAqIEJlc3QgcmVzdWx0cyBmb3Igbm9uLWZyYWN0aW9uYWwgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB2O1xuICAgICAqL1xuICAgIHNldCBhbW91bnQodikge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB2O1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC5zaGFkZXIua2VybmVsUmFkaXVzID0gQzJkRmFzdEJsdXJDb21wb25lbnQuX2Ftb3VudFRvS2VybmVsUmFkaXVzKHYpO1xuICAgIH1cblxuICAgIHN0YXRpYyBfYW1vdW50VG9LZXJuZWxSYWRpdXModikge1xuICAgICAgICByZXR1cm4gQzJkRmFzdEJsdXJDb21wb25lbnQuZ2V0U3BsaW5lKCkuZ2V0VmFsdWUoTWF0aC5taW4oMSwgdiAqIDAuMjUpKTtcbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn1cblxuY2xhc3MgV2ViR0xGYXN0Qmx1ckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgX3RlbXBsYXRlKCkge1xuICAgICAgICBjb25zdCBvblVwZGF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGVsZW1lbnRDb3JlKSB7XG4gICAgICAgICAgICBpZiAoKGVsZW1lbnRDb3JlLl9yZWNhbGMgJiAoMiArIDEyOCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IGVsZW1lbnRDb3JlLnc7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IGVsZW1lbnRDb3JlLmg7XG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IGVsZW1lbnRDb3JlO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyID0gY3VyLl9jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICAgICAgY3VyLl9lbGVtZW50LncgPSB3O1xuICAgICAgICAgICAgICAgICAgICBjdXIuX2VsZW1lbnQuaCA9IGg7XG4gICAgICAgICAgICAgICAgfSB3aGlsZShjdXIuX2NoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgVGV4dHdyYXA6IHtydHQ6IHRydWUsIGZvcmNlWkluZGV4Q29udGV4dDogdHJ1ZSwgcmVuZGVyT2Zmc2NyZWVuOiB0cnVlLCBDb250ZW50OiB7fX0sXG4gICAgICAgICAgICBMYXllcnM6IHtcbiAgICAgICAgICAgICAgICBMMDoge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCByZW5kZXJPZmZzY3JlZW46IHRydWUsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fSxcbiAgICAgICAgICAgICAgICBMMToge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCByZW5kZXJPZmZzY3JlZW46IHRydWUsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fSxcbiAgICAgICAgICAgICAgICBMMjoge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCByZW5kZXJPZmZzY3JlZW46IHRydWUsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fSxcbiAgICAgICAgICAgICAgICBMMzoge3J0dDogdHJ1ZSwgb25VcGRhdGU6IG9uVXBkYXRlLCByZW5kZXJPZmZzY3JlZW46IHRydWUsIHZpc2libGU6IGZhbHNlLCBDb250ZW50OiB7c2hhZGVyOiB7dHlwZTogQm94Qmx1clNoYWRlcn19fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFJlc3VsdDoge3NoYWRlcjoge3R5cGU6IEZhc3RCbHVyT3V0cHV0U2hhZGVyfSwgdmlzaWJsZTogZmFsc2V9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgX3NpZ25hbFByb3h5KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG4gICAgICAgIHRoaXMuX3RleHR3cmFwID0gdGhpcy5zZWwoXCJUZXh0d3JhcFwiKTtcbiAgICAgICAgdGhpcy5fd3JhcHBlciA9IHRoaXMuc2VsKFwiVGV4dHdyYXA+Q29udGVudFwiKTtcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gdGhpcy5zZWwoXCJMYXllcnNcIik7XG4gICAgICAgIHRoaXMuX291dHB1dCA9IHRoaXMuc2VsKFwiUmVzdWx0XCIpO1xuXG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSAwO1xuICAgIH1cblxuICAgIF9idWlsZExheWVycygpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyU2hhZGVyU2V0dGluZ3MgPSBbe3g6MSx5OjAsa2VybmVsUmFkaXVzOjF9LHt4OjAseToxLGtlcm5lbFJhZGl1czoxfSx7eDoxLjUseTowLGtlcm5lbFJhZGl1czoxfSx7eDowLHk6MS41LGtlcm5lbFJhZGl1czoxfV07XG4gICAgICAgIGNvbnN0IGZpbHRlclNoYWRlcnMgPSBmaWx0ZXJTaGFkZXJTZXR0aW5ncy5tYXAocyA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBTaGFkZXIuY3JlYXRlKHRoaXMuc3RhZ2UsIE9iamVjdC5hc3NpZ24oe3R5cGU6IExpbmVhckJsdXJTaGFkZXJ9LCBzKSk7XG4gICAgICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDApLCB0aGlzLl90ZXh0d3JhcC5nZXRUZXh0dXJlKCksIFtdKTtcbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygxKSwgdGhpcy5nZXRMYXllcigwKS5nZXRUZXh0dXJlKCksIFtmaWx0ZXJTaGFkZXJzWzBdLCBmaWx0ZXJTaGFkZXJzWzFdXSk7XG5cbiAgICAgICAgLy8gTm90aWNlIHRoYXQgMS41IGZpbHRlcnMgc2hvdWxkIGJlIGFwcGxpZWQgYmVmb3JlIDEuMCBmaWx0ZXJzLlxuICAgICAgICB0aGlzLl9zZXRMYXllclRleHR1cmUodGhpcy5nZXRMYXllckNvbnRlbnRzKDIpLCB0aGlzLmdldExheWVyKDEpLmdldFRleHR1cmUoKSwgW2ZpbHRlclNoYWRlcnNbMF0sIGZpbHRlclNoYWRlcnNbMV0sIGZpbHRlclNoYWRlcnNbMl0sIGZpbHRlclNoYWRlcnNbM11dKTtcbiAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKHRoaXMuZ2V0TGF5ZXJDb250ZW50cygzKSwgdGhpcy5nZXRMYXllcigyKS5nZXRUZXh0dXJlKCksIFtmaWx0ZXJTaGFkZXJzWzBdLCBmaWx0ZXJTaGFkZXJzWzFdLCBmaWx0ZXJTaGFkZXJzWzJdLCBmaWx0ZXJTaGFkZXJzWzNdXSk7XG4gICAgfVxuXG4gICAgX3NldExheWVyVGV4dHVyZShlbGVtZW50LCB0ZXh0dXJlLCBzdGVwcykge1xuICAgICAgICBpZiAoIXN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudC50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwcy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gZWxlbWVudC5zdGFnZS5jKHtydHQ6IHRydWUsIHNoYWRlcjogc3RlcH0pO1xuXG4gICAgICAgICAgICAvLyBSZWN1cnNlLlxuICAgICAgICAgICAgdGhpcy5fc2V0TGF5ZXJUZXh0dXJlKGNoaWxkLCB0ZXh0dXJlLCBzdGVwcyk7XG5cbiAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRMaXN0LmFkZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbCgnVGV4dHdyYXA+Q29udGVudCcpO1xuICAgIH1cblxuICAgIHNldCBjb250ZW50KHYpIHtcbiAgICAgICAgdGhpcy5zZWwoJ1RleHR3cmFwPkNvbnRlbnQnKS5wYXRjaCh2LCB0cnVlKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZyh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1kgPSB2O1xuICAgICAgICB0aGlzLl91cGRhdGVCbHVyU2l6ZSgpO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nWCh2KSB7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdYID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZ1kodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nWSA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUJsdXJTaXplKCk7XG4gICAgfVxuXG4gICAgZ2V0TGF5ZXIoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJzLnNlbChcIkxcIiArIGkpO1xuICAgIH1cblxuICAgIGdldExheWVyQ29udGVudHMoaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcihpKS5zZWwoXCJDb250ZW50XCIpO1xuICAgIH1cblxuICAgIF9vblJlc2l6ZSgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQmx1clNpemUoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlQmx1clNpemUoKSB7XG4gICAgICAgIGxldCB3ID0gdGhpcy5yZW5kZXJXaWR0aDtcbiAgICAgICAgbGV0IGggPSB0aGlzLnJlbmRlckhlaWdodDtcblxuICAgICAgICBsZXQgcGFkZGluZ1ggPSB0aGlzLl9wYWRkaW5nWDtcbiAgICAgICAgbGV0IHBhZGRpbmdZID0gdGhpcy5fcGFkZGluZ1k7XG5cbiAgICAgICAgbGV0IGZ3ID0gdyArIHBhZGRpbmdYICogMjtcbiAgICAgICAgbGV0IGZoID0gaCArIHBhZGRpbmdZICogMjtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAudyA9IGZ3O1xuICAgICAgICB0aGlzLl93cmFwcGVyLnggPSBwYWRkaW5nWDtcbiAgICAgICAgdGhpcy5nZXRMYXllcigwKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDApLncgPSBmdyAvIDI7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMSkudyA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygxKS53ID0gZncgLyA0O1xuICAgICAgICB0aGlzLmdldExheWVyKDIpLncgPSB0aGlzLmdldExheWVyQ29udGVudHMoMikudyA9IGZ3IC8gODtcbiAgICAgICAgdGhpcy5nZXRMYXllcigzKS53ID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDMpLncgPSBmdyAvIDE2O1xuICAgICAgICB0aGlzLl9vdXRwdXQueCA9IC1wYWRkaW5nWDtcbiAgICAgICAgdGhpcy5fdGV4dHdyYXAueCA9IC1wYWRkaW5nWDtcbiAgICAgICAgdGhpcy5fb3V0cHV0LncgPSBmdztcblxuICAgICAgICB0aGlzLl90ZXh0d3JhcC5oID0gZmg7XG4gICAgICAgIHRoaXMuX3dyYXBwZXIueSA9IHBhZGRpbmdZO1xuICAgICAgICB0aGlzLmdldExheWVyKDApLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMCkuaCA9IGZoIC8gMjtcbiAgICAgICAgdGhpcy5nZXRMYXllcigxKS5oID0gdGhpcy5nZXRMYXllckNvbnRlbnRzKDEpLmggPSBmaCAvIDQ7XG4gICAgICAgIHRoaXMuZ2V0TGF5ZXIoMikuaCA9IHRoaXMuZ2V0TGF5ZXJDb250ZW50cygyKS5oID0gZmggLyA4O1xuICAgICAgICB0aGlzLmdldExheWVyKDMpLmggPSB0aGlzLmdldExheWVyQ29udGVudHMoMykuaCA9IGZoIC8gMTY7XG4gICAgICAgIHRoaXMuX291dHB1dC55ID0gLXBhZGRpbmdZO1xuICAgICAgICB0aGlzLl90ZXh0d3JhcC55ID0gLXBhZGRpbmdZO1xuICAgICAgICB0aGlzLl9vdXRwdXQuaCA9IGZoO1xuXG4gICAgICAgIHRoaXMudyA9IHc7XG4gICAgICAgIHRoaXMuaCA9IGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYW1vdW50IG9mIGJsdXIuIEEgdmFsdWUgYmV0d2VlbiAwIGFuZCA0LiBHb2VzIHVwIGV4cG9uZW50aWFsbHkgZm9yIGJsdXIuXG4gICAgICogQmVzdCByZXN1bHRzIGZvciBub24tZnJhY3Rpb25hbCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHY7XG4gICAgICovXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHY7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCBhbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQ7XG4gICAgfVxuXG4gICAgX3VwZGF0ZSgpIHtcbiAgICAgICAgbGV0IHYgPSBNYXRoLm1pbig0LCBNYXRoLm1heCgwLCB0aGlzLl9hbW91bnQpKTtcbiAgICAgICAgaWYgKHYgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR3cmFwLnJlbmRlclRvVGV4dHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5vdGhlclRleHR1cmVTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR3cmFwLnJlbmRlclRvVGV4dHVyZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXQudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMCkudmlzaWJsZSA9ICh2ID4gMCk7XG4gICAgICAgICAgICB0aGlzLmdldExheWVyKDEpLnZpc2libGUgPSAodiA+IDEpO1xuICAgICAgICAgICAgdGhpcy5nZXRMYXllcigyKS52aXNpYmxlID0gKHYgPiAyKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0TGF5ZXIoMykudmlzaWJsZSA9ICh2ID4gMyk7XG5cbiAgICAgICAgICAgIGlmICh2IDw9IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQudGV4dHVyZSA9IHRoaXMuX3RleHR3cmFwLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLm90aGVyVGV4dHVyZVNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoMCkuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIuYSA9IHY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYgPD0gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC50ZXh0dXJlID0gdGhpcy5nZXRMYXllcigwKS5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5vdGhlclRleHR1cmVTb3VyY2UgPSB0aGlzLmdldExheWVyKDEpLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLmEgPSB2IC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnRleHR1cmUgPSB0aGlzLmdldExheWVyKDEpLmdldFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQuc2hhZGVyLm90aGVyVGV4dHVyZVNvdXJjZSA9IHRoaXMuZ2V0TGF5ZXIoMikuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIuYSA9IHYgLSAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2IDw9IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXQudGV4dHVyZSA9IHRoaXMuZ2V0TGF5ZXIoMikuZ2V0VGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dC5zaGFkZXIub3RoZXJUZXh0dXJlU291cmNlID0gdGhpcy5nZXRMYXllcigzKS5nZXRUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0LnNoYWRlci5hID0gdiAtIDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2hhZGVyKHMpIHtcbiAgICAgICAgc3VwZXIuc2hhZGVyID0gcztcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gUGxlYXNlIGVuYWJsZSByZW5kZXJUb1RleHR1cmUgdG8gdXNlIHdpdGggYSBzaGFkZXIuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2ZpcnN0QWN0aXZlKCkge1xuICAgICAgICB0aGlzLl9idWlsZExheWVycygpO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFNoYWRlciB0aGF0IGNvbWJpbmVzIHR3byB0ZXh0dXJlcyBpbnRvIG9uZSBvdXRwdXQuXG4gKi9cbmNsYXNzIEZhc3RCbHVyT3V0cHV0U2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICB0aGlzLl9hID0gMDtcbiAgICAgICAgdGhpcy5fb3RoZXJUZXh0dXJlU291cmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfVxuXG4gICAgc2V0IGEodikge1xuICAgICAgICB0aGlzLl9hID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgb3RoZXJUZXh0dXJlU291cmNlKHYpIHtcbiAgICAgICAgdGhpcy5fb3RoZXJUZXh0dXJlU291cmNlID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJhXCIsIHRoaXMuX2EsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInVTYW1wbGVyMlwiLCAxLCB0aGlzLmdsLnVuaWZvcm0xaSk7XG4gICAgfVxuXG4gICAgYmVmb3JlRHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGdsVGV4dHVyZSA9IHRoaXMuX290aGVyVGV4dHVyZVNvdXJjZSA/IHRoaXMuX290aGVyVGV4dHVyZVNvdXJjZS5uYXRpdmVUZXh0dXJlIDogbnVsbDtcblxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgfVxufVxuXG5GYXN0Qmx1ck91dHB1dFNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyMjtcbiAgICB1bmlmb3JtIGZsb2F0IGE7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBpZiAoYSA9PSAxLjApIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcjIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gKCgxLjAgLSBhKSAqIHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKyAoYSAqIHRleHR1cmUyRCh1U2FtcGxlcjIsIHZUZXh0dXJlQ29vcmQpKSkgKiB2Q29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvbXBvbmVudCBmcm9tIFwiLi4vYXBwbGljYXRpb24vQ29tcG9uZW50Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0Q29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLl93cmFwcGVyID0gc3VwZXIuX2NoaWxkcmVuLmEoe30pO1xuXG4gICAgICAgIHRoaXMuX3JlbG9hZFZpc2libGVFbGVtZW50cyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3Zpc2libGVJdGVtcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XG5cbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNpdGlvbiBkZWZpbml0aW9uIHRoYXQgaXMgYmVpbmcgdXNlZCB3aGVuIHNjcm9sbGluZyB0aGUgaXRlbXMuXG4gICAgICAgICAqIEB0eXBlIFRyYW5zaXRpb25TZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc2Nyb2xsVHJhbnNpdGlvblNldHRpbmdzID0gdGhpcy5zdGFnZS50cmFuc2l0aW9ucy5jcmVhdGVTZXR0aW5ncyh7fSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY3JvbGwgYXJlYSBzaXplIGluIHBpeGVscyBwZXIgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2l0ZW1TaXplID0gMTAwO1xuXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0U2Nyb2xsT2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLl9pdGVtU2Nyb2xsT2Zmc2V0ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIHRoZSBsaXN0IGp1bXAgd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBlbmQgdG8gc3RhcnQsIG9yIHNob3VsZCBpdCBiZSBjb250aW51b3VzLCBsaWtlIGEgY2Fycm91c2VsP1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcm9sbCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgcmVzdHJpY3RpbmcgdGhlIHN0YXJ0IHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JvbGxNaW4gPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGxvd3MgcmVzdHJpY3RpbmcgdGhlIGVuZCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yb2xsTWF4ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5pdGlvbiBmb3IgYSBjdXN0b20gYW5pbWF0aW9uIHRoYXQgaXMgYXBwbGllZCB3aGVuIGFuIGl0ZW0gaXMgKHBhcnRpYWxseSkgc2VsZWN0ZWQuXG4gICAgICAgICAqIEB0eXBlIEFuaW1hdGlvblNldHRpbmdzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcm9ncmVzc0FuaW1hdGlvbiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludmVydHMgdGhlIHNjcm9sbGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW52ZXJ0RGlyZWN0aW9uID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheW91dCB0aGUgaXRlbXMgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHk/XG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5pdGVtTGlzdCA9IG5ldyBMaXN0SXRlbXModGhpcyk7XG4gICAgfVxuXG4gICAgX2FsbG93Q2hpbGRyZW5BY2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1MaXN0LmdldCgpO1xuICAgIH1cblxuICAgIHNldCBpdGVtcyhjaGlsZHJlbikge1xuICAgICAgICB0aGlzLml0ZW1MaXN0LnBhdGNoKGNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5fd3JhcHBlci50cmFuc2l0aW9uKHRoaXMucHJvcGVydHksIHRoaXMuX3Njcm9sbFRyYW5zaXRpb25TZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRyYW5zaXRpb24gPSB0aGlzLl93cmFwcGVyLnRyYW5zaXRpb24odGhpcy5wcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRyYW5zaXRpb24ub24oJ3Byb2dyZXNzJywgcCA9PiB0aGlzLnVwZGF0ZSgpKTtcblxuICAgICAgICB0aGlzLnNldEluZGV4KDAsIHRydWUsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgc2V0SW5kZXgoaW5kZXgsIGltbWVkaWF0ZSA9IGZhbHNlLCBjbG9zZXN0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IG5FbGVtZW50cyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoIW5FbGVtZW50cykgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuZW1pdCgndW5mb2N1cycsIHRoaXMuZ2V0RWxlbWVudCh0aGlzLnJlYWxJbmRleCksIHRoaXMuX2luZGV4LCB0aGlzLnJlYWxJbmRleCk7XG5cbiAgICAgICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byBzYW1lIG9mZnNldCBjbG9zZXN0IHRvIHRoZSBpbmRleC5cbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBVdGlscy5nZXRNb2R1bG9JbmRleChpbmRleCwgbkVsZW1lbnRzKTtcbiAgICAgICAgICAgIGxldCBvID0gVXRpbHMuZ2V0TW9kdWxvSW5kZXgodGhpcy5pbmRleCwgbkVsZW1lbnRzKTtcbiAgICAgICAgICAgIGxldCBkaWZmID0gb2Zmc2V0IC0gbztcbiAgICAgICAgICAgIGlmIChkaWZmID4gMC41ICogbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZGlmZiAtPSBuRWxlbWVudHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAtMC41ICogbkVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgZGlmZiArPSBuRWxlbWVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pbmRleCArPSBkaWZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yb2xsIHx8ICh0aGlzLnZpZXdwb3J0U2l6ZSA+IHRoaXMuX2l0ZW1TaXplICogbkVsZW1lbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5faW5kZXggPSBVdGlscy5nZXRNb2R1bG9JbmRleCh0aGlzLl9pbmRleCwgbkVsZW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSAodGhpcy5faG9yaXpvbnRhbCBeIHRoaXMuX2ludmVydERpcmVjdGlvbiA/IC0xIDogMSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IGRpcmVjdGlvbiAqIHRoaXMuX2luZGV4ICogdGhpcy5faXRlbVNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JvbGwpIHtcbiAgICAgICAgICAgIGxldCBtaW4sIG1heCwgc2Nyb2xsRGVsdGE7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09IDEpIHtcbiAgICAgICAgICAgICAgICBtYXggPSAobkVsZW1lbnRzIC0gMSkgKiB0aGlzLl9pdGVtU2l6ZTtcbiAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YSA9IHRoaXMuX3ZpZXdwb3J0U2Nyb2xsT2Zmc2V0ICogdGhpcy52aWV3cG9ydFNpemUgLSB0aGlzLl9pdGVtU2Nyb2xsT2Zmc2V0ICogdGhpcy5faXRlbVNpemU7XG5cbiAgICAgICAgICAgICAgICBtYXggLT0gc2Nyb2xsRGVsdGE7XG5cbiAgICAgICAgICAgICAgICBtaW4gPSB0aGlzLnZpZXdwb3J0U2l6ZSAtICh0aGlzLl9pdGVtU2l6ZSArIHNjcm9sbERlbHRhKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb2xsTWluKSBtaW4gLT0gdGhpcy5fcm9sbE1pbjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcm9sbE1heCkgbWF4ICs9IHRoaXMuX3JvbGxNYXg7XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHZhbHVlLCBtYXgpLCBtaW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXggPSAobkVsZW1lbnRzICogdGhpcy5faXRlbVNpemUgLSB0aGlzLnZpZXdwb3J0U2l6ZSk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRGVsdGEgPSB0aGlzLl92aWV3cG9ydFNjcm9sbE9mZnNldCAqIHRoaXMudmlld3BvcnRTaXplIC0gdGhpcy5faXRlbVNjcm9sbE9mZnNldCAqIHRoaXMuX2l0ZW1TaXplO1xuXG4gICAgICAgICAgICAgICAgbWF4ICs9IHNjcm9sbERlbHRhO1xuXG4gICAgICAgICAgICAgICAgbGV0IG1pbiA9IHNjcm9sbERlbHRhO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JvbGxNaW4pIG1pbiAtPSB0aGlzLl9yb2xsTWluO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yb2xsTWF4KSBtYXggKz0gdGhpcy5fcm9sbE1heDtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgoLW1heCwgdmFsdWUpLCAtbWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Njcm9sbFRyYW5zaXRpb24uc3RhcnQodmFsdWUpO1xuXG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFRyYW5zaXRpb24uZmluaXNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ2ZvY3VzJywgdGhpcy5nZXRFbGVtZW50KHRoaXMucmVhbEluZGV4KSwgdGhpcy5faW5kZXgsIHRoaXMucmVhbEluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRBeGlzUG9zaXRpb24oKSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSAtdGhpcy5fc2Nyb2xsVHJhbnNpdGlvbi5fdGFyZ2V0VmFsdWU7XG5cbiAgICAgICAgbGV0IGRpcmVjdGlvbiA9ICh0aGlzLl9ob3Jpem9udGFsIF4gdGhpcy5faW52ZXJ0RGlyZWN0aW9uID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IHZhbHVlID0gLWRpcmVjdGlvbiAqIHRoaXMuX2luZGV4ICogdGhpcy5faXRlbVNpemU7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U2Nyb2xsT2Zmc2V0ICogdGhpcy52aWV3cG9ydFNpemUgKyAodmFsdWUgLSB0YXJnZXQpO1xuICAgIH1cblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSByZXR1cm47XG5cbiAgICAgICAgbGV0IG5FbGVtZW50cyA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAoIW5FbGVtZW50cykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBkaXJlY3Rpb24gPSAodGhpcy5faG9yaXpvbnRhbCBeIHRoaXMuX2ludmVydERpcmVjdGlvbiA/IC0xIDogMSk7XG5cbiAgICAgICAgLy8gTWFwIHBvc2l0aW9uIHRvIGluZGV4IHZhbHVlLlxuICAgICAgICBsZXQgdiA9ICh0aGlzLl9ob3Jpem9udGFsID8gdGhpcy5fd3JhcHBlci54IDogdGhpcy5fd3JhcHBlci55KTtcblxuICAgICAgICBsZXQgdmlld3BvcnRTaXplID0gdGhpcy52aWV3cG9ydFNpemU7XG4gICAgICAgIGxldCBzY3JvbGxEZWx0YSA9IHRoaXMuX3ZpZXdwb3J0U2Nyb2xsT2Zmc2V0ICogdmlld3BvcnRTaXplIC0gdGhpcy5faXRlbVNjcm9sbE9mZnNldCAqIHRoaXMuX2l0ZW1TaXplO1xuICAgICAgICB2ICs9IHNjcm9sbERlbHRhO1xuXG4gICAgICAgIGxldCBzLCBlLCBwcywgcGU7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT0gLTEpIHtcbiAgICAgICAgICAgIHMgPSBNYXRoLmZsb29yKC12IC8gdGhpcy5faXRlbVNpemUpO1xuICAgICAgICAgICAgcHMgPSAxIC0gKCgtdiAvIHRoaXMuX2l0ZW1TaXplKSAtIHMpO1xuICAgICAgICAgICAgZSA9IE1hdGguZmxvb3IoKHZpZXdwb3J0U2l6ZSAtIHYpIC8gdGhpcy5faXRlbVNpemUpO1xuICAgICAgICAgICAgcGUgPSAoKCh2aWV3cG9ydFNpemUgLSB2KSAvIHRoaXMuX2l0ZW1TaXplKSAtIGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcyA9IE1hdGguY2VpbCh2IC8gdGhpcy5faXRlbVNpemUpO1xuICAgICAgICAgICAgcHMgPSAxICsgKHYgLyB0aGlzLl9pdGVtU2l6ZSkgLSBzO1xuICAgICAgICAgICAgZSA9IE1hdGguY2VpbCgodiAtIHZpZXdwb3J0U2l6ZSkgLyB0aGlzLl9pdGVtU2l6ZSk7XG4gICAgICAgICAgICBwZSA9IGUgLSAoKHYgLSB2aWV3cG9ydFNpemUpIC8gdGhpcy5faXRlbVNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yb2xsIHx8ICh2aWV3cG9ydFNpemUgPiB0aGlzLl9pdGVtU2l6ZSAqIG5FbGVtZW50cykpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHNob3cgYWRkaXRpb25hbCBpdGVtcy5cbiAgICAgICAgICAgIGlmIChlID49IG5FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGUgPSBuRWxlbWVudHMgLSAxO1xuICAgICAgICAgICAgICAgIHBlID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzID49IG5FbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHMgPSBuRWxlbWVudHMgLSAxO1xuICAgICAgICAgICAgICAgIHBzID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlIDw9IC0xKSB7XG4gICAgICAgICAgICAgICAgZSA9IDA7XG4gICAgICAgICAgICAgICAgcGUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMgPD0gLTEpIHtcbiAgICAgICAgICAgICAgICBzID0gMDtcbiAgICAgICAgICAgICAgICBwcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb2Zmc2V0ID0gLWRpcmVjdGlvbiAqIHMgKiB0aGlzLl9pdGVtU2l6ZTtcblxuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBzOyAoZGlyZWN0aW9uID09IC0xID8gaW5kZXggPD0gZSA6IGluZGV4ID49IGUpOyAoZGlyZWN0aW9uID09IC0xID8gaW5kZXgrKyA6IGluZGV4LS0pKSB7XG4gICAgICAgICAgICBsZXQgcmVhbEluZGV4ID0gVXRpbHMuZ2V0TW9kdWxvSW5kZXgoaW5kZXgsIG5FbGVtZW50cyk7XG5cbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KHJlYWxJbmRleCk7XG4gICAgICAgICAgICBpdGVtID0gZWxlbWVudC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlSXRlbXMuZGVsZXRlKGl0ZW0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnggPSBvZmZzZXQgKyBzY3JvbGxEZWx0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS55ID0gb2Zmc2V0ICsgc2Nyb2xsRGVsdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB3YXNWaXNpYmxlID0gaXRlbS52aXNpYmxlO1xuICAgICAgICAgICAgaXRlbS52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCF3YXNWaXNpYmxlIHx8IHRoaXMuX3JlbG9hZFZpc2libGVFbGVtZW50cykge1xuICAgICAgICAgICAgICAgIC8vIFR1cm5lZCB2aXNpYmxlLlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndmlzaWJsZScsIGluZGV4LCByZWFsSW5kZXgpO1xuICAgICAgICAgICAgfVxuXG5cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb2dyZXNzQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSAxO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwcztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09IGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHBlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVzZSBhbmltYXRpb24gdG8gcHJvZ3Jlc3MuXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NBbmltYXRpb24uYXBwbHkoZWxlbWVudCwgcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLl9pdGVtU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBpdGVtIHZpc2liaWxpdHkuXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fdmlzaWJsZUl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaW52aXNpYmxlSXRlbSkge1xuICAgICAgICAgICAgaW52aXNpYmxlSXRlbS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLl92aXNpYmxlSXRlbXMuZGVsZXRlKGludmlzaWJsZUl0ZW0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IHM7IChkaXJlY3Rpb24gPT0gLTEgPyBpbmRleCA8PSBlIDogaW5kZXggPj0gZSk7IChkaXJlY3Rpb24gPT0gLTEgPyBpbmRleCsrIDogaW5kZXgtLSkpIHtcbiAgICAgICAgICAgIGxldCByZWFsSW5kZXggPSBVdGlscy5nZXRNb2R1bG9JbmRleChpbmRleCwgbkVsZW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVJdGVtcy5hZGQodGhpcy5nZXRXcmFwcGVyKHJlYWxJbmRleCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVsb2FkVmlzaWJsZUVsZW1lbnRzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0UHJldmlvdXMoKSB7XG4gICAgICAgIHRoaXMuc2V0SW5kZXgodGhpcy5faW5kZXggLSAxKTtcbiAgICB9XG5cbiAgICBzZXROZXh0KCkge1xuICAgICAgICB0aGlzLnNldEluZGV4KHRoaXMuX2luZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgZ2V0V3JhcHBlcihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcHBlci5jaGlsZHJlbltpbmRleF07XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudChpbmRleCkge1xuICAgICAgICBsZXQgZSA9IHRoaXMuX3dyYXBwZXIuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICByZXR1cm4gZSA/IGUuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgIH1cblxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgdGhpcy5fcmVsb2FkVmlzaWJsZUVsZW1lbnRzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgbGV0IGUgPSB0aGlzLl93cmFwcGVyLmNoaWxkcmVuW3RoaXMucmVhbEluZGV4XTtcbiAgICAgICAgcmV0dXJuIGUgPyBlLmNoaWxkcmVuWzBdIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd3JhcHBlci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgfVxuXG4gICAgZ2V0IHByb3BlcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbCA/ICd4JyA6ICd5JztcbiAgICB9XG5cbiAgICBnZXQgdmlld3BvcnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbCA/IHRoaXMudyA6IHRoaXMuaDtcbiAgICB9XG5cbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9XG5cbiAgICBnZXQgcmVhbEluZGV4KCkge1xuICAgICAgICByZXR1cm4gVXRpbHMuZ2V0TW9kdWxvSW5kZXgodGhpcy5faW5kZXgsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBnZXQgaXRlbVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtU2l6ZTtcbiAgICB9XG5cbiAgICBzZXQgaXRlbVNpemUodikge1xuICAgICAgICB0aGlzLl9pdGVtU2l6ZSA9IHY7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHZpZXdwb3J0U2Nyb2xsT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRTY3JvbGxPZmZzZXQ7XG4gICAgfVxuXG4gICAgc2V0IHZpZXdwb3J0U2Nyb2xsT2Zmc2V0KHYpIHtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRTY3JvbGxPZmZzZXQgPSB2O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCBpdGVtU2Nyb2xsT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbVNjcm9sbE9mZnNldDtcbiAgICB9XG5cbiAgICBzZXQgaXRlbVNjcm9sbE9mZnNldCh2KSB7XG4gICAgICAgIHRoaXMuX2l0ZW1TY3JvbGxPZmZzZXQgPSB2O1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGdldCBzY3JvbGxUcmFuc2l0aW9uU2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxUcmFuc2l0aW9uU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgc2V0IHNjcm9sbFRyYW5zaXRpb25TZXR0aW5ncyh2KSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRyYW5zaXRpb25TZXR0aW5ncy5wYXRjaCh2KTtcbiAgICB9XG5cbiAgICBzZXQgc2Nyb2xsVHJhbnNpdGlvbih2KSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRyYW5zaXRpb25TZXR0aW5ncy5wYXRjaCh2KTtcbiAgICB9XG5cbiAgICBnZXQgc2Nyb2xsVHJhbnNpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbFRyYW5zaXRpb247XG4gICAgfVxuXG4gICAgZ2V0IHByb2dyZXNzQW5pbWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3NBbmltYXRpb247XG4gICAgfVxuXG4gICAgc2V0IHByb2dyZXNzQW5pbWF0aW9uKHYpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3NBbmltYXRpb24gPSB0aGlzLnN0YWdlLmFuaW1hdGlvbnMuY3JlYXRlU2V0dGluZ3Modik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmVzc0FuaW1hdGlvbiA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvbGw7XG4gICAgfVxuXG4gICAgc2V0IHJvbGwodikge1xuICAgICAgICB0aGlzLl9yb2xsID0gdjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgcm9sbE1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvbGxNaW47XG4gICAgfVxuXG4gICAgc2V0IHJvbGxNaW4odikge1xuICAgICAgICB0aGlzLl9yb2xsTWluID0gdjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgcm9sbE1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvbGxNYXg7XG4gICAgfVxuXG4gICAgc2V0IHJvbGxNYXgodikge1xuICAgICAgICB0aGlzLl9yb2xsTWF4ID0gdjtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBnZXQgaW52ZXJ0RGlyZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52ZXJ0RGlyZWN0aW9uO1xuICAgIH1cblxuICAgIHNldCBpbnZlcnREaXJlY3Rpb24odikge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludmVydERpcmVjdGlvbiA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaG9yaXpvbnRhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvcml6b250YWw7XG4gICAgfVxuXG4gICAgc2V0IGhvcml6b250YWwodikge1xuICAgICAgICBpZiAodiAhPT0gdGhpcy5faG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuaW1wb3J0IE9iamVjdExpc3RXcmFwcGVyIGZyb20gXCIuLi90b29scy9PYmplY3RMaXN0V3JhcHBlci5tanNcIjtcbmNsYXNzIExpc3RJdGVtcyBleHRlbmRzIE9iamVjdExpc3RXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0KSB7XG4gICAgICAgIGxldCB3cmFwID0gKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGl0ZW0uc3RhZ2UuY3JlYXRlRWxlbWVudCgpO1xuICAgICAgICAgICAgcGFyZW50LmFkZChpdGVtKTtcbiAgICAgICAgICAgIHBhcmVudC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgICB9KVxuXG4gICAgICAgIHN1cGVyKGxpc3QuX3dyYXBwZXIuX2NoaWxkcmVuLCB3cmFwKTtcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcbiAgICB9XG5cbiAgICBvbkFkZChpdGVtLCBpbmRleCkge1xuICAgICAgICBzdXBlci5vbkFkZChpdGVtLCBpbmRleCk7XG4gICAgICAgIHRoaXMuY2hlY2tTdGFydGVkKGluZGV4KTtcbiAgICB9XG5cbiAgICBjaGVja1N0YXJ0ZWQoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5saXN0Ll9yZWxvYWRWaXNpYmxlRWxlbWVudHMgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMubGlzdC5fc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5saXN0LnN0YXJ0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zZXRJbmRleCgwLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdC5faW5kZXggPj0gdGhpcy5saXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2V0SW5kZXgoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25SZW1vdmUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIub25SZW1vdmUoaXRlbSwgaW5kZXgpO1xuICAgICAgICBsZXQgcmkgPSB0aGlzLmxpc3QucmVhbEluZGV4O1xuICAgICAgICBpZiAocmkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICBpZiAocmkgPT09IHRoaXMubGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByaS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3Quc2V0SW5kZXgocmkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJpID4gaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zZXRJbmRleChyaSAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5saXN0Ll9yZWxvYWRWaXNpYmxlRWxlbWVudHMgPSB0cnVlO1xuICAgIH1cblxuICAgIG9uU2V0KGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHN1cGVyLm9uU2V0KGl0ZW0sIGluZGV4KTtcbiAgICAgICAgdGhpcy5jaGVja1N0YXJ0ZWQoaW5kZXgpO1xuICAgIH1cblxuICAgIG9uU3luYyhyZW1vdmVkLCBhZGRlZCwgb3JkZXIpIHtcbiAgICAgICAgc3VwZXIub25TeW5jKHJlbW92ZWQsIGFkZGVkLCBvcmRlcik7XG4gICAgICAgIHRoaXMuY2hlY2tTdGFydGVkKDApO1xuICAgIH1cblxuICAgIGdldCBfc2lnbmFsUHJveHkoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufVxuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gXCIuLi9hcHBsaWNhdGlvbi9Db21wb25lbnQubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNtb290aFNjYWxlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyBfdGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBDb250ZW50V3JhcDoge3JlbmRlck9mZnNjcmVlbjogdHJ1ZSwgZm9yY2VaSW5kZXhDb250ZXh0OiB0cnVlLCBvbkFmdGVyVXBkYXRlOiBTbW9vdGhTY2FsZUNvbXBvbmVudC5fdXBkYXRlRGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBDb250ZW50OiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNjYWxlOiB7dmlzaWJsZTogZmFsc2V9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy5fc21vb3RoU2NhbGUgPSAxO1xuICAgICAgICB0aGlzLl9pdGVyYXRpb25zID0gMDtcbiAgICB9XG5cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnKCdDb250ZW50Jyk7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQodikge1xuICAgICAgICB0aGlzLnRhZygnQ29udGVudCcpLnBhdGNoKHYsIHRydWUpO1xuICAgIH1cblxuICAgIGdldCBzbW9vdGhTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Ntb290aFNjYWxlO1xuICAgIH1cblxuICAgIHNldCBzbW9vdGhTY2FsZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zbW9vdGhTY2FsZSAhPT0gdikge1xuICAgICAgICAgICAgbGV0IGl0cyA9IDA7XG4gICAgICAgICAgICB3aGlsZSh2IDwgMC41ICYmIGl0cyA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaXRzKys7XG4gICAgICAgICAgICAgICAgdiA9IHYgKiAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3NldEl0ZXJhdGlvbnMoaXRzKTtcblxuICAgICAgICAgICAgdGhpcy5fc21vb3RoU2NhbGUgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldEl0ZXJhdGlvbnMoaXRzKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVyYXRpb25zICE9PSBpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlcnMgPSB0aGlzLnNlbChcIlNjYWxlXCIpLmNoaWxkTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLnNlbChcIkNvbnRlbnRXcmFwXCIpO1xuICAgICAgICAgICAgd2hpbGUgKHNjYWxlcnMubGVuZ3RoIDwgaXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBzY2FsZXJzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gKGZpcnN0ID8gY29udGVudC5nZXRUZXh0dXJlKCkgOiBzY2FsZXJzLmxhc3QuZ2V0VGV4dHVyZSgpKTtcbiAgICAgICAgICAgICAgICBzY2FsZXJzLmEoe3J0dDogdHJ1ZSwgcmVuZGVyT2Zmc2NyZWVuOiB0cnVlLCB0ZXh0dXJlOiB0ZXh0dXJlfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFNtb290aFNjYWxlQ29tcG9uZW50Ll91cGRhdGVEaW1lbnNpb25zKHRoaXMudGFnKFwiQ29udGVudFdyYXBcIiksIHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCB1c2VTY2FsZXJzID0gKGl0cyA+IDApO1xuICAgICAgICAgICAgdGhpcy5wYXRjaCh7XG4gICAgICAgICAgICAgICAgQ29udGVudFdyYXA6IHtyZW5kZXJUb1RleHR1cmU6IHVzZVNjYWxlcnN9LFxuICAgICAgICAgICAgICAgIFNjYWxlOiB7dmlzaWJsZTogdXNlU2NhbGVyc31cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHNjYWxlcnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVycy5nZXRBdChpKS5wYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGkgPCBpdHMsXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlck9mZnNjcmVlbjogaSAhPT0gaXRzIC0gMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXRlcmF0aW9ucyA9IGl0cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfdXBkYXRlRGltZW5zaW9ucyhjb250ZW50V3JhcCwgZm9yY2UpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGNvbnRlbnRXcmFwLmNoaWxkcmVuWzBdO1xuICAgICAgICBsZXQgdyA9IGNvbnRlbnQucmVuZGVyV2lkdGg7XG4gICAgICAgIGxldCBoID0gY29udGVudC5yZW5kZXJIZWlnaHQ7XG4gICAgICAgIGlmICh3ICE9PSBjb250ZW50V3JhcC53IHx8IGggIT09IGNvbnRlbnRXcmFwLmggfHwgZm9yY2UpIHtcbiAgICAgICAgICAgIGNvbnRlbnRXcmFwLncgPSB3O1xuICAgICAgICAgICAgY29udGVudFdyYXAuaCA9IGg7XG5cbiAgICAgICAgICAgIGNvbnN0IHNjYWxlcnMgPSBjb250ZW50V3JhcC5wYXJlbnQudGFnKFwiU2NhbGVcIikuY2hpbGRyZW47XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHNjYWxlcnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdyA9IHcgKiAwLjU7XG4gICAgICAgICAgICAgICAgaCA9IGggKiAwLjU7XG4gICAgICAgICAgICAgICAgc2NhbGVyc1tpXS53ID0gdztcbiAgICAgICAgICAgICAgICBzY2FsZXJzW2ldLmggPSBoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IF9zaWduYWxQcm94eSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuaW1wb3J0IExheW91dCBmcm9tIFwiLi9sYXlvdXQvRmxleExheW91dC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxleENvbnRhaW5lciB7XG5cblxuICAgIGNvbnN0cnVjdG9yKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5faXRlbSA9IGl0ZW07XG5cbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IExheW91dCh0aGlzKTtcbiAgICAgICAgdGhpcy5faG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JldmVyc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fd3JhcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hbGlnbkl0ZW1zID0gJ3N0cmV0Y2gnO1xuICAgICAgICB0aGlzLl9qdXN0aWZ5Q29udGVudCA9ICdmbGV4LXN0YXJ0JztcbiAgICAgICAgdGhpcy5fYWxpZ25Db250ZW50ID0gJ2ZsZXgtc3RhcnQnO1xuXG4gICAgICAgIHRoaXMuX3BhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdSaWdodCA9IDA7XG4gICAgICAgIHRoaXMuX3BhZGRpbmdCb3R0b20gPSAwO1xuICAgIH1cblxuICAgIGdldCBpdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbTtcbiAgICB9XG5cbiAgICBfY2hhbmdlZERpbWVuc2lvbnMoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW0uY2hhbmdlZERpbWVuc2lvbnMoKTtcbiAgICB9XG5cbiAgICBfY2hhbmdlZENvbnRlbnRzKCkge1xuICAgICAgICB0aGlzLl9pdGVtLmNoYW5nZWRDb250ZW50cygpO1xuICAgIH1cblxuICAgIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5faG9yaXpvbnRhbCA/IFwicm93XCIgOiBcImNvbHVtblwiKSArICh0aGlzLl9yZXZlcnNlID8gXCItcmV2ZXJzZVwiIDogXCJcIik7XG4gICAgfVxuXG4gICAgc2V0IGRpcmVjdGlvbihmKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gZikgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2hvcml6b250YWwgPSAoZiA9PT0gJ3JvdycgfHwgZiA9PT0gJ3Jvdy1yZXZlcnNlJyk7XG4gICAgICAgIHRoaXMuX3JldmVyc2UgPSAoZiA9PT0gJ3Jvdy1yZXZlcnNlJyB8fCBmID09PSAnY29sdW1uLXJldmVyc2UnKTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBzZXQgd3JhcCh2KSB7XG4gICAgICAgIHRoaXMuX3dyYXAgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBnZXQgd3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXA7XG4gICAgfVxuXG4gICAgZ2V0IGFsaWduSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnbkl0ZW1zO1xuICAgIH1cblxuICAgIHNldCBhbGlnbkl0ZW1zKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FsaWduSXRlbXMgPT09IHYpIHJldHVybjtcbiAgICAgICAgaWYgKEZsZXhDb250YWluZXIuQUxJR05fSVRFTVMuaW5kZXhPZih2KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWxpZ25JdGVtcywgb3B0aW9uczogXCIgKyBGbGV4Q29udGFpbmVyLkFMSUdOX0lURU1TLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hbGlnbkl0ZW1zID0gdjtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBnZXQgYWxpZ25Db250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ25Db250ZW50O1xuICAgIH1cblxuICAgIHNldCBhbGlnbkNvbnRlbnQodikge1xuICAgICAgICBpZiAodGhpcy5fYWxpZ25Db250ZW50ID09PSB2KSByZXR1cm47XG4gICAgICAgIGlmIChGbGV4Q29udGFpbmVyLkFMSUdOX0NPTlRFTlQuaW5kZXhPZih2KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWxpZ25Db250ZW50LCBvcHRpb25zOiBcIiArIEZsZXhDb250YWluZXIuQUxJR05fQ09OVEVOVC5qb2luKFwiLFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxpZ25Db250ZW50ID0gdjtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBnZXQganVzdGlmeUNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9qdXN0aWZ5Q29udGVudDtcbiAgICB9XG5cbiAgICBzZXQganVzdGlmeUNvbnRlbnQodikge1xuICAgICAgICBpZiAodGhpcy5fanVzdGlmeUNvbnRlbnQgPT09IHYpIHJldHVybjtcblxuICAgICAgICBpZiAoRmxleENvbnRhaW5lci5KVVNUSUZZX0NPTlRFTlQuaW5kZXhPZih2KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24ganVzdGlmeUNvbnRlbnQsIG9wdGlvbnM6IFwiICsgRmxleENvbnRhaW5lci5KVVNUSUZZX0NPTlRFTlQuam9pbihcIixcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2p1c3RpZnlDb250ZW50ID0gdjtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkQ29udGVudHMoKTtcbiAgICB9XG5cbiAgICBzZXQgcGFkZGluZyh2KSB7XG4gICAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSB2O1xuICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSB2O1xuICAgICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IHY7XG4gICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZGRpbmdMZWZ0O1xuICAgIH1cbiAgICBcbiAgICBzZXQgcGFkZGluZ0xlZnQodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nTGVmdCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWREaW1lbnNpb25zKCk7XG4gICAgfVxuICAgIFxuICAgIGdldCBwYWRkaW5nTGVmdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdMZWZ0O1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nVG9wKHYpIHtcbiAgICAgICAgdGhpcy5fcGFkZGluZ1RvcCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWREaW1lbnNpb25zKCk7XG4gICAgfVxuXG4gICAgZ2V0IHBhZGRpbmdUb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nVG9wO1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nUmlnaHQodikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nUmlnaHQgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkRGltZW5zaW9ucygpO1xuICAgIH1cblxuICAgIGdldCBwYWRkaW5nUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nUmlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdCb3R0b20odikge1xuICAgICAgICB0aGlzLl9wYWRkaW5nQm90dG9tID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZERpbWVuc2lvbnMoKTtcbiAgICB9XG5cbiAgICBnZXQgcGFkZGluZ0JvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmdCb3R0b207XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG59XG5cbkZsZXhDb250YWluZXIuQUxJR05fSVRFTVMgPSBbXCJmbGV4LXN0YXJ0XCIsIFwiZmxleC1lbmRcIiwgXCJjZW50ZXJcIiwgXCJzdHJldGNoXCJdO1xuRmxleENvbnRhaW5lci5BTElHTl9DT05URU5UID0gW1wiZmxleC1zdGFydFwiLCBcImZsZXgtZW5kXCIsIFwiY2VudGVyXCIsIFwic3BhY2UtYmV0d2VlblwiLCBcInNwYWNlLWFyb3VuZFwiLCBcInNwYWNlLWV2ZW5seVwiLCBcInN0cmV0Y2hcIl07XG5GbGV4Q29udGFpbmVyLkpVU1RJRllfQ09OVEVOVCA9IFtcImZsZXgtc3RhcnRcIiwgXCJmbGV4LWVuZFwiLCBcImNlbnRlclwiLCBcInNwYWNlLWJldHdlZW5cIiwgXCJzcGFjZS1hcm91bmRcIiwgXCJzcGFjZS1ldmVubHlcIl07XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQmFzZSBmcm9tIFwiLi4vdHJlZS9CYXNlLm1qc1wiO1xuaW1wb3J0IEZsZXhVdGlscyBmcm9tIFwiLi9GbGV4VXRpbHMubWpzXCI7XG5pbXBvcnQgRmxleENvbnRhaW5lciBmcm9tIFwiLi9GbGV4Q29udGFpbmVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbGV4SXRlbSB7XG5cbiAgICBjb25zdHJ1Y3RvcihpdGVtKSB7XG4gICAgICAgIHRoaXMuX2N0ciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICAgICAgICB0aGlzLl9ncm93ID0gMDtcbiAgICAgICAgdGhpcy5fc2hyaW5rID0gRmxleEl0ZW0uU0hSSU5LX0FVVE87XG4gICAgICAgIHRoaXMuX2FsaWduU2VsZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbWluV2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9taW5IZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9tYXhXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX21heEhlaWdodCA9IDA7XG5cbiAgICAgICAgdGhpcy5fbWFyZ2luTGVmdCA9IDA7XG4gICAgICAgIHRoaXMuX21hcmdpblRvcCA9IDA7XG4gICAgICAgIHRoaXMuX21hcmdpblJpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fbWFyZ2luQm90dG9tID0gMDtcbiAgICB9XG5cbiAgICBnZXQgaXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW07XG4gICAgfVxuXG4gICAgZ2V0IGdyb3coKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm93O1xuICAgIH1cblxuICAgIHNldCBncm93KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyb3cgPT09IHYpIHJldHVybjtcblxuICAgICAgICB0aGlzLl9ncm93ID0gcGFyc2VJbnQodikgfHwgMDtcblxuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IHNocmluaygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NocmluayA9PT0gRmxleEl0ZW0uU0hSSU5LX0FVVE8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXREZWZhdWx0U2hyaW5rKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NocmluaztcbiAgICB9XG5cbiAgICBfZ2V0RGVmYXVsdFNocmluaygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbS5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWxsIG5vbi1mbGV4IGNvbnRhaW5lcnMgYXJlIGFic29sdXRlbHkgcG9zaXRpb25lZCBpdGVtcyB3aXRoIGZpeGVkIGRpbWVuc2lvbnMsIGFuZCBieSBkZWZhdWx0IG5vdCBzaHJpbmthYmxlLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgc2hyaW5rKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NocmluayA9PT0gdikgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX3NocmluayA9IHBhcnNlSW50KHYpIHx8IDA7XG5cbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBhbGlnblNlbGYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnblNlbGY7XG4gICAgfVxuXG4gICAgc2V0IGFsaWduU2VsZih2KSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGlnblNlbGYgPT09IHYpIHJldHVybjtcblxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGlnblNlbGYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoRmxleENvbnRhaW5lci5BTElHTl9JVEVNUy5pbmRleE9mKHYpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWxpZ25TZWxmLCBvcHRpb25zOiBcIiArIEZsZXhDb250YWluZXIuQUxJR05fSVRFTVMuam9pbihcIixcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWxpZ25TZWxmID0gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgbWluV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW5XaWR0aDtcbiAgICB9XG5cbiAgICBzZXQgbWluV2lkdGgodikge1xuICAgICAgICB0aGlzLl9taW5XaWR0aCA9IE1hdGgubWF4KDAsIHYpO1xuICAgICAgICB0aGlzLl9pdGVtLmNoYW5nZWREaW1lbnNpb25zKHRydWUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBnZXQgbWluSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluSGVpZ2h0O1xuICAgIH1cblxuICAgIHNldCBtaW5IZWlnaHQodikge1xuICAgICAgICB0aGlzLl9taW5IZWlnaHQgPSBNYXRoLm1heCgwLCB2KTtcbiAgICAgICAgdGhpcy5faXRlbS5jaGFuZ2VkRGltZW5zaW9ucyhmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IG1heFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4V2lkdGg7XG4gICAgfVxuXG4gICAgc2V0IG1heFdpZHRoKHYpIHtcbiAgICAgICAgdGhpcy5fbWF4V2lkdGggPSBNYXRoLm1heCgwLCB2KTtcbiAgICAgICAgdGhpcy5faXRlbS5jaGFuZ2VkRGltZW5zaW9ucyh0cnVlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgZ2V0IG1heEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heEhlaWdodDtcbiAgICB9XG5cbiAgICBzZXQgbWF4SGVpZ2h0KHYpIHtcbiAgICAgICAgdGhpcy5fbWF4SGVpZ2h0ID0gTWF0aC5tYXgoMCwgdik7XG4gICAgICAgIHRoaXMuX2l0ZW0uY2hhbmdlZERpbWVuc2lvbnMoZmFsc2UsIHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBub3RlIG1hcmdpbnMgYmVoYXZlIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGluIEhUTUwgd2l0aCByZWdhcmQgdG8gc2hyaW5raW5nLlxuICAgICAqIEluIEhUTUwsIChvdXRlcikgbWFyZ2lucyBjYW4gYmUgcmVtb3ZlZCB3aGVuIHNocmlua2luZy4gSW4gdGhpcyBlbmdpbmUsIHRoZXkgd2lsbCBub3Qgc2hyaW5rIGF0IGFsbC5cbiAgICAgKi9cbiAgICBzZXQgbWFyZ2luKHYpIHtcbiAgICAgICAgdGhpcy5tYXJnaW5MZWZ0ID0gdjtcbiAgICAgICAgdGhpcy5tYXJnaW5Ub3AgPSB2O1xuICAgICAgICB0aGlzLm1hcmdpblJpZ2h0ID0gdjtcbiAgICAgICAgdGhpcy5tYXJnaW5Cb3R0b20gPSB2O1xuICAgIH1cblxuICAgIGdldCBtYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmdpbkxlZnQ7XG4gICAgfVxuXG4gICAgc2V0IG1hcmdpbkxlZnQodikge1xuICAgICAgICB0aGlzLl9tYXJnaW5MZWZ0ID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBtYXJnaW5MZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFyZ2luTGVmdDtcbiAgICB9XG5cbiAgICBzZXQgbWFyZ2luVG9wKHYpIHtcbiAgICAgICAgdGhpcy5fbWFyZ2luVG9wID0gdjtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIGdldCBtYXJnaW5Ub3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXJnaW5Ub3A7XG4gICAgfVxuXG4gICAgc2V0IG1hcmdpblJpZ2h0KHYpIHtcbiAgICAgICAgdGhpcy5fbWFyZ2luUmlnaHQgPSB2O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgfVxuXG4gICAgZ2V0IG1hcmdpblJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFyZ2luUmlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IG1hcmdpbkJvdHRvbSh2KSB7XG4gICAgICAgIHRoaXMuX21hcmdpbkJvdHRvbSA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgbWFyZ2luQm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFyZ2luQm90dG9tO1xuICAgIH1cbiAgICBcbiAgICBfY2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3RyKSB0aGlzLmN0ci5fY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgc2V0IGN0cih2KSB7XG4gICAgICAgIHRoaXMuX2N0ciA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGN0cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0cjtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICBfcmVzZXRMYXlvdXRTaXplKCkge1xuICAgICAgICB0aGlzLl9yZXNldEhvcml6b250YWxBeGlzTGF5b3V0U2l6ZSgpO1xuICAgICAgICB0aGlzLl9yZXNldFZlcnRpY2FsQXhpc0xheW91dFNpemUoKTtcbiAgICB9XG5cbiAgICBfcmVzZXRDcm9zc0F4aXNMYXlvdXRTaXplKCkge1xuICAgICAgICBpZiAodGhpcy5jdHIuX2hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0VmVydGljYWxBeGlzTGF5b3V0U2l6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRIb3Jpem9udGFsQXhpc0xheW91dFNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZXNldEhvcml6b250YWxBeGlzTGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgbGV0IHcgPSBGbGV4VXRpbHMuZ2V0UmVsQXhpc1NpemUodGhpcy5pdGVtLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuX21pbldpZHRoKSB7XG4gICAgICAgICAgICB3ID0gTWF0aC5tYXgodGhpcy5fbWluV2lkdGgsIHcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tYXhXaWR0aCkge1xuICAgICAgICAgICAgdyA9IE1hdGgubWluKHRoaXMuX21heFdpZHRoLCB3KTtcbiAgICAgICAgfVxuICAgICAgICBGbGV4VXRpbHMuc2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCB0cnVlLCB3KTtcbiAgICB9XG5cbiAgICBfcmVzZXRWZXJ0aWNhbEF4aXNMYXlvdXRTaXplKCkge1xuICAgICAgICBsZXQgaCA9IEZsZXhVdGlscy5nZXRSZWxBeGlzU2l6ZSh0aGlzLml0ZW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuX21pbkhlaWdodCkge1xuICAgICAgICAgICAgaCA9IE1hdGgubWF4KHRoaXMuX21pbkhlaWdodCwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21heEhlaWdodCkge1xuICAgICAgICAgICAgaCA9IE1hdGgubWluKHRoaXMuX21heEhlaWdodCwgaCk7XG4gICAgICAgIH1cbiAgICAgICAgRmxleFV0aWxzLnNldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgZmFsc2UsIGgpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNaW5TaXplU2V0dGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1pblNpemVTZXR0aW5nKCF0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01heFNpemVTZXR0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWF4U2l6ZVNldHRpbmcoIXRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNNYXhTaXplU2V0dGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1heFNpemVTZXR0aW5nKHRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0TWluU2l6ZVNldHRpbmcoaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbkhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRNYXhTaXplU2V0dGluZyhob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF4V2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWF4SGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRBeGlzTWluU2l6ZSh0aGlzLml0ZW0sIHRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRBeGlzTWluU2l6ZSh0aGlzLml0ZW0sICF0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sIHRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0TWFpbkF4aXNMYXlvdXRQb3MoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFBvcyh0aGlzLml0ZW0sIHRoaXMuY3RyLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfc2V0TWFpbkF4aXNMYXlvdXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuc2V0QXhpc0xheW91dFBvcyh0aGlzLml0ZW0sIHRoaXMuY3RyLl9ob3Jpem9udGFsLCBwb3MpO1xuICAgIH1cblxuICAgIF9zZXRDcm9zc0F4aXNMYXlvdXRQb3MocG9zKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuc2V0QXhpc0xheW91dFBvcyh0aGlzLml0ZW0sICF0aGlzLmN0ci5faG9yaXpvbnRhbCwgcG9zKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sICF0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX3Jlc2l6ZUNyb3NzQXhpcyhzaXplKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMucmVzaXplQXhpcyh0aGlzLml0ZW0sICF0aGlzLmN0ci5faG9yaXpvbnRhbCwgc2l6ZSk7XG4gICAgfVxuXG4gICAgX3Jlc2l6ZU1haW5BeGlzKHNpemUpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5yZXNpemVBeGlzKHRoaXMuaXRlbSwgdGhpcy5jdHIuX2hvcml6b250YWwsIHNpemUpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc1BhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0VG90YWxQYWRkaW5nKHRoaXMuaXRlbSwgdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNQYWRkaW5nKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFRvdGFsUGFkZGluZyh0aGlzLml0ZW0sICF0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFRvdGFsTWFyZ2luKHRoaXMuaXRlbSwgdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0VG90YWxNYXJnaW4odGhpcy5pdGVtLCAhdGhpcy5jdHIuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9nZXRIb3Jpem9udGFsTWFyZ2luT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldE1hcmdpbk9mZnNldCh0aGlzLml0ZW0sIHRydWUpO1xuICAgIH1cblxuICAgIF9nZXRWZXJ0aWNhbE1hcmdpbk9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRNYXJnaW5PZmZzZXQodGhpcy5pdGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTWluU2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWFpbkF4aXNNaW5TaXplKCkgKyB0aGlzLl9nZXRNYWluQXhpc1BhZGRpbmcoKSArIHRoaXMuX2dldE1haW5BeGlzTWFyZ2luKCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01pblNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENyb3NzQXhpc01pblNpemUoKSArIHRoaXMuX2dldENyb3NzQXhpc1BhZGRpbmcoKSArIHRoaXMuX2dldENyb3NzQXhpc01hcmdpbigpO1xuICAgIH1cblxuICAgIF9nZXRNYWluQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpICsgdGhpcy5fZ2V0TWFpbkF4aXNQYWRkaW5nKCkgKyB0aGlzLl9nZXRNYWluQXhpc01hcmdpbigpO1xuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDcm9zc0F4aXNMYXlvdXRTaXplKCkgKyB0aGlzLl9nZXRDcm9zc0F4aXNQYWRkaW5nKCkgKyB0aGlzLl9nZXRDcm9zc0F4aXNNYXJnaW4oKTtcbiAgICB9XG5cbiAgICBfaGFzRml4ZWRDcm9zc0F4aXNTaXplKCkge1xuICAgICAgICByZXR1cm4gIUZsZXhVdGlscy5pc1plcm9BeGlzU2l6ZSh0aGlzLml0ZW0sICF0aGlzLmN0ci5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgX2hhc1JlbENyb3NzQXhpc1NpemUoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmN0ci5faG9yaXpvbnRhbCA/IHRoaXMuaXRlbS5mdW5jSCA6IHRoaXMuaXRlbS5mdW5jVyk7XG4gICAgfVxuXG59XG5cblxuRmxleEl0ZW0uU0hSSU5LX0FVVE8gPSAtMTtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBGbGV4Q29udGFpbmVyIGZyb20gXCIuL0ZsZXhDb250YWluZXIubWpzXCI7XG5pbXBvcnQgRmxleEl0ZW0gZnJvbSBcIi4vRmxleEl0ZW0ubWpzXCI7XG5pbXBvcnQgRmxleFV0aWxzIGZyb20gXCIuL0ZsZXhVdGlscy5tanNcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb25uZWN0aW9uIGJldHdlZW4gdGhlIHJlbmRlciB0cmVlIHdpdGggdGhlIGxheW91dCB0cmVlIG9mIHRoaXMgZmxleCBjb250YWluZXIvaXRlbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxleFRhcmdldCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgKG9ubHkgaW4gY2FzZSBvZiBjb250YWluZXIpOlxuICAgICAgICAgKiBiaXQgMDogaGFzIGNoYW5nZWQgb3IgY29udGFpbnMgaXRlbXMgd2l0aCBjaGFuZ2VzXG4gICAgICAgICAqIGJpdCAxOiB3aWR0aCBjaGFuZ2VkXG4gICAgICAgICAqIGJpdCAyOiBoZWlnaHQgY2hhbmdlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVjYWxjID0gMDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLncgPSAwO1xuICAgICAgICB0aGlzLmggPSAwO1xuXG4gICAgICAgIHRoaXMuX29yaWdpbmFsWCA9IDA7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsWSA9IDA7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsV2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9vcmlnaW5hbEhlaWdodCA9IDA7XG5cbiAgICAgICAgdGhpcy5fZmxleCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZsZXhJdGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZmxleEl0ZW1EaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgZmxleExheW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxleCA/IHRoaXMuZmxleC5fbGF5b3V0IDogbnVsbDtcbiAgICB9XG5cbiAgICBsYXlvdXRGbGV4VHJlZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGbGV4RW5hYmxlZCgpICYmIHRoaXMuaXNDaGFuZ2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZmxleExheW91dC5sYXlvdXRUcmVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICAgIH1cblxuICAgIGdldCBmbGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxleDtcbiAgICB9XG5cbiAgICBzZXQgZmxleCh2KSB7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUZsZXgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVGbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9mbGV4LnBhdGNoKHYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZsZXhJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5fZmxleEl0ZW1EaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vuc3VyZUZsZXhJdGVtKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGV4SXRlbTtcbiAgICB9XG5cbiAgICBzZXQgZmxleEl0ZW0odikge1xuICAgICAgICBpZiAodiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZmxleEl0ZW1EaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmxleFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbGV4SXRlbURpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja0VuYWJsZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5fY2xlYXJGbGV4SXRlbXNDYWNoZSgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZW5zdXJlRmxleEl0ZW0oKTtcblxuICAgICAgICAgICAgdGhpcy5fZmxleEl0ZW0ucGF0Y2godik7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9mbGV4SXRlbURpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmxleEl0ZW1EaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrRW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmxleFBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5fY2xlYXJGbGV4SXRlbXNDYWNoZSgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2VuYWJsZUZsZXgoKSB7XG4gICAgICAgIHRoaXMuX2ZsZXggPSBuZXcgRmxleENvbnRhaW5lcih0aGlzKTtcbiAgICAgICAgdGhpcy5fY2hlY2tFbmFibGVkKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZERpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5fZW5hYmxlQ2hpbGRyZW5Bc0ZsZXhJdGVtcygpO1xuICAgIH1cblxuICAgIF9kaXNhYmxlRmxleCgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VkRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl9mbGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hlY2tFbmFibGVkKCk7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVDaGlsZHJlbkFzRmxleEl0ZW1zKCk7XG4gICAgfVxuXG4gICAgX2VuYWJsZUNoaWxkcmVuQXNGbGV4SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fdGFyZ2V0Ll9jaGlsZHJlbjtcbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGQubGF5b3V0Ll9lbmFibGVGbGV4SXRlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rpc2FibGVDaGlsZHJlbkFzRmxleEl0ZW1zKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX3RhcmdldC5fY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkLmxheW91dC5fZGlzYWJsZUZsZXhJdGVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZW5hYmxlRmxleEl0ZW0oKSB7XG4gICAgICAgIHRoaXMuX2Vuc3VyZUZsZXhJdGVtKCk7XG4gICAgICAgIGNvbnN0IGZsZXhQYXJlbnQgPSB0aGlzLl90YXJnZXQuX3BhcmVudC5fbGF5b3V0O1xuICAgICAgICB0aGlzLl9mbGV4SXRlbS5jdHIgPSBmbGV4UGFyZW50Ll9mbGV4O1xuICAgICAgICBmbGV4UGFyZW50LmNoYW5nZWRDb250ZW50cygpO1xuICAgICAgICB0aGlzLl9jaGVja0VuYWJsZWQoKTtcbiAgICB9XG5cbiAgICBfZGlzYWJsZUZsZXhJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5fZmxleEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsZXhJdGVtLmN0ciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBrZWVwIHRoZSBmbGV4SXRlbSBvYmplY3QgYmVjYXVzZSBpdCBtYXkgY29udGFpbiBjdXN0b20gc2V0dGluZ3MuXG4gICAgICAgIHRoaXMuX2NoZWNrRW5hYmxlZCgpO1xuXG4gICAgICAgIC8vIE9mZnNldHMgaGF2ZSBiZWVuIGNoYW5nZWQuIFdlIGNhbid0IHJlY292ZXIgdGhlbSwgc28gd2UnbGwganVzdCBjbGVhciB0aGVtIGluc3RlYWQuXG4gICAgICAgIHRoaXMuX3Jlc2V0T2Zmc2V0cygpO1xuICAgIH1cblxuICAgIF9yZXNldE9mZnNldHMoKSB7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgfVxuXG4gICAgX2Vuc3VyZUZsZXhJdGVtKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZsZXhJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9mbGV4SXRlbSA9IG5ldyBGbGV4SXRlbSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jaGVja0VuYWJsZWQoKSB7XG4gICAgICAgIGNvbnN0IGVuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZCgpO1xuICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCAhPT0gZW5hYmxlZCkge1xuICAgICAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgX2VuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5fc2V0dXBUYXJnZXRGb3JGbGV4KCk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5lbmFibGVGbGV4TGF5b3V0KCk7XG4gICAgfVxuXG4gICAgX2Rpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX3Jlc3RvcmVUYXJnZXRUb05vbkZsZXgoKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmRpc2FibGVGbGV4TGF5b3V0KCk7XG4gICAgfVxuXG4gICAgaXNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZsZXhFbmFibGVkKCkgfHwgdGhpcy5pc0ZsZXhJdGVtRW5hYmxlZCgpO1xuICAgIH1cblxuICAgIGlzRmxleEVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGV4ICE9PSBudWxsO1xuICAgIH1cblxuICAgIGlzRmxleEl0ZW1FbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGV4UGFyZW50ICE9PSBudWxsO1xuICAgIH1cblxuICAgIF9yZXN0b3JlVGFyZ2V0VG9Ob25GbGV4KCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgIHRhcmdldC54ID0gdGhpcy5fb3JpZ2luYWxYO1xuICAgICAgICB0YXJnZXQueSA9IHRoaXMuX29yaWdpbmFsWTtcbiAgICAgICAgdGFyZ2V0LnNldERpbWVuc2lvbnModGhpcy5fb3JpZ2luYWxXaWR0aCwgdGhpcy5fb3JpZ2luYWxIZWlnaHQpO1xuICAgIH1cblxuICAgIF9zZXR1cFRhcmdldEZvckZsZXgoKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldDtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxYID0gdGFyZ2V0Ll94O1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFkgPSB0YXJnZXQuX3k7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsV2lkdGggPSB0YXJnZXQuX3c7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsSGVpZ2h0ID0gdGFyZ2V0Ll9oO1xuICAgIH1cbiAgICBcbiAgICBzZXRQYXJlbnQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gJiYgZnJvbS5pc0ZsZXhDb250YWluZXIoKSkge1xuICAgICAgICAgICAgZnJvbS5fbGF5b3V0Ll9jaGFuZ2VkQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0byAmJiB0by5pc0ZsZXhDb250YWluZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlRmxleEl0ZW0oKTtcbiAgICAgICAgICAgIHRvLl9sYXlvdXQuX2NoYW5nZWRDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoZWNrRW5hYmxlZCgpO1xuICAgIH1cblxuICAgIGdldCBmbGV4UGFyZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fZmxleEl0ZW1EaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl90YXJnZXQuX3BhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuaXNGbGV4Q29udGFpbmVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuX2xheW91dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXRWaXNpYmxlKHYpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5mbGV4UGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQuX2NoYW5nZWRDaGlsZHJlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2l0ZW1zKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IHRoaXMuX2dldEZsZXhJdGVtcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgICB9XG5cbiAgICBfZ2V0RmxleEl0ZW1zKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX3RhcmdldC5fY2hpbGRyZW47XG4gICAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udmlzaWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pc0ZsZXhJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbS5sYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG5cbiAgICBfY2hhbmdlZENoaWxkcmVuKCkge1xuICAgICAgICB0aGlzLl9jbGVhckZsZXhJdGVtc0NhY2hlKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZENvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgX2NsZWFyRmxleEl0ZW1zQ2FjaGUoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICB9XG5cbiAgICBzZXRMYXlvdXQoeCwgeSwgdywgaCkge1xuICAgICAgICBsZXQgb3JpZ2luYWxYID0gdGhpcy5fb3JpZ2luYWxYO1xuICAgICAgICBsZXQgb3JpZ2luYWxZID0gdGhpcy5fb3JpZ2luYWxZO1xuICAgICAgICBpZiAodGhpcy5mdW5jWCkge1xuICAgICAgICAgICAgb3JpZ2luYWxYID0gdGhpcy5mdW5jWChGbGV4VXRpbHMuZ2V0UGFyZW50QXhpc1NpemVXaXRoUGFkZGluZyh0aGlzLCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnVuY1kpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsWSA9IHRoaXMuZnVuY1koRmxleFV0aWxzLmdldFBhcmVudEF4aXNTaXplV2l0aFBhZGRpbmcodGhpcywgZmFsc2UpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzRmxleEl0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNldExheW91dCh4ICsgb3JpZ2luYWxYLCB5ICsgb3JpZ2luYWxZLCB3LCBoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldXNlIHRoZSB4LHkgJ3NldHRpbmdzJy5cbiAgICAgICAgICAgIHRoaXMudGFyZ2V0LnNldExheW91dChvcmlnaW5hbFgsIG9yaWdpbmFsWSwgdywgaCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGFuZ2VkRGltZW5zaW9ucyhjaGFuZ2VXaWR0aCA9IHRydWUsIGNoYW5nZUhlaWdodCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVjYWxjKGNoYW5nZVdpZHRoLCBjaGFuZ2VIZWlnaHQpO1xuICAgIH1cblxuICAgIGNoYW5nZWRDb250ZW50cygpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlUmVjYWxjKCk7XG4gICAgfVxuXG4gICAgZm9yY2VMYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlY2FsYygpO1xuICAgIH1cblxuICAgIGlzQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlY2FsYyA+IDA7XG4gICAgfVxuXG4gICAgX3VwZGF0ZVJlY2FsYyhjaGFuZ2VFeHRlcm5hbFdpZHRoID0gZmFsc2UsIGNoYW5nZUV4dGVybmFsSGVpZ2h0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLl9mbGV4Ll9sYXlvdXQ7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gc29tZXRoaW5nIGludGVybmFsIGNoYW5nZXMsIGl0IGNhbiBoYXZlIGVmZmVjdCBvbiB0aGUgZXh0ZXJuYWwgZGltZW5zaW9ucy5cbiAgICAgICAgICAgIGNoYW5nZUV4dGVybmFsV2lkdGggPSBjaGFuZ2VFeHRlcm5hbFdpZHRoIHx8IGxheW91dC5pc0F4aXNGaXRUb0NvbnRlbnRzKHRydWUpO1xuICAgICAgICAgICAgY2hhbmdlRXh0ZXJuYWxIZWlnaHQgPSBjaGFuZ2VFeHRlcm5hbEhlaWdodCB8fCBsYXlvdXQuaXNBeGlzRml0VG9Db250ZW50cyhmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWNhbGMgPSAxICsgKGNoYW5nZUV4dGVybmFsV2lkdGggPyAyIDogMCkgKyAoY2hhbmdlRXh0ZXJuYWxIZWlnaHQgPyA0IDogMCk7XG4gICAgICAgIGNvbnN0IG5ld1JlY2FsY0ZsYWdzID0gdGhpcy5nZXROZXdSZWNhbGNGbGFncyhyZWNhbGMpO1xuICAgICAgICB0aGlzLl9yZWNhbGMgfD0gcmVjYWxjO1xuICAgICAgICBpZiAobmV3UmVjYWxjRmxhZ3MgPiAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mbGV4UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGV4UGFyZW50Ll91cGRhdGVSZWNhbGNCb3R0b21VcChyZWNhbGMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQudHJpZ2dlckxheW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnRyaWdnZXJMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldE5ld1JlY2FsY0ZsYWdzKGZsYWdzKSB7XG4gICAgICAgIHJldHVybiAoNyAtIHRoaXMuX3JlY2FsYykgJiBmbGFncztcbiAgICB9XG5cbiAgICBfdXBkYXRlUmVjYWxjQm90dG9tVXAoY2hpbGRSZWNhbGMpIHtcbiAgICAgICAgY29uc3QgbmV3UmVjYWxjID0gdGhpcy5fZ2V0UmVjYWxjRnJvbUNoYW5nZWRDaGlsZFJlY2FsYyhjaGlsZFJlY2FsYyk7XG4gICAgICAgIGNvbnN0IG5ld1JlY2FsY0ZsYWdzID0gdGhpcy5nZXROZXdSZWNhbGNGbGFncyhuZXdSZWNhbGMpO1xuICAgICAgICB0aGlzLl9yZWNhbGMgfD0gbmV3UmVjYWxjO1xuICAgICAgICBpZiAobmV3UmVjYWxjRmxhZ3MgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBmbGV4UGFyZW50ID0gdGhpcy5mbGV4UGFyZW50O1xuICAgICAgICAgICAgaWYgKGZsZXhQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBmbGV4UGFyZW50Ll91cGRhdGVSZWNhbGNCb3R0b21VcChuZXdSZWNhbGMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQudHJpZ2dlckxheW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnRyaWdnZXJMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRSZWNhbGNGcm9tQ2hhbmdlZENoaWxkUmVjYWxjKGNoaWxkUmVjYWxjKSB7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMuX2ZsZXguX2xheW91dDtcblxuICAgICAgICBjb25zdCBtYWluQXhpc1JlY2FsY0ZsYWcgPSBsYXlvdXQuX2hvcml6b250YWwgPyAxIDogMjtcbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzUmVjYWxjRmxhZyA9IGxheW91dC5faG9yaXpvbnRhbCA/IDIgOiAxO1xuXG4gICAgICAgIGNvbnN0IGNyb3NzQXhpc0RpbWVuc2lvbnNDaGFuZ2VkSW5DaGlsZCA9IChjaGlsZFJlY2FsYyAmIGNyb3NzQXhpc1JlY2FsY0ZsYWcpO1xuICAgICAgICBpZiAoIWNyb3NzQXhpc0RpbWVuc2lvbnNDaGFuZ2VkSW5DaGlsZCkge1xuICAgICAgICAgICAgY29uc3QgbWFpbkF4aXNEaW1lbnNpb25zQ2hhbmdlZEluQ2hpbGQgPSAoY2hpbGRSZWNhbGMgJiBtYWluQXhpc1JlY2FsY0ZsYWcpO1xuICAgICAgICAgICAgaWYgKG1haW5BeGlzRGltZW5zaW9uc0NoYW5nZWRJbkNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFpbkF4aXNJc1dyYXBwaW5nID0gbGF5b3V0LmlzV3JhcHBpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAobWFpbkF4aXNJc1dyYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyb3NzQXhpc0lzRml0VG9Db250ZW50cyA9IGxheW91dC5pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyb3NzQXhpc0lzRml0VG9Db250ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBkdWUgdG8gd3JhcHBpbmcsIHRoZSBjcm9zcyBheGlzIHNpemUgbWF5IGJlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZFJlY2FsYyArPSBjcm9zc0F4aXNSZWNhbGNGbGFnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzV2lkdGhEeW5hbWljID0gbGF5b3V0LmlzQXhpc0ZpdFRvQ29udGVudHModHJ1ZSk7XG4gICAgICAgIGxldCBpc0hlaWdodER5bmFtaWMgPSBsYXlvdXQuaXNBeGlzRml0VG9Db250ZW50cyhmYWxzZSk7XG5cbiAgICAgICAgaWYgKGxheW91dC5zaHJ1bmspIHtcbiAgICAgICAgICAgIC8vIElmIGR1cmluZyBwcmV2aW91cyBsYXlvdXQgdGhpcyBjb250YWluZXIgd2FzICdzaHJ1bmsnLCBhbnkgY2hhbmdlcyBtYXkgY2hhbmdlIHRoZSAnbWluIGF4aXMgc2l6ZScgb2YgdGhlXG4gICAgICAgICAgICAvLyBjb250ZW50cywgbGVhZGluZyB0byBhIGRpZmZlcmVudCBheGlzIHNpemUgb24gdGhpcyBjb250YWluZXIgZXZlbiB3aGVuIGl0IHdhcyBub3QgJ2ZpdCB0byBjb250ZW50cycuXG4gICAgICAgICAgICBpZiAobGF5b3V0Ll9ob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgaXNXaWR0aER5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc0hlaWdodER5bmFtaWMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbG9jYWxSZWNhbGMgPSAxICsgKGlzV2lkdGhEeW5hbWljID8gMiA6IDApICsgKGlzSGVpZ2h0RHluYW1pYyA/IDQgOiAwKTtcblxuICAgICAgICBjb25zdCBjb21iaW5lZFJlY2FsYyA9IGNoaWxkUmVjYWxjICYgbG9jYWxSZWNhbGM7XG4gICAgICAgIHJldHVybiBjb21iaW5lZFJlY2FsYztcbiAgICB9XG5cbiAgICBnZXQgcmVjYWxjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjYWxjO1xuICAgIH1cblxuICAgIGNsZWFyUmVjYWxjRmxhZygpIHtcbiAgICAgICAgdGhpcy5fcmVjYWxjID0gMDtcbiAgICB9XG5cbiAgICBlbmFibGVMb2NhbFJlY2FsY0ZsYWcoKSB7XG4gICAgICAgIHRoaXMuX3JlY2FsYyA9IDE7XG4gICAgfVxuXG4gICAgZ2V0IG9yaWdpbmFsWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsWDtcbiAgICB9XG5cbiAgICBzZXRPcmlnaW5hbFhXaXRob3V0VXBkYXRpbmdMYXlvdXQodikge1xuICAgICAgICB0aGlzLl9vcmlnaW5hbFggPSB2O1xuICAgIH1cblxuICAgIGdldCBvcmlnaW5hbFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFk7XG4gICAgfVxuXG4gICAgc2V0T3JpZ2luYWxZV2l0aG91dFVwZGF0aW5nTGF5b3V0KHYpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxZID0gdjtcbiAgICB9XG5cbiAgICBnZXQgb3JpZ2luYWxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsV2lkdGg7XG4gICAgfVxuXG4gICAgc2V0IG9yaWdpbmFsV2lkdGgodikge1xuICAgICAgICBpZiAodGhpcy5fb3JpZ2luYWxXaWR0aCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxXaWR0aCA9IHY7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWREaW1lbnNpb25zKHRydWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBvcmlnaW5hbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsSGVpZ2h0O1xuICAgIH1cblxuICAgIHNldCBvcmlnaW5hbEhlaWdodCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEhlaWdodCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxIZWlnaHQgPSB2O1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkRGltZW5zaW9ucyhmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZnVuY1goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQuZnVuY1g7XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0LmZ1bmNZO1xuICAgIH1cblxuICAgIGdldCBmdW5jVygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldC5mdW5jVztcbiAgICB9XG5cbiAgICBnZXQgZnVuY0goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQuZnVuY0g7XG4gICAgfVxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxleFV0aWxzIHtcblxuICAgIHN0YXRpYyBnZXRQYXJlbnRBeGlzU2l6ZVdpdGhQYWRkaW5nKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaXRlbS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRhcmdldC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmxleFBhcmVudCA9IGl0ZW0uZmxleFBhcmVudDtcbiAgICAgICAgICAgIGlmIChmbGV4UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHBlbmRpbmcgbGF5b3V0IHNpemUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXhpc0xheW91dFNpemUoZmxleFBhcmVudCwgaG9yaXpvbnRhbCkgKyB0aGlzLmdldFRvdGFsUGFkZGluZyhmbGV4UGFyZW50LCBob3Jpem9udGFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlICdhYnNvbHV0ZScgc2l6ZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gaG9yaXpvbnRhbCA/IHBhcmVudC53IDogcGFyZW50Lmg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UmVsQXhpc1NpemUoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZnVuY1cpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWxsb3dSZWxBeGlzU2l6ZUZ1bmN0aW9uKGl0ZW0sIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmZ1bmNXKHRoaXMuZ2V0UGFyZW50QXhpc1NpemVXaXRoUGFkZGluZyhpdGVtLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5vcmlnaW5hbFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZnVuY0gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWxsb3dSZWxBeGlzU2l6ZUZ1bmN0aW9uKGl0ZW0sIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5mdW5jSCh0aGlzLmdldFBhcmVudEF4aXNTaXplV2l0aFBhZGRpbmcoaXRlbSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLm9yaWdpbmFsSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIF9hbGxvd1JlbEF4aXNTaXplRnVuY3Rpb24oaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBjb25zdCBmbGV4UGFyZW50ID0gaXRlbS5mbGV4UGFyZW50O1xuICAgICAgICBpZiAoZmxleFBhcmVudCAmJiBmbGV4UGFyZW50Ll9mbGV4Ll9sYXlvdXQuaXNBeGlzRml0VG9Db250ZW50cyhob3Jpem9udGFsKSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWxsb3cgcmVsYXRpdmUgd2lkdGggb24gZml0LXRvLWNvbnRlbnRzIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZmxpY3RzLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1plcm9BeGlzU2l6ZShpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gIWl0ZW0ub3JpZ2luYWxXaWR0aCAmJiAhaXRlbS5mdW5jVztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAhaXRlbS5vcmlnaW5hbEhlaWdodCAmJiAhaXRlbS5mdW5jSDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBeGlzTGF5b3V0UG9zKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIGhvcml6b250YWwgPyBpdGVtLnggOiBpdGVtLnk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEF4aXNMYXlvdXRTaXplKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgcmV0dXJuIGhvcml6b250YWwgPyBpdGVtLncgOiBpdGVtLmg7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldEF4aXNMYXlvdXRQb3MoaXRlbSwgaG9yaXpvbnRhbCwgcG9zKSB7XG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICBpdGVtLnggPSBwb3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdGVtLnkgPSBwb3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgc2V0QXhpc0xheW91dFNpemUoaXRlbSwgaG9yaXpvbnRhbCwgc2l6ZSkge1xuICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaXRlbS53ID0gc2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0uaCA9IHNpemU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QXhpc01pblNpemUoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBsZXQgbWluU2l6ZSA9IHRoaXMuZ2V0UGxhaW5BeGlzTWluU2l6ZShpdGVtLCBob3Jpem9udGFsKTtcblxuICAgICAgICBsZXQgZmxleEl0ZW1NaW5TaXplID0gMDtcbiAgICAgICAgaWYgKGl0ZW0uaXNGbGV4SXRlbUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgZmxleEl0ZW1NaW5TaXplID0gaXRlbS5fZmxleEl0ZW0uX2dldE1pblNpemVTZXR0aW5nKGhvcml6b250YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFzTGltaXRlZE1pblNpemUgPSAoZmxleEl0ZW1NaW5TaXplID4gMCk7XG4gICAgICAgIGlmIChoYXNMaW1pdGVkTWluU2l6ZSkge1xuICAgICAgICAgICAgbWluU2l6ZSA9IE1hdGgubWF4KG1pblNpemUsIGZsZXhJdGVtTWluU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pblNpemU7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFBsYWluQXhpc01pblNpemUoaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaXRlbS5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLl9mbGV4Ll9sYXlvdXQuZ2V0QXhpc01pblNpemUoaG9yaXpvbnRhbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpc1Nocmlua2FibGUgPSAoaXRlbS5mbGV4SXRlbS5zaHJpbmsgIT09IDApO1xuICAgICAgICAgICAgaWYgKGlzU2hyaW5rYWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWxBeGlzU2l6ZShpdGVtLCBob3Jpem9udGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyByZXNpemVBeGlzKGl0ZW0sIGhvcml6b250YWwsIHNpemUpIHtcbiAgICAgICAgaWYgKGl0ZW0uaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBpc01haW5BeGlzID0gKGl0ZW0uX2ZsZXguX2hvcml6b250YWwgPT09IGhvcml6b250YWwpO1xuICAgICAgICAgICAgaWYgKGlzTWFpbkF4aXMpIHtcbiAgICAgICAgICAgICAgICBpdGVtLl9mbGV4Ll9sYXlvdXQucmVzaXplTWFpbkF4aXMoc2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZW0uX2ZsZXguX2xheW91dC5yZXNpemVDcm9zc0F4aXMoc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEF4aXNMYXlvdXRTaXplKGl0ZW0sIGhvcml6b250YWwsIHNpemUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBzdGF0aWMgZ2V0UGFkZGluZ09mZnNldChpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpdGVtLmlzRmxleEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgY29uc3QgZmxleCA9IGl0ZW0uX2ZsZXg7XG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4LnBhZGRpbmdMZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleC5wYWRkaW5nVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VG90YWxQYWRkaW5nKGl0ZW0sIGhvcml6b250YWwpIHtcbiAgICAgICAgaWYgKGl0ZW0uaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBmbGV4ID0gaXRlbS5fZmxleDtcbiAgICAgICAgICAgIGlmIChob3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXgucGFkZGluZ1JpZ2h0ICsgZmxleC5wYWRkaW5nTGVmdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZsZXgucGFkZGluZ1RvcCArIGZsZXgucGFkZGluZ0JvdHRvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE1hcmdpbk9mZnNldChpdGVtLCBob3Jpem9udGFsKSB7XG4gICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcbiAgICAgICAgaWYgKGZsZXhJdGVtKSB7XG4gICAgICAgICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbGV4SXRlbS5tYXJnaW5MZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleEl0ZW0ubWFyZ2luVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VG90YWxNYXJnaW4oaXRlbSwgaG9yaXpvbnRhbCkge1xuICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG4gICAgICAgIGlmIChmbGV4SXRlbSkge1xuICAgICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleEl0ZW0ubWFyZ2luUmlnaHQgKyBmbGV4SXRlbS5tYXJnaW5MZWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxleEl0ZW0ubWFyZ2luVG9wICsgZmxleEl0ZW0ubWFyZ2luQm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTcGFjaW5nQ2FsY3VsYXRvciBmcm9tIFwiLi9TcGFjaW5nQ2FsY3VsYXRvci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29udGVudEFsaWduZXIge1xuXG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIHRoaXMuX2xheW91dCA9IGxheW91dDtcbiAgICAgICAgdGhpcy5fdG90YWxDcm9zc0F4aXNTaXplID0gMDtcbiAgICB9XG5cbiAgICBnZXQgX2xpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Ll9saW5lcztcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl90b3RhbENyb3NzQXhpc1NpemUgPSB0aGlzLl9nZXRUb3RhbENyb3NzQXhpc1NpemUoKTtcbiAgICB9XG5cbiAgICBhbGlnbigpIHtcbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzU2l6ZSA9IHRoaXMuX2xheW91dC5jcm9zc0F4aXNTaXplO1xuICAgICAgICBjb25zdCByZW1haW5pbmdTcGFjZSA9IGNyb3NzQXhpc1NpemUgLSB0aGlzLl90b3RhbENyb3NzQXhpc1NpemU7XG5cbiAgICAgICAgY29uc3Qge3NwYWNpbmdCZWZvcmUsIHNwYWNpbmdCZXR3ZWVufSA9IHRoaXMuX2dldFNwYWNpbmcocmVtYWluaW5nU3BhY2UpO1xuXG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy5fbGluZXM7XG5cbiAgICAgICAgY29uc3QgbW9kZSA9IHRoaXMuX2xheW91dC5fZmxleENvbnRhaW5lci5hbGlnbkNvbnRlbnQ7XG4gICAgICAgIGxldCBncm93U2l6ZSA9IDA7XG4gICAgICAgIGlmIChtb2RlID09PSBcInN0cmV0Y2hcIiAmJiBsaW5lcy5sZW5ndGggJiYgKHJlbWFpbmluZ1NwYWNlID4gMCkpIHtcbiAgICAgICAgICAgIGdyb3dTaXplID0gcmVtYWluaW5nU3BhY2UgLyBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudFBvcyA9IHNwYWNpbmdCZWZvcmU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjcm9zc0F4aXNMYXlvdXRPZmZzZXQgPSBjdXJyZW50UG9zO1xuICAgICAgICAgICAgY29uc3QgYWxpZ25lciA9IGxpbmVzW2ldLmNyZWF0ZUl0ZW1BbGlnbmVyKCk7XG5cbiAgICAgICAgICAgIGxldCBmaW5hbENyb3NzQXhpc0xheW91dFNpemUgPSBsaW5lc1tpXS5jcm9zc0F4aXNMYXlvdXRTaXplICsgZ3Jvd1NpemU7XG5cbiAgICAgICAgICAgIGFsaWduZXIuc2V0Q3Jvc3NBeGlzTGF5b3V0U2l6ZShmaW5hbENyb3NzQXhpc0xheW91dFNpemUpO1xuICAgICAgICAgICAgYWxpZ25lci5zZXRDcm9zc0F4aXNMYXlvdXRPZmZzZXQoY3Jvc3NBeGlzTGF5b3V0T2Zmc2V0KTtcblxuICAgICAgICAgICAgYWxpZ25lci5hbGlnbigpO1xuXG4gICAgICAgICAgICBpZiAoYWxpZ25lci5yZWN1cnNpdmVSZXNpemVPY2N1cmVkKSB7XG4gICAgICAgICAgICAgICAgbGluZXNbaV0uc2V0SXRlbVBvc2l0aW9ucygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IGZpbmFsQ3Jvc3NBeGlzTGF5b3V0U2l6ZTtcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gc3BhY2luZ0JldHdlZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdG90YWxDcm9zc0F4aXNTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxDcm9zc0F4aXNTaXplO1xuICAgIH1cblxuICAgIF9nZXRUb3RhbENyb3NzQXhpc1NpemUoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy5fbGluZXM7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgICAgICB0b3RhbCArPSBsaW5lLmNyb3NzQXhpc0xheW91dFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH1cblxuICAgIF9nZXRTcGFjaW5nKHJlbWFpbmluZ1NwYWNlKSB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLl9sYXlvdXQuX2ZsZXhDb250YWluZXIuYWxpZ25Db250ZW50O1xuICAgICAgICBjb25zdCBudW1iZXJPZkl0ZW1zID0gdGhpcy5fbGluZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gU3BhY2luZ0NhbGN1bGF0b3IuZ2V0U3BhY2luZyhtb2RlLCBudW1iZXJPZkl0ZW1zLCByZW1haW5pbmdTcGFjZSk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29udGVudEFsaWduZXIgZnJvbSBcIi4vQ29udGVudEFsaWduZXIubWpzXCI7XG5pbXBvcnQgRmxleFV0aWxzIGZyb20gXCIuLi9GbGV4VXRpbHMubWpzXCI7XG5pbXBvcnQgTGluZUxheW91dGVyIGZyb20gXCIuL0xpbmVMYXlvdXRlci5tanNcIjtcbmltcG9ydCBJdGVtQ29vcmRpbmF0ZXNVcGRhdGVyIGZyb20gXCIuL0l0ZW1Db29yZGluYXRlc1VwZGF0ZXIubWpzXCI7XG5cbi8qKlxuICogTGF5b3V0cyBhIGZsZXggY29udGFpbmVyIChhbmQgZGVzY2VuZGFudHMpLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGbGV4TGF5b3V0IHtcblxuICAgIGNvbnN0cnVjdG9yKGZsZXhDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5fZmxleENvbnRhaW5lciA9IGZsZXhDb250YWluZXI7XG5cbiAgICAgICAgdGhpcy5fbGluZUxheW91dGVyID0gbmV3IExpbmVMYXlvdXRlcih0aGlzKTtcblxuICAgICAgICB0aGlzLl9yZXNpemluZ01haW5BeGlzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nQ3Jvc3NBeGlzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fY2FjaGVkTWFpbkF4aXNTaXplQWZ0ZXJMYXlvdXQgPSAwO1xuICAgICAgICB0aGlzLl9jYWNoZWRDcm9zc0F4aXNTaXplQWZ0ZXJMYXlvdXQgPSAwO1xuXG4gICAgICAgIHRoaXMuX3NocnVuayA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBzaHJ1bmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaHJ1bms7XG4gICAgfVxuXG4gICAgZ2V0IHJlY2FsYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5yZWNhbGM7XG4gICAgfVxuXG4gICAgbGF5b3V0VHJlZSgpIHtcbiAgICAgICAgY29uc3QgaXNTdWJUcmVlID0gKHRoaXMuaXRlbS5mbGV4UGFyZW50ICE9PSBudWxsKTtcbiAgICAgICAgaWYgKGlzU3ViVHJlZSkge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBkaW1lbnNpb25zIHNldCBieSB0aGUgcGFyZW50IGZsZXggdHJlZS5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN1YlRyZWVMYXlvdXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJlZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlSXRlbUNvb3JkcygpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRyZWVMYXlvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY2FsYykge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZUxheW91dFRyZWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVMYXlvdXRUcmVlRnJvbUNhY2hlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcGVyZm9ybVVwZGF0ZUxheW91dFRyZWUoKSB7XG4gICAgICAgIHRoaXMuX3NldEluaXRpYWxBeGlzU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5fbGF5b3V0QXhlcygpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoTGF5b3V0Q2FjaGUoKTtcbiAgICB9XG5cbiAgICBfcmVmcmVzaExheW91dENhY2hlKCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRNYWluQXhpc1NpemVBZnRlckxheW91dCA9IHRoaXMubWFpbkF4aXNTaXplO1xuICAgICAgICB0aGlzLl9jYWNoZWRDcm9zc0F4aXNTaXplQWZ0ZXJMYXlvdXQgPSB0aGlzLmNyb3NzQXhpc1NpemU7XG4gICAgfVxuXG4gICAgX3BlcmZvcm1VcGRhdGVMYXlvdXRUcmVlRnJvbUNhY2hlKCkge1xuICAgICAgICBjb25zdCBzaXplTWlnaHRIYXZlQ2hhbmdlZCA9ICh0aGlzLml0ZW0uZnVuY1cgfHwgdGhpcy5pdGVtLmZ1bmNIKTtcbiAgICAgICAgaWYgKHNpemVNaWdodEhhdmVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYWZ0ZXIgYWxsLlxuICAgICAgICAgICAgdGhpcy5pdGVtLmVuYWJsZUxvY2FsUmVjYWxjRmxhZygpO1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZUxheW91dFRyZWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFpbkF4aXNTaXplID0gdGhpcy5fY2FjaGVkTWFpbkF4aXNTaXplQWZ0ZXJMYXlvdXQ7XG4gICAgICAgICAgICB0aGlzLmNyb3NzQXhpc1NpemUgPSB0aGlzLl9jYWNoZWRDcm9zc0F4aXNTaXplQWZ0ZXJMYXlvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVJdGVtQ29vcmRzKCkge1xuICAgICAgICBjb25zdCB1cGRhdGVyID0gbmV3IEl0ZW1Db29yZGluYXRlc1VwZGF0ZXIodGhpcyk7XG4gICAgICAgIHVwZGF0ZXIuZmluYWxpemUoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlU3ViVHJlZUxheW91dCgpIHtcbiAgICAgICAgLy8gVGhlIGRpbWVuc2lvbnMgb2YgdGhpcyBjb250YWluZXIgYXJlIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgLy8gVGhhdCdzIHdoeSB3ZSBjYW4gc2FmZWx5ICdyZXVzZScgdGhvc2UgYW5kIHJlLWxheW91dCB0aGUgY29udGVudHMuXG4gICAgICAgIGNvbnN0IGNyb3NzQXhpc1NpemUgPSB0aGlzLmNyb3NzQXhpc1NpemU7XG4gICAgICAgIHRoaXMuX2xheW91dE1haW5BeGlzKCk7XG4gICAgICAgIHRoaXMucGVyZm9ybVJlc2l6ZUNyb3NzQXhpcyhjcm9zc0F4aXNTaXplKTtcbiAgICB9XG5cbiAgICBfc2V0SW5pdGlhbEF4aXNTaXplcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbS5pc0ZsZXhJdGVtRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW0uZmxleEl0ZW0uX3Jlc2V0TGF5b3V0U2l6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYWluQXhpc1NpemUgPSB0aGlzLl9nZXRNYWluQXhpc0Jhc2lzKCk7XG4gICAgICAgICAgICB0aGlzLmNyb3NzQXhpc1NpemUgPSB0aGlzLl9nZXRDcm9zc0F4aXNCYXNpcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jlc2l6aW5nTWFpbkF4aXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVzaXppbmdDcm9zc0F4aXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2hydW5rID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2xheW91dEF4ZXMoKSB7XG4gICAgICAgIHRoaXMuX2xheW91dE1haW5BeGlzKCk7XG4gICAgICAgIHRoaXMuX2xheW91dENyb3NzQXhpcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcmUgbWFpbkF4aXNTaXplIHNob3VsZCBleGNsdWRlIHBhZGRpbmcuXG4gICAgICovXG4gICAgX2xheW91dE1haW5BeGlzKCkge1xuICAgICAgICB0aGlzLl9sYXlvdXRMaW5lcygpO1xuICAgICAgICB0aGlzLl9maXRNYWluQXhpc1NpemVUb0NvbnRlbnRzKCk7XG4gICAgfVxuXG4gICAgX2xheW91dExpbmVzKCkge1xuICAgICAgICB0aGlzLl9saW5lTGF5b3V0ZXIubGF5b3V0TGluZXMoKTtcbiAgICB9XG5cbiAgICBnZXQgX2xpbmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUxheW91dGVyLmxpbmVzO1xuICAgIH1cblxuICAgIF9maXRNYWluQXhpc1NpemVUb0NvbnRlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc2l6aW5nTWFpbkF4aXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTWFpbkF4aXNGaXRUb0NvbnRlbnRzKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1haW5BeGlzU2l6ZSA9IHRoaXMuX2xpbmVMYXlvdXRlci5tYWluQXhpc0NvbnRlbnRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByZSBjcm9zc0F4aXNTaXplIHNob3VsZCBleGNsdWRlIHBhZGRpbmcuXG4gICAgICovXG4gICAgX2xheW91dENyb3NzQXhpcygpIHtcbiAgICAgICAgY29uc3QgYWxpZ25lciA9IG5ldyBDb250ZW50QWxpZ25lcih0aGlzKTtcbiAgICAgICAgYWxpZ25lci5pbml0KCk7XG4gICAgICAgIHRoaXMuX3RvdGFsQ3Jvc3NBeGlzU2l6ZSA9IGFsaWduZXIudG90YWxDcm9zc0F4aXNTaXplO1xuICAgICAgICB0aGlzLl9maXRDcm9zc0F4aXNTaXplVG9Db250ZW50cygpO1xuICAgICAgICBhbGlnbmVyLmFsaWduKCk7XG4gICAgfVxuXG4gICAgX2ZpdENyb3NzQXhpc1NpemVUb0NvbnRlbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc2l6aW5nQ3Jvc3NBeGlzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Nyb3NzQXhpc0ZpdFRvQ29udGVudHMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NBeGlzU2l6ZSA9IHRoaXMuX3RvdGFsQ3Jvc3NBeGlzU2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzV3JhcHBpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGV4Q29udGFpbmVyLndyYXA7XG4gICAgfVxuXG4gICAgaXNBeGlzRml0VG9Db250ZW50cyhob3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9ob3Jpem9udGFsID09PSBob3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc01haW5BeGlzRml0VG9Db250ZW50cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc01haW5BeGlzRml0VG9Db250ZW50cygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzV3JhcHBpbmcoKSAmJiAhdGhpcy5faGFzRml4ZWRNYWluQXhpc0Jhc2lzKCk7XG4gICAgfVxuXG4gICAgaXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2hhc0ZpeGVkQ3Jvc3NBeGlzQmFzaXMoKTtcbiAgICB9XG5cbiAgICBfaGFzRml4ZWRNYWluQXhpc0Jhc2lzKCkge1xuICAgICAgICByZXR1cm4gIUZsZXhVdGlscy5pc1plcm9BeGlzU2l6ZSh0aGlzLml0ZW0sIHRoaXMuX2hvcml6b250YWwpO1xuICAgIH1cblxuICAgIF9oYXNGaXhlZENyb3NzQXhpc0Jhc2lzKCkge1xuICAgICAgICByZXR1cm4gIUZsZXhVdGlscy5pc1plcm9BeGlzU2l6ZSh0aGlzLml0ZW0sICF0aGlzLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBnZXRBeGlzTWluU2l6ZShob3Jpem9udGFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9ob3Jpem9udGFsID09PSBob3Jpem9udGFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TWFpbkF4aXNNaW5TaXplKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0Q3Jvc3NBeGlzTWluU2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVMYXlvdXRlci5tYWluQXhpc01pblNpemU7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01pblNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lTGF5b3V0ZXIuY3Jvc3NBeGlzTWluU2l6ZTtcbiAgICB9XG5cbiAgICByZXNpemVNYWluQXhpcyhzaXplKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5BeGlzU2l6ZSAhPT0gc2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVjYWxjID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVJlc2l6ZU1haW5BeGlzKHNpemUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hlY2tWYWxpZENhY2hlTWFpbkF4aXNSZXNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1haW5BeGlzU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpdENyb3NzQXhpc1NpemVUb0NvbnRlbnRzKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgbWlzcy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtLmVuYWJsZUxvY2FsUmVjYWxjRmxhZygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1SZXNpemVNYWluQXhpcyhzaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2hlY2tWYWxpZENhY2hlTWFpbkF4aXNSZXNpemUoc2l6ZSkge1xuICAgICAgICBjb25zdCBpc0ZpbmFsTWFpbkF4aXNTaXplID0gKHNpemUgPT09IHRoaXMudGFyZ2V0TWFpbkF4aXNTaXplKTtcbiAgICAgICAgaWYgKGlzRmluYWxNYWluQXhpc1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbklnbm9yZUNhY2hlTWlzcyA9ICF0aGlzLmlzQ3Jvc3NBeGlzRml0VG9Db250ZW50cygpO1xuICAgICAgICBpZiAoY2FuSWdub3JlQ2FjaGVNaXNzKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBtYWluIGF4aXMgcmVzaXplcyBhbmQgY2hlY2sgaWYgZmluYWwgcmVzaXplIG1hdGNoZXMgdGhlIHRhcmdldCBtYWluIGF4aXMgc2l6ZVxuICAgICAgICAgICAgLy8gIChJdGVtQ29vcmRpbmF0ZXNVcGRhdGVyKS5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwZXJmb3JtUmVzaXplTWFpbkF4aXMoc2l6ZSkge1xuICAgICAgICBjb25zdCBpc1Nocmlua2luZyA9IChzaXplIDwgdGhpcy5tYWluQXhpc1NpemUpO1xuICAgICAgICB0aGlzLl9zaHJ1bmsgPSBpc1Nocmlua2luZztcblxuICAgICAgICB0aGlzLm1haW5BeGlzU2l6ZSA9IHNpemU7XG5cbiAgICAgICAgdGhpcy5fcmVzaXppbmdNYWluQXhpcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xheW91dEF4ZXMoKTtcbiAgICAgICAgdGhpcy5fcmVzaXppbmdNYWluQXhpcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJlc2l6ZUNyb3NzQXhpcyhzaXplKSB7XG4gICAgICAgIGlmICh0aGlzLmNyb3NzQXhpc1NpemUgIT09IHNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY2FsYyA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1SZXNpemVDcm9zc0F4aXMoc2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NBeGlzU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwZXJmb3JtUmVzaXplQ3Jvc3NBeGlzKHNpemUpIHtcbiAgICAgICAgdGhpcy5jcm9zc0F4aXNTaXplID0gc2l6ZTtcblxuICAgICAgICB0aGlzLl9yZXNpemluZ0Nyb3NzQXhpcyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xheW91dENyb3NzQXhpcygpO1xuICAgICAgICB0aGlzLl9yZXNpemluZ0Nyb3NzQXhpcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCB0YXJnZXRNYWluQXhpc1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ob3Jpem9udGFsID8gdGhpcy5pdGVtLnRhcmdldC53IDogdGhpcy5pdGVtLnRhcmdldC5oO1xuICAgIH1cblxuICAgIGdldCB0YXJnZXRDcm9zc0F4aXNTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG9yaXpvbnRhbCA/IHRoaXMuaXRlbS50YXJnZXQuaCA6IHRoaXMuaXRlbS50YXJnZXQudztcbiAgICB9XG5cbiAgICBnZXRQYXJlbnRGbGV4Q29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtLmlzRmxleEl0ZW1FbmFibGVkKCkgPyB0aGlzLml0ZW0uZmxleEl0ZW0uY3RyIDogbnVsbDtcbiAgICB9XG5cbiAgICBfZ2V0SG9yaXpvbnRhbFBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0VG90YWxQYWRkaW5nKHRoaXMuaXRlbSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgX2dldFZlcnRpY2FsUGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIEZsZXhVdGlscy5nZXRUb3RhbFBhZGRpbmcodGhpcy5pdGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgX2dldEhvcml6b250YWxQYWRkaW5nT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFBhZGRpbmdPZmZzZXQodGhpcy5pdGVtLCB0cnVlKTtcbiAgICB9XG5cbiAgICBfZ2V0VmVydGljYWxQYWRkaW5nT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldFBhZGRpbmdPZmZzZXQodGhpcy5pdGVtLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzQmFzaXMoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0UmVsQXhpc1NpemUodGhpcy5pdGVtLCB0aGlzLl9ob3Jpem9udGFsKTtcbiAgICB9XG5cbiAgICBfZ2V0Q3Jvc3NBeGlzQmFzaXMoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0UmVsQXhpc1NpemUodGhpcy5pdGVtLCAhdGhpcy5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgZ2V0IF9ob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxleENvbnRhaW5lci5faG9yaXpvbnRhbDtcbiAgICB9XG5cbiAgICBnZXQgX3JldmVyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mbGV4Q29udGFpbmVyLl9yZXZlcnNlO1xuICAgIH1cblxuICAgIGdldCBpdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmxleENvbnRhaW5lci5pdGVtO1xuICAgIH1cblxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbS5pdGVtcztcbiAgICB9XG5cbiAgICBnZXQgcmVzaXppbmdNYWluQXhpcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6aW5nTWFpbkF4aXM7XG4gICAgfVxuXG4gICAgZ2V0IHJlc2l6aW5nQ3Jvc3NBeGlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzaXppbmdDcm9zc0F4aXM7XG4gICAgfVxuXG4gICAgZ2V0IG51bWJlck9mSXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbiAgICBnZXQgbWFpbkF4aXNTaXplKCkge1xuICAgICAgICByZXR1cm4gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgdGhpcy5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgZ2V0IGNyb3NzQXhpc1NpemUoKSB7XG4gICAgICAgIHJldHVybiBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUodGhpcy5pdGVtLCAhdGhpcy5faG9yaXpvbnRhbCk7XG4gICAgfVxuXG4gICAgc2V0IG1haW5BeGlzU2l6ZSh2KSB7XG4gICAgICAgIEZsZXhVdGlscy5zZXRBeGlzTGF5b3V0U2l6ZSh0aGlzLml0ZW0sIHRoaXMuX2hvcml6b250YWwsIHYpO1xuICAgIH1cblxuICAgIHNldCBjcm9zc0F4aXNTaXplKHYpIHtcbiAgICAgICAgRmxleFV0aWxzLnNldEF4aXNMYXlvdXRTaXplKHRoaXMuaXRlbSwgIXRoaXMuX2hvcml6b250YWwsIHYpO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEZsZXhVdGlscyBmcm9tIFwiLi4vRmxleFV0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJdGVtQ29vcmRpbmF0ZXNVcGRhdGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGxheW91dCkge1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuX2lzUmV2ZXJzZSA9IHRoaXMuX2ZsZXhDb250YWluZXIuX3JldmVyc2U7XG4gICAgICAgIHRoaXMuX2hvcml6b250YWxQYWRkaW5nT2Zmc2V0ID0gdGhpcy5fbGF5b3V0Ll9nZXRIb3Jpem9udGFsUGFkZGluZ09mZnNldCgpO1xuICAgICAgICB0aGlzLl92ZXJ0aWNhbFBhZGRpbmdPZmZzZXQgPSB0aGlzLl9sYXlvdXQuX2dldFZlcnRpY2FsUGFkZGluZ09mZnNldCgpO1xuICAgIH1cblxuICAgIGdldCBfZmxleENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5fZmxleENvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RmxleCA9IHRoaXMuX2xheW91dC5nZXRQYXJlbnRGbGV4Q29udGFpbmVyKCk7XG4gICAgICAgIGlmIChwYXJlbnRGbGV4KSB7XG4gICAgICAgICAgICAvLyBXZSBtdXN0IHVwZGF0ZSBpdCBmcm9tIHRoZSBwYXJlbnQgdG8gc2V0IHBhZGRpbmcgb2Zmc2V0cyBhbmQgcmV2ZXJzZSBwb3NpdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXIgPSBuZXcgSXRlbUNvb3JkaW5hdGVzVXBkYXRlcihwYXJlbnRGbGV4Ll9sYXlvdXQpO1xuICAgICAgICAgICAgdXBkYXRlci5fZmluYWxpemVJdGVtQW5kQ2hpbGRyZW4odGhpcy5fZmxleENvbnRhaW5lci5pdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplUm9vdCgpO1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemVJdGVtcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2ZpbmFsaXplUm9vdCgpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2ZsZXhDb250YWluZXIuaXRlbTtcbiAgICAgICAgbGV0IHggPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFBvcyhpdGVtLCB0cnVlKTtcbiAgICAgICAgbGV0IHkgPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFBvcyhpdGVtLCBmYWxzZSk7XG4gICAgICAgIGxldCB3ID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKGl0ZW0sIHRydWUpO1xuICAgICAgICBsZXQgaCA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0U2l6ZShpdGVtLCBmYWxzZSk7XG5cbiAgICAgICAgdyArPSB0aGlzLl9sYXlvdXQuX2dldEhvcml6b250YWxQYWRkaW5nKCk7XG4gICAgICAgIGggKz0gdGhpcy5fbGF5b3V0Ll9nZXRWZXJ0aWNhbFBhZGRpbmcoKTtcblxuICAgICAgICBpdGVtLmNsZWFyUmVjYWxjRmxhZygpO1xuXG4gICAgICAgIGl0ZW0uc2V0TGF5b3V0KHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgIF9maW5hbGl6ZUl0ZW1zKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xheW91dC5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkQ2FjaGUgPSB0aGlzLl92YWxpZGF0ZUl0ZW1DYWNoZShpdGVtKTtcblxuICAgICAgICAgICAgLy8gTm90aWNlIHRoYXQgd2UgbXVzdCBhbHNvIGZpbmFsaXplIGEgY2FjaGVkIGl0ZW1zLCBhcyBpdCdzIGNvb3JkaW5hdGVzIG1heSBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICB0aGlzLl9maW5hbGl6ZUl0ZW0oaXRlbSk7XG5cbiAgICAgICAgICAgIGlmICghdmFsaWRDYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplSXRlbUNoaWxkcmVuKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3ZhbGlkYXRlSXRlbUNhY2hlKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0ucmVjYWxjID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5pc0ZsZXhFbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXlvdXQgPSBpdGVtLl9mbGV4Ll9sYXlvdXQ7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25zTWF0Y2hQcmV2aW91c1Jlc3VsdCA9IChpdGVtLncgPT09IGl0ZW0udGFyZ2V0LncgJiYgaXRlbS5oID09PSBpdGVtLnRhcmdldC5oKTtcbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9uc01hdGNoUHJldmlvdXNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNyb3NzQXhpc1NpemUgPSBsYXlvdXQuY3Jvc3NBeGlzU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LnBlcmZvcm1SZXNpemVNYWluQXhpcyhsYXlvdXQubWFpbkF4aXNTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0LnBlcmZvcm1SZXNpemVDcm9zc0F4aXMoY3Jvc3NBeGlzU2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBfZmluYWxpemVJdGVtQW5kQ2hpbGRyZW4oaXRlbSkge1xuICAgICAgICB0aGlzLl9maW5hbGl6ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplSXRlbUNoaWxkcmVuKGl0ZW0pO1xuICAgIH1cblxuICAgIF9maW5hbGl6ZUl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAodGhpcy5faXNSZXZlcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXZlcnNlTWFpbkF4aXNMYXlvdXRQb3MoaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgeCA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0UG9zKGl0ZW0sIHRydWUpO1xuICAgICAgICBsZXQgeSA9IEZsZXhVdGlscy5nZXRBeGlzTGF5b3V0UG9zKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgbGV0IHcgPSBGbGV4VXRpbHMuZ2V0QXhpc0xheW91dFNpemUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIGxldCBoID0gRmxleFV0aWxzLmdldEF4aXNMYXlvdXRTaXplKGl0ZW0sIGZhbHNlKTtcblxuICAgICAgICB4ICs9IHRoaXMuX2hvcml6b250YWxQYWRkaW5nT2Zmc2V0O1xuICAgICAgICB5ICs9IHRoaXMuX3ZlcnRpY2FsUGFkZGluZ09mZnNldDtcblxuICAgICAgICBjb25zdCBmbGV4ID0gaXRlbS5mbGV4O1xuICAgICAgICBpZiAoZmxleCkge1xuICAgICAgICAgICAgdyArPSBpdGVtLl9mbGV4Ll9sYXlvdXQuX2dldEhvcml6b250YWxQYWRkaW5nKCk7XG4gICAgICAgICAgICBoICs9IGl0ZW0uX2ZsZXguX2xheW91dC5fZ2V0VmVydGljYWxQYWRkaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG4gICAgICAgIGlmIChmbGV4SXRlbSkge1xuICAgICAgICAgICAgeCArPSBmbGV4SXRlbS5fZ2V0SG9yaXpvbnRhbE1hcmdpbk9mZnNldCgpO1xuICAgICAgICAgICAgeSArPSBmbGV4SXRlbS5fZ2V0VmVydGljYWxNYXJnaW5PZmZzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uY2xlYXJSZWNhbGNGbGFnKCk7XG4gICAgICAgIGl0ZW0uc2V0TGF5b3V0KHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgIF9maW5hbGl6ZUl0ZW1DaGlsZHJlbihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGZsZXggPSBpdGVtLl9mbGV4O1xuICAgICAgICBpZiAoZmxleCkge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlciA9IG5ldyBJdGVtQ29vcmRpbmF0ZXNVcGRhdGVyKGZsZXguX2xheW91dCk7XG4gICAgICAgICAgICB1cGRhdGVyLl9maW5hbGl6ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmV2ZXJzZU1haW5BeGlzTGF5b3V0UG9zKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgZW5kUG9zID0gKGl0ZW0uZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0UG9zKCkgKyBpdGVtLmZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpKTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRQb3MgPSB0aGlzLl9sYXlvdXQubWFpbkF4aXNTaXplIC0gZW5kUG9zO1xuICAgICAgICBpdGVtLmZsZXhJdGVtLl9zZXRNYWluQXhpc0xheW91dFBvcyhyZXZlcnNlZFBvcyk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTGluZUxheW91dCBmcm9tIFwiLi9saW5lL0xpbmVMYXlvdXQubWpzXCI7XG5cbi8qKlxuICogRGlzdHJpYnV0ZXMgaXRlbXMgb3ZlciBsYXlvdXQgbGluZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVMYXlvdXRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0ID0gbGF5b3V0O1xuICAgICAgICB0aGlzLl9tYWluQXhpc01pblNpemUgPSAtMTtcbiAgICAgICAgdGhpcy5fY3Jvc3NBeGlzTWluU2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLl9tYWluQXhpc0NvbnRlbnRTaXplID0gMDtcbiAgICB9XG5cbiAgICBnZXQgbGluZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcztcbiAgICB9XG5cbiAgICBnZXQgbWFpbkF4aXNNaW5TaXplKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFpbkF4aXNNaW5TaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fbWFpbkF4aXNNaW5TaXplID0gdGhpcy5fZ2V0TWFpbkF4aXNNaW5TaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21haW5BeGlzTWluU2l6ZTtcbiAgICB9XG5cbiAgICBnZXQgY3Jvc3NBeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nyb3NzQXhpc01pblNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jcm9zc0F4aXNNaW5TaXplID0gdGhpcy5fZ2V0Q3Jvc3NBeGlzTWluU2l6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jcm9zc0F4aXNNaW5TaXplO1xuICAgIH1cblxuICAgIGdldCBtYWluQXhpc0NvbnRlbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFpbkF4aXNDb250ZW50U2l6ZTtcbiAgICB9XG5cbiAgICBsYXlvdXRMaW5lcygpIHtcbiAgICAgICAgdGhpcy5fc2V0dXAoKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYXlvdXQuaXRlbXM7XG4gICAgICAgIGNvbnN0IHdyYXAgPSB0aGlzLl9sYXlvdXQuaXNXcmFwcGluZygpO1xuXG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGNvbnN0IG4gPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICAgICAgdGhpcy5fbGF5b3V0RmxleEl0ZW0oaXRlbSk7XG5cbiAgICAgICAgICAgIC8vIEdldCBwcmVkaWN0ZWQgbWFpbiBheGlzIHNpemUuXG4gICAgICAgICAgICBjb25zdCBpdGVtTWFpbkF4aXNTaXplID0gaXRlbS5mbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKTtcblxuICAgICAgICAgICAgaWYgKHdyYXAgJiYgKGkgPiBzdGFydEluZGV4KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzT3ZlcmZsb3dpbmcgPSAodGhpcy5fY3VyTWFpbkF4aXNQb3MgKyBpdGVtTWFpbkF4aXNTaXplID4gdGhpcy5fbWFpbkF4aXNTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPdmVyZmxvd2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXRMaW5lKHN0YXJ0SW5kZXgsIGkgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VyTWFpbkF4aXNQb3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2FkZFRvTWFpbkF4aXNQb3MoaXRlbU1haW5BeGlzU2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRJbmRleCA8IGkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dExpbmUoc3RhcnRJbmRleCwgaSAtIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2xheW91dEZsZXhJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uaXNGbGV4RW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBpdGVtLmZsZXhMYXlvdXQudXBkYXRlVHJlZUxheW91dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5mbGV4SXRlbS5fcmVzZXRMYXlvdXRTaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0dXAoKSB7XG4gICAgICAgIHRoaXMuX21haW5BeGlzU2l6ZSA9IHRoaXMuX2xheW91dC5tYWluQXhpc1NpemU7XG4gICAgICAgIHRoaXMuX2N1ck1haW5BeGlzUG9zID0gMDtcbiAgICAgICAgdGhpcy5fbWF4TWFpbkF4aXNQb3MgPSAwO1xuICAgICAgICB0aGlzLl9saW5lcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuX21haW5BeGlzTWluU2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLl9jcm9zc0F4aXNNaW5TaXplID0gLTE7XG4gICAgICAgIHRoaXMuX21haW5BeGlzQ29udGVudFNpemUgPSAwO1xuICAgIH1cblxuICAgIF9hZGRUb01haW5BeGlzUG9zKGl0ZW1NYWluQXhpc1NpemUpIHtcbiAgICAgICAgdGhpcy5fY3VyTWFpbkF4aXNQb3MgKz0gaXRlbU1haW5BeGlzU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuX2N1ck1haW5BeGlzUG9zID4gdGhpcy5fbWF4TWFpbkF4aXNQb3MpIHtcbiAgICAgICAgICAgIHRoaXMuX21heE1haW5BeGlzUG9zID0gdGhpcy5fY3VyTWFpbkF4aXNQb3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbGF5b3V0TGluZShzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBjb25zdCBhdmFpbGFibGVTcGFjZSA9IHRoaXMuX2dldEF2YWlsYWJsZU1haW5BeGlzTGF5b3V0U3BhY2UoKTtcbiAgICAgICAgY29uc3QgbGluZSA9IG5ldyBMaW5lTGF5b3V0KHRoaXMuX2xheW91dCwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGF2YWlsYWJsZVNwYWNlKTtcbiAgICAgICAgbGluZS5wZXJmb3JtTGF5b3V0KCk7XG4gICAgICAgIHRoaXMuX2xpbmVzLnB1c2gobGluZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX21haW5BeGlzQ29udGVudFNpemUgPT09IDAgfHwgKHRoaXMuX2N1ck1haW5BeGlzUG9zID4gdGhpcy5fbWFpbkF4aXNDb250ZW50U2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX21haW5BeGlzQ29udGVudFNpemUgPSB0aGlzLl9jdXJNYWluQXhpc1BvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRBdmFpbGFibGVNYWluQXhpc0xheW91dFNwYWNlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xheW91dC5yZXNpemluZ01haW5BeGlzICYmIHRoaXMuX2xheW91dC5pc01haW5BeGlzRml0VG9Db250ZW50cygpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWluQXhpc1NpemUgLSB0aGlzLl9jdXJNYWluQXhpc1BvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRDcm9zc0F4aXNNaW5TaXplKCkge1xuICAgICAgICBsZXQgY3Jvc3NBeGlzTWluU2l6ZSA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGF5b3V0Lml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgaXRlbUNyb3NzQXhpc01pblNpemUgPSBpdGVtLmZsZXhJdGVtLl9nZXRDcm9zc0F4aXNNaW5TaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKTtcbiAgICAgICAgICAgIGNyb3NzQXhpc01pblNpemUgPSBNYXRoLm1heChjcm9zc0F4aXNNaW5TaXplLCBpdGVtQ3Jvc3NBeGlzTWluU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyb3NzQXhpc01pblNpemU7XG4gICAgfVxuXG4gICAgX2dldE1haW5BeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzWzBdLmdldE1haW5BeGlzTWluU2l6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV3JhcHBpbmcgbGluZXM6IHNwZWNpZmllZCB3aWR0aCBpcyB1c2VkIGFzIG1pbiB3aWR0aCAoaW4gYWNjb3JkYW5jZSB0byBXM0MgZmxleGJveCkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Lm1haW5BeGlzU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BhY2luZ0NhbGN1bGF0b3Ige1xuXG4gICAgc3RhdGljIGdldFNwYWNpbmcobW9kZSwgbnVtYmVyT2ZJdGVtcywgcmVtYWluaW5nU3BhY2UpIHtcbiAgICAgICAgY29uc3QgaXRlbUdhcHMgPSAobnVtYmVyT2ZJdGVtcyAtIDEpO1xuICAgICAgICBsZXQgc3BhY2VQZXJHYXA7XG5cbiAgICAgICAgbGV0IHNwYWNpbmdCZWZvcmUsIHNwYWNpbmdCZXR3ZWVuO1xuXG4gICAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmxleC1zdGFydFwiOlxuICAgICAgICAgICAgICAgIHNwYWNpbmdCZWZvcmUgPSAwO1xuICAgICAgICAgICAgICAgIHNwYWNpbmdCZXR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmbGV4LWVuZFwiOlxuICAgICAgICAgICAgICAgIHNwYWNpbmdCZWZvcmUgPSByZW1haW5pbmdTcGFjZTtcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmV0d2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICAgICAgICAgICAgc3BhY2luZ0JlZm9yZSA9IHJlbWFpbmluZ1NwYWNlIC8gMjtcbiAgICAgICAgICAgICAgICBzcGFjaW5nQmV0d2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3BhY2UtYmV0d2VlblwiOlxuICAgICAgICAgICAgICAgIHNwYWNpbmdCZWZvcmUgPSAwO1xuICAgICAgICAgICAgICAgIHNwYWNpbmdCZXR3ZWVuID0gTWF0aC5tYXgoMCwgcmVtYWluaW5nU3BhY2UpIC8gaXRlbUdhcHM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3BhY2UtYXJvdW5kXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1NwYWNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTcGFjaW5nKFwiY2VudGVyXCIsIG51bWJlck9mSXRlbXMsIHJlbWFpbmluZ1NwYWNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFjZVBlckdhcCA9IHJlbWFpbmluZ1NwYWNlIC8gKGl0ZW1HYXBzICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmdCZWZvcmUgPSAwLjUgKiBzcGFjZVBlckdhcDtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2luZ0JldHdlZW4gPSBzcGFjZVBlckdhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3BhY2UtZXZlbmx5XCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1NwYWNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTcGFjaW5nKFwiY2VudGVyXCIsIG51bWJlck9mSXRlbXMsIHJlbWFpbmluZ1NwYWNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzcGFjZVBlckdhcCA9IHJlbWFpbmluZ1NwYWNlIC8gKGl0ZW1HYXBzICsgMik7XG4gICAgICAgICAgICAgICAgICAgIHNwYWNpbmdCZWZvcmUgPSBzcGFjZVBlckdhcDtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2luZ0JldHdlZW4gPSBzcGFjZVBlckdhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyZXRjaFwiOlxuICAgICAgICAgICAgICAgIHNwYWNpbmdCZWZvcmUgPSAwO1xuICAgICAgICAgICAgICAgIHNwYWNpbmdCZXR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBtb2RlOiBcIiArIG1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtzcGFjaW5nQmVmb3JlLCBzcGFjaW5nQmV0d2Vlbn1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW1BbGlnbmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGxpbmUpIHtcbiAgICAgICAgdGhpcy5fbGluZSA9IGxpbmU7XG4gICAgICAgIHRoaXMuX2Nyb3NzQXhpc0xheW91dFNpemUgPSAwO1xuICAgICAgICB0aGlzLl9jcm9zc0F4aXNMYXlvdXRPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9hbGlnbkl0ZW1zU2V0dGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVJlc2l6ZU9jY3VyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IF9sYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lLl9sYXlvdXQ7XG4gICAgfVxuXG4gICAgZ2V0IF9mbGV4Q29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0Ll9mbGV4Q29udGFpbmVyO1xuICAgIH1cblxuICAgIHNldENyb3NzQXhpc0xheW91dFNpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLl9jcm9zc0F4aXNMYXlvdXRTaXplID0gc2l6ZTtcbiAgICB9XG5cbiAgICBzZXRDcm9zc0F4aXNMYXlvdXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX2Nyb3NzQXhpc0xheW91dE9mZnNldCA9IG9mZnNldDtcbiAgICB9XG5cbiAgICBhbGlnbigpIHtcbiAgICAgICAgdGhpcy5fYWxpZ25JdGVtc1NldHRpbmcgPSB0aGlzLl9mbGV4Q29udGFpbmVyLmFsaWduSXRlbXM7XG5cbiAgICAgICAgdGhpcy5faXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzID0gdGhpcy5fbGF5b3V0LmlzQXhpc0ZpdFRvQ29udGVudHMoIXRoaXMuX2ZsZXhDb250YWluZXIuX2hvcml6b250YWwpO1xuXG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVJlc2l6ZU9jY3VyZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9saW5lLml0ZW1zO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbGluZS5zdGFydEluZGV4OyBpIDw9IHRoaXMuX2xpbmUuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgdGhpcy5fYWxpZ25JdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJlY3Vyc2l2ZVJlc2l6ZU9jY3VyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWN1cnNpdmVSZXNpemVPY2N1cmVkO1xuICAgIH1cblxuICAgIF9hbGlnbkl0ZW0oaXRlbSkge1xuICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG4gICAgICAgIGxldCBhbGlnbiA9IGZsZXhJdGVtLmFsaWduU2VsZiB8fCB0aGlzLl9hbGlnbkl0ZW1zU2V0dGluZztcblxuICAgICAgICBpZiAoYWxpZ24gPT09IFwic3RyZXRjaFwiICYmIHRoaXMuX3ByZXZlbnRTdHJldGNoKGZsZXhJdGVtKSkge1xuICAgICAgICAgICAgYWxpZ24gPSBcImZsZXgtc3RhcnRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGlnbiAhPT0gXCJzdHJldGNoXCIgJiYgIXRoaXMuX2lzQ3Jvc3NBeGlzRml0VG9Db250ZW50cykge1xuICAgICAgICAgICAgaWYgKGZsZXhJdGVtLl9oYXNSZWxDcm9zc0F4aXNTaXplKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBBcyBjcm9zcyBheGlzIHNpemUgbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHJlY2FsYyB0aGUgcmVsYXRpdmUgZmxleCBpdGVtJ3Mgc2l6ZS5cbiAgICAgICAgICAgICAgICBmbGV4SXRlbS5fcmVzZXRDcm9zc0F4aXNMYXlvdXRTaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2goYWxpZ24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJmbGV4LXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxpZ25JdGVtRmxleFN0YXJ0KGZsZXhJdGVtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmbGV4LWVuZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduSXRlbUZsZXhFbmQoZmxleEl0ZW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICAgICAgICAgIHRoaXMuX2FsaWduSXRlbUZsZXhDZW50ZXIoZmxleEl0ZW0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmV0Y2hcIjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGlnbkl0ZW1TdHJldGNoKGZsZXhJdGVtKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hbGlnbkl0ZW1GbGV4U3RhcnQoZmxleEl0ZW0pIHtcbiAgICAgICAgZmxleEl0ZW0uX3NldENyb3NzQXhpc0xheW91dFBvcyh0aGlzLl9jcm9zc0F4aXNMYXlvdXRPZmZzZXQpO1xuICAgIH1cblxuICAgIF9hbGlnbkl0ZW1GbGV4RW5kKGZsZXhJdGVtKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1Dcm9zc0F4aXNTaXplID0gZmxleEl0ZW0uX2dldENyb3NzQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpO1xuICAgICAgICBmbGV4SXRlbS5fc2V0Q3Jvc3NBeGlzTGF5b3V0UG9zKHRoaXMuX2Nyb3NzQXhpc0xheW91dE9mZnNldCArICh0aGlzLl9jcm9zc0F4aXNMYXlvdXRTaXplIC0gaXRlbUNyb3NzQXhpc1NpemUpKTtcbiAgICB9XG5cbiAgICBfYWxpZ25JdGVtRmxleENlbnRlcihmbGV4SXRlbSkge1xuICAgICAgICBjb25zdCBpdGVtQ3Jvc3NBeGlzU2l6ZSA9IGZsZXhJdGVtLl9nZXRDcm9zc0F4aXNMYXlvdXRTaXplV2l0aFBhZGRpbmdBbmRNYXJnaW4oKTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gKHRoaXMuX2Nyb3NzQXhpc0xheW91dFNpemUgLSBpdGVtQ3Jvc3NBeGlzU2l6ZSkgLyAyO1xuICAgICAgICBmbGV4SXRlbS5fc2V0Q3Jvc3NBeGlzTGF5b3V0UG9zKHRoaXMuX2Nyb3NzQXhpc0xheW91dE9mZnNldCArIGNlbnRlcik7XG4gICAgfVxuXG4gICAgX2FsaWduSXRlbVN0cmV0Y2goZmxleEl0ZW0pIHtcbiAgICAgICAgZmxleEl0ZW0uX3NldENyb3NzQXhpc0xheW91dFBvcyh0aGlzLl9jcm9zc0F4aXNMYXlvdXRPZmZzZXQpO1xuXG4gICAgICAgIGNvbnN0IG1haW5BeGlzTGF5b3V0U2l6ZUJlZm9yZVJlc2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemUoKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLl9jcm9zc0F4aXNMYXlvdXRTaXplIC0gZmxleEl0ZW0uX2dldENyb3NzQXhpc01hcmdpbigpIC0gZmxleEl0ZW0uX2dldENyb3NzQXhpc1BhZGRpbmcoKTtcblxuICAgICAgICBjb25zdCBjcm9zc0F4aXNNaW5TaXplU2V0dGluZyA9IGZsZXhJdGVtLl9nZXRDcm9zc0F4aXNNaW5TaXplU2V0dGluZygpO1xuICAgICAgICBpZiAoY3Jvc3NBeGlzTWluU2l6ZVNldHRpbmcgPiAwKSB7XG4gICAgICAgICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgY3Jvc3NBeGlzTWluU2l6ZVNldHRpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzTWF4U2l6ZVNldHRpbmcgPSBmbGV4SXRlbS5fZ2V0Q3Jvc3NBeGlzTWF4U2l6ZVNldHRpbmcoKTtcbiAgICAgICAgY29uc3QgY3Jvc3NBeGlzTWF4U2l6ZVNldHRpbmdFbmFibGVkID0gKGNyb3NzQXhpc01heFNpemVTZXR0aW5nID4gMCk7XG4gICAgICAgIGlmIChjcm9zc0F4aXNNYXhTaXplU2V0dGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHNpemUgPSBNYXRoLm1pbihzaXplLCBjcm9zc0F4aXNNYXhTaXplU2V0dGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICBmbGV4SXRlbS5fcmVzaXplQ3Jvc3NBeGlzKHNpemUpO1xuICAgICAgICBjb25zdCBtYWluQXhpc0xheW91dFNpemVBZnRlclJlc2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc0xheW91dFNpemUoKTtcblxuICAgICAgICBjb25zdCByZWN1cnNpdmVSZXNpemUgPSAobWFpbkF4aXNMYXlvdXRTaXplQWZ0ZXJSZXNpemUgIT09IG1haW5BeGlzTGF5b3V0U2l6ZUJlZm9yZVJlc2l6ZSk7XG4gICAgICAgIGlmIChyZWN1cnNpdmVSZXNpemUpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZSByZXNpemUgY2FuIGhhcHBlbiB3aGVuIHRoaXMgZmxleCBpdGVtIGhhcyB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIHRoYW4gdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgLy8gYW5kIGlzIHdyYXBwaW5nIGFuZCBhdXRvLXNpemluZy4gRHVlIHRvIGl0ZW0vY29udGVudCBzdHJldGNoaW5nIHRoZSBtYWluIGF4aXMgc2l6ZSBvZiB0aGUgZmxleFxuICAgICAgICAgICAgLy8gaXRlbSBtYXkgZGVjcmVhc2UuIElmIGl0IGRvZXMgc28sIHdlIG11c3QgcmUtanVzdGlmeS1jb250ZW50IHRoZSBjb21wbGV0ZSBsaW5lLlxuICAgICAgICAgICAgLy8gTm90aWNlIHRoYXQgd2UgZG9uJ3QgYWNjb3VudCBmb3IgY2hhbmdlcyB0byB0aGUgKGlmIGF1dG9zaXplZCkgbWFpbiBheGlzIHNpemUgY2F1c2VkIGJ5IHJlY3Vyc2l2ZVxuICAgICAgICAgICAgLy8gcmVzaXplLCB3aGljaCBtYXkgY2F1c2UgdGhlIGNvbnRhaW5lcidzIG1haW4gYXhpcyB0byBub3Qgc2hyaW5rIHRvIHRoZSBjb250ZW50cyBwcm9wZXJseS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYnkgZGVzaWduLCBiZWNhdXNlIGlmIHdlIGhhZCByZS1ydW4gdGhlIG1haW4gYXhpcyBsYXlvdXQsIHdlIGNvdWxkIHJ1biBpbnRvIGlzc3VlcyBzdWNoXG4gICAgICAgICAgICAvLyBhcyBzbG93IGxheW91dCBvciBlbmRsZXNzIGxvb3BzLlxuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUmVzaXplT2NjdXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcHJldmVudFN0cmV0Y2goZmxleEl0ZW0pIHtcbiAgICAgICAgY29uc3QgaGFzRml4ZWRDcm9zc0F4aXNTaXplID0gZmxleEl0ZW0uX2hhc0ZpeGVkQ3Jvc3NBeGlzU2l6ZSgpO1xuICAgICAgICBjb25zdCBmb3JjZVN0cmV0Y2ggPSAoZmxleEl0ZW0uYWxpZ25TZWxmID09PSBcInN0cmV0Y2hcIik7XG4gICAgICAgIHJldHVybiBoYXNGaXhlZENyb3NzQXhpc1NpemUgJiYgIWZvcmNlU3RyZXRjaDtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTcGFjaW5nQ2FsY3VsYXRvciBmcm9tIFwiLi4vU3BhY2luZ0NhbGN1bGF0b3IubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEl0ZW1Qb3NpdGlvbmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGxpbmVMYXlvdXQpIHtcbiAgICAgICAgdGhpcy5fbGluZSA9IGxpbmVMYXlvdXQ7XG4gICAgfVxuXG4gICAgZ2V0IF9sYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lLl9sYXlvdXQ7XG4gICAgfVxuXG4gICAgcG9zaXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHtzcGFjaW5nQmVmb3JlLCBzcGFjaW5nQmV0d2Vlbn0gPSB0aGlzLl9nZXRTcGFjaW5nKCk7XG5cbiAgICAgICAgbGV0IGN1cnJlbnRQb3MgPSBzcGFjaW5nQmVmb3JlO1xuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGluZS5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2xpbmUuc3RhcnRJbmRleDsgaSA8PSB0aGlzLl9saW5lLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcblxuICAgICAgICAgICAgaXRlbS5mbGV4SXRlbS5fc2V0TWFpbkF4aXNMYXlvdXRQb3MoY3VycmVudFBvcyk7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IGl0ZW0uZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZVdpdGhQYWRkaW5nQW5kTWFyZ2luKCk7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IHNwYWNpbmdCZXR3ZWVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFNwYWNpbmcoKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ1NwYWNlID0gdGhpcy5fbGluZS5fYXZhaWxhYmxlU3BhY2U7XG4gICAgICAgIGxldCBtb2RlID0gdGhpcy5fbGF5b3V0Ll9mbGV4Q29udGFpbmVyLmp1c3RpZnlDb250ZW50O1xuICAgICAgICBjb25zdCBudW1iZXJPZkl0ZW1zID0gdGhpcy5fbGluZS5udW1iZXJPZkl0ZW1zO1xuXG4gICAgICAgIHJldHVybiBTcGFjaW5nQ2FsY3VsYXRvci5nZXRTcGFjaW5nKG1vZGUsIG51bWJlck9mSXRlbXMsIHJlbWFpbmluZ1NwYWNlKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTaXplU2hyaW5rZXIgZnJvbSBcIi4vU2l6ZVNocmlua2VyLm1qc1wiO1xuaW1wb3J0IFNpemVHcm93ZXIgZnJvbSBcIi4vU2l6ZUdyb3dlci5tanNcIjtcbmltcG9ydCBJdGVtUG9zaXRpb25lciBmcm9tIFwiLi9JdGVtUG9zaXRpb25lci5tanNcIjtcbmltcG9ydCBJdGVtQWxpZ25lciBmcm9tIFwiLi9JdGVtQWxpZ25lci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGluZUxheW91dCB7XG5cbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBhdmFpbGFibGVTcGFjZSkge1xuICAgICAgICB0aGlzLl9sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBsYXlvdXQuaXRlbXM7XG4gICAgICAgIHRoaXMuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlU3BhY2UgPSBhdmFpbGFibGVTcGFjZTtcbiAgICB9XG5cbiAgICBwZXJmb3JtTGF5b3V0KCkge1xuICAgICAgICB0aGlzLl9zZXRJdGVtU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5zZXRJdGVtUG9zaXRpb25zKCk7XG4gICAgICAgIHRoaXMuX2NhbGNMYXlvdXRJbmZvKCk7XG4gICAgfVxuXG4gICAgX3NldEl0ZW1TaXplcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F2YWlsYWJsZVNwYWNlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZ3Jvd0l0ZW1TaXplcyh0aGlzLl9hdmFpbGFibGVTcGFjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYXZhaWxhYmxlU3BhY2UgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zaHJpbmtJdGVtU2l6ZXMoLXRoaXMuX2F2YWlsYWJsZVNwYWNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9ncm93SXRlbVNpemVzKGFtb3VudCkge1xuICAgICAgICBjb25zdCBncm93ZXIgPSBuZXcgU2l6ZUdyb3dlcih0aGlzKTtcbiAgICAgICAgZ3Jvd2VyLmdyb3coYW1vdW50KTtcbiAgICAgICAgdGhpcy5fYXZhaWxhYmxlU3BhY2UgLT0gZ3Jvd2VyLmdldEdyb3duU2l6ZSgpO1xuICAgIH1cblxuICAgIF9zaHJpbmtJdGVtU2l6ZXMoYW1vdW50KSB7XG4gICAgICAgIGNvbnN0IHNocmlua2VyID0gbmV3IFNpemVTaHJpbmtlcih0aGlzKTtcbiAgICAgICAgc2hyaW5rZXIuc2hyaW5rKGFtb3VudCk7XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZVNwYWNlICs9IHNocmlua2VyLmdldFNocnVua1NpemUoKTtcbiAgICB9XG5cbiAgICBzZXRJdGVtUG9zaXRpb25zKCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbmVyID0gbmV3IEl0ZW1Qb3NpdGlvbmVyKHRoaXMpO1xuICAgICAgICBwb3NpdGlvbmVyLnBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlSXRlbUFsaWduZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSXRlbUFsaWduZXIodGhpcyk7XG4gICAgfVxuXG4gICAgX2NhbGNMYXlvdXRJbmZvKCkge1xuICAgICAgICB0aGlzLl9jYWxjQ3Jvc3NBeGlzTWF4TGF5b3V0U2l6ZSgpO1xuICAgIH1cblxuICAgIGdldE1haW5BeGlzTWluU2l6ZSgpIHtcbiAgICAgICAgbGV0IG1haW5BeGlzTWluU2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtc1tpXTtcbiAgICAgICAgICAgIG1haW5BeGlzTWluU2l6ZSArPSBpdGVtLmZsZXhJdGVtLl9nZXRNYWluQXhpc01pblNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYWluQXhpc01pblNpemU7XG4gICAgfVxuICAgIFxuICAgIGdldCBudW1iZXJPZkl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRJbmRleCAtIHRoaXMuc3RhcnRJbmRleCArIDE7XG4gICAgfVxuXG4gICAgZ2V0IGNyb3NzQXhpc0xheW91dFNpemUoKSB7XG4gICAgICAgIGNvbnN0IG5vU3BlY2lmaWVkQ3Jvc3NBeGlzU2l6ZSA9ICh0aGlzLl9sYXlvdXQuaXNDcm9zc0F4aXNGaXRUb0NvbnRlbnRzKCkgJiYgIXRoaXMuX2xheW91dC5yZXNpemluZ0Nyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IHNob3VsZEZpdFRvQ29udGVudHMgPSAodGhpcy5fbGF5b3V0LmlzV3JhcHBpbmcoKSB8fCBub1NwZWNpZmllZENyb3NzQXhpc1NpemUpO1xuICAgICAgICBpZiAoc2hvdWxkRml0VG9Db250ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nyb3NzQXhpc01heExheW91dFNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0LmNyb3NzQXhpc1NpemU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2FsY0Nyb3NzQXhpc01heExheW91dFNpemUoKSB7XG4gICAgICAgIHRoaXMuX2Nyb3NzQXhpc01heExheW91dFNpemUgPSB0aGlzLl9nZXRDcm9zc0F4aXNNYXhMYXlvdXRTaXplKCk7XG4gICAgfVxuXG4gICAgX2dldENyb3NzQXhpc01heExheW91dFNpemUoKSB7XG4gICAgICAgIGxldCBjcm9zc0F4aXNNYXhTaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhcnRJbmRleDsgaSA8PSB0aGlzLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zW2ldO1xuICAgICAgICAgICAgY3Jvc3NBeGlzTWF4U2l6ZSA9IE1hdGgubWF4KGNyb3NzQXhpc01heFNpemUsIGl0ZW0uZmxleEl0ZW0uX2dldENyb3NzQXhpc0xheW91dFNpemVXaXRoUGFkZGluZ0FuZE1hcmdpbigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Jvc3NBeGlzTWF4U2l6ZTtcbiAgICB9XG5cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2l6ZUdyb3dlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihsaW5lKSB7XG4gICAgICAgIHRoaXMuX2xpbmUgPSBsaW5lO1xuICAgICAgICB0aGlzLl9hbW91bnRSZW1haW5pbmcgPSAwO1xuICAgICAgICB0aGlzLl9ncm93blNpemUgPSAwO1xuICAgIH1cblxuICAgIGdyb3coYW1vdW50KSB7XG4gICAgICAgIHRoaXMuX2dyb3duU2l6ZSA9IDA7XG5cbiAgICAgICAgdGhpcy5fYW1vdW50UmVtYWluaW5nID0gYW1vdW50O1xuICAgICAgICBsZXQgdG90YWxHcm93QW1vdW50ID0gdGhpcy5fZ2V0VG90YWxHcm93QW1vdW50KCk7XG4gICAgICAgIGlmICh0b3RhbEdyb3dBbW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGluZS5pdGVtcztcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBsZXQgYW1vdW50UGVyR3JvdyA9IHRoaXMuX2Ftb3VudFJlbWFpbmluZyAvIHRvdGFsR3Jvd0Ftb3VudDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbGluZS5zdGFydEluZGV4OyBpIDw9IHRoaXMuX2xpbmUuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3Jvd0Ftb3VudCA9IGZsZXhJdGVtLmdyb3c7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzR3Jvd2FibGVJdGVtID0gKGdyb3dBbW91bnQgPiAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzR3Jvd2FibGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdyA9IGdyb3dBbW91bnQgKiBhbW91bnRQZXJHcm93O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4U2l6ZSA9IGZsZXhJdGVtLl9nZXRNYWluQXhpc01heFNpemVTZXR0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heFNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPj0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGZ1bGx5IGdyb3duLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm93ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhHcm93ID0gbWF4U2l6ZSAtIHNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnVsbHlHcm93biA9IChncm93ID49IG1heEdyb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdWxseUdyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm93ID0gbWF4R3JvdztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJpYnV0ZSByZW1haW5pbmcgYW1vdW50IG92ZXIgdGhlIG90aGVyIGZsZXggaXRlbXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEdyb3dBbW91bnQgLT0gZ3Jvd0Ftb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3cgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxTaXplID0gc2l6ZSArIGdyb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleEl0ZW0uX3Jlc2l6ZU1haW5BeGlzKGZpbmFsU2l6ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncm93blNpemUgKz0gZ3JvdztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbW91bnRSZW1haW5pbmcgLT0gZ3JvdztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9hbW91bnRSZW1haW5pbmcpIDwgMTBlLTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUodG90YWxHcm93QW1vdW50ICYmIChNYXRoLmFicyh0aGlzLl9hbW91bnRSZW1haW5pbmcpID4gMTBlLTYpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUb3RhbEdyb3dBbW91bnQoKSB7XG4gICAgICAgIGxldCB0b3RhbCA9IDA7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGluZS5pdGVtcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2xpbmUuc3RhcnRJbmRleDsgaSA8PSB0aGlzLl9saW5lLmVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcblxuICAgICAgICAgICAgaWYgKGZsZXhJdGVtLmdyb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTWF4U2l6ZVNldHRpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gRXhjbHVkZSB0aG9zZSBhbHJlYWR5IGZ1bGx5IGdyb3duLlxuICAgICAgICAgICAgICAgIGlmIChtYXhTaXplID09PSAwIHx8IHNpemUgPCBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IGZsZXhJdGVtLmdyb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG5cbiAgICBnZXRHcm93blNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm93blNpemU7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaXplU2hyaW5rZXIge1xuXG4gICAgY29uc3RydWN0b3IobGluZSkge1xuICAgICAgICB0aGlzLl9saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5fYW1vdW50UmVtYWluaW5nID0gMDtcbiAgICAgICAgdGhpcy5fc2hydW5rU2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgc2hyaW5rKGFtb3VudCkge1xuICAgICAgICB0aGlzLl9zaHJ1bmtTaXplID0gMDtcblxuICAgICAgICB0aGlzLl9hbW91bnRSZW1haW5pbmcgPSBhbW91bnQ7XG4gICAgICAgIGxldCB0b3RhbFNocmlua0Ftb3VudCA9IHRoaXMuX2dldFRvdGFsU2hyaW5rQW1vdW50KCk7XG4gICAgICAgIGlmICh0b3RhbFNocmlua0Ftb3VudCkge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9saW5lLml0ZW1zO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBhbW91bnRQZXJTaHJpbmsgPSB0aGlzLl9hbW91bnRSZW1haW5pbmcgLyB0b3RhbFNocmlua0Ftb3VudDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fbGluZS5zdGFydEluZGV4OyBpIDw9IHRoaXMuX2xpbmUuZW5kSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZsZXhJdGVtID0gaXRlbS5mbGV4SXRlbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hyaW5rQW1vdW50ID0gZmxleEl0ZW0uc2hyaW5rO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Nocmlua2FibGVJdGVtID0gKHNocmlua0Ftb3VudCA+IDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaHJpbmthYmxlSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNocmluayA9IHNocmlua0Ftb3VudCAqIGFtb3VudFBlclNocmluaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pblNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNNaW5TaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTGF5b3V0U2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemUgPiBtaW5TaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4U2hyaW5rID0gc2l6ZSAtIG1pblNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGdWxseVNocnVuayA9IChzaHJpbmsgPj0gbWF4U2hyaW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdWxseVNocnVuaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmsgPSBtYXhTaHJpbms7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJpYnV0ZSByZW1haW5pbmcgYW1vdW50IG92ZXIgdGhlIG90aGVyIGZsZXggaXRlbXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsU2hyaW5rQW1vdW50IC09IHNocmlua0Ftb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFNpemUgPSBzaXplIC0gc2hyaW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhJdGVtLl9yZXNpemVNYWluQXhpcyhmaW5hbFNpemUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hydW5rU2l6ZSArPSBzaHJpbms7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYW1vdW50UmVtYWluaW5nIC09IHNocmluaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9hbW91bnRSZW1haW5pbmcpIDwgMTBlLTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUodG90YWxTaHJpbmtBbW91bnQgJiYgKE1hdGguYWJzKHRoaXMuX2Ftb3VudFJlbWFpbmluZykgPiAxMGUtNikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFRvdGFsU2hyaW5rQW1vdW50KCkge1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xpbmUuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9saW5lLnN0YXJ0SW5kZXg7IGkgPD0gdGhpcy5fbGluZS5lbmRJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgICAgICBjb25zdCBmbGV4SXRlbSA9IGl0ZW0uZmxleEl0ZW07XG5cbiAgICAgICAgICAgIGlmIChmbGV4SXRlbS5zaHJpbmspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5TaXplID0gZmxleEl0ZW0uX2dldE1haW5BeGlzTWluU2l6ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBmbGV4SXRlbS5fZ2V0TWFpbkF4aXNMYXlvdXRTaXplKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIHRob3NlIGFscmVhZHkgZnVsbHkgc2hydW5rLlxuICAgICAgICAgICAgICAgIGlmIChzaXplID4gbWluU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0b3RhbCArPSBmbGV4SXRlbS5zaHJpbms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG5cbiAgICBnZXRTaHJ1bmtTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hydW5rU2l6ZTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBBcHBsaWNhdGlvbiBmcm9tIFwiLi9hcHBsaWNhdGlvbi9BcHBsaWNhdGlvbi5tanNcIjtcbmltcG9ydCBDb21wb25lbnQgZnJvbSBcIi4vYXBwbGljYXRpb24vQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IEJhc2UgZnJvbSBcIi4vdHJlZS9CYXNlLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgRWxlbWVudCBmcm9tIFwiLi90cmVlL0VsZW1lbnQubWpzXCI7XG5pbXBvcnQgRWxlbWVudENvcmUgZnJvbSBcIi4vdHJlZS9jb3JlL0VsZW1lbnRDb3JlLm1qc1wiO1xuaW1wb3J0IEVsZW1lbnRUZXh0dXJpemVyIGZyb20gXCIuL3RyZWUvY29yZS9FbGVtZW50VGV4dHVyaXplci5tanNcIjtcbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuaW1wb3J0IFRvb2xzIGZyb20gXCIuL3Rvb2xzL1Rvb2xzLm1qc1wiO1xuaW1wb3J0IE9iak1lcmdlciBmcm9tIFwiLi90b29scy9PYmpNZXJnZXIubWpzXCI7XG5pbXBvcnQgT2JqZWN0TGlzdFByb3h5IGZyb20gXCIuL3Rvb2xzL09iamVjdExpc3RQcm94eS5tanNcIjtcbmltcG9ydCBPYmplY3RMaXN0V3JhcHBlciBmcm9tIFwiLi90b29scy9PYmplY3RMaXN0V3JhcHBlci5tanNcIjtcblxuaW1wb3J0IFJlY3RhbmdsZVRleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvUmVjdGFuZ2xlVGV4dHVyZS5tanNcIjtcbmltcG9ydCBOb2lzZVRleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvTm9pc2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFRleHRUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL1RleHRUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IEltYWdlVGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9JbWFnZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgSHRtbFRleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvSHRtbFRleHR1cmUubWpzXCI7XG5pbXBvcnQgU3RhdGljVGV4dHVyZSBmcm9tIFwiLi90ZXh0dXJlcy9TdGF0aWNUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFN0YXRpY0NhbnZhc1RleHR1cmUgZnJvbSBcIi4vdGV4dHVyZXMvU3RhdGljQ2FudmFzVGV4dHVyZS5tanNcIjtcbmltcG9ydCBTb3VyY2VUZXh0dXJlIGZyb20gXCIuL3RleHR1cmVzL1NvdXJjZVRleHR1cmUubWpzXCI7XG5cbmltcG9ydCBMaXN0Q29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvTGlzdENvbXBvbmVudC5tanNcIjtcbmltcG9ydCBGYXN0Qmx1ckNvbXBvbmVudCBmcm9tIFwiLi9jb21wb25lbnRzL0Zhc3RCbHVyQ29tcG9uZW50Lm1qc1wiO1xuaW1wb3J0IEJsb29tQ29tcG9uZW50IGZyb20gXCIuL2NvbXBvbmVudHMvQmxvb21Db21wb25lbnQubWpzXCI7XG5pbXBvcnQgU21vb3RoU2NhbGVDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50cy9TbW9vdGhTY2FsZUNvbXBvbmVudC5tanNcIjtcbmltcG9ydCBCb3JkZXJDb21wb25lbnQgZnJvbSBcIi4vY29tcG9uZW50cy9Cb3JkZXJDb21wb25lbnQubWpzXCI7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gXCIuL0V2ZW50RW1pdHRlci5tanNcIjtcblxuaW1wb3J0IFdlYkdMU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL1dlYkdMU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFdlYkdMRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgeyBXZWJHTEdyYXlzY2FsZVNoYWRlciB9IGZyb20gXCIuL3JlbmRlcmVyL2NvbW1vbi9zaGFkZXJzL0dyYXlzY2FsZVNoYWRlci5tanNcIjtcbmltcG9ydCBCb3hCbHVyU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvQm94Qmx1clNoYWRlci5tanNcIjtcbmltcG9ydCBEaXRoZXJpbmdTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9EaXRoZXJpbmdTaGFkZXIubWpzXCI7XG5pbXBvcnQgQ2lyY3VsYXJQdXNoU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvQ2lyY3VsYXJQdXNoU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEludmVyc2lvblNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0ludmVyc2lvblNoYWRlci5tanNcIjtcbmltcG9ydCBMaW5lYXJCbHVyU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvTGluZWFyQmx1clNoYWRlci5tanNcIjtcbmltcG9ydCBPdXRsaW5lU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvT3V0bGluZVNoYWRlci5tanNcIjtcbmltcG9ydCBQaXhlbGF0ZVNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1BpeGVsYXRlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFJhZGlhbEZpbHRlclNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1JhZGlhbEZpbHRlclNoYWRlci5tanNcIjtcbmltcG9ydCBSb3VuZGVkUmVjdGFuZ2xlU2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUm91bmRlZFJlY3RhbmdsZVNoYWRlci5tanNcIjtcbmltcG9ydCBGYWRlT3V0U2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvRmFkZU91dFNoYWRlci5tanNcIjtcbmltcG9ydCBWaWduZXR0ZVNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL1ZpZ25ldHRlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFNwaW5uZXJTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9TcGlubmVyU2hhZGVyLm1qc1wiO1xuaW1wb3J0IEhvbGVTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9Ib2xlU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFJhZGlhbEdyYWRpZW50U2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvUmFkaWFsR3JhZGllbnRTaGFkZXIubWpzXCI7XG5pbXBvcnQgTGlnaHQzZFNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci93ZWJnbC9zaGFkZXJzL0xpZ2h0M2RTaGFkZXIubWpzXCI7XG5pbXBvcnQgUGVyc3BlY3RpdmVTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9QZXJzcGVjdGl2ZVNoYWRlci5tanNcIjtcbmltcG9ydCBNYWduaWZpZXJTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvd2ViZ2wvc2hhZGVycy9NYWduaWZpZXJTaGFkZXIubWpzXCI7XG5cbmltcG9ydCBDMmRTaGFkZXIgZnJvbSBcIi4vcmVuZGVyZXIvYzJkL0MyZFNoYWRlci5tanNcIjtcbmltcG9ydCBDMmREZWZhdWx0U2hhZGVyIGZyb20gXCIuL3JlbmRlcmVyL2MyZC9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgeyBDMmRHcmF5c2NhbGVTaGFkZXIgfSBmcm9tIFwiLi9yZW5kZXJlci9jb21tb24vc2hhZGVycy9HcmF5c2NhbGVTaGFkZXIubWpzXCI7XG5pbXBvcnQgQzJkQmx1clNoYWRlciBmcm9tIFwiLi9yZW5kZXJlci9jMmQvc2hhZGVycy9CbHVyU2hhZGVyLm1qc1wiO1xuXG5pbXBvcnQgU3RhZ2UgZnJvbSBcIi4vdHJlZS9TdGFnZS5tanNcIjtcbmltcG9ydCBTcGlubmVyU2hhZGVyMiBmcm9tICcuL3JlbmRlcmVyL3dlYmdsL3NoYWRlcnMvU3Bpbm5lclNoYWRlcjIubWpzJztcblxuY29uc3QgbGlnaHRuaW5nID0ge1xuICAgIEFwcGxpY2F0aW9uLFxuICAgIENvbXBvbmVudCxcbiAgICBCYXNlLFxuICAgIFV0aWxzLFxuICAgIFN0YWdlVXRpbHMsXG4gICAgRWxlbWVudCxcbiAgICBUb29scyxcbiAgICBTdGFnZSxcbiAgICBFbGVtZW50Q29yZSxcbiAgICBFbGVtZW50VGV4dHVyaXplcixcbiAgICBUZXh0dXJlLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBzaGFkZXJzOiB7XG4gICAgICAgIEdyYXlzY2FsZTogV2ViR0xHcmF5c2NhbGVTaGFkZXIsXG4gICAgICAgIEJveEJsdXI6IEJveEJsdXJTaGFkZXIsXG4gICAgICAgIERpdGhlcmluZzogRGl0aGVyaW5nU2hhZGVyLFxuICAgICAgICBDaXJjdWxhclB1c2g6IENpcmN1bGFyUHVzaFNoYWRlcixcbiAgICAgICAgSW52ZXJzaW9uOiBJbnZlcnNpb25TaGFkZXIsXG4gICAgICAgIExpbmVhckJsdXI6IExpbmVhckJsdXJTaGFkZXIsXG4gICAgICAgIE91dGxpbmU6IE91dGxpbmVTaGFkZXIsXG4gICAgICAgIFBpeGVsYXRlOiBQaXhlbGF0ZVNoYWRlcixcbiAgICAgICAgUmFkaWFsRmlsdGVyOiBSYWRpYWxGaWx0ZXJTaGFkZXIsXG4gICAgICAgIFJvdW5kZWRSZWN0YW5nbGU6IFJvdW5kZWRSZWN0YW5nbGVTaGFkZXIsXG4gICAgICAgIFNwaW5uZXIyOiBTcGlubmVyU2hhZGVyMixcbiAgICAgICAgRmFkZU91dDogRmFkZU91dFNoYWRlcixcbiAgICAgICAgSG9sZTogSG9sZVNoYWRlcixcbiAgICAgICAgVmlnbmV0dGU6IFZpZ25ldHRlU2hhZGVyLFxuICAgICAgICBTcGlubmVyOiBTcGlubmVyU2hhZGVyLFxuICAgICAgICBSYWRpYWxHcmFkaWVudDogUmFkaWFsR3JhZGllbnRTaGFkZXIsXG4gICAgICAgIExpZ2h0M2Q6IExpZ2h0M2RTaGFkZXIsXG4gICAgICAgIFBlcnNwZWN0aXZlOiBQZXJzcGVjdGl2ZVNoYWRlcixcbiAgICAgICAgTWFnbmlmaWVyOiBNYWduaWZpZXJTaGFkZXIsXG4gICAgICAgIFdlYkdMU2hhZGVyLFxuICAgICAgICBXZWJHTERlZmF1bHRTaGFkZXIsXG4gICAgICAgIEMyZFNoYWRlcixcbiAgICAgICAgQzJkRGVmYXVsdFNoYWRlcixcbiAgICAgICAgYzJkOiB7XG4gICAgICAgICAgICBHcmF5c2NhbGU6IEMyZEdyYXlzY2FsZVNoYWRlcixcbiAgICAgICAgICAgIEJsdXI6IEMyZEJsdXJTaGFkZXJcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGV4dHVyZXM6IHtcbiAgICAgICAgUmVjdGFuZ2xlVGV4dHVyZSxcbiAgICAgICAgTm9pc2VUZXh0dXJlLFxuICAgICAgICBUZXh0VGV4dHVyZSxcbiAgICAgICAgSW1hZ2VUZXh0dXJlLFxuICAgICAgICBIdG1sVGV4dHVyZSxcbiAgICAgICAgU3RhdGljVGV4dHVyZSxcbiAgICAgICAgU3RhdGljQ2FudmFzVGV4dHVyZSxcbiAgICAgICAgU291cmNlVGV4dHVyZVxuICAgIH0sXG4gICAgY29tcG9uZW50czoge1xuICAgICAgICBGYXN0Qmx1ckNvbXBvbmVudCxcbiAgICAgICAgQmxvb21Db21wb25lbnQsXG4gICAgICAgIFNtb290aFNjYWxlQ29tcG9uZW50LFxuICAgICAgICBCb3JkZXJDb21wb25lbnQsXG4gICAgICAgIExpc3RDb21wb25lbnRcbiAgICB9LFxuICAgIHRvb2xzOiB7XG4gICAgICAgIE9iak1lcmdlcixcbiAgICAgICAgT2JqZWN0TGlzdFByb3h5LFxuICAgICAgICBPYmplY3RMaXN0V3JhcHBlclxuICAgIH1cbn07XG5cbmlmIChVdGlscy5pc1dlYikge1xuICAgIHdpbmRvdy5sbmcgPSBsaWdodG5pbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxpZ2h0bmluZztcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBXZWJQbGF0Zm9ybSBmcm9tIFwiLi9icm93c2VyL1dlYlBsYXRmb3JtLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF0Zm9ybUxvYWRlciB7XG4gICAgc3RhdGljIGxvYWQob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5wbGF0Zm9ybSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucGxhdGZvcm07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gV2ViUGxhdGZvcm07XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZVdvcmtlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2lkID0gMDtcblxuICAgICAgICB0aGlzLl9pbml0V29ya2VyKCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgICAgICAgdGhpcy5fd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2luaXRXb3JrZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBgKCR7Y3JlYXRlV29ya2VyLnRvU3RyaW5nKCl9KSgpYDtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtjb2RlLnJlcGxhY2UoJ1widXNlIHN0cmljdFwiOycsICcnKV0pOyAvLyBmaXJlZm94IGFkZHMgXCJ1c2Ugc3RyaWN0XCI7IHRvIGFueSBmdW5jdGlvbiB3aGljaCBtaWdodCBibG9jayB3b3JrZXIgZXhlY3V0aW9uIHNvIGtub2NrIGl0IG9mZlxuICAgICAgICBjb25zdCBibG9iVVJMID0gKHdpbmRvdy5VUkwgPyBVUkwgOiB3ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChibG9iLCB7XG4gICAgICAgICAgICB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDsgY2hhcnNldD11dGYtOCdcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG5cbiAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOiAnY29uZmlnJywgY29uZmlnOiB7cGF0aDogd2luZG93LmxvY2F0aW9uLmhyZWYsIHByb3RvY29sOiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9fSk7XG5cbiAgICAgICAgdGhpcy5fd29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS5pZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gZS5kYXRhLmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtcy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmRhdGEudHlwZSA9PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoKGl0ZW0sIGUuZGF0YS5pbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoaXRlbSwgZS5kYXRhLmluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3JlYXRlKHNyYykge1xuICAgICAgICBjb25zdCBpZCA9ICsrdGhpcy5faWQ7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgSW1hZ2VXb3JrZXJJbWFnZSh0aGlzLCBpZCwgc3JjKTtcbiAgICAgICAgdGhpcy5faXRlbXMuc2V0KGlkLCBpdGVtKTtcbiAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKHt0eXBlOiBcImFkZFwiLCBpZDogaWQsIHNyYzogc3JjfSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIGNhbmNlbChpbWFnZSkge1xuICAgICAgICB0aGlzLl93b3JrZXIucG9zdE1lc3NhZ2Uoe3R5cGU6IFwiY2FuY2VsXCIsIGlkOiBpbWFnZS5pZH0pO1xuICAgICAgICB0aGlzLl9pdGVtcy5kZWxldGUoaW1hZ2UuaWQpO1xuICAgIH1cblxuICAgIGVycm9yKGltYWdlLCBpbmZvKSB7XG4gICAgICAgIGltYWdlLmVycm9yKGluZm8pO1xuICAgICAgICB0aGlzLl9pdGVtcy5kZWxldGUoaW1hZ2UuaWQpO1xuICAgIH1cblxuICAgIGZpbmlzaChpbWFnZSwgaW5mbykge1xuICAgICAgICBpbWFnZS5sb2FkKGluZm8pO1xuICAgICAgICB0aGlzLl9pdGVtcy5kZWxldGUoaW1hZ2UuaWQpO1xuICAgIH1cblxufVxuXG5jbGFzcyBJbWFnZVdvcmtlckltYWdlIHtcblxuICAgIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGlkLCBzcmMpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX3NyYyA9IHNyYztcbiAgICAgICAgdGhpcy5fb25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuX29uTG9hZCA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuXG4gICAgZ2V0IHNyYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NyYztcbiAgICB9XG5cbiAgICBzZXQgb25FcnJvcihmKSB7XG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSBmO1xuICAgIH1cblxuICAgIHNldCBvbkxvYWQoZikge1xuICAgICAgICB0aGlzLl9vbkxvYWQgPSBmO1xuICAgIH1cblxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5jYW5jZWwodGhpcyk7XG4gICAgfVxuXG4gICAgbG9hZChpbmZvKSB7XG4gICAgICAgIGlmICh0aGlzLl9vbkxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29uTG9hZChpbmZvKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVycm9yKGluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuX29uRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoaW5mbyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyoqXG4gKiBOb3RpY2UgdGhhdCwgd2l0aGluIHRoZSBjcmVhdGVXb3JrZXIgZnVuY3Rpb24sIHdlIG11c3Qgb25seSB1c2UgRVM1IGNvZGUgdG8ga2VlcCBpdCBFUzUtdmFsaWQgYWZ0ZXIgYmFiZWxpZnlpbmcsIGFzXG4gKiAgdGhlIGNvbnZlcnRlZCBjb2RlIG9mIHRoaXMgc2VjdGlvbiBpcyBjb252ZXJ0ZWQgdG8gYSBibG9iIGFuZCB1c2VkIGFzIHRoZSBqcyBvZiB0aGUgd2ViIHdvcmtlciB0aHJlYWQuXG4gKi9cbmNvbnN0IGNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgZnVuY3Rpb24gSW1hZ2VXb3JrZXJTZXJ2ZXIoKSB7XG5cbiAgICAgICAgdGhpcy5pdGVtcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHQuX3JlY2VpdmVNZXNzYWdlKGUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlci5pc1BhdGhBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIC9eKD86XFwvfFthLXpdKzpcXC9cXC8pLy50ZXN0KHBhdGgpIHx8IHBhdGguc3Vic3RyKDAsIDUpID09ICdkYXRhOic7XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVyLnByb3RvdHlwZS5fcmVjZWl2ZU1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmRhdGEudHlwZSA9PT0gJ2NvbmZpZycpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnID0gZS5kYXRhLmNvbmZpZztcblxuICAgICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLmNvbmZpZy5wYXRoO1xuICAgICAgICAgICAgLy8gdGhlIGNvbnN0cnVjdGluZyBvZiB0aGUgYmFzZXBhdGggZmFpbHNcbiAgICAgICAgICAgIC8vIGlmIGxvY2F0aW9uLmhhc2ggY29udGFpbnMgYSBzbGFzaFxuICAgICAgICAgICAgdmFyIGhhc0hhc2hQYXRoID0gLyMuKj9cXC8vO1xuICAgICAgICAgICAgaWYoaGFzSGFzaFBhdGgudGVzdChiYXNlKSl7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UucmVwbGFjZSgvIy4qJC8sJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGFydHMgPSBiYXNlLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIHBhcnRzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVsYXRpdmVCYXNlID0gcGFydHMuam9pbihcIi9cIikgKyBcIi9cIjtcblxuICAgICAgICB9IGVsc2UgaWYgKGUuZGF0YS50eXBlID09PSAnYWRkJykge1xuICAgICAgICAgICAgdGhpcy5hZGQoZS5kYXRhLmlkLCBlLmRhdGEuc3JjKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEudHlwZSA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKGUuZGF0YS5pZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGlkLCBzcmMpIHtcbiAgICAgICAgLy8gQ29udmVydCByZWxhdGl2ZSBVUkxzLlxuICAgICAgICBpZiAoIUltYWdlV29ya2VyU2VydmVyLmlzUGF0aEFic29sdXRlKHNyYykpIHtcbiAgICAgICAgICAgIHNyYyA9IHRoaXMuX3JlbGF0aXZlQmFzZSArIHNyYztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmMuc3Vic3RyKDAsMikgPT09IFwiLy9cIikge1xuICAgICAgICAgICAgLy8gVGhpcyBkb2Vzbid0IHdvcmsgZm9yIGltYWdlIHdvcmtlcnMuXG4gICAgICAgICAgICBzcmMgPSB0aGlzLmNvbmZpZy5wcm90b2NvbCArIHNyYztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVtID0gbmV3IEltYWdlV29ya2VyU2VydmVySXRlbShpZCwgc3JjKTtcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xuICAgICAgICBpdGVtLm9uRmluaXNoID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICB0LmZpbmlzaChpdGVtLCByZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBpdGVtLm9uRXJyb3IgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgICAgICB0LmVycm9yKGl0ZW0sIGluZm8pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLml0ZW1zLnNldChpZCwgaXRlbSk7XG4gICAgICAgIGl0ZW0uc3RhcnQoKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5pdGVtcy5nZXQoaWQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgaXRlbS5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEltYWdlV29ya2VyU2VydmVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihpdGVtLCB7aW1hZ2VCaXRtYXAsIGhhc0FscGhhQ2hhbm5lbH0pIHtcbiAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJkYXRhXCIsXG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICAgICBpbWFnZUJpdG1hcCxcbiAgICAgICAgICAgICAgICBoYXNBbHBoYUNoYW5uZWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW2ltYWdlQml0bWFwXSk7XG4gICAgICAgIHRoaXMuaXRlbXMuZGVsZXRlKGl0ZW0uaWQpO1xuICAgIH07XG5cbiAgICBJbWFnZVdvcmtlclNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihpdGVtLCB7dHlwZSwgbWVzc2FnZX0pIHtcbiAgICAgICAgcG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLml0ZW1zLmRlbGV0ZShpdGVtLmlkKTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXIuaXNXUEVCcm93c2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiV1BFXCIpICE9PSAtMSk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIEltYWdlV29ya2VyU2VydmVySXRlbShpZCwgc3JjKSB7XG5cbiAgICAgICAgdGhpcy5fb25FcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fb25GaW5pc2ggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX3NyYyA9IHNyYztcbiAgICAgICAgdGhpcy5feGhyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLCAnaWQnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbWFnZVdvcmtlclNlcnZlckl0ZW0ucHJvdG90eXBlLCAnb25GaW5pc2gnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25GaW5pc2g7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgdGhpcy5fb25GaW5pc2ggPSBmO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZSwgJ29uRXJyb3InLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25FcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yID0gZjtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl94aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdGhpcy5feGhyLm9wZW4oXCJHRVRcIiwgdGhpcy5fc3JjLCB0cnVlKTtcbiAgICAgICAgdGhpcy5feGhyLnJlc3BvbnNlVHlwZSA9IFwiYmxvYlwiO1xuXG4gICAgICAgIHZhciB0ID0gdGhpcztcbiAgICAgICAgdGhpcy5feGhyLm9uZXJyb3IgPSBmdW5jdGlvbihvRXZlbnQpIHtcbiAgICAgICAgICAgIHQuZXJyb3Ioe3R5cGU6IFwiY29ubmVjdGlvblwiLCBtZXNzYWdlOiBcIkNvbm5lY3Rpb24gZXJyb3JcIn0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3hoci5vbmxvYWQgPSBmdW5jdGlvbihvRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBibG9iID0gdC5feGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgdC5fbWltZVR5cGUgPSBibG9iLnR5cGU7XG5cbiAgICAgICAgICAgIHQuX2NyZWF0ZUltYWdlQml0bWFwKGJsb2IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3hoci5zZW5kKCk7XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUuX2NyZWF0ZUltYWdlQml0bWFwID0gZnVuY3Rpb24oYmxvYikge1xuICAgICAgICB2YXIgdCA9IHRoaXM7XG4gICAgICAgIGNyZWF0ZUltYWdlQml0bWFwKGJsb2IsIHtwcmVtdWx0aXBseUFscGhhOiAncHJlbXVsdGlwbHknLCBjb2xvclNwYWNlQ29udmVyc2lvbjogJ25vbmUnLCBpbWFnZU9yaWVudGF0aW9uOiAnbm9uZSd9KS50aGVuKGZ1bmN0aW9uKGltYWdlQml0bWFwKSB7XG4gICAgICAgICAgICB0LmZpbmlzaCh7XG4gICAgICAgICAgICAgICAgaW1hZ2VCaXRtYXAsXG4gICAgICAgICAgICAgICAgaGFzQWxwaGFDaGFubmVsOiB0Ll9oYXNBbHBoYUNoYW5uZWwoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHQuZXJyb3Ioe3R5cGU6IFwicGFyc2VcIiwgbWVzc2FnZTogXCJFcnJvciBwYXJzaW5nIGltYWdlIGRhdGFcIn0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgSW1hZ2VXb3JrZXJTZXJ2ZXJJdGVtLnByb3RvdHlwZS5faGFzQWxwaGFDaGFubmVsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChJbWFnZVdvcmtlclNlcnZlci5pc1dQRUJyb3dzZXIoKSkge1xuICAgICAgICAgICAgLy8gV2hlbiB1c2luZyB1bmFjY2VsZXJhdGVkIHJlbmRlcmluZyBpbWFnZSAoaHR0cHM6Ly9naXRodWIuY29tL1dlYlBsYXRmb3JtRm9yRW1iZWRkZWQvV1BFV2ViS2l0L2Jsb2Ivd3BlLTIwMTcwNzI4L1NvdXJjZS9XZWJDb3JlL2h0bWwvSW1hZ2VCaXRtYXAuY3BwI0w1MiksXG4gICAgICAgICAgICAvLyBldmVyeXRoaW5nIGluY2x1ZGluZyBKUEcgaW1hZ2VzIGFyZSBpbiBSR0JBIGZvcm1hdC4gVXBsb2FkIGlzIHdheSBmYXN0ZXIgd2hlbiB1c2luZyBhbiBhbHBoYSBjaGFubmVsLlxuICAgICAgICAgICAgLy8gQHRvZG86IGFmdGVyIGhhcmR3YXJlIGFjY2VsZXJhdGlvbiBpcyBmaXhlZCBhbmQgcmUtZW5hYmxlZCwgSlBHIHNob3VsZCBiZSB1cGxvYWRlZCBpbiBSR0IgdG8gZ2V0IHRoZSBiZXN0IHBvc3NpYmxlIHBlcmZvcm1hbmNlIGFuZCBtZW1vcnkgdXNhZ2UuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fbWltZVR5cGUuaW5kZXhPZihcImltYWdlL3BuZ1wiKSAhPT0gLTEpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5feGhyKSB7XG4gICAgICAgICAgICB0aGlzLl94aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbih0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FuY2VsZWQgJiYgdGhpcy5fb25FcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcih7dHlwZSwgbWVzc2FnZX0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEltYWdlV29ya2VyU2VydmVySXRlbS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oaW5mbykge1xuICAgICAgICBpZiAoIXRoaXMuX2NhbmNlbGVkICYmIHRoaXMuX29uRmluaXNoKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkZpbmlzaChpbmZvKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd29ya2VyID0gbmV3IEltYWdlV29ya2VyU2VydmVyKCk7XG59O1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IEltYWdlV29ya2VyIGZyb20gXCIuL0ltYWdlV29ya2VyLm1qc1wiO1xuXG4vKipcbiAqIFBsYXRmb3JtLXNwZWNpZmljIGZ1bmN0aW9uYWxpdHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYlBsYXRmb3JtIHtcblxuICAgIGluaXQoc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgICAgICB0aGlzLl9sb29waW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2F3YWl0aW5nTG9vcCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLnN0YWdlLmdldE9wdGlvbihcInVzZUltYWdlV29ya2VyXCIpKSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcCB8fCAhd2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIENhbid0IHVzZSBpbWFnZSB3b3JrZXIgYmVjYXVzZSBicm93c2VyIGRvZXMgbm90IGhhdmUgY3JlYXRlSW1hZ2VCaXRtYXAgYW5kIFdlYiBXb3JrZXIgc3VwcG9ydFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2VXb3JrZXIgPSBuZXcgSW1hZ2VXb3JrZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbWFnZVdvcmtlcikge1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VXb3JrZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW92ZUtleUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlQ2xpY2tIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUhvdmVySGFuZGxlcigpO1xuICAgICAgICB0aGlzLl9yZW1vdmVTY3JvbGxXaGVlbEhhbmRsZXIoKTtcbiAgICB9XG5cbiAgICBzdGFydExvb3AoKSB7XG4gICAgICAgIHRoaXMuX2xvb3BpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuX2F3YWl0aW5nTG9vcCkge1xuICAgICAgICAgICAgdGhpcy5sb29wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9wTG9vcCgpIHtcbiAgICAgICAgdGhpcy5fbG9vcGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGxvb3AoKSB7XG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGxwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9hd2FpdGluZ0xvb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLl9sb29waW5nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdGFnZS5kcmF3RnJhbWUoKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobHApO1xuICAgICAgICAgICAgICAgIHNlbGYuX2F3YWl0aW5nTG9vcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxwKTtcbiAgICB9XG5cbiAgICB1cGxvYWRHbFRleHR1cmUoZ2wsIHRleHR1cmVTb3VyY2UsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoc291cmNlIGluc3RhbmNlb2YgSW1hZ2VEYXRhIHx8IHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCB8fCAod2luZG93LkltYWdlQml0bWFwICYmIHNvdXJjZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSkge1xuICAgICAgICAgICAgLy8gV2ViLXNwZWNpZmljIGRhdGEgdHlwZXMuXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIG9wdGlvbnMuaW50ZXJuYWxGb3JtYXQsIG9wdGlvbnMuZm9ybWF0LCBvcHRpb25zLnR5cGUsIHNvdXJjZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIHNvbWUgYnJvd3NlcnMgKGUuZy4gVGl6ZW4pIGFzIHRoZXkgZG8gbm90IGNvbnZlcnQgY2FudmFzIGRhdGEgdG8gdGV4dHVyZSBjb3JyZWN0bHksIHNvbWV0aW1lcyBjYXVzaW5nIGFydGlmYWN0cy5cbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHNvdXJjZS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBvcHRpb25zLmludGVybmFsRm9ybWF0LCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBvcHRpb25zLmludGVybmFsRm9ybWF0LCB0ZXh0dXJlU291cmNlLncsIHRleHR1cmVTb3VyY2UuaCwgMCwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRTcmNUZXh0dXJlKHtzcmMsIGhhc0FscGhhfSwgY2IpIHtcbiAgICAgICAgbGV0IGNhbmNlbENiID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgaXNQbmcgPSAoc3JjLmluZGV4T2YoXCIucG5nXCIpID49IDApIHx8IHNyYy5zdWJzdHIoMCwgMjEpID09ICdkYXRhOmltYWdlL3BuZztiYXNlNjQnO1xuICAgICAgICBpZiAodGhpcy5faW1hZ2VXb3JrZXIpIHtcbiAgICAgICAgICAgIC8vIFdQRS1zcGVjaWZpYyBpbWFnZSBwYXJzZXIuXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuX2ltYWdlV29ya2VyLmNyZWF0ZShzcmMpO1xuICAgICAgICAgICAgaW1hZ2Uub25FcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihcIkltYWdlIGxvYWQgZXJyb3JcIik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1hZ2Uub25Mb2FkID0gZnVuY3Rpb24oe2ltYWdlQml0bWFwLCBoYXNBbHBoYUNoYW5uZWx9KSB7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGltYWdlQml0bWFwLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiB7c3JjOiBzcmN9LFxuICAgICAgICAgICAgICAgICAgICBoYXNBbHBoYTogaGFzQWxwaGFDaGFubmVsLFxuICAgICAgICAgICAgICAgICAgICBwcmVtdWx0aXBseUFscGhhOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FuY2VsQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgICAgICAvLyBPbiB0aGUgUFM0IHBsYXRmb3JtIHNldHRpbmcgdGhlIGBjcm9zc09yaWdpbmAgYXR0cmlidXRlIG9uXG4gICAgICAgICAgICAvLyBpbWFnZXMgY2FuIGNhdXNlIENPUlMgZmFpbHVyZXMuXG4gICAgICAgICAgICBpZiAoIShzcmMuc3Vic3RyKDAsNSkgPT0gXCJkYXRhOlwiKSAmJiAhVXRpbHMuaXNQUzQpIHtcbiAgICAgICAgICAgICAgICAvLyBCYXNlNjQuXG4gICAgICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvciBtZXNzYWdlIHdoZW4gY2FuY2VsbGVkLlxuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5zcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKFwiSW1hZ2UgbG9hZCBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGltYWdlLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJJbmZvOiB7c3JjOiBzcmN9LFxuICAgICAgICAgICAgICAgICAgICBoYXNBbHBoYTogaXNQbmcgfHwgaGFzQWxwaGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBzcmM7XG5cbiAgICAgICAgICAgIGNhbmNlbENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Uub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbmNlbENiO1xuICAgIH1cblxuICAgIGNyZWF0ZVdlYkdMQ29udGV4dCh3LCBoKSB7XG4gICAgICAgIGxldCBjYW52YXMgPSB0aGlzLnN0YWdlLmdldE9wdGlvbignY2FudmFzJykgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAgICAgaWYgKHcgJiYgaCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9wdHMgPSB7XG4gICAgICAgICAgICBhbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIGFudGlhbGlhczogZmFsc2UsXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXG4gICAgICAgICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdHMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRzKTtcbiAgICAgICAgaWYgKCFnbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB3ZWJHTC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbDtcbiAgICB9XG5cbiAgICBjcmVhdGVDYW52YXNDb250ZXh0KHcsIGgpIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdjYW52YXMnKSB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgICAgICBpZiAodyAmJiBoKSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3O1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYzJkID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghYzJkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IDJkIGNhbnZhcy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjMmQ7XG4gICAgfVxuXG4gICAgZ2V0SHJUaW1lKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIDogKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICBnZXREcmF3aW5nQ2FudmFzKCkge1xuICAgICAgICAvLyBXZSBjYW4ndCByZXVzZSB0aGlzIGNhbnZhcyBiZWNhdXNlIHRleHR1cmVzIG1heSBsb2FkIGFzeW5jLlxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZU9wdGlvbnNGb3JEcmF3aW5nQ2FudmFzKGNhbnZhcykge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgICAgICBvcHRpb25zLnNvdXJjZSA9IGNhbnZhcztcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgbmV4dEZyYW1lKGNoYW5nZXMpIHtcbiAgICAgICAgLyogV2ViR0wgYmxpdHMgYXV0b21hdGljYWxseSAqL1xuICAgIH1cblxuICAgIHJlZ2lzdGVyS2V5ZG93bkhhbmRsZXIoa2V5aGFuZGxlcikge1xuICAgICAgICB0aGlzLl9rZXlkb3duTGlzdGVuZXIgPSAoZSkgPT4ge1xuICAgICAgICAgICAga2V5aGFuZGxlcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyS2V5dXBIYW5kbGVyKGtleWhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fa2V5dXBMaXN0ZW5lciA9IChlKSA9PiB7XG4gICAgICAgICAgICBrZXloYW5kbGVyKGUpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB0aGlzLl9rZXl1cExpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlS2V5SGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2tleWRvd25MaXN0ZW5lcikge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duTGlzdGVuZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2tleXVwTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHRoaXMuX2tleXVwTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJDbGlja0hhbmRsZXIoY2xpY2tIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2NsaWNrTGlzdGVuZXIgPSBlID0+IHtcbiAgICAgICAgICAgIGNsaWNrSGFuZGxlcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2NsaWNrTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIF9yZW1vdmVDbGlja0hhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3RlckhvdmVySGFuZGxlcihob3ZlckhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5faG92ZXJMaXN0ZW5lciA9IGUgPT4ge1xuICAgICAgICAgICAgaG92ZXJIYW5kbGVyKGUpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5faG92ZXJMaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgX3JlbW92ZUhvdmVySGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hvdmVyTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9ob3Zlckxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyU2Nyb2xsV2hlZWxIYW5kbGVyKHJlZ2lzdGVyU2Nyb2xsV2hlZWxIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFdoZWVsTGlzdGVuZXIgPSBlID0+IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyU2Nyb2xsV2hlZWxIYW5kbGVyKGUpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX3Njcm9sbFdoZWVsTGlzdGVuZXIpO1xuICAgIH1cblxuICAgIF9yZW1vdmVTY3JvbGxXaGVlbEhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxXaGVlbExpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9zY3JvbGxXaGVlbExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgICAgICB0aGlzLl9kZWZhdWx0U2hhZGVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdjKGFnZ3Jlc3NpdmUpIHtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgIH1cblxuICAgIGdldERlZmF1bHRTaGFkZXIoY3R4ID0gdGhpcy5zdGFnZS5jdHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZhdWx0U2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0U2hhZGVyID0gdGhpcy5fY3JlYXRlRGVmYXVsdFNoYWRlcihjdHgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U2hhZGVyO1xuICAgIH1cblxuICAgIF9jcmVhdGVEZWZhdWx0U2hhZGVyKGN0eCkge1xuICAgIH1cblxuICAgIGlzVmFsaWRTaGFkZXJUeXBlKHNoYWRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChzaGFkZXJUeXBlLnByb3RvdHlwZSBpbnN0YW5jZW9mIHRoaXMuX2dldFNoYWRlckJhc2VUeXBlKCkpO1xuICAgIH1cblxuICAgIGNyZWF0ZVNoYWRlcihjdHgsIHNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHNoYWRlclR5cGUgPSBzZXR0aW5ncy50eXBlO1xuICAgICAgICAvLyBJZiBzaGFkZXIgdHlwZSBpcyBub3QgY29ycmVjdCwgdXNlIGEgZGlmZmVyZW50IHBsYXRmb3JtLlxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFNoYWRlclR5cGUoc2hhZGVyVHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnZlcnRlZFNoYWRlclR5cGUgPSB0aGlzLl9nZXRTaGFkZXJBbHRlcm5hdGl2ZShzaGFkZXJUeXBlKTtcbiAgICAgICAgICAgIGlmICghY29udmVydGVkU2hhZGVyVHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIFNoYWRlciBoYXMgbm8gaW1wbGVtZW50YXRpb24gZm9yIHJlbmRlciB0YXJnZXQ6IFwiICsgc2hhZGVyVHlwZS5uYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlRGVmYXVsdFNoYWRlcihjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb252ZXJ0ZWRTaGFkZXJUeXBlKGN0eCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgc2hhZGVyVHlwZShjdHgpO1xuICAgICAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFNoYWRlckJhc2VUeXBlKCkge1xuICAgIH1cblxuICAgIF9nZXRTaGFkZXJBbHRlcm5hdGl2ZShzaGFkZXJUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERlZmF1bHRTaGFkZXIoKTtcbiAgICB9XG5cbiAgICBjb3B5UmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlLCBuYXRpdmVUZXh0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW0xpZ2h0bmluZ10gY29weVJlbmRlclRleHR1cmUgbm90IHN1cHBvcnRlZCBieSByZW5kZXJlcicpO1xuICAgIH1cbn1cblxuaW1wb3J0IEJhc2UgZnJvbSBcIi4uL3RyZWUvQmFzZS5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDb3JlUXVhZExpc3QgZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUXVhZExpc3QubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEMyZENvcmVRdWFkTGlzdCBleHRlbmRzIENvcmVRdWFkTGlzdCB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICB0aGlzLnJlbmRlckNvbnRleHRzID0gW107XG4gICAgICAgIHRoaXMubW9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBzZXRSZW5kZXJDb250ZXh0KGluZGV4LCB2KSB7XG4gICAgICAgIHRoaXMucmVuZGVyQ29udGV4dHNbaW5kZXhdID0gdjtcbiAgICB9XG5cbiAgICBzZXRTaW1wbGVUYyhpbmRleCwgdikge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgdGhpcy5tb2Rlc1tpbmRleF0gfD0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZXNbaW5kZXhdIC09ICh0aGlzLm1vZGVzW2luZGV4XSAmIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0V2hpdGUoaW5kZXgsIHYpIHtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZXNbaW5kZXhdIHw9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVzW2luZGV4XSAtPSAodGhpcy5tb2Rlc1tpbmRleF0gJiAyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFJlbmRlckNvbnRleHQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ29udGV4dHNbaW5kZXhdO1xuICAgIH1cblxuICAgIGdldFNpbXBsZVRjKGluZGV4KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tb2Rlc1tpbmRleF0gJiAxKTtcbiAgICB9XG5cbiAgICBnZXRXaGl0ZShpbmRleCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubW9kZXNbaW5kZXhdICYgMik7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29yZVF1YWRPcGVyYXRpb24gZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUXVhZE9wZXJhdGlvbi5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQzJkQ29yZVF1YWRPcGVyYXRpb24gZXh0ZW5kcyBDb3JlUXVhZE9wZXJhdGlvbiB7XG5cbiAgICBnZXRSZW5kZXJDb250ZXh0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldFJlbmRlckNvbnRleHQodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRTaW1wbGVUYyhpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRTaW1wbGVUYyh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGdldFdoaXRlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldFdoaXRlKHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29yZVJlbmRlckV4ZWN1dG9yIGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVJlbmRlckV4ZWN1dG9yLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vLi4vdHJlZS9VdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQzJkQ29yZVJlbmRlckV4ZWN1dG9yIGV4dGVuZHMgQ29yZVJlbmRlckV4ZWN1dG9yIHtcblxuICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMuX21haW5SZW5kZXJUZXh0dXJlID0gdGhpcy5jdHguc3RhZ2UuZ2V0Q2FudmFzKCk7XG4gICAgfVxuXG4gICAgX3JlbmRlclF1YWRPcGVyYXRpb24ob3ApIHtcbiAgICAgICAgbGV0IHNoYWRlciA9IG9wLnNoYWRlcjtcblxuICAgICAgICBpZiAob3AubGVuZ3RoIHx8IG9wLnNoYWRlci5hZGRFbXB0eSgpKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9yZW5kZXJUZXh0dXJlIHx8IHRoaXMuX21haW5SZW5kZXJUZXh0dXJlO1xuICAgICAgICAgICAgc2hhZGVyLmJlZm9yZURyYXcob3AsIHRhcmdldCk7XG4gICAgICAgICAgICBzaGFkZXIuZHJhdyhvcCwgdGFyZ2V0KTtcbiAgICAgICAgICAgIHNoYWRlci5hZnRlckRyYXcob3AsIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2xlYXJSZW5kZXJUZXh0dXJlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRDb250ZXh0KCk7XG5cbiAgICAgICAgbGV0IGNsZWFyQ29sb3IgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIGlmICh0aGlzLl9tYWluUmVuZGVyVGV4dHVyZS5jdHggPT09IGN0eCkge1xuICAgICAgICAgICAgY2xlYXJDb2xvciA9IHRoaXMuY3R4LnN0YWdlLmdldENsZWFyQ29sb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlbmRlclRleHR1cmUgPSBjdHguY2FudmFzO1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBpZiAoIWNsZWFyQ29sb3JbMF0gJiYgIWNsZWFyQ29sb3JbMV0gJiYgIWNsZWFyQ29sb3JbMl0gJiYgIWNsZWFyQ29sb3JbM10pIHtcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgcmVuZGVyVGV4dHVyZS53aWR0aCwgcmVuZGVyVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZ0Zyb21BcnJheShjbGVhckNvbG9yKTtcbiAgICAgICAgICAgIC8vIERvIG5vdCB1c2UgZmlsbFJlY3QgYmVjYXVzZSBpdCBwcm9kdWNlcyBhcnRpZmFjdHMuXG4gICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LnJlY3QoMCwgMCwgcmVuZGVyVGV4dHVyZS53aWR0aCwgcmVuZGVyVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIF9nZXRDb250ZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmUuY3R4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21haW5SZW5kZXJUZXh0dXJlLmN0eDtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICBfcmVzdG9yZUNvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldENvbnRleHQoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4Ll9zY2lzc29yID0gbnVsbDtcbiAgICB9XG5cbiAgICBfc2V0U2Npc3NvcihhcmVhKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldENvbnRleHQoKTtcblxuICAgICAgICBpZiAoIUMyZENvcmVSZW5kZXJFeGVjdXRvci5fZXF1YWxTY2lzc29yQXJlYXMoY3R4LmNhbnZhcywgY3R4Ll9zY2lzc29yLCBhcmVhKSkge1xuICAgICAgICAgICAgLy8gQ2xpcHBpbmcgaXMgc3RvcmVkIGluIHRoZSBjYW52YXMgY29udGV4dCBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFdlIGNhbid0IHJlc2V0IGNsaXBwaW5nIGFsb25lIHNvIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgZnVsbCBjb250ZXh0LlxuICAgICAgICAgICAgdGhpcy5fcmVzdG9yZUNvbnRleHQoKTtcblxuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICAgICAgaWYgKGFyZWEpIHtcbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoTWF0aC5yb3VuZChhcmVhWzBdICogcHJlY2lzaW9uKSwgTWF0aC5yb3VuZChhcmVhWzFdICogcHJlY2lzaW9uKSwgTWF0aC5yb3VuZChhcmVhWzJdICogcHJlY2lzaW9uKSwgTWF0aC5yb3VuZChhcmVhWzNdICogcHJlY2lzaW9uKSk7XG4gICAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguX3NjaXNzb3IgPSBhcmVhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIF9lcXVhbFNjaXNzb3JBcmVhcyhjYW52YXMsIGFyZWEsIGN1cnJlbnQpIHtcbiAgICAgICAgaWYgKCFhcmVhKSB7XG4gICAgICAgICAgICBhcmVhID0gWzAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodF1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBbMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0XVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBVdGlscy5lcXVhbFZhbHVlcyhhcmVhLCBjdXJyZW50KVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IEMyZENvcmVRdWFkTGlzdCBmcm9tIFwiLi9DMmRDb3JlUXVhZExpc3QubWpzXCI7XG5pbXBvcnQgQzJkQ29yZVF1YWRPcGVyYXRpb24gZnJvbSBcIi4vQzJkQ29yZVF1YWRPcGVyYXRpb24ubWpzXCI7XG5pbXBvcnQgQzJkQ29yZVJlbmRlckV4ZWN1dG9yIGZyb20gXCIuL0MyZENvcmVSZW5kZXJFeGVjdXRvci5tanNcIjtcbmltcG9ydCBDb3JlUmVuZGVyU3RhdGUgZnJvbSBcIi4uLy4uL3RyZWUvY29yZS9Db3JlUmVuZGVyU3RhdGUubWpzXCI7XG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9zaGFkZXJzL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgQzJkU2hhZGVyIGZyb20gXCIuL0MyZFNoYWRlci5tanNcIjtcbmltcG9ydCBSZW5kZXJlciBmcm9tIFwiLi4vUmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgVGV4dHVyZVRpbnRNYW5hZ2VyIGZyb20gXCIuL0MyZFRleHR1cmVUaW50TWFuYWdlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQzJkUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy50aW50TWFuYWdlciA9IG5ldyBUZXh0dXJlVGludE1hbmFnZXIoc3RhZ2UpO1xuXG4gICAgICAgIHRoaXMuc2V0dXBDMmQodGhpcy5zdGFnZS5jMmQuY2FudmFzKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRpbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlRGVmYXVsdFNoYWRlcihjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0U2hhZGVyKGN0eCk7XG4gICAgfVxuXG4gICAgX2dldFNoYWRlckJhc2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gQzJkU2hhZGVyXG4gICAgfVxuXG4gICAgX2dldFNoYWRlckFsdGVybmF0aXZlKHNoYWRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNoYWRlclR5cGUuZ2V0QzJkICYmIHNoYWRlclR5cGUuZ2V0QzJkKCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29yZVF1YWRMaXN0KGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IEMyZENvcmVRdWFkTGlzdChjdHgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvcmVRdWFkT3BlcmF0aW9uKGN0eCwgc2hhZGVyLCBzaGFkZXJPd25lciwgcmVuZGVyVGV4dHVyZUluZm8sIHNjaXNzb3IsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgQzJkQ29yZVF1YWRPcGVyYXRpb24oY3R4LCBzaGFkZXIsIHNoYWRlck93bmVyLCByZW5kZXJUZXh0dXJlSW5mbywgc2Npc3NvciwgaW5kZXgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvcmVSZW5kZXJFeGVjdXRvcihjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDMmRDb3JlUmVuZGVyRXhlY3V0b3IoY3R4KTtcbiAgICB9XG4gICAgXG4gICAgY3JlYXRlQ29yZVJlbmRlclN0YXRlKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IENvcmVSZW5kZXJTdGF0ZShjdHgpO1xuICAgIH1cblxuICAgIGNyZWF0ZVJlbmRlclRleHR1cmUodywgaCwgcHcsIHBoKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBwdztcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHBoO1xuICAgICAgICB0aGlzLnNldHVwQzJkKGNhbnZhcyk7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuICAgIFxuICAgIGZyZWVSZW5kZXJUZXh0dXJlKG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50aW50TWFuYWdlci5kZWxldGUobmF0aXZlVGV4dHVyZSk7XG4gICAgfVxuXG4gICAgZ2MoYWdncmVzc2l2ZSkge1xuICAgICAgICB0aGlzLnRpbnRNYW5hZ2VyLmdjKGFnZ3Jlc3NpdmUpO1xuICAgIH1cblxuICAgIHVwbG9hZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICAvLyBGb3IgY2FudmFzLCB3ZSBkbyBub3QgbmVlZCB0byB1cGxvYWQuXG4gICAgICAgIGlmIChvcHRpb25zLnNvdXJjZS5idWZmZXIpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgUkdCQSBidWZmZXIgdG8gY2FudmFzLlxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBvcHRpb25zLnc7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gb3B0aW9ucy5oO1xuXG4gICAgICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShvcHRpb25zLnNvdXJjZS5idWZmZXIpLCBvcHRpb25zLncsIG9wdGlvbnMuaCk7XG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3B0aW9ucy5zb3VyY2U7XG4gICAgfVxuXG4gICAgZnJlZVRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICB0aGlzLnRpbnRNYW5hZ2VyLmRlbGV0ZSh0ZXh0dXJlU291cmNlLm5hdGl2ZVRleHR1cmUpO1xuICAgIH1cblxuICAgIGFkZFF1YWQocmVuZGVyU3RhdGUsIHF1YWRzLCBpbmRleCkge1xuICAgICAgICAvLyBSZW5kZXIgY29udGV4dCBjaGFuZ2VzIHdoaWxlIHRyYXZlcnNpbmcgc28gd2Ugc2F2ZSBpdCBieSByZWYuXG4gICAgICAgIGNvbnN0IGVsZW1lbnRDb3JlID0gcXVhZHMucXVhZEVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgcXVhZHMuc2V0UmVuZGVyQ29udGV4dChpbmRleCwgZWxlbWVudENvcmUuX3JlbmRlckNvbnRleHQpO1xuICAgICAgICBxdWFkcy5zZXRXaGl0ZShpbmRleCwgZWxlbWVudENvcmUuaXNXaGl0ZSgpKTtcbiAgICAgICAgcXVhZHMuc2V0U2ltcGxlVGMoaW5kZXgsIGVsZW1lbnRDb3JlLmhhc1NpbXBsZVRleENvb3JkcygpKTtcbiAgICB9XG5cbiAgICBpc1JlbmRlclRleHR1cmVSZXVzYWJsZShyZW5kZXJTdGF0ZSwgcmVuZGVyVGV4dHVyZUluZm8pIHtcbiAgICAgICAgLy8gQHRvZG86IGNoZWNrIHJlbmRlciBjb29yZHMvbWF0cml4LCBtYXliZSBtb3ZlIHRoaXMgdG8gY29yZT9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZpbmlzaFJlbmRlclN0YXRlKHJlbmRlclN0YXRlKSB7XG4gICAgfVxuXG4gICAgc2V0dXBDMmQoY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjYW52YXMuY3R4ID0gY3R4O1xuXG4gICAgICAgIGN0eC5fc2Npc3NvciA9IG51bGw7XG5cbiAgICAgICAgLy8gU2F2ZSBiYXNlIHN0YXRlIHNvIHdlIGNhbiByZXN0b3JlIHRoZSBkZWZhdWx0cyBsYXRlci5cbiAgICAgICAgY2FudmFzLmN0eC5zYXZlKCk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU2hhZGVyIGZyb20gXCIuLi8uLi90cmVlL1NoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQzJkU2hhZGVyIGV4dGVuZHMgU2hhZGVyIHtcblxuICAgIGJlZm9yZURyYXcob3BlcmF0aW9uKSB7XG4gICAgfVxuXG4gICAgZHJhdyhvcGVyYXRpb24pIHtcbiAgICB9XG5cbiAgICBhZnRlckRyYXcob3BlcmF0aW9uKSB7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDMmRUZXh0dXJlVGludE1hbmFnZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ID0gMDtcbiAgICAgICAgdGhpcy5fY2FjaGVkTmF0aXZlVGV4dHVyZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5nYyh0cnVlKTtcbiAgICB9XG5cbiAgICBfYWRkTWVtb3J5VXNhZ2UoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSArPSBkZWx0YTtcblxuICAgICAgICB0aGlzLnN0YWdlLmFkZE1lbW9yeVVzYWdlKGRlbHRhKTtcbiAgICB9XG5cbiAgICBkZWxldGUobmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gbmF0aXZlIHRleHR1cmUgaXMgY2xlYW5lZCB1cC5cbiAgICAgICAgaWYgKHRoaXMuX2hhc0NhY2hlKG5hdGl2ZVRleHR1cmUpKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2dldENhY2hlKG5hdGl2ZVRleHR1cmUpO1xuICAgICAgICAgICAgY29uc3QgcHJldk1lbVVzYWdlID0gY2FjaGUubWVtb3J5VXNhZ2U7XG4gICAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkTmF0aXZlVGV4dHVyZXMuZGVsZXRlKG5hdGl2ZVRleHR1cmUpO1xuICAgICAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UoY2FjaGUubWVtb3J5VXNhZ2UgLSBwcmV2TWVtVXNhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VGludFRleHR1cmUobmF0aXZlVGV4dHVyZSwgY29sb3IpIHtcbiAgICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlcjtcblxuICAgICAgICB0aGlzLl9jYWNoZWROYXRpdmVUZXh0dXJlcy5hZGQobmF0aXZlVGV4dHVyZSk7XG5cbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9nZXRDYWNoZShuYXRpdmVUZXh0dXJlKTtcblxuICAgICAgICBjb25zdCBpdGVtID0gY2FjaGUuZ2V0KGNvbG9yKTtcbiAgICAgICAgaXRlbS5sZiA9IGZyYW1lO1xuXG4gICAgICAgIGlmIChpdGVtLnR4KSB7XG4gICAgICAgICAgICBpZiAobmF0aXZlVGV4dHVyZS51cGRhdGUgPiBpdGVtLnUpIHtcbiAgICAgICAgICAgICAgICAvLyBOYXRpdmUgdGV4dHVyZSB3YXMgdXBkYXRlZCBpbiB0aGUgbWVhbiB0aW1lOiByZW5ldy5cbiAgICAgICAgICAgICAgICB0aGlzLl90aW50VGV4dHVyZShpdGVtLnR4LCBuYXRpdmVUZXh0dXJlLCBjb2xvcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBiZWZvcmUgPSBjYWNoZS5tZW1vcnlVc2FnZTtcblxuICAgICAgICAgICAgLy8gRmluZCBibGFuY28gdGludCB0ZXh0dXJlLlxuICAgICAgICAgICAgbGV0IHRhcmdldCA9IGNhY2hlLnJldXNlVGV4dHVyZShmcmFtZSk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmN0eC5jbGVhclJlY3QoMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb2NhdGUgbmV3LlxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIHRhcmdldC53aWR0aCA9IG5hdGl2ZVRleHR1cmUudztcbiAgICAgICAgICAgICAgICB0YXJnZXQuaGVpZ2h0ID0gbmF0aXZlVGV4dHVyZS5oO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jdHggPSB0YXJnZXQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdGludFRleHR1cmUodGFyZ2V0LCBuYXRpdmVUZXh0dXJlLCBjb2xvcik7XG4gICAgICAgICAgICBjYWNoZS5zZXQoY29sb3IsIHRhcmdldCwgZnJhbWUpO1xuXG4gICAgICAgICAgICBjb25zdCBhZnRlciA9IGNhY2hlLm1lbW9yeVVzYWdlO1xuXG4gICAgICAgICAgICBpZiAoYWZ0ZXIgIT09IGJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKGFmdGVyIC0gYmVmb3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF90aW50VGV4dHVyZSh0YXJnZXQsIHNvdXJjZSwgY29sb3IpIHtcbiAgICAgICAgbGV0IGNvbCA9IGNvbG9yLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgd2hpbGUgKGNvbC5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgICBjb2wgPSBcIjBcIiArIGNvbDtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuY3R4LmZpbGxTdHlsZSA9ICcjJyArIGNvbDtcbiAgICAgICAgdGFyZ2V0LmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICAgIHRhcmdldC5jdHguZmlsbFJlY3QoMCwgMCwgc291cmNlLncsIHNvdXJjZS5oKTtcbiAgICAgICAgdGFyZ2V0LmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbXVsdGlwbHknO1xuICAgICAgICB0YXJnZXQuY3R4LmRyYXdJbWFnZShzb3VyY2UsIDAsIDAsIHNvdXJjZS53LCBzb3VyY2UuaCwgMCwgMCwgdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0KTtcblxuICAgICAgICAvLyBBbHBoYS1taXggdGhlIHRleHR1cmUuXG4gICAgICAgIHRhcmdldC5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICAgICAgdGFyZ2V0LmN0eC5kcmF3SW1hZ2Uoc291cmNlLCAwLCAwLCBzb3VyY2Uudywgc291cmNlLmgsIDAsIDAsIHRhcmdldC53aWR0aCwgdGFyZ2V0LmhlaWdodCk7XG4gICAgfVxuXG4gICAgX2hhc0NhY2hlKG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgcmV0dXJuICEhbmF0aXZlVGV4dHVyZS5fdGludENhY2hlO1xuICAgIH1cblxuICAgIF9nZXRDYWNoZShuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgIGlmICghbmF0aXZlVGV4dHVyZS5fdGludENhY2hlKSB7XG4gICAgICAgICAgICBuYXRpdmVUZXh0dXJlLl90aW50Q2FjaGUgPSBuZXcgQzJkVGludENhY2hlKG5hdGl2ZVRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVUZXh0dXJlLl90aW50Q2FjaGU7XG4gICAgfVxuXG4gICAgZ2MoYWdncmVzc2l2ZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXI7XG4gICAgICAgIGxldCBkZWx0YSA9IDA7XG4gICAgICAgIHRoaXMuX2NhY2hlZE5hdGl2ZVRleHR1cmVzLmZvckVhY2godGV4dHVyZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2dldENhY2hlKHRleHR1cmUpO1xuICAgICAgICAgICAgaWYgKGFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSBjYWNoZS5tZW1vcnlVc2FnZTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmUgPSBjYWNoZS5tZW1vcnlVc2FnZTtcbiAgICAgICAgICAgICAgICBjYWNoZS5jbGVhbnVwKGZyYW1lKTtcbiAgICAgICAgICAgICAgICBjYWNoZS5yZWxlYXNlQmxhbmNvVGV4dHVyZXMoKTtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSAoY2FjaGUubWVtb3J5VXNhZ2UgLSBiZWZvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYWdncmVzc2l2ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkTmF0aXZlVGV4dHVyZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UoZGVsdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmNsYXNzIEMyZFRpbnRDYWNoZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuX3R4ID0gbmF0aXZlVGV4dHVyZTtcbiAgICAgICAgdGhpcy5fY29sb3JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ibGFuY29UZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RDbGVhbnVwRnJhbWUgPSAwO1xuICAgICAgICB0aGlzLl9tZW1UZXh0dXJlcyA9IDA7XG4gICAgfVxuXG4gICAgZ2V0IG1lbW9yeVVzYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVtVGV4dHVyZXMgKiB0aGlzLl90eC53ICogdGhpcy5fdHguaDtcbiAgICB9XG5cbiAgICByZWxlYXNlQmxhbmNvVGV4dHVyZXMoKSB7XG4gICAgICAgIHRoaXMuX21lbVRleHR1cmVzIC09IHRoaXMuX2JsYW5jb1RleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fYmxhbmNvVGV4dHVyZXMgPSBbXTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgLy8gRGVyZWZlcmVuY2UgdGhlIHRleHR1cmVzLlxuICAgICAgICB0aGlzLl9ibGFuY29UZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbG9ycy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9tZW1UZXh0dXJlcyA9IDA7XG4gICAgfVxuXG4gICAgZ2V0KGNvbG9yKSB7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy5fY29sb3JzLmdldChjb2xvcik7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgaXRlbSA9IHtsZjogLTEsIHR4OiB1bmRlZmluZWQsIHU6IC0xfTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9ycy5zZXQoY29sb3IsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHNldChjb2xvciwgdGV4dHVyZSwgZnJhbWUpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0KGNvbG9yKTtcbiAgICAgICAgaXRlbS5sZiA9IGZyYW1lO1xuICAgICAgICBpdGVtLnR4ID0gdGV4dHVyZTtcbiAgICAgICAgaXRlbS51ID0gZnJhbWU7XG4gICAgICAgIHRoaXMuX21lbVRleHR1cmVzKys7XG4gICAgfVxuXG4gICAgY2xlYW51cChmcmFtZSkge1xuICAgICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gY2xlYW4gdXAgb25jZSBwZXIgZnJhbWUuXG4gICAgICAgIGlmICh0aGlzLl9sYXN0Q2xlYW51cEZyYW1lICE9PSBmcmFtZSkge1xuXG4gICAgICAgICAgICAvLyBXZSBsaW1pdCBibGFuY28gdGV4dHVyZXMgcmV1c2UgdG8gb25lIGZyYW1lIG9ubHkgdG8gcHJldmVudCBtZW1vcnkgdXNhZ2UgZ3Jvd3RoLlxuICAgICAgICAgICAgdGhpcy5fYmxhbmNvVGV4dHVyZXMgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5fY29sb3JzLmZvckVhY2goKGl0ZW0sIGNvbG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZW50cmllcyB0aGF0IHdlcmUgbm90IHVzZWQgbGFzdCBmcmFtZS5cbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5sZiA8IGZyYW1lIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBhcyByZXVzYWJsZSBibGFuY28gdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2JsYW5jb1RleHR1cmVzLnB1c2goaXRlbS50eCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sb3JzLmRlbGV0ZShjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RDbGVhbnVwRnJhbWUgPSBmcmFtZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldXNlVGV4dHVyZShmcmFtZSkge1xuICAgICAgICAvLyBUcnkgdG8gcmV1c2UgdGV4dHVyZXMsIGJlY2F1c2UgY3JlYXRpbmcgdGhlbSBldmVyeSBmcmFtZSBpcyBleHBlbnNpdmUuXG4gICAgICAgIHRoaXMuY2xlYW51cChmcmFtZSk7XG4gICAgICAgIGlmICh0aGlzLl9ibGFuY29UZXh0dXJlcyAmJiB0aGlzLl9ibGFuY29UZXh0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX21lbVRleHR1cmVzLS07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxhbmNvVGV4dHVyZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmx1clNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fa2VybmVsUmFkaXVzID0gMTtcbiAgICB9XG5cbiAgICBnZXQga2VybmVsUmFkaXVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2VybmVsUmFkaXVzO1xuICAgIH1cblxuICAgIHNldCBrZXJuZWxSYWRpdXModikge1xuICAgICAgICB0aGlzLl9rZXJuZWxSYWRpdXMgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQgPT09IDA7XG4gICAgfVxuXG4gICAgX2JlZm9yZURyYXdFbCh7dGFyZ2V0fSkge1xuICAgICAgICB0YXJnZXQuY3R4LmZpbHRlciA9IFwiYmx1cihcIiArIHRoaXMuX2tlcm5lbFJhZGl1cyArIFwicHgpXCI7XG4gICAgfVxuXG4gICAgX2FmdGVyRHJhd0VsKHt0YXJnZXR9KSB7XG4gICAgICAgIHRhcmdldC5jdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuXG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDMmRTaGFkZXIgZnJvbSBcIi4uL0MyZFNoYWRlci5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi8uLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRTaGFkZXIgZXh0ZW5kcyBDMmRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG4gICAgICAgIHRoaXMuX3JlY3RhbmdsZVRleHR1cmUgPSBjdHguc3RhZ2UucmVjdGFuZ2xlVGV4dHVyZS5zb3VyY2UubmF0aXZlVGV4dHVyZTtcbiAgICAgICAgdGhpcy5fdGludE1hbmFnZXIgPSB0aGlzLmN0eC5zdGFnZS5yZW5kZXJlci50aW50TWFuYWdlcjtcbiAgICB9XG5cbiAgICBkcmF3KG9wZXJhdGlvbiwgdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRhcmdldC5jdHg7XG4gICAgICAgIGxldCBsZW5ndGggPSBvcGVyYXRpb24ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IG9wZXJhdGlvbi5nZXRUZXh0dXJlKGkpO1xuICAgICAgICAgICAgY29uc3QgdmMgPSBvcGVyYXRpb24uZ2V0RWxlbWVudENvcmUoaSk7XG4gICAgICAgICAgICBjb25zdCByYyA9IG9wZXJhdGlvbi5nZXRSZW5kZXJDb250ZXh0KGkpO1xuICAgICAgICAgICAgY29uc3Qgd2hpdGUgPSBvcGVyYXRpb24uZ2V0V2hpdGUoaSk7XG4gICAgICAgICAgICBjb25zdCBzdGMgPSBvcGVyYXRpb24uZ2V0U2ltcGxlVGMoaSk7XG5cbiAgICAgICAgICAgIC8vQHRvZG86IHRyeSB0byBvcHRpbWl6ZSBvdXQgcGVyLWRyYXcgdHJhbnNmb3JtIHNldHRpbmcuIHNwbGl0IHRyYW5zbGF0ZSwgdHJhbnNmb3JtLlxuICAgICAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKHJjLnRhICogcHJlY2lzaW9uLCByYy50YyAqIHByZWNpc2lvbiwgcmMudGIgKiBwcmVjaXNpb24sIHJjLnRkICogcHJlY2lzaW9uLCByYy5weCAqIHByZWNpc2lvbiwgcmMucHkgKiBwcmVjaXNpb24pO1xuXG4gICAgICAgICAgICBjb25zdCByZWN0ID0gKHR4ID09PSB0aGlzLl9yZWN0YW5nbGVUZXh0dXJlKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSB7b3BlcmF0aW9uLCB0YXJnZXQsIGluZGV4OiBpLCByZWN0fTtcblxuICAgICAgICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgZ3JhZGllbnQuXG4gICAgICAgICAgICAgICAgaWYgKHdoaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbG9yR3JhZGllbnQoY3R4LCB2Yyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gcmMuYWxwaGE7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVmb3JlRHJhd0VsKGluZm8pO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB2Yy53LCB2Yy5oKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZnRlckRyYXdFbChpbmZvKTtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEB0b2RvOiBzZXQgaW1hZ2Ugc21vb3RoaW5nIGJhc2VkIG9uIHRoZSB0ZXh0dXJlLlxuXG4gICAgICAgICAgICAgICAgLy8gQHRvZG86IG9wdGltaXplIGJ5IHJlZ2lzdGVyaW5nIHdoZXRoZXIgaWRlbnRpdHkgdGV4Y29vcmRzIGFyZSB1c2VkLlxuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHJjLmFscGhhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZURyYXdFbChpbmZvKTtcblxuICAgICAgICAgICAgICAgIC8vIEB0b2RvOiB0ZXN0IGlmIHJvdW5kaW5nIHlpZWxkcyBiZXR0ZXIgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgICAgICAgICAvLyBOb3RpY2UgdGhhdCBzaW1wbGUgdGV4dHVyZSBjb29yZHMgY2FuIGJlIHR1cm5lZCBvbiBldmVuIHRob3VnaCB2Yy5fdWx4IGV0YyBhcmUgbm90IHNpbXBsZSwgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vICB3ZSBhcmUgcmVuZGVyaW5nIGEgcmVuZGVyLXRvLXRleHR1cmUgKHRleGNvb3JkcyB3ZXJlIHN0YXNoZWQpLiBTYW1lIGlzIHRydWUgZm9yICd3aGl0ZScgY29sb3IgYnR3LlxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVggPSBzdGMgPyAwIDogKHZjLl91bHggKiB0eC53KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VZID0gc3RjID8gMCA6ICh2Yy5fdWx5ICogdHguaCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlVyA9IChzdGMgPyAxIDogKHZjLl9icnggLSB2Yy5fdWx4KSkgKiB0eC53O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUggPSAoc3RjID8gMSA6ICh2Yy5fYnJ5IC0gdmMuX3VseSkpICogdHguaDtcblxuICAgICAgICAgICAgICAgIGxldCBjb2xvcml6ZSA9ICF3aGl0ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3JpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRvZG86IGNhY2hlIHRoZSB0aW50IHRleHR1cmUgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cblxuICAgICAgICAgICAgICAgICAgICAvLyBEcmF3IHRvIGludGVybWVkaWF0ZSB0ZXh0dXJlIHdpdGggYmFja2dyb3VuZCBjb2xvci9ncmFkaWVudC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyB1cyBmcm9tIGhhdmluZyB0byBjcmVhdGUgYSBsb3Qgb2YgcmVuZGVyIHRleHR1cmUgY2FudmFzZXMuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWNlIHRoYXQgd2UgZG9uJ3Qgc3VwcG9ydCAobm9uLXJlY3QpIGdyYWRpZW50cywgb25seSBjb2xvciB0aW50aW5nIGZvciBjMmQuIFdlJ2xsIGp1c3QgdGFrZSB0aGUgYXZlcmFnZSBjb2xvci5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gdmMuX2NvbG9yVWw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Yy5fY29sb3JVbCAhPT0gdmMuX2NvbG9yVXIgfHwgdmMuX2NvbG9yVXIgIT09IHZjLl9jb2xvckJsIHx8IHZjLl9jb2xvckJyICE9PSB2Yy5fY29sb3JCbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBTdGFnZVV0aWxzLm1lcmdlTXVsdGlDb2xvcnNFcXVhbChbdmMuX2NvbG9yVWwsIHZjLl9jb2xvclVyLCB2Yy5fY29sb3JCbCwgdmMuX2NvbG9yQnJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFscGhhID0gKChjb2xvciAvIDE2Nzc3MjE2KSB8IDApIC8gMjU1LjA7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSAqPSBhbHBoYTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZ2IgPSBjb2xvciAmIDB4MDBGRkZGRkY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbnRUZXh0dXJlID0gdGhpcy5fdGludE1hbmFnZXIuZ2V0VGludFRleHR1cmUodHgsIHJnYik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWN0dWFsbHkgZHJhdyByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRpbnRUZXh0dXJlLCBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VXLCBzb3VyY2VILCAwLCAwLCB2Yy53LCB2Yy5oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0eCwgc291cmNlWCwgc291cmNlWSwgc291cmNlVywgc291cmNlSCwgMCwgMCwgdmMudywgdmMuaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2FmdGVyRHJhd0VsKGluZm8pO1xuICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDEuMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRDb2xvckdyYWRpZW50KGN0eCwgdmMsIHcgPSB2Yy53LCBoID0gdmMuaCwgdHJhbnNwYXJlbmN5ID0gdHJ1ZSkge1xuICAgICAgICBsZXQgY29sb3IgPSB2Yy5fY29sb3JVbDtcbiAgICAgICAgbGV0IGdyYWRpZW50O1xuICAgICAgICAvL0B0b2RvOiBxdWljayBzaW5nbGUgY29sb3IgY2hlY2suXG4gICAgICAgIC8vQHRvZG86IGNhY2hlIGdyYWRpZW50L2ZpbGwgc3R5bGUgKGlmIHBvc3NpYmxlLCBwcm9iYWJseSBjb250ZXh0LXNwZWNpZmljKS5cblxuICAgICAgICBpZiAodmMuX2NvbG9yVWwgPT09IHZjLl9jb2xvclVyKSB7XG4gICAgICAgICAgICBpZiAodmMuX2NvbG9yQmwgPT09IHZjLl9jb2xvckJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZjLl9jb2xvclVsID09PSB2Yy5jb2xvckJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBjb2xvci5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBncmFkaWVudC5cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodmMuX2NvbG9yVWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodmMuX2NvbG9yQmwpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBTdGFnZVV0aWxzLmdldFJnYlN0cmluZyh2Yy5fY29sb3JVbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFN0YWdlVXRpbHMuZ2V0UmdiU3RyaW5nKHZjLl9jb2xvckJsKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm90IHN1cHBvcnRlZCBncmFkaWVudC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2Yy5fY29sb3JVbCA9PT0gdmMuX2NvbG9yQmwgJiYgdmMuX2NvbG9yVXIgPT09IHZjLl9jb2xvckJyKSB7XG4gICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBncmFkaWVudC5cbiAgICAgICAgICAgICAgICBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCB3LCAwKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodmMuX2NvbG9yVWwpKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsIFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh2Yy5fY29sb3JCcikpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBTdGFnZVV0aWxzLmdldFJnYlN0cmluZyh2Yy5fY29sb3JVbCkpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgU3RhZ2VVdGlscy5nZXRSZ2JTdHJpbmcodmMuX2NvbG9yQnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JhZGllbnQpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0cmFuc3BhcmVuY3kgPyBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcoY29sb3IpIDogU3RhZ2VVdGlscy5nZXRSZ2JTdHJpbmcoY29sb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2JlZm9yZURyYXdFbChpbmZvKSB7XG4gICAgfVxuXG4gICAgX2FmdGVyRHJhd0VsKGluZm8pIHtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBDMmREZWZhdWx0U2hhZGVyIGZyb20gXCIuLi8uLi9jMmQvc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IFdlYkdMRGVmYXVsdFNoYWRlciBmcm9tIFwiLi4vLi4vd2ViZ2wvc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgY2xhc3MgV2ViR0xHcmF5c2NhbGVTaGFkZXIgZXh0ZW5kcyBXZWJHTERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gMTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QzJkKCkge1xuICAgICAgICByZXR1cm4gQzJkR3JheXNjYWxlU2hhZGVyO1xuICAgIH1cblxuXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50ID09PSAwO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImFtb3VudFwiLCB0aGlzLl9hbW91bnQsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICB9XG5cbn1cblxuV2ViR0xHcmF5c2NhbGVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIGZsb2F0IGFtb3VudDtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yO1xuICAgICAgICBmbG9hdCBncmF5bmVzcyA9IDAuMiAqIGNvbG9yLnIgKyAwLjYgKiBjb2xvci5nICsgMC4yICogY29sb3IuYjtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChhbW91bnQgKiB2ZWMzKGdyYXluZXNzLCBncmF5bmVzcywgZ3JheW5lc3MpICsgKDEuMCAtIGFtb3VudCkgKiBjb2xvci5yZ2IsIGNvbG9yLmEpO1xuICAgIH1cbmA7XG5cbmV4cG9ydCBjbGFzcyBDMmRHcmF5c2NhbGVTaGFkZXIgZXh0ZW5kcyBDMmREZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IDE7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFdlYkdMKCkge1xuICAgICAgICByZXR1cm4gV2ViR0xHcmF5c2NhbGVTaGFkZXI7XG4gICAgfVxuXG5cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50O1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQgPT09IDA7XG4gICAgfVxuXG4gICAgX2JlZm9yZURyYXdFbCh7dGFyZ2V0fSkge1xuICAgICAgICB0YXJnZXQuY3R4LmZpbHRlciA9IFwiZ3JheXNjYWxlKFwiICsgdGhpcy5fYW1vdW50ICsgXCIpXCI7XG4gICAgfVxuXG4gICAgX2FmdGVyRHJhd0VsKHt0YXJnZXR9KSB7XG4gICAgICAgIHRhcmdldC5jdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgV2ViR0xSZW5kZXJlciBmcm9tIFwiLi4vd2ViZ2wvV2ViR0xSZW5kZXJlci5tanNcIjtcbmltcG9ydCBTcGFya1NoYWRlciBmcm9tIFwiLi9zaGFkZXJzL1NwYXJrU2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTcGFya1JlbmRlcmVyIGV4dGVuZHMgV2ViR0xSZW5kZXJlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSkge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZURlZmF1bHRTaGFkZXIoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3BhcmtTaGFkZXIoY3R4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVDb3JlUmVuZGVyRXhlY3V0b3IoY3R4KSB7XG4gICAgICAgIGdsb2JhbC5iZWdpbkRyYXdpbmcoKTtcbiAgICAgICAgbGV0IHJldCA9IHN1cGVyLmNyZWF0ZUNvcmVSZW5kZXJFeGVjdXRvcihjdHgpO1xuICAgICAgICBnbG9iYWwuZW5kRHJhd2luZygpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBXZWJHTFNoYWRlciBmcm9tIFwiLi4vLi4vd2ViZ2wvV2ViR0xTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwYXJrU2hhZGVyIGV4dGVuZHMgV2ViR0xTaGFkZXIge1xuXG4gICAgZW5hYmxlQXR0cmlicygpIHtcbiAgICAgICAgLy8gRW5hYmxlcyB0aGUgYXR0cmlicyBpbiB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYVZlcnRleFBvc2l0aW9uXCIpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAwKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVZlcnRleFBvc2l0aW9uXCIpKTtcblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMiAqIDQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU29tZSBzaGFkZXJzIG1heSBpZ25vcmUgdGhlIGNvbG9yLlxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIiksIDQsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIDIwLCA0ICogNCk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIC8vIERpc2FibGVzIHRoZSBhdHRyaWJzIGluIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFWZXJ0ZXhQb3NpdGlvblwiKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicHJvamVjdGlvblwiLCB0aGlzLl9nZXRQcm9qZWN0aW9uKG9wZXJhdGlvbiksIHRoaXMuZ2wudW5pZm9ybTJmdiwgZmFsc2UpO1xuICAgIH1cblxuICAgIGRyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IG9wZXJhdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGdsVGV4dHVyZSA9IG9wZXJhdGlvbi5nZXRUZXh0dXJlKDApO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHR4ID0gb3BlcmF0aW9uLmdldFRleHR1cmUoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGdsVGV4dHVyZSAhPT0gdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsVGV4dHVyZS5vcHRpb25zICYmIGdsVGV4dHVyZS5vcHRpb25zLmltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWxlbWVudFBvc3Rpb24gPSAoaSA+IDApID8gKGkgLSAxKSA6IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRPcHRpb24oJ3ByZWNpc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZjID0gb3BlcmF0aW9uLmdldEVsZW1lbnRDb3JlKGVsZW1lbnRQb3N0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3R4LnN0YWdlLnBsYXRmb3JtLnBhaW50KGdsLCBnbFRleHR1cmUub3B0aW9ucy5pbWFnZVJlZiwgdmMuX3dvcmxkQ29udGV4dC5weCpwcmVjaXNpb24sIHZjLl93b3JsZENvbnRleHQucHkqcHJlY2lzaW9uLCB2Yy5fY29sb3JVbCwgdmMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYgKiAoaSAtIHBvcyksIGdsLlVOU0lHTkVEX1NIT1JULCAocG9zICsgb3BlcmF0aW9uLmluZGV4KSAqIDYgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbFRleHR1cmUgPSB0eDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdsVGV4dHVyZS5vcHRpb25zICYmIGdsVGV4dHVyZS5vcHRpb25zLmltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldE9wdGlvbigncHJlY2lzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YyA9IG9wZXJhdGlvbi5nZXRFbGVtZW50Q29yZShwb3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN0eC5zdGFnZS5wbGF0Zm9ybS5wYWludChnbCwgZ2xUZXh0dXJlLm9wdGlvbnMuaW1hZ2VSZWYsIHZjLl93b3JsZENvbnRleHQucHgqcHJlY2lzaW9uLCB2Yy5fd29ybGRDb250ZXh0LnB5KnByZWNpc2lvbiwgdmMuX2NvbG9yVWwsIHZjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2ICogKGxlbmd0aCAtIHBvcyksIGdsLlVOU0lHTkVEX1NIT1JULCAocG9zICsgb3BlcmF0aW9uLmluZGV4KSAqIDYgKiAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuU3BhcmtTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuU3BhcmtTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvcmVRdWFkTGlzdCBmcm9tIFwiLi4vLi4vdHJlZS9jb3JlL0NvcmVRdWFkTGlzdC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xDb3JlUXVhZExpc3QgZXh0ZW5kcyBDb3JlUXVhZExpc3Qge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG5cbiAgICAgICAgLy8gQWxsb2NhdGUgYSBmYWlybHkgYmlnIGNodW5rIG9mIG1lbW9yeSB0aGF0IHNob3VsZCBiZSBlbm91Z2ggdG8gc3VwcG9ydCB+MTAwMDAwIChkZWZhdWx0KSBxdWFkcy5cbiAgICAgICAgLy8gV2UgZG8gbm90ICh3YW50IHRvKSBoYW5kbGUgbWVtb3J5IG92ZXJmbG93LlxuICAgICAgICBjb25zdCBieXRlU2l6ZSA9IGN0eC5zdGFnZS5nZXRPcHRpb24oJ2J1ZmZlck1lbW9yeScpO1xuXG4gICAgICAgIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTaXplKTtcbiAgICAgICAgdGhpcy5mbG9hdHMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZGF0YSk7XG4gICAgICAgIHRoaXMudWludHMgPSBuZXcgVWludDMyQXJyYXkodGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBnZXRBdHRyaWJzRGF0YUJ5dGVPZmZzZXQoaW5kZXgpIHtcbiAgICAgICAgLy8gV2hlcmUgdGhpcyBxdWFkIGNhbiBiZSBmb3VuZCBpbiB0aGUgYXR0cmlicyBidWZmZXIuXG4gICAgICAgIHJldHVybiBpbmRleCAqIDgwO1xuICAgIH1cblxuICAgIGdldFF1YWRDb250ZW50cygpIHtcbiAgICAgICAgLy8gRGVidWc6IGxvZyBjb250ZW50cyBvZiBxdWFkIGJ1ZmZlci5cbiAgICAgICAgbGV0IGZsb2F0cyA9IHRoaXMuZmxvYXRzO1xuICAgICAgICBsZXQgdWludHMgPSB0aGlzLnVpbnRzO1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0ciA9ICdlbnRyeSAnICsgaSArICc6ICc7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgIGxldCBiID0gaSAqIDIwICsgaiAqIDQ7XG4gICAgICAgICAgICAgICAgc3RyICs9IGZsb2F0c1tiXSArICcsJyArIGZsb2F0c1tiKzFdICsgJzonICsgZmxvYXRzW2IrMl0gKyAnLCcgKyBmbG9hdHNbYiszXSArICdbJyArIHVpbnRzW2IrNF0udG9TdHJpbmcoMTYpICsgJ10gJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzLnB1c2goc3RyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaW5lcztcbiAgICB9XG5cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IENvcmVRdWFkT3BlcmF0aW9uIGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVF1YWRPcGVyYXRpb24ubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMQ29yZVF1YWRPcGVyYXRpb24gZXh0ZW5kcyBDb3JlUXVhZE9wZXJhdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgsIHNoYWRlciwgc2hhZGVyT3duZXIsIHJlbmRlclRleHR1cmVJbmZvLCBzY2lzc29yLCBpbmRleCkge1xuICAgICAgICBzdXBlcihjdHgsIHNoYWRlciwgc2hhZGVyT3duZXIsIHJlbmRlclRleHR1cmVJbmZvLCBzY2lzc29yLCBpbmRleCk7XG5cbiAgICAgICAgdGhpcy5leHRyYUF0dHJpYnNEYXRhQnl0ZU9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgZ2V0QXR0cmlic0RhdGFCeXRlT2Zmc2V0KGluZGV4KSB7XG4gICAgICAgIC8vIFdoZXJlIHRoaXMgcXVhZCBjYW4gYmUgZm91bmQgaW4gdGhlIGF0dHJpYnMgYnVmZmVyLlxuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRBdHRyaWJzRGF0YUJ5dGVPZmZzZXQodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSByZWxhdGl2ZSBwaXhlbCBjb29yZGluYXRlcyBpbiB0aGUgc2hhZGVyIG93bmVyIHRvIGdsIHBvc2l0aW9uIGNvb3JkaW5hdGVzIGluIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybiB7bnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0Tm9ybWFsUmVuZGVyVGV4dHVyZUNvb3Jkcyh4LCB5KSB7XG4gICAgICAgIGxldCBjb29yZHMgPSB0aGlzLnNoYWRlck93bmVyLmdldFJlbmRlclRleHR1cmVDb29yZHMoeCwgeSk7XG4gICAgICAgIGNvb3Jkc1swXSAvPSB0aGlzLmdldFJlbmRlcldpZHRoKCk7XG4gICAgICAgIGNvb3Jkc1sxXSAvPSB0aGlzLmdldFJlbmRlckhlaWdodCgpO1xuICAgICAgICBjb29yZHNbMF0gPSBjb29yZHNbMF0gKiAyIC0gMTtcbiAgICAgICAgY29vcmRzWzFdID0gMSAtIGNvb3Jkc1sxXSAqIDI7XG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfVxuXG4gICAgZ2V0UHJvamVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGV4dHVyZUluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN0eC5yZW5kZXJFeGVjLl9wcm9qZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZS5wcm9qZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ29yZVJlbmRlckV4ZWN1dG9yIGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVJlbmRlckV4ZWN1dG9yLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTENvcmVSZW5kZXJFeGVjdXRvciBleHRlbmRzIENvcmVSZW5kZXJFeGVjdXRvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KVxuXG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLmN0eC5zdGFnZS5nbDtcblxuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuXG4gICAgICAgIC8vIENyZWF0ZSBuZXcgc2hhcmFibGUgYnVmZmVyIGZvciBwYXJhbXMuXG4gICAgICAgIHRoaXMuX2F0dHJpYnNCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICBsZXQgbWF4UXVhZHMgPSBNYXRoLmZsb29yKHRoaXMucmVuZGVyU3RhdGUucXVhZHMuZGF0YS5ieXRlTGVuZ3RoIC8gODApO1xuXG4gICAgICAgIC8vIEluaXQgd2ViZ2wgYXJyYXlzLlxuICAgICAgICBsZXQgYWxsSW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShtYXhRdWFkcyAqIDYpO1xuXG4gICAgICAgIC8vIGZpbGwgdGhlIGluZGljZXMgd2l0aCB0aGUgcXVhZHMgdG8gZHJhdy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgbWF4UXVhZHM7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgICAgICAgICBhbGxJbmRpY2VzW2ldID0gajtcbiAgICAgICAgICAgIGFsbEluZGljZXNbaSArIDFdID0gaiArIDE7XG4gICAgICAgICAgICBhbGxJbmRpY2VzW2kgKyAyXSA9IGogKyAyO1xuICAgICAgICAgICAgYWxsSW5kaWNlc1tpICsgM10gPSBqO1xuICAgICAgICAgICAgYWxsSW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgICAgIGFsbEluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcXVhZHMgYnVmZmVyIGNhbiBiZSAocmUpdXNlZCB0byBkcmF3IGEgcmFuZ2Ugb2YgcXVhZHMuXG4gICAgICAgIHRoaXMuX3F1YWRzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX3F1YWRzQnVmZmVyKTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYWxsSW5kaWNlcywgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgIC8vIFRoZSBtYXRyaXggdGhhdCBjYXVzZXMgdGhlIFswLDAgLSBXLEhdIGJveCB0byBtYXAgdG8gWy0xLC0xIC0gMSwxXSBpbiB0aGUgZW5kIHJlc3VsdHMuXG4gICAgICAgIHRoaXMuX3Byb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KFsyL3RoaXMuY3R4LnN0YWdlLmNvb3Jkc1dpZHRoLCAtMi90aGlzLmN0eC5zdGFnZS5jb29yZHNIZWlnaHRdKTtcblxuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5nbC5kZWxldGVCdWZmZXIodGhpcy5fYXR0cmlic0J1ZmZlcik7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX3F1YWRzQnVmZmVyKTtcbiAgICB9XG5cbiAgICBfcmVzZXQoKSB7XG4gICAgICAgIHN1cGVyLl9yZXNldCgpO1xuXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG4gICAgICAgIHRoaXMuX3N0b3BTaGFkZXJQcm9ncmFtKCk7XG4gICAgICAgIHRoaXMuX3NldHVwQnVmZmVycygpO1xuICAgIH1cblxuICAgIF9zZXR1cEJ1ZmZlcnMoKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX3F1YWRzQnVmZmVyKTtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucmVuZGVyU3RhdGUucXVhZHMuZGF0YSwgMCwgdGhpcy5yZW5kZXJTdGF0ZS5xdWFkcy5kYXRhTGVuZ3RoKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX2F0dHJpYnNCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZWxlbWVudCwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICB9XG5cbiAgICBfc2V0dXBRdWFkT3BlcmF0aW9uKHF1YWRPcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuX3NldHVwUXVhZE9wZXJhdGlvbihxdWFkT3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fdXNlU2hhZGVyUHJvZ3JhbShxdWFkT3BlcmF0aW9uLnNoYWRlciwgcXVhZE9wZXJhdGlvbik7XG4gICAgfVxuXG4gICAgX3JlbmRlclF1YWRPcGVyYXRpb24ob3ApIHtcbiAgICAgICAgbGV0IHNoYWRlciA9IG9wLnNoYWRlcjtcblxuICAgICAgICBpZiAob3AubGVuZ3RoIHx8IG9wLnNoYWRlci5hZGRFbXB0eSgpKSB7XG4gICAgICAgICAgICBzaGFkZXIuYmVmb3JlRHJhdyhvcCk7XG4gICAgICAgICAgICBzaGFkZXIuZHJhdyhvcCk7XG4gICAgICAgICAgICBzaGFkZXIuYWZ0ZXJEcmF3KG9wKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V2ViR0xTaGFkZXJ9IHNoYWRlcjtcbiAgICAgKiBAcGFyYW0ge0NvcmVRdWFkT3BlcmF0aW9ufSBvcGVyYXRpb247XG4gICAgICovXG4gICAgX3VzZVNoYWRlclByb2dyYW0oc2hhZGVyLCBvcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKCFzaGFkZXIuaGFzU2FtZVByb2dyYW0odGhpcy5fY3VycmVudFNoYWRlclByb2dyYW0pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFNoYWRlclByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U2hhZGVyUHJvZ3JhbS5zdG9wUHJvZ3JhbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhZGVyLnVzZVByb2dyYW0oKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXJQcm9ncmFtID0gc2hhZGVyO1xuICAgICAgICB9XG4gICAgICAgIHNoYWRlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgfVxuXG4gICAgX3N0b3BTaGFkZXJQcm9ncmFtKCkge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudFNoYWRlclByb2dyYW0pIHtcbiAgICAgICAgICAgIC8vIFRoZSBjdXJyZW50bHkgdXNlZCBzaGFkZXIgcHJvZ3JhbSBzaG91bGQgYmUgc3RvcHBlZCBncmFjZWZ1bGx5LlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNoYWRlclByb2dyYW0uc3RvcFByb2dyYW0oKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTaGFkZXJQcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9iaW5kUmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgIHN1cGVyLl9iaW5kUmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKTtcblxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLDAsdGhpcy5jdHguc3RhZ2Uudyx0aGlzLmN0eC5zdGFnZS5oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5fcmVuZGVyVGV4dHVyZS5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLDAsdGhpcy5fcmVuZGVyVGV4dHVyZS53LCB0aGlzLl9yZW5kZXJUZXh0dXJlLmgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NsZWFyUmVuZGVyVGV4dHVyZSgpIHtcbiAgICAgICAgc3VwZXIuX2NsZWFyUmVuZGVyVGV4dHVyZSgpO1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIGxldCBnbENsZWFyQ29sb3IgPSB0aGlzLmN0eC5zdGFnZS5nZXRDbGVhckNvbG9yKCk7XG4gICAgICAgICAgICBpZiAoZ2xDbGVhckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcihnbENsZWFyQ29sb3JbMF0gKiBnbENsZWFyQ29sb3JbM10sIGdsQ2xlYXJDb2xvclsxXSAqIGdsQ2xlYXJDb2xvclszXSwgZ2xDbGVhckNvbG9yWzJdICogZ2xDbGVhckNvbG9yWzNdLCBnbENsZWFyQ29sb3JbM10pO1xuICAgICAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGV4dHVyZS5cbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRTY2lzc29yKGFyZWEpIHtcbiAgICAgICAgc3VwZXIuX3NldFNjaXNzb3IoYXJlYSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NjaXNzb3IgPT09IGFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY2lzc29yID0gYXJlYTtcblxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAoIWFyZWEpIHtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgICAgICAgICAgbGV0IHByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICAgICAgbGV0IHkgPSBhcmVhWzFdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBGbGlwLlxuICAgICAgICAgICAgICAgIHkgPSAodGhpcy5jdHguc3RhZ2UuaCAvIHByZWNpc2lvbiAtIChhcmVhWzFdICsgYXJlYVszXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuc2Npc3NvcihNYXRoLnJvdW5kKGFyZWFbMF0gKiBwcmVjaXNpb24pLCBNYXRoLnJvdW5kKHkgKiBwcmVjaXNpb24pLCBNYXRoLnJvdW5kKGFyZWFbMl0gKiBwcmVjaXNpb24pLCBNYXRoLnJvdW5kKGFyZWFbM10gKiBwcmVjaXNpb24pKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSBcIi4uLy4uL3RyZWUvU3RhZ2VVdGlscy5tanNcIjtcbmltcG9ydCBXZWJHTENvcmVRdWFkTGlzdCBmcm9tIFwiLi9XZWJHTENvcmVRdWFkTGlzdC5tanNcIjtcbmltcG9ydCBXZWJHTENvcmVRdWFkT3BlcmF0aW9uIGZyb20gXCIuL1dlYkdMQ29yZVF1YWRPcGVyYXRpb24ubWpzXCI7XG5pbXBvcnQgV2ViR0xDb3JlUmVuZGVyRXhlY3V0b3IgZnJvbSBcIi4vV2ViR0xDb3JlUmVuZGVyRXhlY3V0b3IubWpzXCI7XG5pbXBvcnQgQ29yZVJlbmRlclN0YXRlIGZyb20gXCIuLi8uLi90cmVlL2NvcmUvQ29yZVJlbmRlclN0YXRlLm1qc1wiO1xuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vc2hhZGVycy9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IFdlYkdMU2hhZGVyIGZyb20gXCIuL1dlYkdMU2hhZGVyLm1qc1wiO1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gXCIuLi9SZW5kZXJlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViR0xSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcbiAgICAgICAgdGhpcy5zaGFkZXJQcm9ncmFtcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNoYWRlclByb2dyYW1zLmZvckVhY2goc2hhZGVyUHJvZ3JhbSA9PiBzaGFkZXJQcm9ncmFtLmRlc3Ryb3koKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZURlZmF1bHRTaGFkZXIoY3R4KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdFNoYWRlcihjdHgpO1xuICAgIH1cblxuICAgIF9nZXRTaGFkZXJCYXNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFdlYkdMU2hhZGVyXG4gICAgfVxuXG4gICAgX2dldFNoYWRlckFsdGVybmF0aXZlKHNoYWRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHNoYWRlclR5cGUuZ2V0V2ViR0wgJiYgc2hhZGVyVHlwZS5nZXRXZWJHTCgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvcmVRdWFkTGlzdChjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHTENvcmVRdWFkTGlzdChjdHgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUNvcmVRdWFkT3BlcmF0aW9uKGN0eCwgc2hhZGVyLCBzaGFkZXJPd25lciwgcmVuZGVyVGV4dHVyZUluZm8sIHNjaXNzb3IsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR0xDb3JlUXVhZE9wZXJhdGlvbihjdHgsIHNoYWRlciwgc2hhZGVyT3duZXIsIHJlbmRlclRleHR1cmVJbmZvLCBzY2lzc29yLCBpbmRleCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQ29yZVJlbmRlckV4ZWN1dG9yKGN0eCkge1xuICAgICAgICByZXR1cm4gbmV3IFdlYkdMQ29yZVJlbmRlckV4ZWN1dG9yKGN0eCk7XG4gICAgfVxuICAgIFxuICAgIGNyZWF0ZUNvcmVSZW5kZXJTdGF0ZShjdHgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb3JlUmVuZGVyU3RhdGUoY3R4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVSZW5kZXJUZXh0dXJlKHcsIGgsIHB3LCBwaCkge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuc3RhZ2UuZ2w7XG4gICAgICAgIGNvbnN0IGdsVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcblxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHB3LCBwaCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgICAgZ2xUZXh0dXJlLnBhcmFtcyA9IHt9O1xuICAgICAgICBnbFRleHR1cmUucGFyYW1zW2dsLlRFWFRVUkVfTUFHX0ZJTFRFUl0gPSBnbC5MSU5FQVI7XG4gICAgICAgIGdsVGV4dHVyZS5wYXJhbXNbZ2wuVEVYVFVSRV9NSU5fRklMVEVSXSA9IGdsLkxJTkVBUjtcbiAgICAgICAgZ2xUZXh0dXJlLnBhcmFtc1tnbC5URVhUVVJFX1dSQVBfU10gPSBnbC5DTEFNUF9UT19FREdFO1xuICAgICAgICBnbFRleHR1cmUucGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9UXSA9IGdsLkNMQU1QX1RPX0VER0U7XG4gICAgICAgIGdsVGV4dHVyZS5vcHRpb25zID0ge2Zvcm1hdDogZ2wuUkdCQSwgaW50ZXJuYWxGb3JtYXQ6IGdsLlJHQkEsIHR5cGU6IGdsLlVOU0lHTkVEX0JZVEV9O1xuXG4gICAgICAgIC8vIFdlIG5lZWQgYSBzcGVjaWZpYyBmcmFtZWJ1ZmZlciBmb3IgZXZlcnkgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgIGdsVGV4dHVyZS5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGdsVGV4dHVyZS5wcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMi93LCAyL2hdKTtcblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsVGV4dHVyZS5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlLCAwKTtcblxuICAgICAgICByZXR1cm4gZ2xUZXh0dXJlO1xuICAgIH1cbiAgICBcbiAgICBmcmVlUmVuZGVyVGV4dHVyZShnbFRleHR1cmUpIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5zdGFnZS5nbDtcbiAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZ2xUZXh0dXJlLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZShnbFRleHR1cmUpO1xuICAgIH1cblxuICAgIHVwbG9hZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuc3RhZ2UuZ2w7XG5cbiAgICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy5zb3VyY2U7XG5cbiAgICAgICAgY29uc3QgZm9ybWF0ID0ge1xuICAgICAgICAgICAgcHJlbXVsdGlwbHlBbHBoYTogdHJ1ZSxcbiAgICAgICAgICAgIGhhc0FscGhhOiB0cnVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgncHJlbXVsdGlwbHlBbHBoYScpKSB7XG4gICAgICAgICAgICBmb3JtYXQucHJlbXVsdGlwbHlBbHBoYSA9IG9wdGlvbnMucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2ZsaXBCbHVlUmVkJykpIHtcbiAgICAgICAgICAgIGZvcm1hdC5mbGlwQmx1ZVJlZCA9IG9wdGlvbnMuZmxpcEJsdWVSZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCdoYXNBbHBoYScpKSB7XG4gICAgICAgICAgICBmb3JtYXQuaGFzQWxwaGEgPSBvcHRpb25zLmhhc0FscGhhO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3JtYXQuaGFzQWxwaGEpIHtcbiAgICAgICAgICAgIGZvcm1hdC5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQudGV4UGFyYW1zID0gb3B0aW9ucy50ZXhQYXJhbXMgfHwge31cbiAgICAgICAgZm9ybWF0LnRleE9wdGlvbnMgPSBvcHRpb25zLnRleE9wdGlvbnMgfHwge31cblxuICAgICAgICBsZXQgZ2xUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBnbFRleHR1cmUpO1xuXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgZm9ybWF0LnByZW11bHRpcGx5QWxwaGEpO1xuXG4gICAgICAgIGlmIChVdGlscy5pc05vZGUpIHtcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX0JMVUVfUkVELCAhIWZvcm1hdC5mbGlwQmx1ZVJlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXhQYXJhbXMgPSBmb3JtYXQudGV4UGFyYW1zO1xuICAgICAgICBpZiAoIXRleFBhcmFtc1tnbC5URVhUVVJFX01BR19GSUxURVJdKSB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9NQUdfRklMVEVSXSA9IGdsLkxJTkVBUjtcbiAgICAgICAgaWYgKCF0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9NSU5fRklMVEVSXSkgdGV4UGFyYW1zW2dsLlRFWFRVUkVfTUlOX0ZJTFRFUl0gPSBnbC5MSU5FQVI7XG4gICAgICAgIGlmICghdGV4UGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9TXSkgdGV4UGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9TXSA9IGdsLkNMQU1QX1RPX0VER0U7XG4gICAgICAgIGlmICghdGV4UGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9UXSkgdGV4UGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9UXSA9IGdsLkNMQU1QX1RPX0VER0U7XG5cbiAgICAgICAgT2JqZWN0LmtleXModGV4UGFyYW1zKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRleFBhcmFtc1trZXldO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBwYXJzZUludChrZXkpLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRleE9wdGlvbnMgPSBmb3JtYXQudGV4T3B0aW9ucztcbiAgICAgICAgdGV4T3B0aW9ucy5mb3JtYXQgPSB0ZXhPcHRpb25zLmZvcm1hdCB8fCAoZm9ybWF0Lmhhc0FscGhhID8gZ2wuUkdCQSA6IGdsLlJHQik7XG4gICAgICAgIHRleE9wdGlvbnMudHlwZSA9IHRleE9wdGlvbnMudHlwZSB8fCBnbC5VTlNJR05FRF9CWVRFO1xuICAgICAgICB0ZXhPcHRpb25zLmludGVybmFsRm9ybWF0ID0gdGV4T3B0aW9ucy5pbnRlcm5hbEZvcm1hdCB8fCB0ZXhPcHRpb25zLmZvcm1hdDtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVJlZikge1xuICAgICAgICAgICAgdGV4T3B0aW9ucy5pbWFnZVJlZiA9IG9wdGlvbnMuaW1hZ2VSZWY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWdlLnBsYXRmb3JtLnVwbG9hZEdsVGV4dHVyZShnbCwgdGV4dHVyZVNvdXJjZSwgc291cmNlLCB0ZXhPcHRpb25zKTtcblxuICAgICAgICBnbFRleHR1cmUucGFyYW1zID0gVXRpbHMuY2xvbmVPYmpTaGFsbG93KHRleFBhcmFtcyk7XG4gICAgICAgIGdsVGV4dHVyZS5vcHRpb25zID0gVXRpbHMuY2xvbmVPYmpTaGFsbG93KHRleE9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiBnbFRleHR1cmU7XG4gICAgfVxuXG4gICAgZnJlZVRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICB0aGlzLnN0YWdlLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZVNvdXJjZS5uYXRpdmVUZXh0dXJlKTtcbiAgICB9XG5cbiAgICBhZGRRdWFkKHJlbmRlclN0YXRlLCBxdWFkcywgaW5kZXgpIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IChpbmRleCAqIDIwKTtcbiAgICAgICAgY29uc3QgZWxlbWVudENvcmUgPSBxdWFkcy5xdWFkRWxlbWVudHNbaW5kZXhdO1xuXG4gICAgICAgIGxldCByID0gZWxlbWVudENvcmUuX3JlbmRlckNvbnRleHQ7XG5cbiAgICAgICAgbGV0IGZsb2F0cyA9IHJlbmRlclN0YXRlLnF1YWRzLmZsb2F0cztcbiAgICAgICAgbGV0IHVpbnRzID0gcmVuZGVyU3RhdGUucXVhZHMudWludHM7XG4gICAgICAgIGNvbnN0IG1jYSA9IFN0YWdlVXRpbHMubWVyZ2VDb2xvckFscGhhO1xuXG4gICAgICAgIGlmIChyLnRiICE9PSAwIHx8IHIudGMgIT09IDApIHtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0KytdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvclVsLCByLmFscGhhKTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB4ICsgZWxlbWVudENvcmUuX3cgKiByLnRhO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHkgKyBlbGVtZW50Q29yZS5fdyAqIHIudGM7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0KytdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvclVyLCByLmFscGhhKTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB4ICsgZWxlbWVudENvcmUuX3cgKiByLnRhICsgZWxlbWVudENvcmUuX2ggKiByLnRiO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHkgKyBlbGVtZW50Q29yZS5fdyAqIHIudGMgKyBlbGVtZW50Q29yZS5faCAqIHIudGQ7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0KytdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvckJyLCByLmFscGhhKTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSByLnB4ICsgZWxlbWVudENvcmUuX2ggKiByLnRiO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHkgKyBlbGVtZW50Q29yZS5faCAqIHIudGQ7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0XSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JCbCwgci5hbHBoYSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW1wbGUuXG4gICAgICAgICAgICBsZXQgY3ggPSByLnB4ICsgZWxlbWVudENvcmUuX3cgKiByLnRhO1xuICAgICAgICAgICAgbGV0IGN5ID0gci5weSArIGVsZW1lbnRDb3JlLl9oICogci50ZDtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gci5weTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl91bHk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXQrK10gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yVWwsIHIuYWxwaGEpO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGN4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHk7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX2JyeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fdWx5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0KytdID0gbWNhKGVsZW1lbnRDb3JlLl9jb2xvclVyLCByLmFscGhhKTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBjeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBjeTtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IGVsZW1lbnRDb3JlLl9icnk7XG4gICAgICAgICAgICB1aW50c1tvZmZzZXQrK10gPSBtY2EoZWxlbWVudENvcmUuX2NvbG9yQnIsIHIuYWxwaGEpO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCsrXSA9IHIucHg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gY3k7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0KytdID0gZWxlbWVudENvcmUuX3VseDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQrK10gPSBlbGVtZW50Q29yZS5fYnJ5O1xuICAgICAgICAgICAgdWludHNbb2Zmc2V0XSA9IG1jYShlbGVtZW50Q29yZS5fY29sb3JCbCwgci5hbHBoYSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlclRleHR1cmVSZXVzYWJsZShyZW5kZXJTdGF0ZSwgcmVuZGVyVGV4dHVyZUluZm8pIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IChyZW5kZXJTdGF0ZS5fcmVuZGVyVGV4dHVyZUluZm8ub2Zmc2V0ICogODApIC8gNDtcbiAgICAgICAgbGV0IGZsb2F0cyA9IHJlbmRlclN0YXRlLnF1YWRzLmZsb2F0cztcbiAgICAgICAgbGV0IHVpbnRzID0gcmVuZGVyU3RhdGUucXVhZHMudWludHM7XG4gICAgICAgIHJldHVybiAoKGZsb2F0c1tvZmZzZXRdID09PSAwKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxXSA9PT0gMCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMl0gPT09IDApICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDNdID09PSAwKSAmJlxuICAgICAgICAgICAgKHVpbnRzW29mZnNldCArIDRdID09PSAweEZGRkZGRkZGKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyA1XSA9PT0gcmVuZGVyVGV4dHVyZUluZm8udykgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgNl0gPT09IDApICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDddID09PSAxKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyA4XSA9PT0gMCkgJiZcbiAgICAgICAgICAgICh1aW50c1tvZmZzZXQgKyA5XSA9PT0gMHhGRkZGRkZGRikgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMTBdID09PSByZW5kZXJUZXh0dXJlSW5mby53KSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxMV0gPT09IHJlbmRlclRleHR1cmVJbmZvLmgpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDEyXSA9PT0gMSkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMTNdID09PSAxKSAmJlxuICAgICAgICAgICAgKHVpbnRzW29mZnNldCArIDE0XSA9PT0gMHhGRkZGRkZGRikgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMTVdID09PSAwKSAmJlxuICAgICAgICAgICAgKGZsb2F0c1tvZmZzZXQgKyAxNl0gPT09IHJlbmRlclRleHR1cmVJbmZvLmgpICYmXG4gICAgICAgICAgICAoZmxvYXRzW29mZnNldCArIDE3XSA9PT0gMCkgJiZcbiAgICAgICAgICAgIChmbG9hdHNbb2Zmc2V0ICsgMThdID09PSAxKSAmJlxuICAgICAgICAgICAgKHVpbnRzW29mZnNldCArIDE5XSA9PT0gMHhGRkZGRkZGRikpO1xuICAgIH1cblxuICAgIGZpbmlzaFJlbmRlclN0YXRlKHJlbmRlclN0YXRlKSB7XG4gICAgICAgIC8vIFNldCBleHRyYSBzaGFkZXIgYXR0cmlidXRlIGRhdGEuXG4gICAgICAgIGxldCBvZmZzZXQgPSByZW5kZXJTdGF0ZS5sZW5ndGggKiA4MDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSByZW5kZXJTdGF0ZS5xdWFkT3BlcmF0aW9ucy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnF1YWRPcGVyYXRpb25zW2ldLmV4dHJhQXR0cmlic0RhdGFCeXRlT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGV4dHJhID0gcmVuZGVyU3RhdGUucXVhZE9wZXJhdGlvbnNbaV0uc2hhZGVyLmdldEV4dHJhQXR0cmliQnl0ZXNQZXJWZXJ0ZXgoKSAqIDQgKiByZW5kZXJTdGF0ZS5xdWFkT3BlcmF0aW9uc1tpXS5sZW5ndGg7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZXh0cmE7XG4gICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5xdWFkT3BlcmF0aW9uc1tpXS5zaGFkZXIuc2V0RXh0cmFBdHRyaWJzSW5CdWZmZXIocmVuZGVyU3RhdGUucXVhZE9wZXJhdGlvbnNbaV0sIHJlbmRlclN0YXRlLnF1YWRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJTdGF0ZS5xdWFkcy5kYXRhTGVuZ3RoID0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGNvcHlSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUsIG5hdGl2ZVRleHR1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnN0YWdlLmdsO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBuYXRpdmVUZXh0dXJlKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCByZW5kZXJUZXh0dXJlLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gcmVuZGVyVGV4dHVyZS5wcmVjaXNpb247XG4gICAgICAgIGdsLmNvcHlUZXhTdWJJbWFnZTJEKFxuICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBwcmVjaXNpb24gKiAob3B0aW9ucy5zeCB8fCAwKSxcbiAgICAgICAgICAgIHByZWNpc2lvbiAqIChvcHRpb25zLnN5IHx8IDApLFxuICAgICAgICAgICAgcHJlY2lzaW9uICogKG9wdGlvbnMueCB8fCAwKSxcbiAgICAgICAgICAgIHByZWNpc2lvbiAqIChvcHRpb25zLnkgfHwgMCksXG4gICAgICAgICAgICBwcmVjaXNpb24gKiAob3B0aW9ucy53IHx8IHJlbmRlclRleHR1cmUub3cpLFxuICAgICAgICAgICAgcHJlY2lzaW9uICogKG9wdGlvbnMuaCB8fCByZW5kZXJUZXh0dXJlLm9oKSk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgV2ViR0xTaGFkZXJQcm9ncmFtIGZyb20gXCIuL1dlYkdMU2hhZGVyUHJvZ3JhbS5tanNcIjtcbmltcG9ydCBTaGFkZXIgZnJvbSBcIi4uLy4uL3RyZWUvU2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJHTFNoYWRlciBleHRlbmRzIFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICBjb25zdCBzdGFnZSA9IGN0eC5zdGFnZTtcblxuICAgICAgICB0aGlzLl9wcm9ncmFtID0gc3RhZ2UucmVuZGVyZXIuc2hhZGVyUHJvZ3JhbXMuZ2V0KHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIXRoaXMuX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0gPSBuZXcgV2ViR0xTaGFkZXJQcm9ncmFtKHRoaXMuY29uc3RydWN0b3IudmVydGV4U2hhZGVyU291cmNlLCB0aGlzLmNvbnN0cnVjdG9yLmZyYWdtZW50U2hhZGVyU291cmNlKTtcblxuICAgICAgICAgICAgLy8gTGV0IHRoZSB2Ym8gY29udGV4dCBwZXJmb3JtIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICAgIHN0YWdlLnJlbmRlcmVyLnNoYWRlclByb2dyYW1zLnNldCh0aGlzLmNvbnN0cnVjdG9yLCB0aGlzLl9wcm9ncmFtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZ2wgPSBzdGFnZS5nbDtcbiAgICB9XG5cbiAgICBnZXQgZ2xQcm9ncmFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5nbFByb2dyYW07XG4gICAgfVxuXG4gICAgX2luaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5jb21waWxlKHRoaXMuZ2wpO1xuICAgIH1cblxuICAgIGdldCBpbml0aWFsaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVkO1xuICAgIH1cblxuICAgIF91bmlmb3JtKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2dyYW0uZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpO1xuICAgIH1cblxuICAgIF9hdHRyaWIobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5nZXRBdHRyaWJMb2NhdGlvbihuYW1lKTtcbiAgICB9XG5cbiAgICBfc2V0VW5pZm9ybShuYW1lLCB2YWx1ZSwgZ2xGdW5jdGlvbikge1xuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFVuaWZvcm1WYWx1ZShuYW1lLCB2YWx1ZSwgZ2xGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgdXNlUHJvZ3JhbSgpIHtcbiAgICAgICAgdGhpcy5faW5pdCgpO1xuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5nbFByb2dyYW0pO1xuICAgICAgICB0aGlzLmJlZm9yZVVzYWdlKCk7XG4gICAgICAgIHRoaXMuZW5hYmxlQXR0cmlicygpO1xuICAgIH1cblxuICAgIHN0b3BQcm9ncmFtKCkge1xuICAgICAgICB0aGlzLmFmdGVyVXNhZ2UoKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQXR0cmlicygpO1xuICAgIH1cblxuICAgIGhhc1NhbWVQcm9ncmFtKG90aGVyKSB7XG4gICAgICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBmaXJzdCBjaGVjayBmb3IgaWRlbnRpY2FsIHJlZmVyZW5jZXMuXG4gICAgICAgIHJldHVybiAob3RoZXIgJiYgKChvdGhlciA9PT0gdGhpcykgfHwgKG90aGVyLl9wcm9ncmFtID09PSB0aGlzLl9wcm9ncmFtKSkpO1xuICAgIH1cblxuICAgIGJlZm9yZVVzYWdlKCkge1xuICAgICAgICAvLyBPdmVycmlkZSB0byBzZXQgc2V0dGluZ3Mgb3RoZXIgdGhhbiB0aGUgZGVmYXVsdCBzZXR0aW5ncyAoYmxlbmQgbW9kZSBldGMpLlxuICAgIH1cblxuICAgIGFmdGVyVXNhZ2UoKSB7XG4gICAgICAgIC8vIEFsbCBzZXR0aW5ncyBjaGFuZ2VkIGluIGJlZm9yZVVzYWdlIHNob3VsZCBiZSByZXNldCBoZXJlLlxuICAgIH1cblxuICAgIGVuYWJsZUF0dHJpYnMoKSB7XG5cbiAgICB9XG5cbiAgICBkaXNhYmxlQXR0cmlicygpIHtcblxuICAgIH1cblxuICAgIGdldEV4dHJhQXR0cmliQnl0ZXNQZXJWZXJ0ZXgoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGdldFZlcnRleEF0dHJpYlBvaW50ZXJPZmZzZXQob3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb24uZXh0cmFBdHRyaWJzRGF0YUJ5dGVPZmZzZXQgLSBvcGVyYXRpb24uaW5kZXggKiA0ICogdGhpcy5nZXRFeHRyYUF0dHJpYkJ5dGVzUGVyVmVydGV4KCk7XG4gICAgfVxuXG4gICAgc2V0RXh0cmFBdHRyaWJzSW5CdWZmZXIob3BlcmF0aW9uKSB7XG4gICAgICAgIC8vIFNldCBleHRyYSBhdHRyaWIgZGF0YSBpbiBpbiBvcGVyYXRpb24ucXVhZHMuZGF0YS9mbG9hdHMvdWludHMsIHN0YXJ0aW5nIGZyb21cbiAgICAgICAgLy8gb3BlcmF0aW9uLmV4dHJhQXR0cmlic0J1ZmZlckJ5dGVPZmZzZXQuXG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgLy8gU2V0IGFsbCBzaGFkZXItc3BlY2lmaWMgdW5pZm9ybXMuXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IGFsbCB1bmlmb3JtcyBzaG91bGQgYmUgc2V0LCBldmVuIGlmIHRoZXkgaGF2ZSBub3QgYmVlbiBjaGFuZ2VkIHdpdGhpbiB0aGlzIHNoYWRlciBpbnN0YW5jZS5cbiAgICAgICAgLy8gVGhlIHVuaWZvcm1zIGFyZSBzaGFyZWQgYnkgYWxsIHNoYWRlcnMgdGhhdCBoYXZlIHRoZSBzYW1lIHR5cGUgKGFuZCBzaGFkZXIgcHJvZ3JhbSkuXG4gICAgfVxuXG4gICAgX2dldFByb2plY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb24uZ2V0UHJvamVjdGlvbigpO1xuICAgIH1cblxuICAgIGdldEZsaXBZKG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvamVjdGlvbihvcGVyYXRpb24pWzFdIDwgMDtcbiAgICB9XG5cbiAgICBiZWZvcmVEcmF3KG9wZXJhdGlvbikge1xuICAgIH1cblxuICAgIGRyYXcob3BlcmF0aW9uKSB7XG4gICAgfVxuXG4gICAgYWZ0ZXJEcmF3KG9wZXJhdGlvbikge1xuICAgIH1cblxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8vIFByb2dyYW0gdGFrZXMgbGl0dGxlIHJlc291cmNlcywgc28gaXQgaXMgb25seSBkZXN0cm95ZWQgd2hlbiB0aGUgZnVsbCBzdGFnZSBpcyBkZXN0cm95ZWQuXG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEJhc2UgZnVuY3Rpb25hbGl0eSBmb3Igc2hhZGVyIHNldHVwL2Rlc3Ryb3kuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkdMU2hhZGVyUHJvZ3JhbSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG5cbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSB2ZXJ0ZXhTaGFkZXJTb3VyY2U7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlclNvdXJjZTtcblxuICAgICAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcblxuICAgICAgICB0aGlzLl91bmlmb3JtTG9jYXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVMb2NhdGlvbnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgdGhpcy5fY3VycmVudFVuaWZvcm1WYWx1ZXMgPSB7fTtcbiAgICB9XG5cbiAgICBjb21waWxlKGdsKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuXG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cbiAgICAgICAgbGV0IGdsVmVydFNoYWRlciA9IHRoaXMuX2dsQ29tcGlsZShnbC5WRVJURVhfU0hBREVSLCB0aGlzLnZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgICAgIGxldCBnbEZyYWdTaGFkZXIgPSB0aGlzLl9nbENvbXBpbGUoZ2wuRlJBR01FTlRfU0hBREVSLCB0aGlzLmZyYWdtZW50U2hhZGVyU291cmNlKTtcblxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIodGhpcy5fcHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3Byb2dyYW0sIGdsRnJhZ1NoYWRlcik7XG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHRoaXMuX3Byb2dyYW0pO1xuXG4gICAgICAgIC8vIGlmIGxpbmtpbmcgZmFpbHMsIHRoZW4gbG9nIGFuZCBjbGVhbnVwXG4gICAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcih0aGlzLl9wcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuJyk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXSBnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuX3Byb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10gZ2wuZ2V0RXJyb3IoKScsIGdsLmdldEVycm9yKCkpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIHByb2dyYW0gaW5mbyBsb2csIGxvZyBpdFxuICAgICAgICAgICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMuX3Byb2dyYW0pICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0xpZ2h0bmluZ10gV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIGdsLmdldFByb2dyYW1JbmZvTG9nKHRoaXMuX3Byb2dyYW0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYW4gdXAgc29tZSBzaGFkZXJzXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRTaGFkZXIpO1xuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZ2xGcmFnU2hhZGVyKTtcbiAgICB9XG5cbiAgICBfZ2xDb21waWxlKHR5cGUsIHNyYykge1xuICAgICAgICBsZXQgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XG5cbiAgICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgICAgICBpZiAoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddJywgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCAnVHlwZTogJyArICh0eXBlID09PSB0aGlzLmdsLlZFUlRFWF9TSEFERVIgPyAndmVydGV4IHNoYWRlcicgOiAnZnJhZ21lbnQgc2hhZGVyJykgKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tMaWdodG5pbmddJywgdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgICAgICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbTGlnaHRuaW5nXScsIFwiPT09PT09PT09PSBzb3VyY2UgPT09PT09PT09PVxcblwiICsgc3JjLnNwbGl0KFwiXFxuXCIpLm1hcChsaW5lID0+IFwiXCIgKyAoKytpZHgpICsgXCI6IFwiICsgbGluZSkuam9pbihcIlxcblwiKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gdGhpcy5fdW5pZm9ybUxvY2F0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChsb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fdW5pZm9ybUxvY2F0aW9ucy5zZXQobmFtZSwgbG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGdldEF0dHJpYkxvY2F0aW9uKG5hbWUpIHtcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gdGhpcy5fYXR0cmlidXRlTG9jYXRpb25zLmdldChuYW1lKTtcbiAgICAgICAgaWYgKGxvY2F0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2F0dHJpYnV0ZUxvY2F0aW9ucy5zZXQobmFtZSwgbG9jYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0odGhpcy5fcHJvZ3JhbSk7XG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBnbFByb2dyYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9ncmFtO1xuICAgIH1cblxuICAgIGdldCBjb21waWxlZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcHJvZ3JhbTtcbiAgICB9XG5cbiAgICBfdmFsdWVFcXVhbHModjEsIHYyKSB7XG4gICAgICAgIC8vIFVuaWZvcm0gdmFsdWUgaXMgZWl0aGVyIGEgdHlwZWQgYXJyYXkgb3IgYSBudW1lcmljIHZhbHVlLlxuICAgICAgICBpZiAodjEubGVuZ3RoICYmIHYyLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB2MS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodjFbaV0gIT09IHYyW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAodjEgPT09IHYyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF92YWx1ZUNsb25lKHYpIHtcbiAgICAgICAgaWYgKHYubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdi5zbGljZSgwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0VW5pZm9ybVZhbHVlKG5hbWUsIHZhbHVlLCBnbEZ1bmN0aW9uKSB7XG4gICAgICAgIGxldCB2ID0gdGhpcy5fY3VycmVudFVuaWZvcm1WYWx1ZXNbbmFtZV07XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQgfHwgIXRoaXMuX3ZhbHVlRXF1YWxzKHYsIHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGNsb25lZFZhbHVlID0gdGhpcy5fdmFsdWVDbG9uZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VW5pZm9ybVZhbHVlc1tuYW1lXSA9IGNsb25lZFZhbHVlO1xuXG4gICAgICAgICAgICBsZXQgbG9jID0gdGhpcy5nZXRVbmlmb3JtTG9jYXRpb24obmFtZSk7XG4gICAgICAgICAgICBpZiAobG9jKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzTWF0cml4ID0gKGdsRnVuY3Rpb24gPT09IHRoaXMuZ2wudW5pZm9ybU1hdHJpeDJmdiB8fCBnbEZ1bmN0aW9uID09PSB0aGlzLmdsLnVuaWZvcm1NYXRyaXgzZnYgfHwgZ2xGdW5jdGlvbiA9PT0gdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xGdW5jdGlvbi5jYWxsKHRoaXMuZ2wsIGxvYywgZmFsc2UsIGNsb25lZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbEZ1bmN0aW9uLmNhbGwodGhpcy5nbCwgbG9jLCBjbG9uZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG4vKipcbiAqIDR4NCBib3ggYmx1ciBzaGFkZXIgd2hpY2ggd29ya3MgaW4gY29uanVuY3Rpb24gd2l0aCBhIDUwJSByZXNjYWxlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCb3hCbHVyU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGNvbnN0IGR4ID0gMS4wIC8gb3BlcmF0aW9uLmdldFRleHR1cmVXaWR0aCgwKTtcbiAgICAgICAgY29uc3QgZHkgPSAxLjAgLyBvcGVyYXRpb24uZ2V0VGV4dHVyZUhlaWdodCgwKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInN0ZXBUZXh0dXJlQ29vcmRcIiwgbmV3IEZsb2F0MzJBcnJheShbZHgsIGR5XSksIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgfVxuXG59XG5cbkJveEJsdXJTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHVuaWZvcm0gdmVjMiBzdGVwVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkVWw7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRVcjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZEJsO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkQnI7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmRVbCA9IGFUZXh0dXJlQ29vcmQgLSBzdGVwVGV4dHVyZUNvb3JkO1xuICAgICAgICB2VGV4dHVyZUNvb3JkQnIgPSBhVGV4dHVyZUNvb3JkICsgc3RlcFRleHR1cmVDb29yZDtcbiAgICAgICAgdlRleHR1cmVDb29yZFVyID0gdmVjMih2VGV4dHVyZUNvb3JkQnIueCwgdlRleHR1cmVDb29yZFVsLnkpO1xuICAgICAgICB2VGV4dHVyZUNvb3JkQmwgPSB2ZWMyKHZUZXh0dXJlQ29vcmRVbC54LCB2VGV4dHVyZUNvb3JkQnIueSk7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cbkJveEJsdXJTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRVbDtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZFVyO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkQmw7XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmRCcjtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjNCBjb2xvciA9IDAuMjUgKiAodGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkVWwpICsgdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkVXIpICsgdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkQmwpICsgdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkQnIpKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB2Q29sb3I7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi8uLi8uLi90cmVlL1V0aWxzLm1qc1wiO1xuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2lyY3VsYXJQdXNoU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICB0aGlzLl9pbnB1dFZhbHVlID0gMDtcblxuICAgICAgICB0aGlzLl9tYXhEZXJpdmF0aXZlID0gMC4wMTtcblxuICAgICAgICB0aGlzLl9ub3JtYWxpemVkVmFsdWUgPSAwO1xuXG4gICAgICAgIC8vIFRoZSBvZmZzZXQgYmV0d2VlbiBidWNrZXRzLiBBIHZhbHVlIGJldHdlZW4gMCBhbmQgMS5cbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcblxuICAgICAgICB0aGlzLl9hbW91bnQgPSAwLjE7XG5cbiAgICAgICAgdGhpcy5fYXNwZWN0UmF0aW8gPSAxO1xuXG4gICAgICAgIHRoaXMuX29mZnNldFggPSAwO1xuXG4gICAgICAgIHRoaXMuX29mZnNldFkgPSAwO1xuXG4gICAgICAgIHRoaXMuYnVja2V0cyA9IDEwMDtcbiAgICB9XG5cbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hc3BlY3RSYXRpbztcbiAgICB9XG5cbiAgICBzZXQgYXNwZWN0UmF0aW8odikge1xuICAgICAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IG9mZnNldFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXRYO1xuICAgIH1cblxuICAgIHNldCBvZmZzZXRYKHYpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IG9mZnNldFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXRZO1xuICAgIH1cblxuICAgIHNldCBvZmZzZXRZKHYpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IGFtb3VudCh2KSB7XG4gICAgICAgIHRoaXMuX2Ftb3VudCA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9XG5cbiAgICBzZXQgaW5wdXRWYWx1ZSh2KSB7XG4gICAgICAgIHRoaXMuX2lucHV0VmFsdWUgPSB2O1xuICAgIH1cblxuICAgIGdldCBpbnB1dFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXRWYWx1ZTtcbiAgICB9XG5cbiAgICBzZXQgbWF4RGVyaXZhdGl2ZSh2KSB7XG4gICAgICAgIHRoaXMuX21heERlcml2YXRpdmUgPSB2O1xuICAgIH1cblxuICAgIGdldCBtYXhEZXJpdmF0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4RGVyaXZhdGl2ZTtcbiAgICB9XG5cbiAgICBzZXQgYnVja2V0cyh2KSB7XG4gICAgICAgIGlmICh2ID4gMTAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbTGlnaHRuaW5nXSBDaXJjdWxhclB1c2hTaGFkZXI6IHN1cHBvcnRzIG1heCAxMDAgYnVja2V0c1wiKTtcbiAgICAgICAgICAgIHYgPSAxMDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBzZXQgYmVmb3JlIHN0YXJ0aW5nLlxuICAgICAgICB0aGlzLl9idWNrZXRzID0gdjtcblxuICAgICAgICAvLyBJbml0IHZhbHVlcyBhcnJheSBpbiB0aGUgY29ycmVjdCBsZW5ndGguXG4gICAgICAgIHRoaXMuX3ZhbHVlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX2dldFZhbHVlcyh2KSk7XG5cbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYnVja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1Y2tldHM7XG4gICAgfVxuXG4gICAgX2dldFZhbHVlcyhuKSB7XG4gICAgICAgIGNvbnN0IHYgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHYucHVzaCh0aGlzLl9pbnB1dFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9ncmVzc2VzIHRoZSBzaGFkZXIgd2l0aCB0aGUgc3BlY2lmaWVkIChmcmFjdGlvbmFsKSBudW1iZXIgb2YgYnVja2V0cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbztcbiAgICAgKiAgIEEgbnVtYmVyIGZyb20gMCB0byAxICgxID0gYWxsIGJ1Y2tldHMpLlxuICAgICAqL1xuICAgIHByb2dyZXNzKG8pIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ICs9IG8gKiB0aGlzLl9idWNrZXRzO1xuICAgICAgICBjb25zdCBmdWxsID0gTWF0aC5mbG9vcih0aGlzLl9vZmZzZXQpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgLT0gZnVsbDtcbiAgICAgICAgdGhpcy5fc2hpZnRCdWNrZXRzKGZ1bGwpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIF9zaGlmdEJ1Y2tldHMobikge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fYnVja2V0cyAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRJbmRleCA9IGkgLSBuO1xuICAgICAgICAgICAgaWYgKHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWRWYWx1ZSA9IE1hdGgubWluKHRoaXMuX25vcm1hbGl6ZWRWYWx1ZSArIHRoaXMuX21heERlcml2YXRpdmUsIE1hdGgubWF4KHRoaXMuX25vcm1hbGl6ZWRWYWx1ZSAtIHRoaXMuX21heERlcml2YXRpdmUsIHRoaXMuX2lucHV0VmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92YWx1ZXNbaV0gPSAyNTUgKiB0aGlzLl9ub3JtYWxpemVkVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IHRoaXMuX3ZhbHVlc1t0YXJnZXRJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgb2Zmc2V0KHYpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJhc3BlY3RSYXRpb1wiLCB0aGlzLl9hc3BlY3RSYXRpbywgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwib2Zmc2V0WFwiLCB0aGlzLl9vZmZzZXRYLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJvZmZzZXRZXCIsIHRoaXMuX29mZnNldFksIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImFtb3VudFwiLCB0aGlzLl9hbW91bnQsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcIm9mZnNldFwiLCB0aGlzLl9vZmZzZXQsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImJ1Y2tldHNcIiwgdGhpcy5fYnVja2V0cywgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwidVZhbHVlU2FtcGxlclwiLCAxLCB0aGlzLmdsLnVuaWZvcm0xaSk7XG4gICAgfVxuXG4gICAgdXNlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudCA9PT0gMDtcbiAgICB9XG5cbiAgICBiZWZvcmVEcmF3KG9wZXJhdGlvbikge1xuICAgICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTEpO1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlc1RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl92YWx1ZXNUZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzTm9kZSkge1xuICAgICAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX0JMVUVfUkVELCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3ZhbHVlc1RleHR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBsb2FkIG5ldyB2YWx1ZXMuXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuQUxQSEEsIHRoaXMuX2J1Y2tldHMsIDEsIDAsIGdsLkFMUEhBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLl92YWx1ZXMpO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICB9XG5cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5fdmFsdWVzVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMuX3ZhbHVlc1RleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cblxuQ2lyY3VsYXJQdXNoU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdW5pZm9ybSBmbG9hdCBvZmZzZXRYO1xuICAgIHVuaWZvcm0gZmxvYXQgb2Zmc2V0WTtcbiAgICB1bmlmb3JtIGZsb2F0IGFzcGVjdFJhdGlvO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjMiB2UG9zO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2UG9zID0gdlRleHR1cmVDb29yZCAqIDIuMCAtIDEuMDtcbiAgICAgICAgdlBvcy55ID0gdlBvcy55ICogYXNwZWN0UmF0aW87XG4gICAgICAgIHZQb3MueSA9IHZQb3MueSArIG9mZnNldFk7XG4gICAgICAgIHZQb3MueCA9IHZQb3MueCArIG9mZnNldFg7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cbkNpcmN1bGFyUHVzaFNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZhcnlpbmcgdmVjMiB2UG9zO1xuICAgIHVuaWZvcm0gZmxvYXQgYW1vdW50O1xuICAgIHVuaWZvcm0gZmxvYXQgb2Zmc2V0O1xuICAgIHVuaWZvcm0gZmxvYXQgdmFsdWVzWzEwMF07XG4gICAgdW5pZm9ybSBmbG9hdCBidWNrZXRzO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVWYWx1ZVNhbXBsZXI7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBmbG9hdCBsID0gbGVuZ3RoKHZQb3MpO1xuICAgICAgICBmbG9hdCBtID0gKGwgKiBidWNrZXRzICogMC42NzggLSBvZmZzZXQpIC8gYnVja2V0cztcbiAgICAgICAgZmxvYXQgZiA9IHRleHR1cmUyRCh1VmFsdWVTYW1wbGVyLCB2ZWMyKG0sIDAuMCkpLmEgKiBhbW91bnQ7XG4gICAgICAgIHZlYzIgdW5pdCA9IHZQb3MgLyBsO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQgLSBmICogdW5pdCkgKiB2Q29sb3I7XG4gICAgfVxuYDtcblxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgV2ViR0xTaGFkZXIgZnJvbSBcIi4uL1dlYkdMU2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWZhdWx0U2hhZGVyIGV4dGVuZHMgV2ViR0xTaGFkZXIge1xuXG4gICAgZW5hYmxlQXR0cmlicygpIHtcbiAgICAgICAgLy8gRW5hYmxlcyB0aGUgYXR0cmlicyBpbiB0aGUgc2hhZGVyIHByb2dyYW0uXG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYVZlcnRleFBvc2l0aW9uXCIpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAwKTtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVZlcnRleFBvc2l0aW9uXCIpKTtcblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMiAqIDQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU29tZSBzaGFkZXJzIG1heSBpZ25vcmUgdGhlIGNvbG9yLlxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIiksIDQsIGdsLlVOU0lHTkVEX0JZVEUsIHRydWUsIDIwLCA0ICogNCk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhQ29sb3JcIikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIC8vIERpc2FibGVzIHRoZSBhdHRyaWJzIGluIHRoZSBzaGFkZXIgcHJvZ3JhbS5cbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFWZXJ0ZXhQb3NpdGlvblwiKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F0dHJpYihcImFUZXh0dXJlQ29vcmRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYVRleHR1cmVDb29yZFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYXR0cmliKFwiYUNvbG9yXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFDb2xvclwiKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicHJvamVjdGlvblwiLCB0aGlzLl9nZXRQcm9qZWN0aW9uKG9wZXJhdGlvbiksIHRoaXMuZ2wudW5pZm9ybTJmdiwgZmFsc2UpO1xuICAgIH1cblxuICAgIGRyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IG9wZXJhdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGdsVGV4dHVyZSA9IG9wZXJhdGlvbi5nZXRUZXh0dXJlKDApO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHR4ID0gb3BlcmF0aW9uLmdldFRleHR1cmUoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGdsVGV4dHVyZSAhPT0gdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgNiAqIChpIC0gcG9zKSwgZ2wuVU5TSUdORURfU0hPUlQsIChwb3MgKyBvcGVyYXRpb24uaW5kZXgpICogNiAqIDIpO1xuICAgICAgICAgICAgICAgICAgICBnbFRleHR1cmUgPSB0eDtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCA2ICogKGxlbmd0aCAtIHBvcyksIGdsLlVOU0lHTkVEX1NIT1JULCAocG9zICsgb3BlcmF0aW9uLmluZGV4KSAqIDYgKiAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5EZWZhdWx0U2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IC1zaWduKHByb2plY3Rpb24ueSkgKiBnbF9Qb3NpdGlvbi55O1xuICAgIH1cbmA7XG5cbkRlZmF1bHRTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE5vaXNlVGV4dHVyZSBmcm9tIFwiLi4vLi4vLi4vdGV4dHVyZXMvTm9pc2VUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuLyoqXG4gKiBUaGlzIHNoYWRlciBjYW4gYmUgdXNlZCB0byBmaXggYSBwcm9ibGVtIHRoYXQgaXMga25vd24gYXMgJ2dyYWRpZW50IGJhbmRpbmcnLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaXRoZXJpbmdTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIHRoaXMuX25vaXNlVGV4dHVyZSA9IG5ldyBOb2lzZVRleHR1cmUoY3R4LnN0YWdlKTtcblxuICAgICAgICB0aGlzLl9ncmFpbmluZyA9IDEvMjU2O1xuXG4gICAgICAgIHRoaXMuX3JhbmRvbSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNldCBncmFpbmluZyh2KSB7XG4gICAgICAgIHRoaXMuX2dyYWluaW5nID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgcmFuZG9tKHYpIHtcbiAgICAgICAgdGhpcy5fcmFuZG9tID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXRFeHRyYUF0dHJpYnNJbkJ1ZmZlcihvcGVyYXRpb24pIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIG5vaXNlIHRleHR1cmUgaXMgdXBsb2FkZWQgdG8gdGhlIEdQVS5cbiAgICAgICAgdGhpcy5fbm9pc2VUZXh0dXJlLmxvYWQoKTtcblxuICAgICAgICBsZXQgb2Zmc2V0ID0gb3BlcmF0aW9uLmV4dHJhQXR0cmlic0RhdGFCeXRlT2Zmc2V0IC8gNDtcbiAgICAgICAgbGV0IGZsb2F0cyA9IG9wZXJhdGlvbi5xdWFkcy5mbG9hdHM7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IG9wZXJhdGlvbi5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbm9pc2UgdGV4dHVyZSBjb29yZGluYXRlcyBzbyB0aGF0IGl0IHNwYW5zIHRoZSBmdWxsIGVsZW1lbnQuXG4gICAgICAgICAgICBsZXQgYnJ4ID0gb3BlcmF0aW9uLmdldEVsZW1lbnRXaWR0aChpKSAvIHRoaXMuX25vaXNlVGV4dHVyZS5nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICAgICAgbGV0IGJyeSA9IG9wZXJhdGlvbi5nZXRFbGVtZW50SGVpZ2h0KGkpIC8gdGhpcy5fbm9pc2VUZXh0dXJlLmdldFJlbmRlckhlaWdodCgpO1xuXG4gICAgICAgICAgICBsZXQgdWx4ID0gMDtcbiAgICAgICAgICAgIGxldCB1bHkgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JhbmRvbSkge1xuICAgICAgICAgICAgICAgIHVseCA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICAgICAgdWx5ID0gTWF0aC5yYW5kb20oKTtcblxuICAgICAgICAgICAgICAgIGJyeCArPSB1bHg7XG4gICAgICAgICAgICAgICAgYnJ5ICs9IHVseTtcblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZsaXAgZm9yIG1vcmUgcmFuZG9tbmVzcy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHVseDtcbiAgICAgICAgICAgICAgICAgICAgdWx4ID0gYnJ4O1xuICAgICAgICAgICAgICAgICAgICBicnggPSB0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChNYXRoLnJhbmRvbSgpIDwgMC41KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZsaXAgZm9yIG1vcmUgcmFuZG9tbmVzcy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IHVseTtcbiAgICAgICAgICAgICAgICAgICAgdWx5ID0gYnJ5O1xuICAgICAgICAgICAgICAgICAgICBicnkgPSB0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3BlY2lmeSBhbGwgY29ybmVyIHBvaW50cy5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXRdID0gdWx4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDFdID0gdWx5O1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgMl0gPSBicng7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgM10gPSB1bHk7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA0XSA9IGJyeDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA1XSA9IGJyeTtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDZdID0gdWx4O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDddID0gYnJ5O1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlZm9yZURyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYU5vaXNlVGV4dHVyZUNvb3JkXCIpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDgsIHRoaXMuZ2V0VmVydGV4QXR0cmliUG9pbnRlck9mZnNldChvcGVyYXRpb24pKTtcblxuICAgICAgICBsZXQgZ2xUZXh0dXJlID0gdGhpcy5fbm9pc2VUZXh0dXJlLnNvdXJjZS5uYXRpdmVUZXh0dXJlO1xuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUxKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZ2xUZXh0dXJlKTtcbiAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgfVxuXG4gICAgZ2V0RXh0cmFBdHRyaWJCeXRlc1BlclZlcnRleCgpIHtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwidU5vaXNlU2FtcGxlclwiLCAxLCB0aGlzLmdsLnVuaWZvcm0xaSk7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJncmFpbmluZ1wiLCAyICogdGhpcy5fZ3JhaW5pbmcsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICB9XG5cbiAgICBlbmFibGVBdHRyaWJzKCkge1xuICAgICAgICBzdXBlci5lbmFibGVBdHRyaWJzKCk7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFOb2lzZVRleHR1cmVDb29yZFwiKSk7XG4gICAgfVxuXG4gICAgZGlzYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIHN1cGVyLmRpc2FibGVBdHRyaWJzKCk7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhTm9pc2VUZXh0dXJlQ29vcmRcIikpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncmFpbmluZyA9PT0gMDtcbiAgICB9XG5cbiAgICBhZnRlckRyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9yYW5kb20pIHtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuRGl0aGVyaW5nU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhTm9pc2VUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjMiB2Tm9pc2VUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZOb2lzZVRleHR1cmVDb29yZCA9IGFOb2lzZVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuRGl0aGVyaW5nU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjMiB2Tm9pc2VUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1Tm9pc2VTYW1wbGVyO1xuICAgIHVuaWZvcm0gZmxvYXQgZ3JhaW5pbmc7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IG5vaXNlID0gdGV4dHVyZTJEKHVOb2lzZVNhbXBsZXIsIHZOb2lzZVRleHR1cmVDb29yZCk7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSAoY29sb3IgKiB2Q29sb3IpICsgZ3JhaW5pbmcgKiAobm9pc2UuciAtIDAuNSk7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gJy4vRGVmYXVsdFNoYWRlci5tanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlT3V0U2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fZmFkZSA9IFswLCAwLCAwLCAwXTtcbiAgICB9XG5cbiAgICBzZXQgdG9wKG51bSkge1xuICAgICAgICB0aGlzLl9mYWRlWzBdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWRlWzBdO1xuICAgIH1cblxuICAgIHNldCByaWdodChudW0pIHtcbiAgICAgICAgdGhpcy5fZmFkZVsxXSA9IG51bTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWRlWzFdO1xuICAgIH1cblxuICAgIHNldCBib3R0b20obnVtKSB7XG4gICAgICAgIHRoaXMuX2ZhZGVbMl0gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGVbMl07XG4gICAgfVxuXG4gICAgc2V0IGxlZnQobnVtKSB7XG4gICAgICAgIHRoaXMuX2ZhZGVbM10gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWRlWzNdO1xuICAgIH1cblxuICAgIHNldCBmYWRlKHYpIHtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgaWYodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWRlID0gW3ZbMF0sIHZbMV0sIHZbMF0sIHZbMV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZih2Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhZGUgPSBbdlswXSwgdlsxXSwgdlsyXSwgdGhpcy5fZmFkZVszXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZhZGUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmFkZSA9IFt2WzBdLCB2WzBdLCB2WzBdLCB2WzBdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZhZGUgPSBbdiwgdiwgdiwgdl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgZmFkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhZGU7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBjb25zdCBvd25lciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcblxuICAgICAgICBjb25zdCByZW5kZXJQcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgY29uc3QgZmFkZSA9IHRoaXMuX2ZhZGUubWFwKChmKSA9PiBmICogcmVuZGVyUHJlY2lzaW9uKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnZmFkZScsICBuZXcgRmxvYXQzMkFycmF5KGZhZGUpLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyZXNvbHV0aW9uJywgbmV3IEZsb2F0MzJBcnJheShbb3duZXIuX3cgKiByZW5kZXJQcmVjaXNpb24sIG93bmVyLl9oICogcmVuZGVyUHJlY2lzaW9uXSksIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgfVxufVxuXG5GYWRlT3V0U2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgdW5pZm9ybSB2ZWM0IGZhZGU7XG4gICAgXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcbiAgICAgICAgdmVjMiBoYWxmUmVzID0gMC41ICogcmVzb2x1dGlvbi54eTtcbiAgICAgICAgdmVjMiBwb2ludCA9IHZUZXh0dXJlQ29vcmQueHkgKiByZXNvbHV0aW9uLnh5O1xuICAgICAgICBcbiAgICAgICAgdmVjMiBwb3MxO1xuICAgICAgICB2ZWMyIHBvczI7XG4gICAgICAgIHZlYzIgZDtcbiAgICAgICAgZmxvYXQgYztcbiAgICAgICAgZmxvYXQgdCA9IDAuMDtcbiAgICAgICAgICAgICBcbiAgICAgICAgaWYoZmFkZVswXSA+IDAuMCkge1xuICAgICAgICAgICAgcG9zMSA9IHZlYzIocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICBwb3MyID0gdmVjMihwb2ludC54LCBwb2ludC55ICsgZmFkZVswXSk7XG4gICAgICAgICAgICBkID0gcG9zMiAtIHBvczE7XG4gICAgICAgICAgICBjID0gZG90KHBvczEsIGQpIC8gZG90KGQsIGQpO1xuICAgICAgICAgICAgdCA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGNsYW1wKGMsIDAuMCwgMS4wKSk7XG4gICAgICAgICAgICBjb2xvciA9IG1peCh2ZWM0KDAuMCksIGNvbG9yLCB0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoZmFkZVsxXSA+IDAuMCkge1xuICAgICAgICAgICAgdmVjMiBwb3MxID0gdmVjMihwb2ludC54IC0gcmVzb2x1dGlvbi54IC0gZmFkZVsxXSwgdlRleHR1cmVDb29yZC55KTtcbiAgICAgICAgICAgIHZlYzIgcG9zMiA9IHZlYzIocG9pbnQueCAtIHJlc29sdXRpb24ueCwgdlRleHR1cmVDb29yZC55KTtcbiAgICAgICAgICAgIGQgPSBwb3MxIC0gcG9zMjtcbiAgICAgICAgICAgIGMgPSBkb3QocG9zMiwgZCkgLyBkb3QoZCwgZCk7XG4gICAgICAgICAgICB0ID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgY2xhbXAoYywgMC4wLCAxLjApKTtcbiAgICAgICAgICAgIGNvbG9yID0gbWl4KHZlYzQoMC4wKSwgY29sb3IsIHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihmYWRlWzJdID4gMC4wKSB7XG4gICAgICAgICAgICB2ZWMyIHBvczEgPSB2ZWMyKHZUZXh0dXJlQ29vcmQueCwgcG9pbnQueSAtIHJlc29sdXRpb24ueSAtIGZhZGVbMl0pO1xuICAgICAgICAgICAgdmVjMiBwb3MyID0gdmVjMih2VGV4dHVyZUNvb3JkLngsIHBvaW50LnkgLSByZXNvbHV0aW9uLnkpO1xuICAgICAgICAgICAgZCA9IHBvczEgLSBwb3MyO1xuICAgICAgICAgICAgYyA9IGRvdChwb3MyLCBkKSAvIGRvdChkLCBkKTtcbiAgICAgICAgICAgIHQgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBjbGFtcChjLCAwLjAsIDEuMCkpO1xuICAgICAgICAgICAgY29sb3IgPSBtaXgodmVjNCgwLjApLCBjb2xvciwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGZhZGVbM10gPiAwLjApIHtcbiAgICAgICAgICAgIHBvczEgPSB2ZWMyKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICAgICAgcG9zMiA9IHZlYzIocG9pbnQueCArIGZhZGVbM10sIHBvaW50LnkpO1xuICAgICAgICAgICAgZCA9IHBvczIgLSBwb3MxO1xuICAgICAgICAgICAgYyA9IGRvdChwb3MxLCBkKSAvIGRvdChkLCBkKTtcbiAgICAgICAgICAgIHQgPSBzbW9vdGhzdGVwKDAuMCwgMS4wLCBjbGFtcChjLCAwLjAsIDEuMCkpO1xuICAgICAgICAgICAgY29sb3IgPSBtaXgodmVjNCgwLjApLCBjb2xvciwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIb2xlU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgIHRoaXMuX3cgPSAwO1xuICAgICAgICB0aGlzLl9oID0gMDtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gMDtcbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfVxuXG4gICAgc2V0IHgodikge1xuICAgICAgICB0aGlzLl94ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfVxuXG4gICAgc2V0IHkodikge1xuICAgICAgICB0aGlzLl95ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfVxuXG4gICAgc2V0IHcodikge1xuICAgICAgICB0aGlzLl93ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgfVxuXG4gICAgc2V0IGgodikge1xuICAgICAgICB0aGlzLl9oID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcmFkaXVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xuICAgIH1cblxuICAgIHNldCByYWRpdXModikge1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcblxuICAgICAgICBjb25zdCBvd25lciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcbiAgICAgICAgY29uc3QgcmVuZGVyUHJlY2lzaW9uID0gdGhpcy5jdHguc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKClcblxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwieFwiLCB0aGlzLl94ICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ5XCIsIHRoaXMuX3kgKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcIndcIiwgdGhpcy5fdyAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiaFwiLCB0aGlzLl9oICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3JhZGl1cycsICAodGhpcy5fcmFkaXVzICsgLjUpICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Jlc29sdXRpb24nLCBuZXcgRmxvYXQzMkFycmF5KFtvd25lci5fdyAqIHJlbmRlclByZWNpc2lvbiwgb3duZXIuX2ggKiByZW5kZXJQcmVjaXNpb25dKSwgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3ggPT09IDAgJiYgdGhpcy5feSA9PT0gMCAmJiB0aGlzLl93ID09PSAwICYmIHRoaXMuX2ggPT09IDApXG4gICAgfVxufVxuXG5Ib2xlU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IERlZmF1bHRTaGFkZXIudmVydGV4U2hhZGVyU291cmNlO1xuXG5Ib2xlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIGZsb2F0IHg7XG4gICAgdW5pZm9ybSBmbG9hdCB5O1xuICAgIHVuaWZvcm0gZmxvYXQgdztcbiAgICB1bmlmb3JtIGZsb2F0IGg7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG5cbiAgICBmbG9hdCByb3VuZEJveCh2ZWMyIHAsIHZlYzIgYiwgZmxvYXQgcikge1xuICAgICAgICBmbG9hdCBkID0gbGVuZ3RoKG1heChhYnMocCktYityLCAwLjEpKS1yO1xuICAgICAgICByZXR1cm4gc21vb3Roc3RlcCgxLjAsIDAuMCwgZCk7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbiAgICAgICAgdmVjMiBwb3MgPSB2VGV4dHVyZUNvb3JkLnh5ICogcmVzb2x1dGlvbiAtIHZlYzIoeCwgeSkgLSB2ZWMyKHcsIGgpIC8gMi4wO1xuICAgICAgICB2ZWMyIHNpemUgPSB2ZWMyKHcsIGgpIC8gMi4wO1xuICAgICAgICBmbG9hdCBiID0gcm91bmRCb3gocG9zLCBzaXplLCByYWRpdXMpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBtaXgoY29sb3IsIHZlYzQoMC4wKSwgYik7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmVyc2lvblNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gMTtcbiAgICB9XG5cbiAgICBzZXQgYW1vdW50KHYpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1vdW50O1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbW91bnQgPT09IDA7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiYW1vdW50XCIsIHRoaXMuX2Ftb3VudCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgIH1cblxufVxuXG5JbnZlcnNpb25TaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIGZsb2F0IGFtb3VudDtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICBjb2xvci5yZ2IgPSBjb2xvci5yZ2IgKiAoMS4wIC0gYW1vdW50KSArIGFtb3VudCAqICgxLjAgKiBjb2xvci5hIC0gY29sb3IucmdiKTsgXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogdkNvbG9yO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpZ2h0M2RTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIHRoaXMuX3N0cmVuZ3RoID0gMC41O1xuICAgICAgICB0aGlzLl9hbWJpZW50ID0gMC41O1xuICAgICAgICB0aGlzLl9mdWRnZSA9IDAuNDtcblxuICAgICAgICB0aGlzLl9yeCA9IDA7XG4gICAgICAgIHRoaXMuX3J5ID0gMDtcblxuICAgICAgICB0aGlzLl96ID0gMDtcbiAgICAgICAgdGhpcy5fcGl2b3RYID0gTmFOO1xuICAgICAgICB0aGlzLl9waXZvdFkgPSBOYU47XG4gICAgICAgIHRoaXMuX3Bpdm90WiA9IDA7XG5cbiAgICAgICAgdGhpcy5fbGlnaHRZID0gMDtcbiAgICAgICAgdGhpcy5fbGlnaHRaID0gMDtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG5cbiAgICAgICAgbGV0IHZyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuICAgICAgICBsZXQgZWxlbWVudCA9IHZyLmVsZW1lbnQ7XG5cbiAgICAgICAgbGV0IHBpdm90WCA9IGlzTmFOKHRoaXMuX3Bpdm90WCkgPyBlbGVtZW50LnBpdm90WCAqIHZyLncgOiB0aGlzLl9waXZvdFg7XG4gICAgICAgIGxldCBwaXZvdFkgPSBpc05hTih0aGlzLl9waXZvdFkpID8gZWxlbWVudC5waXZvdFkgKiB2ci5oIDogdGhpcy5fcGl2b3RZO1xuICAgICAgICBsZXQgY29vcmRzID0gdnIuZ2V0UmVuZGVyVGV4dHVyZUNvb3JkcyhwaXZvdFgsIHBpdm90WSk7XG5cbiAgICAgICAgLy8gQ291bnRlciBub3JtYWwgcm90YXRpb24uXG5cbiAgICAgICAgbGV0IHJ6ID0gLU1hdGguYXRhbjIodnIuX3JlbmRlckNvbnRleHQudGMsIHZyLl9yZW5kZXJDb250ZXh0LnRhKTtcblxuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicGl2b3RcIiwgbmV3IEZsb2F0MzJBcnJheShbY29vcmRzWzBdLCBjb29yZHNbMV0sIHRoaXMuX3Bpdm90Wl0pLCBnbC51bmlmb3JtM2Z2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInJvdFwiLCBuZXcgRmxvYXQzMkFycmF5KFt0aGlzLl9yeCwgdGhpcy5fcnksIHJ6XSksIGdsLnVuaWZvcm0zZnYpO1xuXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ6XCIsIHRoaXMuX3osIGdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJsaWdodFlcIiwgdGhpcy5saWdodFksIGdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJsaWdodFpcIiwgdGhpcy5saWdodFosIGdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJzdHJlbmd0aFwiLCB0aGlzLl9zdHJlbmd0aCwgZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImFtYmllbnRcIiwgdGhpcy5fYW1iaWVudCwgZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcImZ1ZGdlXCIsIHRoaXMuX2Z1ZGdlLCBnbC51bmlmb3JtMWYpO1xuICAgIH1cblxuICAgIHNldCBzdHJlbmd0aCh2KSB7XG4gICAgICAgIHRoaXMuX3N0cmVuZ3RoID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgc3RyZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJlbmd0aDtcbiAgICB9XG5cbiAgICBzZXQgYW1iaWVudCh2KSB7XG4gICAgICAgIHRoaXMuX2FtYmllbnQgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBhbWJpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW1iaWVudDtcbiAgICB9XG5cbiAgICBzZXQgZnVkZ2Uodikge1xuICAgICAgICB0aGlzLl9mdWRnZSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGZ1ZGdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVkZ2U7XG4gICAgfVxuXG4gICAgZ2V0IHJ4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcng7XG4gICAgfVxuXG4gICAgc2V0IHJ4KHYpIHtcbiAgICAgICAgdGhpcy5fcnggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCByeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J5O1xuICAgIH1cblxuICAgIHNldCByeSh2KSB7XG4gICAgICAgIHRoaXMuX3J5ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgeigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XG4gICAgfVxuXG4gICAgc2V0IHoodikge1xuICAgICAgICB0aGlzLl96ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RYO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFgodikge1xuICAgICAgICB0aGlzLl9waXZvdFggPSB2ICsgMTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RZO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFkodikge1xuICAgICAgICB0aGlzLl9waXZvdFkgPSB2ICsgMTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgbGlnaHRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlnaHRZO1xuICAgIH1cblxuICAgIHNldCBsaWdodFkodikge1xuICAgICAgICB0aGlzLl9saWdodFkgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdFooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9waXZvdFo7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90Wih2KSB7XG4gICAgICAgIHRoaXMuX3Bpdm90WiA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGxpZ2h0WigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpZ2h0WjtcbiAgICB9XG5cbiAgICBzZXQgbGlnaHRaKHYpIHtcbiAgICAgICAgdGhpcy5fbGlnaHRaID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3J4ID09PSAwICYmIHRoaXMuX3J5ID09PSAwICYmIHRoaXMuX3ogPT09IDAgJiYgdGhpcy5fc3RyZW5ndGggPT09IDAgJiYgdGhpcy5fYW1iaWVudCA9PT0gMSk7XG4gICAgfVxuXG59XG5cbkxpZ2h0M2RTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4gICAgdW5pZm9ybSBmbG9hdCBmdWRnZTtcbiAgICB1bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xuICAgIHVuaWZvcm0gZmxvYXQgYW1iaWVudDtcbiAgICB1bmlmb3JtIGZsb2F0IHo7XG4gICAgdW5pZm9ybSBmbG9hdCBsaWdodFk7XG4gICAgdW5pZm9ybSBmbG9hdCBsaWdodFo7XG4gICAgdW5pZm9ybSB2ZWMzIHBpdm90O1xuICAgIHVuaWZvcm0gdmVjMyByb3Q7XG4gICAgdmFyeWluZyB2ZWMzIHBvcztcblxuICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICAgIHBvcyA9IHZlYzMoYVZlcnRleFBvc2l0aW9uLnh5LCB6KTtcbiAgICAgICAgXG4gICAgICAgIHBvcyAtPSBwaXZvdDtcbiAgICAgICAgXG4gICAgICAgIC8vIFVuZG8gWFkgcm90YXRpb25cbiAgICAgICAgbWF0MiBpUm90WHkgPSBtYXQyKCBjb3Mocm90LnopLCBzaW4ocm90LnopLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC1zaW4ocm90LnopLCBjb3Mocm90LnopKTtcbiAgICAgICAgcG9zLnh5ID0gaVJvdFh5ICogcG9zLnh5O1xuICAgICAgICBcbiAgICAgICAgLy8gUGVyZm9ybSAzZCByb3RhdGlvbnNcbiAgICAgICAgZ2xfUG9zaXRpb24ueCA9IGNvcyhyb3QueCkgKiBwb3MueCAtIHNpbihyb3QueCkgKiBwb3MuejtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IHBvcy55O1xuICAgICAgICBnbF9Qb3NpdGlvbi56ID0gc2luKHJvdC54KSAqIHBvcy54ICsgY29zKHJvdC54KSAqIHBvcy56O1xuICAgICAgICBcbiAgICAgICAgcG9zLnggPSBnbF9Qb3NpdGlvbi54O1xuICAgICAgICBwb3MueSA9IGNvcyhyb3QueSkgKiBnbF9Qb3NpdGlvbi55IC0gc2luKHJvdC55KSAqIGdsX1Bvc2l0aW9uLno7XG4gICAgICAgIHBvcy56ID0gc2luKHJvdC55KSAqIGdsX1Bvc2l0aW9uLnkgKyBjb3Mocm90LnkpICogZ2xfUG9zaXRpb24uejtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZG8gWFkgcm90YXRpb25cbiAgICAgICAgaVJvdFh5WzBdWzFdID0gLWlSb3RYeVswXVsxXTtcbiAgICAgICAgaVJvdFh5WzFdWzBdID0gLWlSb3RYeVsxXVswXTtcbiAgICAgICAgcG9zLnh5ID0gaVJvdFh5ICogcG9zLnh5OyBcblxuICAgICAgICAvLyBVbmRvIHRyYW5zbGF0ZSB0byBwaXZvdCBwb3NpdGlvblxuICAgICAgICBwb3MueHl6ICs9IHBpdm90O1xuXG4gICAgICAgIHBvcyA9IHZlYzMocG9zLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIHBvcy55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCBwb3MueiAqIHByb2plY3Rpb24ueCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgZGVwdGggcGVyc3BlY3RpdmVcbiAgICAgICAgZmxvYXQgcGVyc3BlY3RpdmUgPSAxLjAgKyBmdWRnZSAqIHBvcy56O1xuXG4gICAgICAgIHBvcy56ICs9IGxpZ2h0WiAqIHByb2plY3Rpb24ueDtcblxuICAgICAgICAvLyBNYXAgY29vcmRzIHRvIGdsIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICAgIC8vIFNldCB6IHRvIDAgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHBlcmZvcm0gei1jbGlwcGluZ1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAwLjAsIHBlcnNwZWN0aXZlKTtcblxuICAgICAgICAvLyBDb3JyZWN0IGxpZ2h0IHNvdXJjZSBwb3NpdGlvbi5cbiAgICAgICAgcG9zLnkgKz0gbGlnaHRZICogYWJzKHByb2plY3Rpb24ueSk7XG5cbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb2xvciA9IGFDb2xvcjtcbiAgICAgICAgXG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5MaWdodDNkU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdmFyeWluZyB2ZWMzIHBvcztcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIGZsb2F0IGFtYmllbnQ7XG4gICAgdW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIHZlYzQgcmdiYSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgIGZsb2F0IGQgPSBsZW5ndGgocG9zKTtcbiAgICAgICAgZmxvYXQgbiA9IDEuMCAvIG1heCgwLjEsIGQpO1xuICAgICAgICByZ2JhLnJnYiA9IHJnYmEucmdiICogKHN0cmVuZ3RoICogbiArIGFtYmllbnQpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSByZ2JhICogdkNvbG9yO1xuICAgIH1cbmA7XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVhckJsdXJTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG5cbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMF0pO1xuICAgICAgICB0aGlzLl9rZXJuZWxSYWRpdXMgPSAxO1xuICAgIH1cblxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uWzBdO1xuICAgIH1cblxuICAgIHNldCB4KHYpIHtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uWzBdID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvblsxXTtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvblsxXSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGtlcm5lbFJhZGl1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tlcm5lbFJhZGl1cztcbiAgICB9XG5cbiAgICBzZXQga2VybmVsUmFkaXVzKHYpIHtcbiAgICAgICAgdGhpcy5fa2VybmVsUmFkaXVzID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fa2VybmVsUmFkaXVzID09PSAwKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJkaXJlY3Rpb25cIiwgdGhpcy5fZGlyZWN0aW9uLCB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwia2VybmVsUmFkaXVzXCIsIHRoaXMuX2tlcm5lbFJhZGl1cywgdGhpcy5nbC51bmlmb3JtMWkpO1xuXG4gICAgICAgIGNvbnN0IHcgPSBvcGVyYXRpb24uZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgY29uc3QgaCA9IG9wZXJhdGlvbi5nZXRSZW5kZXJIZWlnaHQoKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInJlc29sdXRpb25cIiwgbmV3IEZsb2F0MzJBcnJheShbdywgaF0pLCB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgIH1cbn1cblxuTGluZWFyQmx1clNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHVuaWZvcm0gdmVjMiBkaXJlY3Rpb247XG4gICAgdW5pZm9ybSBpbnQga2VybmVsUmFkaXVzO1xuICAgIFxuICAgIHZlYzQgYmx1cjEoc2FtcGxlcjJEIGltYWdlLCB2ZWMyIHV2LCB2ZWMyIHJlc29sdXRpb24sIHZlYzIgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XG4gICAgICAgIHZlYzIgb2ZmMSA9IHZlYzIoMS4zMzMzMzMzMzMzMzMzMzMzKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjI5NDExNzY0NzA1ODgyMzU0O1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjM1Mjk0MTE3NjQ3MDU4ODI2O1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjEgLyByZXNvbHV0aW9uKSkgKiAwLjM1Mjk0MTE3NjQ3MDU4ODI2O1xuICAgICAgICByZXR1cm4gY29sb3I7IFxuICAgIH1cbiAgICBcbiAgICB2ZWM0IGJsdXIyKHNhbXBsZXIyRCBpbWFnZSwgdmVjMiB1diwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIGRpcmVjdGlvbikge1xuICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xuICAgICAgICB2ZWMyIG9mZjEgPSB2ZWMyKDEuMzg0NjE1Mzg0NikgKiBkaXJlY3Rpb247XG4gICAgICAgIHZlYzIgb2ZmMiA9IHZlYzIoMy4yMzA3NjkyMzA4KSAqIGRpcmVjdGlvbjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjIyNzAyNzAyNzA7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4zMTYyMTYyMTYyO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA3MDI3MDI3MDM7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgLSAob2ZmMiAvIHJlc29sdXRpb24pKSAqIDAuMDcwMjcwMjcwMztcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cbiAgICBcbiAgICB2ZWM0IGJsdXIzKHNhbXBsZXIyRCBpbWFnZSwgdmVjMiB1diwgdmVjMiByZXNvbHV0aW9uLCB2ZWMyIGRpcmVjdGlvbikge1xuICAgICAgICB2ZWM0IGNvbG9yID0gdmVjNCgwLjApO1xuICAgICAgICB2ZWMyIG9mZjEgPSB2ZWMyKDEuNDExNzY0NzA1ODgyMzUzKSAqIGRpcmVjdGlvbjtcbiAgICAgICAgdmVjMiBvZmYyID0gdmVjMigzLjI5NDExNzY0NzA1ODgyMzQpICogZGlyZWN0aW9uO1xuICAgICAgICB2ZWMyIG9mZjMgPSB2ZWMyKDUuMTc2NDcwNTg4MjM1Mjk0KSAqIGRpcmVjdGlvbjtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1dikgKiAwLjE5NjQ4MjU1MDE1MTE0MDQ7XG4gICAgICAgIGNvbG9yICs9IHRleHR1cmUyRChpbWFnZSwgdXYgKyAob2ZmMSAvIHJlc29sdXRpb24pKSAqIDAuMjk2OTA2OTY0NjcyODM0NDtcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYxIC8gcmVzb2x1dGlvbikpICogMC4yOTY5MDY5NjQ2NzI4MzQ0O1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA5NDQ3MDM5Nzg1MDQ0NzMyO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2IC0gKG9mZjIgLyByZXNvbHV0aW9uKSkgKiAwLjA5NDQ3MDM5Nzg1MDQ0NzMyO1xuICAgICAgICBjb2xvciArPSB0ZXh0dXJlMkQoaW1hZ2UsIHV2ICsgKG9mZjMgLyByZXNvbHV0aW9uKSkgKiAwLjAxMDM4MTM2MjQwMTE0ODA1NztcbiAgICAgICAgY29sb3IgKz0gdGV4dHVyZTJEKGltYWdlLCB1diAtIChvZmYzIC8gcmVzb2x1dGlvbikpICogMC4wMTAzODEzNjI0MDExNDgwNTc7XG4gICAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9ICAgIFxuXG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBpZiAoa2VybmVsUmFkaXVzID09IDEpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGJsdXIxKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLCByZXNvbHV0aW9uLCBkaXJlY3Rpb24pICogdkNvbG9yO1xuICAgICAgICB9IGVsc2UgaWYgKGtlcm5lbFJhZGl1cyA9PSAyKSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBibHVyMih1U2FtcGxlciwgdlRleHR1cmVDb29yZCwgcmVzb2x1dGlvbiwgZGlyZWN0aW9uKSAqIHZDb2xvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGJsdXIzKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkLCByZXNvbHV0aW9uLCBkaXJlY3Rpb24pICogdkNvbG9yO1xuICAgICAgICB9XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hZ25pZmllclNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXHRjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG5cdCAgc3VwZXIoY29udGV4dCk7XG5cdCAgdGhpcy5feCA9IDA7XG5cdCAgdGhpcy5feSA9IDA7XG5cdCAgdGhpcy5fdyA9IDA7XG5cdCAgdGhpcy5faCA9IDA7XG5cdCAgdGhpcy5fcmFkaXVzID0gMDtcblx0ICB0aGlzLl9tYWduaWZpY2F0aW9uID0gMC42O1xuXHR9XG4gIFxuXHRnZXQgeCgpIHtcblx0ICByZXR1cm4gdGhpcy5feDtcblx0fVxuICBcblx0c2V0IHgodikge1xuXHQgIHRoaXMuX3ggPSB2O1xuXHQgIHRoaXMucmVkcmF3KCk7XG5cdH1cbiAgXG5cdGdldCB5KCkge1xuXHQgIHJldHVybiB0aGlzLl95O1xuXHR9XG4gIFxuXHRzZXQgeSh2KSB7XG5cdCAgdGhpcy5feSA9IHY7XG5cdCAgdGhpcy5yZWRyYXcoKTtcblx0fVxuICBcblx0Z2V0IHcoKSB7XG5cdCAgcmV0dXJuIHRoaXMuX3c7XG5cdH1cbiAgXG5cdHNldCB3KHYpIHtcblx0ICB0aGlzLl93ID0gdjtcblx0ICB0aGlzLnJlZHJhdygpO1xuXHR9XG4gIFxuXHRnZXQgaCgpIHtcblx0ICByZXR1cm4gdGhpcy5faDtcblx0fVxuICBcblx0c2V0IGgodikge1xuXHQgIHRoaXMuX2ggPSB2O1xuXHQgIHRoaXMucmVkcmF3KCk7XG5cdH1cbiAgXG5cdGdldCBtYWduaWZpY2F0aW9uKCkge1xuXHQgIHJldHVybiB0aGlzLl9tYWduaWZpY2F0aW9uO1xuXHR9XG4gIFxuXHRzZXQgbWFnbmlmaWNhdGlvbih2KSB7XG5cdCAgdGhpcy5fbWFnbmlmaWNhdGlvbiA9IHY7XG5cdCAgdGhpcy5yZWRyYXcoKTtcblx0fVxuICBcblx0Z2V0IHJhZGl1cygpIHtcblx0ICByZXR1cm4gdGhpcy5fcmFkaXVzO1xuXHR9XG4gIFxuXHRzZXQgcmFkaXVzKHYpIHtcblx0ICB0aGlzLl9yYWRpdXMgPSB2O1xuXHQgIHRoaXMucmVkcmF3KCk7XG5cdH1cbiAgXG5cdHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG5cdCAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICBcblx0ICBjb25zdCBvd25lciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcblx0ICBjb25zdCByZW5kZXJQcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcblx0ICB0aGlzLl9zZXRVbmlmb3JtKCd4JywgdGhpcy5feCAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuXHQgIHRoaXMuX3NldFVuaWZvcm0oJ3knLCB0aGlzLl95ICogcmVuZGVyUHJlY2lzaW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG5cdCAgdGhpcy5fc2V0VW5pZm9ybSgndycsIHRoaXMuX3cgKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcblx0ICB0aGlzLl9zZXRVbmlmb3JtKCdoJywgdGhpcy5faCAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuXHQgIHRoaXMuX3NldFVuaWZvcm0oJ21hZ25pZmljYXRpb24nLCB0aGlzLl9tYWduaWZpY2F0aW9uLCB0aGlzLmdsLnVuaWZvcm0xZik7XG5cdCAgdGhpcy5fc2V0VW5pZm9ybShcblx0XHQncmFkaXVzJyxcblx0XHQodGhpcy5fcmFkaXVzICsgMC41KSAqIHJlbmRlclByZWNpc2lvbixcblx0XHR0aGlzLmdsLnVuaWZvcm0xZlxuXHQgICk7XG5cdCAgdGhpcy5fc2V0VW5pZm9ybShcblx0XHQncmVzb2x1dGlvbicsXG5cdFx0bmV3IEZsb2F0MzJBcnJheShbXG5cdFx0ICBvd25lci5fdyAqIHJlbmRlclByZWNpc2lvbixcblx0XHQgIG93bmVyLl9oICogcmVuZGVyUHJlY2lzaW9uXG5cdFx0XSksXG5cdFx0dGhpcy5nbC51bmlmb3JtMmZ2XG5cdCAgKTtcblx0fVxuIFxuXHR1c2VEZWZhdWx0KCkge1xuXHQgIHJldHVybiB0aGlzLl93ID09PSAwICYmIHRoaXMuX2ggPT09IDA7XG5cdH1cbiAgfVxuICBcbiAgTWFnbmlmaWVyU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IERlZmF1bHRTaGFkZXIudmVydGV4U2hhZGVyU291cmNlO1xuICBcbiAgTWFnbmlmaWVyU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuXHQgICNpZmRlZiBHTF9FU1xuXHRcdCMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcblx0XHRwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5cdFx0IyBlbHNlXG5cdFx0cHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG5cdFx0IyBlbmRpZlxuXHQgICNlbmRpZlxuXG5cdCAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cdCAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcblx0ICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblx0ICB1bmlmb3JtIGZsb2F0IHg7XG5cdCAgdW5pZm9ybSBmbG9hdCB5O1xuXHQgIHVuaWZvcm0gZmxvYXQgdztcblx0ICB1bmlmb3JtIGZsb2F0IGg7XG5cdCAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG5cdCAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG5cdCAgdW5pZm9ybSBmbG9hdCBtYWduaWZpY2F0aW9uO1xuICBcblx0ICBmbG9hdCByb3VuZEJveCh2ZWMyIHAsIHZlYzIgYiwgZmxvYXQgcikge1xuXHRcdCAgZmxvYXQgZCA9IGxlbmd0aChtYXgoYWJzKHApLWIrciwgMC4xKSktcjtcblx0XHQgIHJldHVybiBzbW9vdGhzdGVwKDEuMCwgMC4wLCBkKTtcblx0ICB9XG5cblx0ICBmbG9hdCBpbnNpZGUodmVjMiB2KSB7XG5cdFx0dmVjMiBzID0gc3RlcCh2ZWMyKDAuMCwgMC4wKSwgdikgLSBzdGVwKHZlYzIoMS4wLCAxLjApLCB2KTtcblx0XHRyZXR1cm4gcy54ICogcy55OyAgIFxuICAgICAgfVxuICBcblx0ICB2b2lkIG1haW4odm9pZCkge1xuXHRcdHZlYzQgY29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuXHRcdHZlYzIgcG9zID0gdlRleHR1cmVDb29yZC54eSAqIHJlc29sdXRpb24gLSB2ZWMyKHgsIHkpIC0gdmVjMih3LCBoKSAvIDIuMDtcblx0XHR2ZWMyIHNpemUgPSB2ZWMyKHcsIGgpIC8gMi4wO1xuXHRcdGZsb2F0IGIgPSByb3VuZEJveChwb3MsIHNpemUsIHJhZGl1cyk7XG5cdFx0dmVjMiBwb3MyID0gKHZUZXh0dXJlQ29vcmQueHkgKiBtYWduaWZpY2F0aW9uICogcmVzb2x1dGlvbiArIHZlYzIoeCwgeSkgKiBtYWduaWZpY2F0aW9uKSAvIHJlc29sdXRpb247XG5cdFx0Z2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yLCB0ZXh0dXJlMkQodVNhbXBsZXIsIHBvczIpICogaW5zaWRlKHBvczIpLCBiKSAqIHZDb2xvcjtcblx0ICB9XG4gIGA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3V0bGluZVNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gNTtcbiAgICAgICAgdGhpcy5fY29sID0gMHhGRkZGRkZGRjtcbiAgICAgICAgdGhpcy5fY29sb3IgPSBbMSwxLDEsMV07XG4gICAgfVxuXG4gICAgc2V0IHdpZHRoKHYpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3Iodikge1xuICAgICAgICBpZiAodGhpcy5fY29sICE9PSB2KSB7XG4gICAgICAgICAgICBjb25zdCBjb2wgPSBTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZCh2KTtcbiAgICAgICAgICAgIGNvbFswXSA9IGNvbFswXSAqIGNvbFszXTtcbiAgICAgICAgICAgIGNvbFsxXSA9IGNvbFsxXSAqIGNvbFszXTtcbiAgICAgICAgICAgIGNvbFsyXSA9IGNvbFsyXSAqIGNvbFszXTtcblxuICAgICAgICAgICAgdGhpcy5fY29sb3IgPSBjb2w7XG5cbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3dpZHRoID09PSAwIHx8IHRoaXMuX2NvbFszXSA9PT0gMCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBsZXQgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiY29sb3JcIiwgbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9jb2xvciksIGdsLnVuaWZvcm00ZnYpO1xuICAgIH1cblxuICAgIGVuYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIHN1cGVyLmVuYWJsZUF0dHJpYnMoKTtcbiAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhQ29ybmVyXCIpKTtcbiAgICB9XG5cbiAgICBkaXNhYmxlQXR0cmlicygpIHtcbiAgICAgICAgc3VwZXIuZGlzYWJsZUF0dHJpYnMoKTtcbiAgICAgICAgdGhpcy5nbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5fYXR0cmliKFwiYUNvcm5lclwiKSk7XG4gICAgfVxuXG4gICAgc2V0RXh0cmFBdHRyaWJzSW5CdWZmZXIob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBvcGVyYXRpb24uZXh0cmFBdHRyaWJzRGF0YUJ5dGVPZmZzZXQgLyA0O1xuICAgICAgICBsZXQgZmxvYXRzID0gb3BlcmF0aW9uLnF1YWRzLmZsb2F0cztcblxuICAgICAgICBsZXQgbGVuZ3RoID0gb3BlcmF0aW9uLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRDb3JlID0gb3BlcmF0aW9uLmdldEVsZW1lbnRDb3JlKGkpO1xuXG4gICAgICAgICAgICAvLyBXZSBhcmUgc2V0dGluZyBhdHRyaWJ1dGVzIHN1Y2ggdGhhdCBpZiB0aGUgdmFsdWUgaXMgPCAwIG9yID4gMSwgYSBib3JkZXIgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgICAgICAgY29uc3QgZGR3ID0gdGhpcy5fd2lkdGggLyBlbGVtZW50Q29yZS53O1xuICAgICAgICAgICAgY29uc3QgZHcgPSBkZHcgLyAoMSAtIDIgKiBkZHcpO1xuICAgICAgICAgICAgY29uc3QgZGRoID0gdGhpcy5fd2lkdGggLyBlbGVtZW50Q29yZS5oO1xuICAgICAgICAgICAgY29uc3QgZGggPSBkZGggLyAoMSAtIDIgKiBkZGgpO1xuXG4gICAgICAgICAgICAvLyBTcGVjaWZ5IGFsbCBjb3JuZXIgcG9pbnRzLlxuICAgICAgICAgICAgZmxvYXRzW29mZnNldF0gPSAtZHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgMV0gPSAtZGg7XG5cbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAyXSA9IDEgKyBkdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAzXSA9IC1kaDtcblxuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDRdID0gMSArIGR3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDVdID0gMSArIGRoO1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNl0gPSAtZHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgN10gPSAxICsgZGg7XG5cbiAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYmVmb3JlRHJhdyhvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLl9hdHRyaWIoXCJhQ29ybmVyXCIpLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDgsIHRoaXMuZ2V0VmVydGV4QXR0cmliUG9pbnRlck9mZnNldChvcGVyYXRpb24pKTtcbiAgICB9XG5cbiAgICBnZXRFeHRyYUF0dHJpYkJ5dGVzUGVyVmVydGV4KCkge1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG5cbn1cblxuT3V0bGluZVNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFDb3JuZXI7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWMyIHZDb3JuZXI7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2b2lkIG1haW4odm9pZCl7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhVmVydGV4UG9zaXRpb24ueCAqIHByb2plY3Rpb24ueCAtIDEuMCwgYVZlcnRleFBvc2l0aW9uLnkgKiAtYWJzKHByb2plY3Rpb24ueSkgKyAxLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZDb3JuZXIgPSBhQ29ybmVyO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5PdXRsaW5lU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdmFyeWluZyB2ZWMyIHZDb3JuZXI7XG4gICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgdmVjMiBtID0gbWluKHZDb3JuZXIsIDEuMCAtIHZDb3JuZXIpO1xuICAgICAgICBmbG9hdCB2YWx1ZSA9IHN0ZXAoMC4wLCBtaW4obS54LCBtLnkpKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGNvbG9yLCB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogdkNvbG9yLCB2YWx1ZSk7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVyc3BlY3RpdmVTaGFkZXIgZXh0ZW5kcyBEZWZhdWx0U2hhZGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgICAgICBzdXBlcihjdHgpO1xuXG4gICAgICAgIHRoaXMuX2Z1ZGdlID0gMC4yO1xuICAgICAgICB0aGlzLl9yeCA9IDA7XG4gICAgICAgIHRoaXMuX3J5ID0gMDtcbiAgICAgICAgdGhpcy5feiA9IDEuMDtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG5cbiAgICAgICAgY29uc3QgdnIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB2ci5lbGVtZW50O1xuXG4gICAgICAgIGNvbnN0IHBpdm90WCA9IGVsZW1lbnQucGl2b3RYICogdnIudztcbiAgICAgICAgY29uc3QgcGl2b3RZID0gZWxlbWVudC5waXZvdFkgKiB2ci5oO1xuICAgICAgICBjb25zdCBjb29yZHMgPSB2ci5nZXRSZW5kZXJUZXh0dXJlQ29vcmRzKHBpdm90WCwgcGl2b3RZKTtcblxuICAgICAgICAvLyBDb3VudGVyIG5vcm1hbCByb3RhdGlvbi5cbiAgICAgICAgY29uc3QgcnogPSAtTWF0aC5hdGFuMih2ci5fcmVuZGVyQ29udGV4dC50YywgdnIuX3JlbmRlckNvbnRleHQudGEpO1xuXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5nbDtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybShcInBpdm90XCIsIG5ldyBGbG9hdDMyQXJyYXkoW2Nvb3Jkc1swXSwgY29vcmRzWzFdLCAwXSksIGdsLnVuaWZvcm0zZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicm90XCIsIG5ldyBGbG9hdDMyQXJyYXkoW3RoaXMuX3J4LCB0aGlzLl9yeSwgcnpdKSwgZ2wudW5pZm9ybTNmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJ6XCIsIHRoaXMuX3osIGdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJmdWRnZVwiLCB0aGlzLl9mdWRnZSwgZ2wudW5pZm9ybTFmKTtcbiAgICB9XG5cbiAgICBzZXQgZnVkZ2Uodikge1xuICAgICAgICB0aGlzLl9mdWRnZSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGZ1ZGdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVkZ2U7XG4gICAgfVxuXG4gICAgZ2V0IHJ4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcng7XG4gICAgfVxuXG4gICAgc2V0IHJ4KHYpIHtcbiAgICAgICAgdGhpcy5fcnggPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCByeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J5O1xuICAgIH1cblxuICAgIHNldCByeSh2KSB7XG4gICAgICAgIHRoaXMuX3J5ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgeigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XG4gICAgfVxuXG4gICAgc2V0IHoodikge1xuICAgICAgICB0aGlzLl96ID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3J4ID09PSAwICYmIHRoaXMuX3J5ID09PSAwICYmIHRoaXMuX3ogPT09IDApO1xuICAgIH1cblxufVxuXG5QZXJzcGVjdGl2ZVNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgIGF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XG4gICAgYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xuICAgIHVuaWZvcm0gdmVjMiBwcm9qZWN0aW9uO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG5cbiAgICB1bmlmb3JtIGZsb2F0IHo7XG4gICAgdW5pZm9ybSB2ZWMzIHBpdm90O1xuICAgIHVuaWZvcm0gdmVjMyByb3Q7XG4gICAgdmFyeWluZyB2ZWMzIHBvcztcblxuICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICAgIHBvcyA9IHZlYzMoYVZlcnRleFBvc2l0aW9uLnh5LCB6KTtcbiAgICAgICAgXG4gICAgICAgIHBvcyAtPSBwaXZvdDtcbiAgICAgICAgXG4gICAgICAgIC8vIFVuZG8gWFkgcm90YXRpb25cbiAgICAgICAgbWF0MiBpUm90WHkgPSBtYXQyKCBjb3Mocm90LnopLCBzaW4ocm90LnopLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC1zaW4ocm90LnopLCBjb3Mocm90LnopKTtcbiAgICAgICAgcG9zLnh5ID0gaVJvdFh5ICogcG9zLnh5O1xuICAgICAgICBcbiAgICAgICAgLy8gUGVyZm9ybSAzZCByb3RhdGlvbnNcbiAgICAgICAgZ2xfUG9zaXRpb24ueCA9IGNvcyhyb3QueCkgKiBwb3MueCAtIHNpbihyb3QueCkgKiBwb3MuejtcbiAgICAgICAgZ2xfUG9zaXRpb24ueSA9IHBvcy55O1xuICAgICAgICBnbF9Qb3NpdGlvbi56ID0gc2luKHJvdC54KSAqIHBvcy54ICsgY29zKHJvdC54KSAqIHBvcy56O1xuICAgICAgICBcbiAgICAgICAgcG9zLnggPSBnbF9Qb3NpdGlvbi54O1xuICAgICAgICBwb3MueSA9IGNvcyhyb3QueSkgKiBnbF9Qb3NpdGlvbi55IC0gc2luKHJvdC55KSAqIGdsX1Bvc2l0aW9uLno7XG4gICAgICAgIHBvcy56ID0gc2luKHJvdC55KSAqIGdsX1Bvc2l0aW9uLnkgKyBjb3Mocm90LnkpICogZ2xfUG9zaXRpb24uejtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZG8gWFkgcm90YXRpb25cbiAgICAgICAgaVJvdFh5WzBdWzFdID0gLWlSb3RYeVswXVsxXTtcbiAgICAgICAgaVJvdFh5WzFdWzBdID0gLWlSb3RYeVsxXVswXTtcbiAgICAgICAgcG9zLnh5ID0gaVJvdFh5ICogcG9zLnh5OyBcblxuICAgICAgICAvLyBVbmRvIHRyYW5zbGF0ZSB0byBwaXZvdCBwb3NpdGlvblxuICAgICAgICBwb3MueHl6ICs9IHBpdm90O1xuXG4gICAgICAgIHBvcyA9IHZlYzMocG9zLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIHBvcy55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCBwb3MueiAqIHByb2plY3Rpb24ueCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXAgY29vcmRzIHRvIGdsIGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICAgIC8vIFNldCB6IHRvIDAgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIHBlcmZvcm0gei1jbGlwcGluZ1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zLnh5LCAwLjAsIHopO1xuXG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIFxuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgfVxuYDtcblxuUGVyc3BlY3RpdmVTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblxuICAgIHVuaWZvcm0gdmVjMyByb3Q7XG4gICAgdW5pZm9ybSBmbG9hdCBmdWRnZTtcblxuICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICAgIHZlYzIgY29vcmRzID0gdlRleHR1cmVDb29yZDtcblxuICAgICAgICBjb29yZHMueHkgLT0gdmVjMigwLjUpO1xuICAgICAgICBjb29yZHMueSA9IGNvb3Jkcy55ICsgKHNpZ24ocm90WzBdKSAqIDAuNSAtIGNvb3Jkcy54KSAqIHNpbihyb3RbMF0pICogZnVkZ2UgKiBjb29yZHMueTtcbiAgICAgICAgY29vcmRzLnggPSBjb29yZHMueCArIChzaWduKHJvdFsxXSkgKiAwLjUgLSBjb29yZHMueSkgKiBzaW4ocm90WzFdKSAqIGZ1ZGdlICogY29vcmRzLng7XG4gICAgICAgIGNvb3Jkcy54eSArPSB2ZWMyKDAuNSk7XG5cbiAgICAgICAgaWYgKGNvb3Jkcy54IDwgMC4wIHx8IGNvb3Jkcy54ID4gMS4wIHx8IGNvb3Jkcy55IDwgMC4wIHx8IGNvb3Jkcy55ID4gMS4wKSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkcykgKiB2Q29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS1maWx0ZXJzL3RyZWUvbWFzdGVyL2ZpbHRlcnMvcGl4ZWxhdGUvc3JjXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBpeGVsYXRlU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgc3VwZXIoY3R4KTtcblxuICAgICAgICB0aGlzLl9zaXplID0gbmV3IEZsb2F0MzJBcnJheShbNCwgNF0pO1xuICAgIH1cblxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZVswXTtcbiAgICB9XG5cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIHRoaXMuX3NpemVbMF0gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZVsxXTtcbiAgICB9XG5cbiAgICBzZXQgeSh2KSB7XG4gICAgICAgIHRoaXMuX3NpemVbMV0gPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZVswXTtcbiAgICB9XG5cbiAgICBzZXQgc2l6ZSh2KSB7XG4gICAgICAgIHRoaXMuX3NpemVbMF0gPSB2O1xuICAgICAgICB0aGlzLl9zaXplWzFdID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICB1c2VEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLl9zaXplWzBdID09PSAwKSAmJiAodGhpcy5fc2l6ZVsxXSA9PT0gMCkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRXZWJHTEltcGwoKSB7XG4gICAgICAgIHJldHVybiBXZWJHTFBpeGVsYXRlU2hhZGVySW1wbDtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJzaXplXCIsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fc2l6ZSksIGdsLnVuaWZvcm0yZnYpO1xuICAgIH1cblxuICAgIGdldEV4dHJhQXR0cmliQnl0ZXNQZXJWZXJ0ZXgoKSB7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cblxuICAgIGVuYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIHN1cGVyLmVuYWJsZUF0dHJpYnMoKTtcbiAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLl9hdHRyaWIoXCJhVGV4dHVyZVJlc1wiKSk7XG4gICAgfVxuXG4gICAgZGlzYWJsZUF0dHJpYnMoKSB7XG4gICAgICAgIHN1cGVyLmRpc2FibGVBdHRyaWJzKCk7XG4gICAgICAgIHRoaXMuZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuX2F0dHJpYihcImFUZXh0dXJlUmVzXCIpKTtcbiAgICB9XG5cbiAgICBzZXRFeHRyYUF0dHJpYnNJbkJ1ZmZlcihvcGVyYXRpb24pIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IG9wZXJhdGlvbi5leHRyYUF0dHJpYnNEYXRhQnl0ZU9mZnNldCAvIDQ7XG4gICAgICAgIGxldCBmbG9hdHMgPSBvcGVyYXRpb24ucXVhZHMuZmxvYXRzO1xuXG4gICAgICAgIGxldCBsZW5ndGggPSBvcGVyYXRpb24ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdyA9IG9wZXJhdGlvbi5xdWFkcy5nZXRUZXh0dXJlV2lkdGgob3BlcmF0aW9uLmluZGV4ICsgaSk7XG4gICAgICAgICAgICBsZXQgaCA9IG9wZXJhdGlvbi5xdWFkcy5nZXRUZXh0dXJlSGVpZ2h0KG9wZXJhdGlvbi5pbmRleCArIGkpO1xuXG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0XSA9IHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgMV0gPSBoO1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDJdID0gdztcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyAzXSA9IGg7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgNF0gPSB3O1xuICAgICAgICAgICAgZmxvYXRzW29mZnNldCArIDVdID0gaDtcbiAgICAgICAgICAgIGZsb2F0c1tvZmZzZXQgKyA2XSA9IHc7XG4gICAgICAgICAgICBmbG9hdHNbb2Zmc2V0ICsgN10gPSBoO1xuXG4gICAgICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlZm9yZURyYXcob3BlcmF0aW9uKSB7XG4gICAgICAgIGxldCBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5fYXR0cmliKFwiYVRleHR1cmVSZXNcIiksIDIsIGdsLkZMT0FULCBmYWxzZSwgdGhpcy5nZXRFeHRyYUF0dHJpYkJ5dGVzUGVyVmVydGV4KCksIHRoaXMuZ2V0VmVydGV4QXR0cmliUG9pbnRlck9mZnNldChvcGVyYXRpb24pKTtcbiAgICB9XG59XG5cblBpeGVsYXRlU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVSZXM7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVSZXM7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIHZUZXh0dXJlUmVzID0gYVRleHR1cmVSZXM7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5QaXhlbGF0ZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZVJlcztcblxuICAgIHVuaWZvcm0gdmVjMiBzaXplO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgIFxuICAgIHZlYzIgbWFwQ29vcmQoIHZlYzIgY29vcmQgKVxuICAgIHtcbiAgICAgICAgY29vcmQgKj0gdlRleHR1cmVSZXMueHk7XG4gICAgICAgIHJldHVybiBjb29yZDtcbiAgICB9XG4gICAgXG4gICAgdmVjMiB1bm1hcENvb3JkKCB2ZWMyIGNvb3JkIClcbiAgICB7XG4gICAgICAgIGNvb3JkIC89IHZUZXh0dXJlUmVzLnh5O1xuICAgICAgICByZXR1cm4gY29vcmQ7XG4gICAgfVxuICAgIFxuICAgIHZlYzIgcGl4ZWxhdGUodmVjMiBjb29yZCwgdmVjMiBzaXplKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZsb29yKCBjb29yZCAvIHNpemUgKSAqIHNpemU7XG4gICAgfVxuICAgIFxuICAgIHZvaWQgbWFpbih2b2lkKVxuICAgIHtcbiAgICAgICAgdmVjMiBjb29yZCA9IG1hcENvb3JkKHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICBjb29yZCA9IHBpeGVsYXRlKGNvb3JkLCBzaXplKTtcbiAgICAgICAgY29vcmQgPSB1bm1hcENvb3JkKGNvb3JkKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjb29yZCkgKiB2Q29sb3I7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmFkaWFsRmlsdGVyU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gMDtcbiAgICAgICAgdGhpcy5fY3V0b2ZmID0gMTtcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzKHYpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcmFkaXVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xuICAgIH1cblxuICAgIHNldCBjdXRvZmYodikge1xuICAgICAgICB0aGlzLl9jdXRvZmYgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBjdXRvZmYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXRvZmY7XG4gICAgfVxuICAgIFxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXMgPT09IDA7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICAvLyBXZSBzdWJzdHJhY3QgaGFsZiBhIHBpeGVsIHRvIGdldCBhIGJldHRlciBjdXRvZmYgZWZmZWN0LlxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwicmFkaXVzXCIsIDIgKiAodGhpcy5fcmFkaXVzIC0gMC41KSAvIG9wZXJhdGlvbi5nZXRSZW5kZXJXaWR0aCgpLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJjdXRvZmZcIiwgMC41ICogb3BlcmF0aW9uLmdldFJlbmRlcldpZHRoKCkgLyB0aGlzLl9jdXRvZmYsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICB9XG5cbn1cblxuUmFkaWFsRmlsdGVyU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBhdHRyaWJ1dGUgdmVjNCBhQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWMyIHByb2plY3Rpb247XG4gICAgdmFyeWluZyB2ZWMyIHBvcztcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHZvaWQgbWFpbih2b2lkKXtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGFWZXJ0ZXhQb3NpdGlvbi54ICogcHJvamVjdGlvbi54IC0gMS4wLCBhVmVydGV4UG9zaXRpb24ueSAqIC1hYnMocHJvamVjdGlvbi55KSArIDEuMCwgMC4wLCAxLjApO1xuICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICBnbF9Qb3NpdGlvbi55ID0gLXNpZ24ocHJvamVjdGlvbi55KSAqIGdsX1Bvc2l0aW9uLnk7XG4gICAgICAgIHBvcyA9IGdsX1Bvc2l0aW9uLnh5O1xuICAgIH1cbmA7XG5cblJhZGlhbEZpbHRlclNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzIgcG9zO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgdW5pZm9ybSBmbG9hdCBjdXRvZmY7XG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbiAgICAgICAgZmxvYXQgZiA9IG1heCgwLjAsIG1pbigxLjAsIDEuMCAtIChsZW5ndGgocG9zKSAtIHJhZGl1cykgKiBjdXRvZmYpKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvciAqIGY7XG4gICAgfVxuYDtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi8uLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhZGlhbEdyYWRpZW50U2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fcGl2b3QgPSBbMCwgMF07XG4gICAgICAgIHRoaXMuX2ljID0gMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZElDID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKHRoaXMuX2ljKTtcbiAgICAgICAgdGhpcy5fb2MgPSAweDAwZmZmZmZmO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkT0MgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IodGhpcy5fb2MpO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSAwO1xuICAgIH1cblxuICAgIHNldCByYWRpdXNYKHYpIHtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSB2O1xuICAgIH1cblxuICAgIGdldCByYWRpdXNYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xuICAgIH1cblxuICAgIHNldCByYWRpdXNZKHYpIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzWSA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJhZGl1c1koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXNZO1xuICAgIH1cblxuICAgIHNldCByYWRpdXModikge1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBpbm5lckNvbG9yKGFyZ2IpIHtcbiAgICAgICAgdGhpcy5faWMgPSBhcmdiO1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkSUMgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoYXJnYik7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IGlubmVyQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pYztcbiAgICB9XG5cbiAgICBzZXQgb3V0ZXJDb2xvcihhcmdiKSB7XG4gICAgICAgIHRoaXMuX29jID0gYXJnYjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZE9DID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKGFyZ2IpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBjb2xvcihhcmdiKSB7XG4gICAgICAgIHRoaXMuaW5uZXJDb2xvciA9IGFyZ2I7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbm5lckNvbG9yO1xuICAgIH1cblxuICAgIGdldCBvdXRlckNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faWM7XG4gICAgfVxuXG4gICAgc2V0IHgoZikge1xuICAgICAgICB0aGlzLl94ID0gZjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgeShmKSB7XG4gICAgICAgIHRoaXMuX3kgPSBmO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCBwaXZvdCh2KSB7XG4gICAgICAgIGlmKEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90ID0gdjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90ID0gW3ZbMF0sIHZbMV0gfHwgdlswXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdCA9IFt2LCB2XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBwaXZvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WzBdO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFkoZikge1xuICAgICAgICB0aGlzLl9waXZvdFsxXSA9IGY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WzFdO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFgoZikge1xuICAgICAgICB0aGlzLl9waXZvdFswXSA9IGY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WzBdO1xuICAgIH1cblxuICAgIF9nZXROb3JtYWxpemVkQ29sb3IoY29sb3IpIHtcbiAgICAgICAgY29uc3QgY29sID0gU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQoY29sb3IpO1xuICAgICAgICBjb2xbMF0gKj0gY29sWzNdO1xuICAgICAgICBjb2xbMV0gKj0gY29sWzNdO1xuICAgICAgICBjb2xbMl0gKj0gY29sWzNdO1xuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShjb2wpO1xuICAgIH1cblxuICAgIHNldHVwVW5pZm9ybXMob3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyLnNldHVwVW5pZm9ybXMob3BlcmF0aW9uKTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSBvcGVyYXRpb24uc2hhZGVyT3duZXI7XG5cbiAgICAgICAgaWYodGhpcy5feCkge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3RbMF0gPSB0aGlzLl94IC8gb3duZXIudztcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLl95KSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdFsxXSA9IHRoaXMuX3kgLyBvd25lci5oO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5fcmFkaXVzID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSBvd25lci53ICogMC41O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnaW5uZXJDb2xvcicsIHRoaXMuX25vcm1hbGl6ZWRJQywgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnZmlsbCcsIFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKHRoaXMuX29jKVszXSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdvdXRlckNvbG9yJywgdGhpcy5fbm9ybWFsaXplZE9DLCB0aGlzLmdsLnVuaWZvcm00ZnYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdwaXZvdCcsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fcGl2b3QpLCAgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmVzb2x1dGlvbicsIG5ldyBGbG9hdDMyQXJyYXkoW293bmVyLl93LCBvd25lci5faF0pLCAgdGhpcy5nbC51bmlmb3JtMmZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnYWxwaGEnLCBvcGVyYXRpb24uZ2V0RWxlbWVudENvcmUoMCkucmVuZGVyQ29udGV4dC5hbHBoYSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyYWRpdXMnLCAgdGhpcy5fcmFkaXVzLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3JhZGl1c1knLCAgKHRoaXMuX3JhZGl1c1kgfHwgdGhpcy5fcmFkaXVzKSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgIH1cbn1cblxuUmFkaWFsR3JhZGllbnRTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgXG4gICAgI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG4gICAgXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgICB1bmlmb3JtIHZlYzIgcGl2b3Q7XG4gICAgdW5pZm9ybSB2ZWM0IGlubmVyQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWM0IG91dGVyQ29sb3I7XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXNZO1xuICAgIHVuaWZvcm0gZmxvYXQgYWxwaGE7XG4gICAgdW5pZm9ybSBmbG9hdCBmaWxsO1xuICAgIHVuaWZvcm0gZmxvYXQgYXNwZWN0UmF0aW87XG4gICAgXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMyIHBvaW50ID0gdlRleHR1cmVDb29yZC54eSAqIHJlc29sdXRpb247XG4gICAgICAgIHZlYzIgcHJvamVjdGlvbiA9IHZlYzIocGl2b3QueCAqIHJlc29sdXRpb24ueCwgcGl2b3QueSAqIHJlc29sdXRpb24ueSk7XG4gICAgICAgIGZsb2F0IGQgPSBsZW5ndGgoKHBvaW50IC0gcHJvamVjdGlvbikgLyB2ZWMyKHJhZGl1cyAqIDIuMCwgcmFkaXVzWSAqIDIuMCkpO1xuICAgICAgICB2ZWM0IGNvbG9yID0gbWl4KHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3IsIG91dGVyQ29sb3IgKiBhbHBoYSwgZmlsbCk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IG1peChpbm5lckNvbG9yICogYWxwaGEsIGNvbG9yLCBzbW9vdGhzdGVwKDAuMCwgMS4wLCBkKSk7XG4gICAgfVxuYDtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBEZWZhdWx0U2hhZGVyIGZyb20gXCIuL0RlZmF1bHRTaGFkZXIubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3VuZGVkUmVjdGFuZ2xlU2hhZGVyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fYmxlbmQgPSAwO1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSBbMSwgMSwgMSwgMV07XG4gICAgICAgIHRoaXMuX3N0cm9rZSA9IDA7XG4gICAgICAgIHRoaXMuX2ZjID0gMHgwMGZmZmZmZjtcbiAgICAgICAgdGhpcy5fZmlsbENvbG9yID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKDB4ZmZmZmZmZmYpO1xuICAgICAgICB0aGlzLl9zdHJva2VDb2xvciA9IHRoaXMuX2dldE5vcm1hbGl6ZWRDb2xvcigweDAwZmZmZmZmKTtcbiAgICB9XG5cbiAgICBzZXQgYmxlbmQocCkge1xuICAgICAgICB0aGlzLl9ibGVuZCA9IE1hdGgubWluKE1hdGgubWF4KHAsIDApLCAxKTtcbiAgICB9XG5cbiAgICBzZXQgcmFkaXVzKHYpIHtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgaWYodi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSBbdlswXSwgdlsxXSwgdlswXSwgdlsxXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHYubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaXVzID0gW3ZbMF0sIHZbMV0sIHZbMl0sIHRoaXMuX3JhZGl1c1szXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSBbdlswXSwgdlswXSwgdlswXSwgdlswXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yYWRpdXMgPSBbdiwgdiwgdiwgdl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcmFkaXVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xuICAgIH1cblxuICAgIHNldCB0b3BMZWZ0KG51bSkge1xuICAgICAgICB0aGlzLl9yYWRpdXNbMF0gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHRvcExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXNbMF07XG4gICAgfVxuXG4gICAgc2V0IHRvcFJpZ2h0KG51bSkge1xuICAgICAgICB0aGlzLl9yYWRpdXNbMV0gPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHRvcFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzWzFdO1xuICAgIH1cblxuICAgIHNldCBib3R0b21SaWdodChudW0pIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzWzJdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBib3R0b21SaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1c1syXTtcbiAgICB9XG5cbiAgICBzZXQgYm90dG9tTGVmdChudW0pIHtcbiAgICAgICAgdGhpcy5fcmFkaXVzWzNdID0gbnVtO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBib3R0b21MZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzWzRdO1xuICAgIH1cblxuICAgIHNldCBzdHJva2VDb2xvcihhcmdiKSB7XG4gICAgICAgIHRoaXMuX3NjID0gYXJnYjtcbiAgICAgICAgdGhpcy5fc3Ryb2tlQ29sb3IgPSB0aGlzLl9nZXROb3JtYWxpemVkQ29sb3IoYXJnYik7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHN0cm9rZUNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2M7XG4gICAgfVxuXG4gICAgc2V0IGZpbGxDb2xvcihhcmdiKSB7XG4gICAgICAgIHRoaXMuX2ZjID0gYXJnYjtcbiAgICAgICAgdGhpcy5fZmlsbENvbG9yID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKGFyZ2IpO1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBmaWxsQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYztcbiAgICB9XG5cbiAgICBzZXQgc3Ryb2tlKG51bSkge1xuICAgICAgICB0aGlzLl9zdHJva2UgPSBudW07XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgZ2V0IHN0cm9rZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZTtcbiAgICB9XG5cbiAgICBfZ2V0Tm9ybWFsaXplZENvbG9yKGNvbG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbCA9IFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKGNvbG9yKTtcbiAgICAgICAgY29sWzBdICo9IGNvbFszXTtcbiAgICAgICAgY29sWzFdICo9IGNvbFszXTtcbiAgICAgICAgY29sWzJdICo9IGNvbFszXTtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoY29sKTtcbiAgICB9XG5cbiAgICBzZXR1cFVuaWZvcm1zKG9wZXJhdGlvbikge1xuICAgICAgICBzdXBlci5zZXR1cFVuaWZvcm1zKG9wZXJhdGlvbik7XG4gICAgICAgIGNvbnN0IG93bmVyID0gb3BlcmF0aW9uLnNoYWRlck93bmVyO1xuICAgICAgICBjb25zdCByZW5kZXJQcmVjaXNpb24gPSB0aGlzLmN0eC5zdGFnZS5nZXRSZW5kZXJQcmVjaXNpb24oKTtcbiAgICAgICAgY29uc3QgX3JhZGl1cyA9IHRoaXMuX3JhZGl1cy5tYXAoKHIpID0+IChyICsgMC41KSAqIHJlbmRlclByZWNpc2lvbilcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgncmFkaXVzJywgbmV3IEZsb2F0MzJBcnJheShfcmFkaXVzKSwgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnYWxwaGEnLCBvcGVyYXRpb24uZ2V0RWxlbWVudENvcmUoMCkucmVuZGVyQ29udGV4dC5hbHBoYSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdibGVuZCcsIHRoaXMuX2JsZW5kLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3N0cm9rZUNvbG9yJywgdGhpcy5fc3Ryb2tlQ29sb3IsIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2ZpbGxDb2xvcicsIHRoaXMuX2ZpbGxDb2xvciwgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnc3Ryb2tlJywgIHRoaXMuX3N0cm9rZSAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyZXNvbHV0aW9uJywgbmV3IEZsb2F0MzJBcnJheShbb3duZXIuX3cgKiByZW5kZXJQcmVjaXNpb24sIG93bmVyLl9oICogcmVuZGVyUHJlY2lzaW9uXSksIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgfVxufVxuXG5Sb3VuZGVkUmVjdGFuZ2xlU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcblxuICAgIGF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzIgcHJvamVjdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4gICAgdm9pZCBtYWluKHZvaWQpe1xuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVZlcnRleFBvc2l0aW9uLnggKiBwcm9qZWN0aW9uLnggLSAxLjAsIGFWZXJ0ZXhQb3NpdGlvbi55ICogLWFicyhwcm9qZWN0aW9uLnkpICsgMS4wLCAwLjAsIDEuMCk7XG4gICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgIGdsX1Bvc2l0aW9uLnkgPSAtc2lnbihwcm9qZWN0aW9uLnkpICogZ2xfUG9zaXRpb24ueTtcbiAgICB9XG5gO1xuXG5Sb3VuZGVkUmVjdGFuZ2xlU2hhZGVyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuXG4gICAgI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgdW5pZm9ybSB2ZWM0IHJhZGl1cztcbiAgICB1bmlmb3JtIGZsb2F0IHN0cm9rZTtcbiAgICB1bmlmb3JtIHZlYzQgc3Ryb2tlQ29sb3I7XG4gICAgdW5pZm9ybSB2ZWM0IGZpbGxDb2xvcjtcbiAgICB1bmlmb3JtIGZsb2F0IGFscGhhO1xuICAgIHVuaWZvcm0gZmxvYXQgZmlsbDtcbiAgICB1bmlmb3JtIGZsb2F0IGJsZW5kO1xuICAgIFxuICAgIGZsb2F0IGJveERpc3QodmVjMiBwLCB2ZWMyIHNpemUsIGZsb2F0IHJhZGl1cyl7XG4gICAgICAgIHNpemUgLT0gdmVjMihyYWRpdXMpO1xuICAgICAgICB2ZWMyIGQgPSBhYnMocCkgLSBzaXplO1xuICAgICAgICByZXR1cm4gbWluKG1heChkLngsIGQueSksIDAuMCkgKyBsZW5ndGgobWF4KGQsIDAuMCkpIC0gcmFkaXVzO1xuICAgIH1cbiAgICBcbiAgICBmbG9hdCBmaWxsTWFzayhmbG9hdCBkaXN0KXtcbiAgICAgICAgcmV0dXJuIGNsYW1wKC1kaXN0LCAwLjAsIDEuMCk7XG4gICAgfVxuICAgIFxuICAgIGZsb2F0IGlubmVyQm9yZGVyTWFzayhmbG9hdCBkaXN0LCBmbG9hdCB3aWR0aCl7XG4gICAgICAgIGZsb2F0IGFscGhhMSA9IGNsYW1wKGRpc3QgKyB3aWR0aCwgMC4wLCAxLjApO1xuICAgICAgICBmbG9hdCBhbHBoYTIgPSBjbGFtcChkaXN0LCAwLjAsIDEuMCk7XG4gICAgICAgIHJldHVybiBhbHBoYTEgLSBhbHBoYTI7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMyIGhhbGZSZXMgPSAwLjUgKiByZXNvbHV0aW9uLnh5O1xuICAgICAgICBmbG9hdCByID0gMC4wO1xuICAgICAgICBpZiAodlRleHR1cmVDb29yZC54IDwgMC41ICYmIHZUZXh0dXJlQ29vcmQueSA8IDAuNSkge1xuICAgICAgICAgICAgciA9IHJhZGl1c1swXTtcbiAgICAgICAgfSBlbHNlIGlmICh2VGV4dHVyZUNvb3JkLnggPj0gMC41ICYmIHZUZXh0dXJlQ29vcmQueSA8IDAuNSkge1xuICAgICAgICAgICAgciA9IHJhZGl1c1sxXTtcbiAgICAgICAgfSBlbHNlIGlmICh2VGV4dHVyZUNvb3JkLnggPj0gMC41ICYmIHZUZXh0dXJlQ29vcmQueSA+PSAwLjUpIHtcbiAgICAgICAgICAgIHIgPSByYWRpdXNbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByID0gcmFkaXVzWzNdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmbG9hdCBiID0gYm94RGlzdCh2VGV4dHVyZUNvb3JkLnh5ICogcmVzb2x1dGlvbiAtIGhhbGZSZXMsIGhhbGZSZXMgLSAwLjAwNSwgcik7XG4gICAgICAgIHZlYzQgdGV4ID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcbiAgICAgICAgdmVjNCBibGVuZCA9IG1peCh2ZWM0KDEuMCkgKiBhbHBoYSwgdGV4LCBibGVuZCk7ICAgICBcbiAgICAgICAgdmVjNCBsYXllcjEgPSBtaXgodmVjNCgwLjApLCB0ZXggKiBmaWxsQ29sb3IsIGZpbGxNYXNrKGIpKTtcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWl4KGxheWVyMSwgYmxlbmQgKiBzdHJva2VDb2xvciwgaW5uZXJCb3JkZXJNYXNrKGIsIHN0cm9rZSkpO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuaW1wb3J0IFN0YWdlVXRpbHMgZnJvbSAnLi4vLi4vLi4vdHJlZS9TdGFnZVV0aWxzLm1qcydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3Bpbm5lclNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHN1cGVyKGN0eCk7XG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IDEwMDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSA1MDtcbiAgICAgICAgdGhpcy5fcGVyaW9kID0gMTtcbiAgICAgICAgdGhpcy5fYW5nbGUgPSAwLjU7XG4gICAgICAgIHRoaXMuX3Ntb290aCA9IDAuMDA1O1xuICAgICAgICB0aGlzLl9jb2xvciA9IDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDB4ZmYwMDAwMDA7XG4gICAgICAgIHRoaXMuX3RpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cblxuICAgIHNldCByYWRpdXModikge1xuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIHNldCB3aWR0aCh2KSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgcGVyaW9kKHYpIHtcbiAgICAgICAgdGhpcy5fcGVyaW9kID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgYW5nbGUodikge1xuICAgICAgICB0aGlzLl9hbmdsZSA9IHZcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgc21vb3RoKHYpIHtcbiAgICAgICAgdGhpcy5fc21vb3RoID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBzZXQgY29sb3Iodikge1xuICAgICAgICB0aGlzLl9jb2xvciA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0IGJhY2tncm91bmRDb2xvcih2KSB7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHY7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBjb25zdCBvd25lciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lclxuXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJpVGltZVwiLCBEYXRlLm5vdygpIC0gdGhpcy5fdGltZSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuXG4gICAgICAgIGNvbnN0IHJlbmRlclByZWNpc2lvbiA9IHRoaXMuY3R4LnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyYWRpdXMnLCB0aGlzLl9yYWRpdXMgKiByZW5kZXJQcmVjaXNpb24sIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnd2lkdGgnLCB0aGlzLl93aWR0aCAqIHJlbmRlclByZWNpc2lvbiwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdwZXJpb2QnLCB0aGlzLl9wZXJpb2QsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnYW5nbGUnLCB0aGlzLl9hbmdsZSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdzbW9vdGgnLCB0aGlzLl9zbW9vdGgsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnY29sb3InLCBuZXcgRmxvYXQzMkFycmF5KFN0YWdlVXRpbHMuZ2V0UmdiYUNvbXBvbmVudHNOb3JtYWxpemVkKHRoaXMuX2NvbG9yKSksIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2JhY2tncm91bmRDb2xvcicsIG5ldyBGbG9hdDMyQXJyYXkoU3RhZ2VVdGlscy5nZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQodGhpcy5fYmFja2dyb3VuZENvbG9yKSksIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Jlc29sdXRpb24nLCBuZXcgRmxvYXQzMkFycmF5KFtvd25lci5fdyAqIHJlbmRlclByZWNpc2lvbiwgb3duZXIuX2ggKiByZW5kZXJQcmVjaXNpb25dKSwgdGhpcy5nbC51bmlmb3JtMmZ2KVxuXG4gICAgICAgIHRoaXMucmVkcmF3KClcbiAgICB9XG59XG5cblNwaW5uZXJTaGFkZXIudmVydGV4U2hhZGVyU291cmNlID0gRGVmYXVsdFNoYWRlci52ZXJ0ZXhTaGFkZXJTb3VyY2U7XG5cblNwaW5uZXJTaGFkZXIuZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBgXG4gICAgI2lmZGVmIEdMX0VTXG4gICAgIyBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcbiAgICAjIGVsc2VcbiAgICBwcmVjaXNpb24gbG93cCBmbG9hdDtcbiAgICAjIGVuZGlmXG4gICAgI2VuZGlmXG4gICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdmFyeWluZyB2ZWM0IHZDb2xvcjtcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblxuICAgIHVuaWZvcm0gZmxvYXQgaVRpbWU7XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgdW5pZm9ybSBmbG9hdCB3aWR0aDtcbiAgICB1bmlmb3JtIGZsb2F0IHBlcmlvZDtcbiAgICB1bmlmb3JtIGZsb2F0IGFuZ2xlO1xuICAgIHVuaWZvcm0gZmxvYXQgc21vb3RoO1xuICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xuXG4gICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xuICAgIHVuaWZvcm0gdmVjNCBiYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBmbG9hdCByYXRpbyA9IHJlc29sdXRpb24ueSAvIHJlc29sdXRpb24ueDtcblxuICAgIHZlYzIgdHJhbnNwb3NlX3Bvcyh2ZWMyIHBvcykge1xuICAgICAgICBpZiAocmF0aW8gPCAxLikge1xuICAgICAgICAgICAgZmxvYXQgZGlmZiA9IDAuNSAtIHBvcy54O1xuICAgICAgICAgICAgcG9zLnggPSAwLjUgLSBkaWZmIC8gcmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbG9hdCBkaWZmID0gMC41IC0gcG9zLnk7XG4gICAgICAgICAgICBwb3MueSA9IDAuNSAtIGRpZmYgKiByYXRpbztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIGZsb2F0IGdldF9hbmdsZSh2ZWMyIHBvcykge1xuICAgICAgICBwb3MgPSB0cmFuc3Bvc2VfcG9zKHBvcyk7XG4gICAgICAgIGZsb2F0IGEgPSBhdGFuKHBvcy55IC0gMC41LCBwb3MueCAtIDAuNSk7XG4gICAgICAgIGEgPSAoMS4wK2EvMy4xNDE1OSkvMi4wO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZmxvYXQgZGlzdCh2ZWMyIHBvczEsIHZlYzIgcG9zMikge1xuICAgICAgICBwb3MxID0gdHJhbnNwb3NlX3Bvcyhwb3MxKTtcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlKHBvczEsIHBvczIpO1xuICAgIH1cblxuICAgIHZvaWQgbWFpbigpXG4gICAge1xuICAgICAgICB2ZWMyIGZyYWdDb29yZCA9IHZUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZlYzQgZnJhZ0NvbG9yID0gdkNvbG9yO1xuICAgICAgICBcbiAgICAgICAgdmVjMiBzdCA9IHZUZXh0dXJlQ29vcmQ7XG4gICAgICAgIGZsb2F0IHBjdCA9IGRpc3Qoc3QsIHZlYzIoMC41KSk7XG5cbiAgICAgICAgZmxvYXQgYSA9IGdldF9hbmdsZShzdCk7XG4gICAgICAgIGZsb2F0IHQgPSBpVGltZSAvIDEwMDAuMCAvIHBlcmlvZDtcblxuICAgICAgICBmbG9hdCBpbm5lciA9IG1heCgocmFkaXVzIC0gd2lkdGgpIC8gcmVzb2x1dGlvbi54LCAocmFkaXVzIC0gd2lkdGgpIC8gcmVzb2x1dGlvbi55KTtcbiAgICAgICAgZmxvYXQgb3V0ZXIgPSBtYXgocmFkaXVzIC8gcmVzb2x1dGlvbi54LCByYWRpdXMgLyByZXNvbHV0aW9uLnkpO1xuXG4gICAgICAgIGZsb2F0IHgxID0gbW9kKHQsIDEuMCk7XG4gICAgICAgIGZsb2F0IHgyID0gbW9kKHQgKyBhbmdsZSwgMS4wKTtcblxuICAgICAgICBpZiAoeDEgPCB4Mikge1xuICAgICAgICAgICAgaWYgKGEgPiB4MSAmJiBhIDwgeDIpIHtcbiAgICAgICAgICAgICAgICBmbG9hdCB2YWwgPSAoMS4wIC0gKHgyIC0gYSkgLyBhbmdsZSkgKiBzbW9vdGhzdGVwKDAuMCwgMy4gKiBzbW9vdGgsICh4MiAtIGEpKTtcbiAgICAgICAgICAgICAgICBmcmFnQ29sb3IgPSBtaXgoYmFja2dyb3VuZENvbG9yLCBjb2xvciwgdmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGEgPCB4Mikge1xuICAgICAgICAgICAgICAgIGZsb2F0IHZhbCA9ICgxLjAgLSAoeDIgLSBhKSAvIGFuZ2xlKSAqIHNtb290aHN0ZXAoMC4wLCAzLiAqIHNtb290aCwgKHgyIC0gYSkpO1xuICAgICAgICAgICAgICAgIGZyYWdDb2xvciA9IG1peChiYWNrZ3JvdW5kQ29sb3IsIGNvbG9yLCB2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhID4geDEpIHtcbiAgICAgICAgICAgICAgICBmbG9hdCB2YWwgPSAoMS4wIC0gKDEuMCArIHgyIC0gYSkgLyBhbmdsZSkgKiBzbW9vdGhzdGVwKDAuMCwgMy4gKiBzbW9vdGgsICgxLjAgKyB4MiAtIGEpKTtcbiAgICAgICAgICAgICAgICBmcmFnQ29sb3IgPSBtaXgoYmFja2dyb3VuZENvbG9yLCBjb2xvciwgdmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZnJhZ0NvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZmxvYXQgcyA9IHNtb290aHN0ZXAoaW5uZXIsIGlubmVyICsgc21vb3RoICsgMC4wMDAwMSwgcGN0KSAqICgxLjAgLSBzbW9vdGhzdGVwKG91dGVyLCBvdXRlciArIHNtb290aCArIDAuMDAwMDEsIHBjdCkpO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGZyYWdDb29yZCkgKiB2Q29sb3IgKiAoMS4gLSBzICogZnJhZ0NvbG9yLmEpICsgZnJhZ0NvbG9yICogcztcbiAgICB9XG5gO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IERlZmF1bHRTaGFkZXIgZnJvbSBcIi4vRGVmYXVsdFNoYWRlci5tanNcIjtcbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi8uLi8uLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNwaW5uZXJTaGFkZXIyIGV4dGVuZHMgRGVmYXVsdFNoYWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5fcGVyaW9kID0gMTtcbiAgICAgICAgdGhpcy5fc3Ryb2tlID0gMDtcbiAgICAgICAgdGhpcy5fc2hvd0RvdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2Nsb2Nrd2lzZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2JjID0gMHhmZjAwMDAwMDtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZEJDID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKHRoaXMuX2JjKTtcbiAgICAgICAgdGhpcy5fYyA9IDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRDID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKHRoaXMuX2MpO1xuICAgIH1cblxuICAgIHNldCByYWRpdXModikge1xuICAgICAgICBpZih2ID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2O1xuICAgIH1cblxuICAgIHNldCBzdHJva2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlID0gTWF0aC5hYnModmFsdWUpO1xuICAgIH1cblxuICAgIGdldCBzdHJva2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yKGFyZ2IpIHtcbiAgICAgICAgdGhpcy5fYyA9IGFyZ2I7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRDID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKGFyZ2IpO1xuICAgIH1cblxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2M7XG4gICAgfVxuXG4gICAgc2V0IGJhY2tncm91bmRDb2xvcihhcmdiKSB7XG4gICAgICAgIHRoaXMuX2JjID0gYXJnYjtcbiAgICAgICAgdGhpcy5fbm9ybWFsaXplZEJDID0gdGhpcy5fZ2V0Tm9ybWFsaXplZENvbG9yKGFyZ2IpO1xuICAgIH1cblxuICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zYztcbiAgICB9XG5cbiAgICBzZXQgc2hvd0RvdChib29sKSB7XG4gICAgICAgIHRoaXMuX3Nob3dEb3QgPSBib29sO1xuICAgIH1cblxuICAgIGdldCBzaG93RG90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd0RvdDtcbiAgICB9XG5cbiAgICBzZXQgY2xvY2t3aXNlKGJvb2wpIHtcbiAgICAgICAgdGhpcy5fY2xvY2t3aXNlID0gYm9vbDtcbiAgICB9XG5cbiAgICBnZXQgY2xvY2t3aXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvY2t3aXNlO1xuICAgIH1cblxuICAgIHNldCBwZXJpb2Qodikge1xuICAgICAgICB0aGlzLl9wZXJpb2QgPSB2O1xuICAgIH1cblxuICAgIGdldCBwZXJpb2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJpb2Q7XG4gICAgfVxuXG4gICAgX2dldE5vcm1hbGl6ZWRDb2xvcihjb2xvcikge1xuICAgICAgICBjb25zdCBjb2wgPSBTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZChjb2xvcik7XG4gICAgICAgIGNvbFswXSAqPSBjb2xbM107XG4gICAgICAgIGNvbFsxXSAqPSBjb2xbM107XG4gICAgICAgIGNvbFsyXSAqPSBjb2xbM107XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGNvbCk7XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuICAgICAgICBjb25zdCBvd25lciA9IG9wZXJhdGlvbi5zaGFkZXJPd25lcjtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gdGhpcy5fcmFkaXVzIHx8IChvd25lci5fdyAvIDIpO1xuXG4gICAgICAgIGlmKHRoaXMuX3N0cm9rZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlID0gcmFkaXVzICogMC4zMztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3Jlc29sdXRpb24nLCBuZXcgRmxvYXQzMkFycmF5KFtvd25lci5fdywgb3duZXIuX2hdKSwgIHRoaXMuZ2wudW5pZm9ybTJmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2NvbG9yJywgdGhpcy5fbm9ybWFsaXplZEMsIHRoaXMuZ2wudW5pZm9ybTRmdik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2JhY2tncm91bmRDb2xvcicsIHRoaXMuX25vcm1hbGl6ZWRCQywgdGhpcy5nbC51bmlmb3JtNGZ2KTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnc3Ryb2tlJywgIHRoaXMuX3N0cm9rZSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdyYWRpdXMnLCAgcmFkaXVzLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ2RpcmVjdGlvbicsICB0aGlzLl9jbG9ja3dpc2UgPyAtMSA6IDEsIHRoaXMuZ2wudW5pZm9ybTFmKTtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSgnc2hvd0RvdCcsICEhdGhpcy5fc2hvd0RvdCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCd0aW1lJywgRGF0ZS5ub3coKSAtIFNwaW5uZXJTaGFkZXIyLnNwaW5TeW5jLCB0aGlzLmdsLnVuaWZvcm0xZik7XG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oJ3BlcmlvZCcsIHRoaXMuX3BlcmlvZCwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdhbHBoYScsIG9wZXJhdGlvbi5nZXRFbGVtZW50Q29yZSgwKS5yZW5kZXJDb250ZXh0LmFscGhhLCB0aGlzLmdsLnVuaWZvcm0xZik7XG5cbiAgICAgICAgaWYodGhpcy5fc2MgIT09IHRoaXMuX2JjIHx8IHRoaXMuX3N0cm9rZSAhPT0gcmFkaXVzICogMC41KSB7XG4gICAgICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5TcGlubmVyU2hhZGVyMi5zcGluU3luYyA9IERhdGUubm93KCk7XG5cblNwaW5uZXJTaGFkZXIyLmZyYWdtZW50U2hhZGVyU291cmNlID0gYFxuICAgICNpZmRlZiBHTF9FU1xuICAgICMgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcbiAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgIyBlbHNlXG4gICAgcHJlY2lzaW9uIGxvd3AgZmxvYXQ7XG4gICAgIyBlbmRpZlxuICAgICNlbmRpZlxuICAgIFxuICAgICNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1OVxuICAgIFxuICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIHZhcnlpbmcgdmVjNCB2Q29sb3I7XG4gICAgXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XG4gICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xuICAgIHVuaWZvcm0gdmVjNCBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgdW5pZm9ybSBmbG9hdCBkaXJlY3Rpb247XG4gICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xuICAgIHVuaWZvcm0gZmxvYXQgc3Ryb2tlO1xuICAgIHVuaWZvcm0gZmxvYXQgc2hvd0RvdDtcbiAgICB1bmlmb3JtIGZsb2F0IHBlcmlvZDtcbiAgICB1bmlmb3JtIGZsb2F0IGFscGhhO1xuICAgIFxuICAgIGZsb2F0IGNpcmNsZURpc3QodmVjMiBwLCBmbG9hdCByYWRpdXMpe1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHApIC0gcmFkaXVzO1xuICAgIH1cbiAgICBcbiAgICBmbG9hdCBmaWxsTWFzayhmbG9hdCBkaXN0KXtcbiAgICAgICAgcmV0dXJuIGNsYW1wKC1kaXN0LCAwLjAsIDEuMCk7XG4gICAgfVxuICAgIFxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgdmVjMiBoYWxmUmVzID0gMC41ICogcmVzb2x1dGlvbi54eTtcbiAgICAgICAgdmVjMiBjZW50ZXIgPSB2VGV4dHVyZUNvb3JkLnh5ICogcmVzb2x1dGlvbiAtIGhhbGZSZXM7XG4gICAgICAgIFxuICAgICAgICBmbG9hdCBjID0gbWF4KC1jaXJjbGVEaXN0KGNlbnRlciwgcmFkaXVzIC0gc3Ryb2tlKSwgY2lyY2xlRGlzdChjZW50ZXIsIHJhZGl1cykpO1xuICAgICAgICBmbG9hdCByb3QgPSAtKHRpbWUgLyAxMDAwLjAgLyBwZXJpb2QpICogNi4wICogZGlyZWN0aW9uO1xuICAgICAgICBjZW50ZXIgKj0gbWF0Mihjb3Mocm90KSwgc2luKHJvdCksIC1zaW4ocm90KSwgY29zKHJvdCkpO1xuICAgICAgICBcbiAgICAgICAgZmxvYXQgYSA9IGRpcmVjdGlvbiAqIGF0YW4oY2VudGVyLngsIGNlbnRlci55KSAqIFBJICogMC4wNSArIDAuNDU7XG4gICAgICAgIFxuICAgICAgICBmbG9hdCBzdHJva2VSYWQgPSBzdHJva2UgKiAwLjU7XG4gICAgICAgIGEgPSBtaXgoYSwgbWF4KGEsIGZpbGxNYXNrKGNpcmNsZURpc3QodmVjMihjZW50ZXIueCwgY2VudGVyLnkgKyAocmFkaXVzIC0gc3Ryb2tlUmFkKSksIHN0cm9rZVJhZCkpKSwgc2hvd0RvdCk7XG4gICAgICAgIHZlYzQgYmFzZSA9IG1peCh2ZWM0KDAuMCksIGJhY2tncm91bmRDb2xvciAqIGFscGhhLCBmaWxsTWFzayhjKSk7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IG1peChiYXNlLCBjb2xvciAqIGFscGhhLCBmaWxsTWFzayhjKSAqIGEpO1xuICAgIH1cbmA7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRGVmYXVsdFNoYWRlciBmcm9tIFwiLi9EZWZhdWx0U2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaWduZXR0ZVNoYWRlciBleHRlbmRzIERlZmF1bHRTaGFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuX21hZ25pdHVkZSA9IDEuMztcbiAgICAgICAgdGhpcy5faW50ZW5zaXR5ID0gMC43O1xuICAgICAgICB0aGlzLl9waXZvdCA9IFswLjUsIDAuNV07XG4gICAgfVxuXG4gICAgc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIuc2V0dXBVbmlmb3JtcyhvcGVyYXRpb24pO1xuXG4gICAgICAgIHRoaXMuX3NldFVuaWZvcm0oXCJtYWduaXR1ZGVcIiwgdGhpcy5fbWFnbml0dWRlICwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKFwiaW50ZW5zaXR5XCIsIHRoaXMuX2ludGVuc2l0eSwgdGhpcy5nbC51bmlmb3JtMWYpO1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKCdwaXZvdCcsIG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fcGl2b3QpLCB0aGlzLmdsLnVuaWZvcm0yZnYpO1xuICAgICAgICB0aGlzLnJlZHJhdygpXG4gICAgfVxuXG4gICAgc2V0IHBpdm90KHYpIHtcbiAgICAgICAgaWYoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3QgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3QgPSBbdiwgdl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RbMF07XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WCh2KSB7XG4gICAgICAgIHRoaXMuX3Bpdm90WzBdID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RbMV07XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WSh2KSB7XG4gICAgICAgIHRoaXMuX3Bpdm90WzFdID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG5cbiAgICBnZXQgaW50ZW5zaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW50ZW5zaXR5O1xuICAgIH1cblxuICAgIHNldCBpbnRlbnNpdHkodikge1xuICAgICAgICB0aGlzLl9pbnRlbnNpdHkgPSB2O1xuICAgICAgICB0aGlzLnJlZHJhdygpO1xuICAgIH1cblxuICAgIGdldCBtYWduaXR1ZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYWduaXR1ZGU7XG5cbiAgICB9XG5cbiAgICBzZXQgbWFnbml0dWRlKHYpIHtcbiAgICAgICAgdGhpcy5fbWFnbml0dWRlID0gdjtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICB9XG59XG5cblZpZ25ldHRlU2hhZGVyLnZlcnRleFNoYWRlclNvdXJjZSA9IERlZmF1bHRTaGFkZXIudmVydGV4U2hhZGVyU291cmNlO1xuXG5WaWduZXR0ZVNoYWRlci5mcmFnbWVudFNoYWRlclNvdXJjZSA9IGBcbiAgICAjaWZkZWYgR0xfRVNcbiAgICAjIGlmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXG4gICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xuICAgICMgZWxzZVxuICAgIHByZWNpc2lvbiBsb3dwIGZsb2F0O1xuICAgICMgZW5kaWZcbiAgICAjZW5kaWZcbiAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICB2YXJ5aW5nIHZlYzQgdkNvbG9yO1xuICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXG4gICAgdW5pZm9ybSBmbG9hdCBtYWduaXR1ZGU7XG4gICAgdW5pZm9ybSBmbG9hdCBpbnRlbnNpdHk7XG4gICAgdW5pZm9ybSB2ZWMyIHBpdm90O1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICB2ZWMyIHV2ID0gdlRleHR1cmVDb29yZC54eSAtIHBpdm90ICsgdmVjMigwLjUpO1xuICAgICAgICB1di54ID0gY2xhbXAodXYueCwgMC4wLCAxLjApO1xuICAgICAgICB1di55ID0gY2xhbXAodXYueSwgMC4wLCAxLjApO1xuICAgXG4gICAgICAgIHV2ICo9ICAxLjAwIC0gdXYueXg7XG4gICAgICAgIGZsb2F0IHZpZyA9IHV2LnggKiB1di55ICogMjUuMCAqIGludGVuc2l0eTtcbiAgICAgICAgdmlnID0gcG93KHZpZywgMC40NSAqIG1hZ25pdHVkZSk7XG4gICAgICAgIHZlYzQgZnJhZ0NvbG9yID0gdmVjNCh2aWcpICogdkNvbG9yO1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpICogZnJhZ0NvbG9yO1xuXG4gICAgfVxuYFxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSHRtbFRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcbiAgICAgICAgdGhpcy5faHRtbEVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gMTtcbiAgICB9XG5cbiAgICBzZXQgaHRtbEVsZW1lbnQodikge1xuICAgICAgICB0aGlzLl9odG1sRWxlbWVudCA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgaHRtbEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9odG1sRWxlbWVudDtcbiAgICB9XG5cbiAgICBzZXQgc2NhbGUodikge1xuICAgICAgICB0aGlzLl9zY2FsZSA9IHY7XG4gICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgc2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICB9XG5cbiAgICBzZXQgaHRtbCh2KSB7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgdGhpcy5odG1sRWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGQuaW5uZXJIVE1MID0gXCI8ZGl2PlwiICsgdiArIFwiPC9kaXY+XCI7XG4gICAgICAgICAgICB0aGlzLmh0bWxFbGVtZW50ID0gZC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBodG1sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faHRtbEVsZW1lbnQuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIF9nZXRJc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5odG1sRWxlbWVudDtcbiAgICB9XG5cbiAgICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZSArIFwiOlwiICsgdGhpcy5faHRtbEVsZW1lbnQuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIGNvbnN0IGh0bWxFbGVtZW50ID0gdGhpcy5faHRtbEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fc2NhbGU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3cuaHRtbDJjYW52YXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKFwiUGxlYXNlIGluY2x1ZGUgaHRtbDJjYW52YXMgKGh0dHBzOi8vaHRtbDJjYW52YXMuaGVydHplbi5jb20vKVwiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBIdG1sVGV4dHVyZS5nZXRQcmVsb2FkQXJlYSgpO1xuICAgICAgICAgICAgYXJlYS5hcHBlbmRDaGlsZChodG1sRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGh0bWwyY2FudmFzKGh0bWxFbGVtZW50LCB7YmFja2dyb3VuZENvbG9yOiBudWxsLCBzY2FsZTogc2NhbGV9KS50aGVuKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgICAgIGFyZWEucmVtb3ZlQ2hpbGQoaHRtbEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoXCJDYW52YXMgaGVpZ2h0IGlzIDBcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYihudWxsLCB7c291cmNlOiBjYW52YXMsIHdpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodH0pO1xuICAgICAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10nLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFByZWxvYWRBcmVhKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ByZWxvYWRBcmVhKSB7XG4gICAgICAgICAgICAvLyBQcmVsb2FkIGFyZWEgbXVzdCBiZSBpbmNsdWRlZCBpbiBkb2N1bWVudCBib2R5IGFuZCBtdXN0IGJlIHZpc2libGUgdG8gdHJpZ2dlciBodG1sIGVsZW1lbnQgcmVuZGVyaW5nLlxuICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmVsb2FkQXJlYS5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgYSBzaGFkb3cgRE9NIGlmIHBvc3NpYmxlIHRvIHByZXZlbnQgc3R5bGluZyBmcm9tIGludGVyZmVyaW5nLlxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhLmF0dGFjaFNoYWRvdyh7bW9kZTogJ2Nsb3NlZCd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5fcHJlbG9hZEFyZWEuc3R5bGUudG9wID0gJzEwMHZoJztcbiAgICAgICAgICAgIHRoaXMuX3ByZWxvYWRBcmVhLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3ByZWxvYWRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJlbG9hZEFyZWE7XG4gICAgfVxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLl9zcmMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2hhc0FscGhhID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IHNyYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NyYztcbiAgICB9XG5cbiAgICBzZXQgc3JjKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NyYyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc3JjID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoYXNBbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0FscGhhO1xuICAgIH1cblxuICAgIHNldCBoYXNBbHBoYSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNBbHBoYSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faGFzQWxwaGEgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldElzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3NyYztcbiAgICB9XG5cbiAgICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcmM7XG4gICAgfVxuXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgbGV0IHNyYyA9IHRoaXMuX3NyYztcbiAgICAgICAgbGV0IGhhc0FscGhhID0gdGhpcy5faGFzQWxwaGE7XG4gICAgICAgIGlmICh0aGlzLnN0YWdlLmdldE9wdGlvbignc3JjQmFzZVBhdGgnKSkge1xuICAgICAgICAgICAgdmFyIGZjID0gc3JjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoKHNyYy5pbmRleE9mKFwiLy9cIikgPT09IC0xKSAmJiAoKGZjID49IDY1ICYmIGZjIDw9IDkwKSB8fCAoZmMgPj0gOTcgJiYgZmMgPD0gMTIyKSB8fCBmYyA9PSA0NikpIHtcbiAgICAgICAgICAgICAgICAvLyBBbHBoYWJldGljYWwgb3IgZG90OiBwcmVwZW5kIGJhc2UgcGF0aC5cbiAgICAgICAgICAgICAgICBzcmMgPSB0aGlzLnN0YWdlLmdldE9wdGlvbignc3JjQmFzZVBhdGgnKSArIHNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoY2IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YWdlLnBsYXRmb3JtLmxvYWRTcmNUZXh0dXJlKHtzcmM6IHNyYywgaGFzQWxwaGE6IGhhc0FscGhhfSwgY2IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Tm9uRGVmYXVsdHMoKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHN1cGVyLmdldE5vbkRlZmF1bHRzKCk7XG4gICAgICAgIGlmICh0aGlzLl9zcmMpIHtcbiAgICAgICAgICAgIG9iai5zcmMgPSB0aGlzLl9zcmM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbn1cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmUgZnJvbSBcIi4uL3RyZWUvVGV4dHVyZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9pc2VUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgICAgIHJldHVybiAnX19ub2lzZSc7XG4gICAgfVxuXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnN0YWdlLmdsO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vaXNlID0gbmV3IFVpbnQ4QXJyYXkoMTI4ICogMTI4ICogNCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOCAqIDEyOCAqIDQ7IGkrPTQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICAgICAgICAgICAgICBub2lzZVtpXSA9IHY7XG4gICAgICAgICAgICAgICAgbm9pc2VbaSsxXSA9IHY7XG4gICAgICAgICAgICAgICAgbm9pc2VbaSsyXSA9IHY7XG4gICAgICAgICAgICAgICAgbm9pc2VbaSszXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRleFBhcmFtcyA9IHt9XG5cbiAgICAgICAgICAgIGlmIChnbCkge1xuICAgICAgICAgICAgICAgIHRleFBhcmFtc1tnbC5URVhUVVJFX1dSQVBfU10gPSBnbC5SRVBFQVQ7XG4gICAgICAgICAgICAgICAgdGV4UGFyYW1zW2dsLlRFWFRVUkVfV1JBUF9UXSA9IGdsLlJFUEVBVDtcbiAgICAgICAgICAgICAgICB0ZXhQYXJhbXNbZ2wuVEVYVFVSRV9NSU5fRklMVEVSXSA9IGdsLk5FQVJFU1Q7XG4gICAgICAgICAgICAgICAgdGV4UGFyYW1zW2dsLlRFWFRVUkVfTUFHX0ZJTFRFUl0gPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYihudWxsLCB7c291cmNlOiBub2lzZSwgdzogMTI4LCBoOiAxMjgsIHRleFBhcmFtczogdGV4UGFyYW1zfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3RhbmdsZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIF9nZXRMb29rdXBJZCgpIHtcbiAgICAgICAgcmV0dXJuICdfX3doaXRlcGl4JztcbiAgICB9XG5cbiAgICBfZ2V0U291cmNlTG9hZGVyKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIHZhciB3aGl0ZVBpeGVsID0gbmV3IFVpbnQ4QXJyYXkoWzI1NSwgMjU1LCAyNTUsIDI1NV0pO1xuICAgICAgICAgICAgY2IobnVsbCwge3NvdXJjZTogd2hpdGVQaXhlbCwgdzogMSwgaDogMSwgcGVybWFuZW50OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0F1dG9zaXplVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNvdXJjZVRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcblxuICAgICAgICB0aGlzLl90ZXh0dXJlU291cmNlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldCB0ZXh0dXJlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVNvdXJjZTtcbiAgICB9XG5cbiAgICBzZXQgdGV4dHVyZVNvdXJjZSh2KSB7XG4gICAgICAgIGlmICh2ICE9PSB0aGlzLl90ZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICBpZiAodi5pc1Jlc3VsdFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIG9mIGEgcmVzdWx0IHRleHR1cmUsIGF1dG9tYXRpY2FsbHkgaW5oZXJpdCB0aGUgcHJlY2lzaW9uLlxuICAgICAgICAgICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IHRoaXMuc3RhZ2UuZ2V0UmVuZGVyUHJlY2lzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlU291cmNlID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRUZXh0dXJlU291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZVNvdXJjZTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuLi90cmVlL1RleHR1cmUubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRpY0NhbnZhc1RleHR1cmUgZXh0ZW5kcyBUZXh0dXJlIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHN1cGVyKHN0YWdlKTtcbiAgICAgICAgdGhpcy5fZmFjdG9yeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbG9va3VwSWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgc2V0IGNvbnRlbnQoe2ZhY3RvcnksIGxvb2t1cElkID0gdW5kZWZpbmVkfSkge1xuICAgICAgICB0aGlzLl9mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy5fbG9va3VwSWQgPSBsb29rdXBJZDtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgIH1cblxuICAgIF9nZXRJc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9mYWN0b3J5O1xuICAgIH1cblxuICAgIF9nZXRMb29rdXBJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvb2t1cElkO1xuICAgIH1cblxuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLl9mYWN0b3J5O1xuICAgICAgICByZXR1cm4gKGNiKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZigoZXJyLCBjYW52YXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYihudWxsLCB0aGlzLnN0YWdlLnBsYXRmb3JtLmdldFRleHR1cmVPcHRpb25zRm9yRHJhd2luZ0NhbnZhcyhjYW52YXMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMuc3RhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aWNUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihzdGFnZSk7XG5cbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgc2V0IG9wdGlvbnModikge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuXG4gICAgX2dldElzVmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX29wdGlvbnM7XG4gICAgfVxuXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIChjYikgPT4ge1xuICAgICAgICAgICAgY2IobnVsbCwgdGhpcy5fb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVGV4dHVyZSBmcm9tIFwiLi4vdHJlZS9UZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0VGV4dHVyZSBleHRlbmRzIFRleHR1cmUge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgc3VwZXIoc3RhZ2UpO1xuXG4gICAgICAgIC8vIFdlIHVzZSB0aGUgc3RhZ2UgcHJlY2lzaW9uIGFzIHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpbiBjYXNlIG9mIGEgdGV4dCB0ZXh0dXJlLlxuICAgICAgICB0aGlzLl9wcmVjaXNpb24gPSB0aGlzLnN0YWdlLmdldE9wdGlvbigncHJlY2lzaW9uJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIHJlbmRlcmVyKHN0YWdlLCBjYW52YXMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmFkdmFuY2VkUmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFRleHR1cmVSZW5kZXJlckFkdmFuY2VkKHN0YWdlLCBjYW52YXMsIHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFRleHR1cmVSZW5kZXJlcihzdGFnZSwgY2FudmFzLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuXG4gICAgc2V0IHRleHQodikge1xuICAgICAgICBpZiAodGhpcy5fdGV4dCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IFwiXCIgKyB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgIH1cblxuICAgIHNldCB3KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3cgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3cgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oO1xuICAgIH1cblxuICAgIHNldCBoKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2ggPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZvbnRTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgICB9XG5cbiAgICBzZXQgZm9udFN0eWxlKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRTdHlsZSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fZm9udFN0eWxlID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmb250U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTaXplO1xuICAgIH1cblxuICAgIHNldCBmb250U2l6ZSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250U2l6ZSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZvbnRGYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udEZhY2U7XG4gICAgfVxuXG4gICAgc2V0IGZvbnRGYWNlKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRGYWNlICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9mb250RmFjZSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgd29yZFdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgICB9XG5cbiAgICBzZXQgd29yZFdyYXAodikge1xuICAgICAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmRXcmFwID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB3b3JkV3JhcFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd29yZFdyYXBXaWR0aDtcbiAgICB9XG5cbiAgICBzZXQgd29yZFdyYXBXaWR0aCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JkV3JhcFdpZHRoICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcFdpZHRoID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB3b3JkQnJlYWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JkQnJlYWs7XG4gICAgfVxuXG4gICAgc2V0IHdvcmRCcmVhayh2KSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JkQnJlYWsgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmRCcmVhayA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGV4dE92ZXJmbG93KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dE92ZXJmbG93O1xuICAgIH1cblxuICAgIHNldCB0ZXh0T3ZlcmZsb3codikge1xuICAgICAgICBpZiAodiAhPSB0aGlzLl90ZXh0T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRPdmVyZmxvdyA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IGxpbmVIZWlnaHQodikge1xuICAgICAgICBpZiAodGhpcy5fbGluZUhlaWdodCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fbGluZUhlaWdodCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGV4dEJhc2VsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEJhc2VsaW5lO1xuICAgIH1cblxuICAgIHNldCB0ZXh0QmFzZWxpbmUodikge1xuICAgICAgICBpZiAodGhpcy5fdGV4dEJhc2VsaW5lICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0QmFzZWxpbmUgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRleHRBbGlnbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRBbGlnbjtcbiAgICB9XG5cbiAgICBzZXQgdGV4dEFsaWduKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHRBbGlnbiAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEFsaWduID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB2ZXJ0aWNhbEFsaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVydGljYWxBbGlnbjtcbiAgICB9XG5cbiAgICBzZXQgdmVydGljYWxBbGlnbih2KSB7XG4gICAgICAgIGlmICh0aGlzLl92ZXJ0aWNhbEFsaWduICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl92ZXJ0aWNhbEFsaWduID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBvZmZzZXRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WTtcbiAgICB9XG5cbiAgICBzZXQgb2Zmc2V0WSh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9vZmZzZXRZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXRZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBtYXhMaW5lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heExpbmVzO1xuICAgIH1cblxuICAgIHNldCBtYXhMaW5lcyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXhMaW5lcyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fbWF4TGluZXMgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG1heExpbmVzU3VmZml4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4TGluZXNTdWZmaXg7XG4gICAgfVxuXG4gICAgc2V0IG1heExpbmVzU3VmZml4KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX21heExpbmVzU3VmZml4ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhMaW5lc1N1ZmZpeCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdGV4dENvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dENvbG9yO1xuICAgIH1cblxuICAgIHNldCB0ZXh0Q29sb3Iodikge1xuICAgICAgICBpZiAodGhpcy5fdGV4dENvbG9yICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0Q29sb3IgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBhZGRpbmdMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZ0xlZnQ7XG4gICAgfVxuXG4gICAgc2V0IHBhZGRpbmdMZWZ0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhZGRpbmdMZWZ0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nTGVmdCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGFkZGluZ1JpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZ1JpZ2h0O1xuICAgIH1cblxuICAgIHNldCBwYWRkaW5nUmlnaHQodikge1xuICAgICAgICBpZiAodGhpcy5fcGFkZGluZ1JpZ2h0ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nUmlnaHQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNoYWRvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRvdztcbiAgICB9XG5cbiAgICBzZXQgc2hhZG93KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRvdyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzaGFkb3dDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRvd0NvbG9yO1xuICAgIH1cblxuICAgIHNldCBzaGFkb3dDb2xvcih2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkb3dDb2xvciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2hhZG93Q29sb3IgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNoYWRvd09mZnNldFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkb3dPZmZzZXRYO1xuICAgIH1cblxuICAgIHNldCBzaGFkb3dPZmZzZXRYKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRvd09mZnNldFggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNoYWRvd09mZnNldFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkb3dPZmZzZXRZO1xuICAgIH1cblxuICAgIHNldCBzaGFkb3dPZmZzZXRZKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRvd09mZnNldFkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNoYWRvd0JsdXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkb3dCbHVyO1xuICAgIH1cblxuICAgIHNldCBzaGFkb3dCbHVyKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRvd0JsdXIgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWRvd0JsdXIgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGhpZ2hsaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZ2hsaWdodDtcbiAgICB9XG5cbiAgICBzZXQgaGlnaGxpZ2h0KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpZ2hsaWdodCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5faGlnaGxpZ2h0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoaWdobGlnaHRIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRIZWlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IGhpZ2hsaWdodEhlaWdodCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRIZWlnaHQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodEhlaWdodCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGlnaGxpZ2h0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRDb2xvcjtcbiAgICB9XG5cbiAgICBzZXQgaGlnaGxpZ2h0Q29sb3Iodikge1xuICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0Q29sb3IgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodENvbG9yID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoaWdobGlnaHRPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRPZmZzZXQ7XG4gICAgfVxuXG4gICAgc2V0IGhpZ2hsaWdodE9mZnNldCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRPZmZzZXQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodE9mZnNldCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaGlnaGxpZ2h0UGFkZGluZ0xlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRQYWRkaW5nTGVmdDtcbiAgICB9XG5cbiAgICBzZXQgaGlnaGxpZ2h0UGFkZGluZ0xlZnQodikge1xuICAgICAgICBpZiAodGhpcy5faGlnaGxpZ2h0UGFkZGluZ0xlZnQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdMZWZ0ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoaWdobGlnaHRQYWRkaW5nUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRQYWRkaW5nUmlnaHQ7XG4gICAgfVxuXG4gICAgc2V0IGhpZ2hsaWdodFBhZGRpbmdSaWdodCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9oaWdobGlnaHRQYWRkaW5nUmlnaHQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdSaWdodCA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY3V0U3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXRTeDtcbiAgICB9XG5cbiAgICBzZXQgY3V0U3godikge1xuICAgICAgICBpZiAodGhpcy5fY3V0U3ggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1dFN4ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjdXRFeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1dEV4O1xuICAgIH1cblxuICAgIHNldCBjdXRFeCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXRFeCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fY3V0RXggPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGN1dFN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3V0U3k7XG4gICAgfVxuXG4gICAgc2V0IGN1dFN5KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1dFN5ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXRTeSA9IHY7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY3V0RXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXRFeTtcbiAgICB9XG5cbiAgICBzZXQgY3V0RXkodikge1xuICAgICAgICBpZiAodGhpcy5fY3V0RXkgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1dEV5ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBhZHZhbmNlZFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWR2YW5jZWRSZW5kZXJlcjtcbiAgICB9XG5cbiAgICBzZXQgYWR2YW5jZWRSZW5kZXJlcih2KSB7XG4gICAgICAgIGlmICh0aGlzLl9hZHZhbmNlZFJlbmRlcmVyICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9hZHZhbmNlZFJlbmRlcmVyID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBsZXR0ZXJTcGFjaW5nKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xldHRlclNwYWNpbmcgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGxldHRlclNwYWNpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICAgIH1cblxuICAgIHNldCB0ZXh0SW5kZW50KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHRJbmRlbnQgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHRJbmRlbnQgPSB2O1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHRleHRJbmRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0SW5kZW50O1xuICAgIH1cblxuICAgIGdldCBwcmVjaXNpb24oKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wcmVjaXNpb247XG4gICAgfVxuXG4gICAgc2V0IHByZWNpc2lvbih2KSB7XG4gICAgICAgIC8vIFdlIGFjdHVhbGx5IGRyYXcgZGlmZmVyZW50bHkgd2hlbiB0aGUgcHJlY2lzaW9uIGNoYW5nZXMuXG4gICAgICAgIGlmICh0aGlzLnByZWNpc2lvbiAhPT0gdikge1xuICAgICAgICAgICAgc3VwZXIucHJlY2lzaW9uID0gdjtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRJc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnRleHQ7XG4gICAgfVxuXG4gICAgX2dldExvb2t1cElkKCkge1xuICAgICAgICBsZXQgcGFydHMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy53ICE9PSAwKSBwYXJ0cy5wdXNoKFwidyBcIiArIHRoaXMudyk7XG4gICAgICAgIGlmICh0aGlzLmggIT09IDApIHBhcnRzLnB1c2goXCJoIFwiICsgdGhpcy5oKTtcbiAgICAgICAgaWYgKHRoaXMuZm9udFN0eWxlICE9PSBcIm5vcm1hbFwiKSBwYXJ0cy5wdXNoKFwiZlNcIiArIHRoaXMuZm9udFN0eWxlKTtcbiAgICAgICAgaWYgKHRoaXMuZm9udFNpemUgIT09IDQwKSBwYXJ0cy5wdXNoKFwiZnNcIiArIHRoaXMuZm9udFNpemUpO1xuICAgICAgICBpZiAodGhpcy5mb250RmFjZSAhPT0gbnVsbCkgcGFydHMucHVzaChcImZmXCIgKyAoQXJyYXkuaXNBcnJheSh0aGlzLmZvbnRGYWNlKSA/IHRoaXMuZm9udEZhY2Uuam9pbihcIixcIikgOiB0aGlzLmZvbnRGYWNlKSk7XG4gICAgICAgIGlmICh0aGlzLndvcmRXcmFwICE9PSB0cnVlKSBwYXJ0cy5wdXNoKFwid3JcIiArICh0aGlzLndvcmRXcmFwID8gMSA6IDApKTtcbiAgICAgICAgaWYgKHRoaXMud29yZFdyYXBXaWR0aCAhPT0gMCkgcGFydHMucHVzaChcInd3XCIgKyB0aGlzLndvcmRXcmFwV2lkdGgpO1xuICAgICAgICBpZiAodGhpcy53b3JkQnJlYWsgIT09IGZhbHNlKSBwYXJ0cy5wdXNoKFwid2JcIiArIHRoaXMud29yZEJyZWFrID8gMSA6IDApO1xuICAgICAgICBpZiAodGhpcy50ZXh0T3ZlcmZsb3cgIT0gXCJcIikgcGFydHMucHVzaChcInRvXCIgKyB0aGlzLnRleHRPdmVyZmxvdyk7XG4gICAgICAgIGlmICh0aGlzLmxpbmVIZWlnaHQgIT09IG51bGwpIHBhcnRzLnB1c2goXCJsaFwiICsgdGhpcy5saW5lSGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEJhc2VsaW5lICE9PSBcImFscGhhYmV0aWNcIikgcGFydHMucHVzaChcInRiXCIgKyB0aGlzLnRleHRCYXNlbGluZSk7XG4gICAgICAgIGlmICh0aGlzLnRleHRBbGlnbiAhPT0gXCJsZWZ0XCIpIHBhcnRzLnB1c2goXCJ0YVwiICsgdGhpcy50ZXh0QWxpZ24pO1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbEFsaWduICE9PSBcInRvcFwiKSBwYXJ0cy5wdXNoKFwidmFcIiArIHRoaXMudmVydGljYWxBbGlnbik7XG4gICAgICAgIGlmICh0aGlzLm9mZnNldFkgIT09IG51bGwpIHBhcnRzLnB1c2goXCJveVwiICsgdGhpcy5vZmZzZXRZKTtcbiAgICAgICAgaWYgKHRoaXMubWF4TGluZXMgIT09IDApIHBhcnRzLnB1c2goXCJtbFwiICsgdGhpcy5tYXhMaW5lcyk7XG4gICAgICAgIGlmICh0aGlzLm1heExpbmVzU3VmZml4ICE9PSBcIi4uXCIpIHBhcnRzLnB1c2goXCJtc1wiICsgdGhpcy5tYXhMaW5lc1N1ZmZpeCk7XG4gICAgICAgIHBhcnRzLnB1c2goXCJwY1wiICsgdGhpcy5wcmVjaXNpb24pO1xuICAgICAgICBpZiAodGhpcy50ZXh0Q29sb3IgIT09IDB4ZmZmZmZmZmYpIHBhcnRzLnB1c2goXCJjb1wiICsgdGhpcy50ZXh0Q29sb3IudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ0xlZnQgIT09IDApIHBhcnRzLnB1c2goXCJwbFwiICsgdGhpcy5wYWRkaW5nTGVmdCk7XG4gICAgICAgIGlmICh0aGlzLnBhZGRpbmdSaWdodCAhPT0gMCkgcGFydHMucHVzaChcInByXCIgKyB0aGlzLnBhZGRpbmdSaWdodCk7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvdyAhPT0gZmFsc2UpIHBhcnRzLnB1c2goXCJzaFwiICsgKHRoaXMuc2hhZG93ID8gMSA6IDApKTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Q29sb3IgIT09IDB4ZmYwMDAwMDApIHBhcnRzLnB1c2goXCJzY1wiICsgdGhpcy5zaGFkb3dDb2xvci50b1N0cmluZygxNikpO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dPZmZzZXRYICE9PSAwKSBwYXJ0cy5wdXNoKFwic3hcIiArIHRoaXMuc2hhZG93T2Zmc2V0WCk7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd09mZnNldFkgIT09IDApIHBhcnRzLnB1c2goXCJzeVwiICsgdGhpcy5zaGFkb3dPZmZzZXRZKTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93Qmx1ciAhPT0gNSkgcGFydHMucHVzaChcInNiXCIgKyB0aGlzLnNoYWRvd0JsdXIpO1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHQgIT09IGZhbHNlKSBwYXJ0cy5wdXNoKFwiaExcIiArICh0aGlzLmhpZ2hsaWdodCA/IDEgOiAwKSk7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodEhlaWdodCAhPT0gMCkgcGFydHMucHVzaChcImhoXCIgKyB0aGlzLmhpZ2hsaWdodEhlaWdodCk7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodENvbG9yICE9PSAweGZmMDAwMDAwKSBwYXJ0cy5wdXNoKFwiaGNcIiArIHRoaXMuaGlnaGxpZ2h0Q29sb3IudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0T2Zmc2V0ICE9PSBudWxsKSBwYXJ0cy5wdXNoKFwiaG9cIiArIHRoaXMuaGlnaGxpZ2h0T2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0UGFkZGluZ0xlZnQgIT09IG51bGwpIHBhcnRzLnB1c2goXCJobFwiICsgdGhpcy5oaWdobGlnaHRQYWRkaW5nTGVmdCk7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodFBhZGRpbmdSaWdodCAhPT0gbnVsbCkgcGFydHMucHVzaChcImhyXCIgKyB0aGlzLmhpZ2hsaWdodFBhZGRpbmdSaWdodCk7XG4gICAgICAgIGlmICh0aGlzLmxldHRlclNwYWNpbmcgIT09IG51bGwpIHBhcnRzLnB1c2goXCJsc1wiICsgdGhpcy5sZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgaWYgKHRoaXMudGV4dEluZGVudCAhPT0gbnVsbCkgcGFydHMucHVzaChcInRpXCIgKyB0aGlzLnRleHRJbmRlbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLmN1dFN4KSBwYXJ0cy5wdXNoKFwiY3N4XCIgKyB0aGlzLmN1dFN4KTtcbiAgICAgICAgaWYgKHRoaXMuY3V0RXgpIHBhcnRzLnB1c2goXCJjZXhcIiArIHRoaXMuY3V0RXgpO1xuICAgICAgICBpZiAodGhpcy5jdXRTeSkgcGFydHMucHVzaChcImNzeVwiICsgdGhpcy5jdXRTeSk7XG4gICAgICAgIGlmICh0aGlzLmN1dEV5KSBwYXJ0cy5wdXNoKFwiY2V5XCIgKyB0aGlzLmN1dEV5KTtcblxuICAgICAgICBpZiAodGhpcy5hZHZhbmNlZFJlbmRlcmVyKSBwYXJ0cy5wdXNoKFwiYVJcIiArIHRoaXMuYWR2YW5jZWRSZW5kZXJlciA/IDEgOiAwKTtcblxuICAgICAgICBsZXQgaWQgPSBcIlRYJFwiICsgcGFydHMuam9pbihcInxcIikgKyBcIjpcIiArIHRoaXMudGV4dDtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIF9nZXRTb3VyY2VMb2FkZXIoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmNsb25lQXJncygpO1xuXG4gICAgICAgIC8vIEluaGVyaXQgZm9udCBmYWNlIGZyb20gc3RhZ2UuXG4gICAgICAgIGlmIChhcmdzLmZvbnRGYWNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBhcmdzLmZvbnRGYWNlID0gdGhpcy5zdGFnZS5nZXRPcHRpb24oJ2RlZmF1bHRGb250RmFjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLnN0YWdlLmdsO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuc3RhZ2UucGxhdGZvcm0uZ2V0RHJhd2luZ0NhbnZhcygpO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSAoYXJncy5hZHZhbmNlZFJlbmRlcmVyKVxuICAgICAgICAgICAgICA/IG5ldyBUZXh0VGV4dHVyZVJlbmRlcmVyQWR2YW5jZWQodGhpcy5zdGFnZSwgY2FudmFzLCBhcmdzKVxuICAgICAgICAgICAgICA6IG5ldyBUZXh0VGV4dHVyZVJlbmRlcmVyKHRoaXMuc3RhZ2UsIGNhbnZhcywgYXJncyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHAgPSByZW5kZXJlci5kcmF3KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRleFBhcmFtcyA9IHt9O1xuXG4gICAgICAgICAgICBjb25zdCBzaGFycENmZyA9IHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdmb250U2hhcnAnKTtcbiAgICAgICAgICAgIGxldCBzaGFycGVuID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgdGV4dCBibHVyIHdoZW4gdGV4dCB0ZXh0dXJlIGlzIGRvd25zY2FsZWRcbiAgICAgICAgICAgIGlmIChVdGlscy5pc0Jvb2xlYW4oc2hhcnBDZmcpKSB7XG4gICAgICAgICAgICAgICAgc2hhcnBlbiA9IHNoYXJwQ2ZnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdChzaGFycENmZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICAgICAgICAgIHNoYXJwZW4gPSBwcmVjaXNpb24gPD0gc2hhcnBDZmcucHJlY2lzaW9uICYmIGFyZ3MuZm9udFNpemUgPD0gc2hhcnBDZmcuZm9udFNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnbCAmJiBzaGFycGVuKSB7XG4gICAgICAgICAgICAgICAgdGV4UGFyYW1zW2dsLlRFWFRVUkVfTUFHX0ZJTFRFUl0gPSBnbC5ORUFSRVNUO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIHAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEZJWE1FOiBvbiBzb21lIHBsYXRmb3JtcyAoZS5nLiBSUEkpLCB0aHJvdHRsaW5nIHRleHQgdGV4dHVyZXMgY2F1c2UgYXJ0aWZhY3RzICovXG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVySW5mbzogcmVuZGVyZXIucmVuZGVySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm90dGxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleFBhcmFtczogdGV4UGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnN0YWdlLnBsYXRmb3JtLmdldFRleHR1cmVPcHRpb25zRm9yRHJhd2luZ0NhbnZhcyhjYW52YXMpKSk7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVySW5mbzogcmVuZGVyZXIucmVuZGVySW5mbyxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXhQYXJhbXM6IHRleFBhcmFtcyxcbiAgICAgICAgICAgICAgICB9LCB0aGlzLnN0YWdlLnBsYXRmb3JtLmdldFRleHR1cmVPcHRpb25zRm9yRHJhd2luZ0NhbnZhcyhjYW52YXMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICBnZXROb25EZWZhdWx0cygpIHtcbiAgICAgICAgY29uc3Qgbm9uRGVmYXVsdHMgPSBzdXBlci5nZXROb25EZWZhdWx0cygpO1xuICAgICAgICBpZiAodGhpcy50ZXh0ICE9PSBcIlwiKSBub25EZWZhdWx0c1sndGV4dCddID0gdGhpcy50ZXh0O1xuICAgICAgICBpZiAodGhpcy53ICE9PSAwKSBub25EZWZhdWx0c1sndyddID0gdGhpcy53O1xuICAgICAgICBpZiAodGhpcy5oICE9PSAwKSBub25EZWZhdWx0c1snaCddID0gdGhpcy5oO1xuICAgICAgICBpZiAodGhpcy5mb250U3R5bGUgIT09IFwibm9ybWFsXCIpIG5vbkRlZmF1bHRzWydmb250U3R5bGUnXSA9IHRoaXMuZm9udFN0eWxlO1xuICAgICAgICBpZiAodGhpcy5mb250U2l6ZSAhPT0gNDApIG5vbkRlZmF1bHRzW1wiZm9udFNpemVcIl0gPSB0aGlzLmZvbnRTaXplO1xuICAgICAgICBpZiAodGhpcy5mb250RmFjZSAhPT0gbnVsbCkgbm9uRGVmYXVsdHNbXCJmb250RmFjZVwiXSA9IHRoaXMuZm9udEZhY2U7XG4gICAgICAgIGlmICh0aGlzLndvcmRXcmFwICE9PSB0cnVlKSBub25EZWZhdWx0c1tcIndvcmRXcmFwXCJdID0gdGhpcy53b3JkV3JhcDtcbiAgICAgICAgaWYgKHRoaXMud29yZFdyYXBXaWR0aCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJ3b3JkV3JhcFdpZHRoXCJdID0gdGhpcy53b3JkV3JhcFdpZHRoO1xuICAgICAgICBpZiAodGhpcy53b3JkQnJlYWsgIT09IGZhbHNlKSBub25EZWZhdWx0c1tcIndvcmRCcmVha1wiXSA9IHRoaXMud29yZEJyZWFrO1xuICAgICAgICBpZiAodGhpcy50ZXh0T3ZlcmZsb3cgIT0gXCJcIikgbm9uRGVmYXVsdHNbXCJ0ZXh0T3ZlcmZsb3dcIl0gPSB0aGlzLnRleHRPdmVyZmxvdztcbiAgICAgICAgaWYgKHRoaXMubGluZUhlaWdodCAhPT0gbnVsbCkgbm9uRGVmYXVsdHNbXCJsaW5lSGVpZ2h0XCJdID0gdGhpcy5saW5lSGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy50ZXh0QmFzZWxpbmUgIT09IFwiYWxwaGFiZXRpY1wiKSBub25EZWZhdWx0c1tcInRleHRCYXNlbGluZVwiXSA9IHRoaXMudGV4dEJhc2VsaW5lO1xuICAgICAgICBpZiAodGhpcy50ZXh0QWxpZ24gIT09IFwibGVmdFwiKSBub25EZWZhdWx0c1tcInRleHRBbGlnblwiXSA9IHRoaXMudGV4dEFsaWduO1xuICAgICAgICBpZiAodGhpcy52ZXJ0aWNhbEFsaWduICE9PSBcInRvcFwiKSBub25EZWZhdWx0c1tcInZlcnRpY2FsQWxpZ25cIl0gPSB0aGlzLnZlcnRpY2FsQWxpZ247XG4gICAgICAgIGlmICh0aGlzLm9mZnNldFkgIT09IG51bGwpIG5vbkRlZmF1bHRzW1wib2Zmc2V0WVwiXSA9IHRoaXMub2Zmc2V0WTtcbiAgICAgICAgaWYgKHRoaXMubWF4TGluZXMgIT09IDApIG5vbkRlZmF1bHRzW1wibWF4TGluZXNcIl0gPSB0aGlzLm1heExpbmVzO1xuICAgICAgICBpZiAodGhpcy5tYXhMaW5lc1N1ZmZpeCAhPT0gXCIuLlwiKSBub25EZWZhdWx0c1tcIm1heExpbmVzU3VmZml4XCJdID0gdGhpcy5tYXhMaW5lc1N1ZmZpeDtcbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uICE9PSB0aGlzLnN0YWdlLmdldE9wdGlvbigncHJlY2lzaW9uJykpIG5vbkRlZmF1bHRzW1wicHJlY2lzaW9uXCJdID0gdGhpcy5wcmVjaXNpb247XG4gICAgICAgIGlmICh0aGlzLnRleHRDb2xvciAhPT0gMHhmZmZmZmZmZikgbm9uRGVmYXVsdHNbXCJ0ZXh0Q29sb3JcIl0gPSB0aGlzLnRleHRDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMucGFkZGluZ0xlZnQgIT09IDApIG5vbkRlZmF1bHRzW1wicGFkZGluZ0xlZnRcIl0gPSB0aGlzLnBhZGRpbmdMZWZ0O1xuICAgICAgICBpZiAodGhpcy5wYWRkaW5nUmlnaHQgIT09IDApIG5vbkRlZmF1bHRzW1wicGFkZGluZ1JpZ2h0XCJdID0gdGhpcy5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvdyAhPT0gZmFsc2UpIG5vbkRlZmF1bHRzW1wic2hhZG93XCJdID0gdGhpcy5zaGFkb3c7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0NvbG9yICE9PSAweGZmMDAwMDAwKSBub25EZWZhdWx0c1tcInNoYWRvd0NvbG9yXCJdID0gdGhpcy5zaGFkb3dDb2xvcjtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93T2Zmc2V0WCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJzaGFkb3dPZmZzZXRYXCJdID0gdGhpcy5zaGFkb3dPZmZzZXRYO1xuICAgICAgICBpZiAodGhpcy5zaGFkb3dPZmZzZXRZICE9PSAwKSBub25EZWZhdWx0c1tcInNoYWRvd09mZnNldFlcIl0gPSB0aGlzLnNoYWRvd09mZnNldFk7XG4gICAgICAgIGlmICh0aGlzLnNoYWRvd0JsdXIgIT09IDUpIG5vbkRlZmF1bHRzW1wic2hhZG93Qmx1clwiXSA9IHRoaXMuc2hhZG93Qmx1cjtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ICE9PSBmYWxzZSkgbm9uRGVmYXVsdHNbXCJoaWdobGlnaHRcIl0gPSB0aGlzLmhpZ2hsaWdodDtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0SGVpZ2h0ICE9PSAwKSBub25EZWZhdWx0c1tcImhpZ2hsaWdodEhlaWdodFwiXSA9IHRoaXMuaGlnaGxpZ2h0SGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRDb2xvciAhPT0gMHhmZjAwMDAwMCkgbm9uRGVmYXVsdHNbXCJoaWdobGlnaHRDb2xvclwiXSA9IHRoaXMuaGlnaGxpZ2h0Q29sb3I7XG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodE9mZnNldCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJoaWdobGlnaHRPZmZzZXRcIl0gPSB0aGlzLmhpZ2hsaWdodE9mZnNldDtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0UGFkZGluZ0xlZnQgIT09IDApIG5vbkRlZmF1bHRzW1wiaGlnaGxpZ2h0UGFkZGluZ0xlZnRcIl0gPSB0aGlzLmhpZ2hsaWdodFBhZGRpbmdMZWZ0O1xuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRQYWRkaW5nUmlnaHQgIT09IDApIG5vbkRlZmF1bHRzW1wiaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0XCJdID0gdGhpcy5oaWdobGlnaHRQYWRkaW5nUmlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmxldHRlclNwYWNpbmcgIT09IDApIG5vbkRlZmF1bHRzW1wibGV0dGVyU3BhY2luZ1wiXSA9IHRoaXMubGV0dGVyU3BhY2luZztcbiAgICAgICAgaWYgKHRoaXMudGV4dEluZGVudCAhPT0gMCkgbm9uRGVmYXVsdHNbXCJ0ZXh0SW5kZW50XCJdID0gdGhpcy50ZXh0SW5kZW50O1xuXG4gICAgICAgIGlmICh0aGlzLmN1dFN4KSBub25EZWZhdWx0c1tcImN1dFN4XCJdID0gdGhpcy5jdXRTeDtcbiAgICAgICAgaWYgKHRoaXMuY3V0RXgpIG5vbkRlZmF1bHRzW1wiY3V0RXhcIl0gPSB0aGlzLmN1dEV4O1xuICAgICAgICBpZiAodGhpcy5jdXRTeSkgbm9uRGVmYXVsdHNbXCJjdXRTeVwiXSA9IHRoaXMuY3V0U3k7XG4gICAgICAgIGlmICh0aGlzLmN1dEV5KSBub25EZWZhdWx0c1tcImN1dEV5XCJdID0gdGhpcy5jdXRFeTtcblxuICAgICAgICBpZiAodGhpcy5hZHZhbmNlZFJlbmRlcmVyKSBub25EZWZhdWx0c1tcInJlbmRlcmVyXCJdID0gdGhpcy5hZHZhbmNlZFJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gbm9uRGVmYXVsdHM7XG4gICAgfVxuXG4gICAgY2xvbmVBcmdzKCkge1xuICAgICAgICBsZXQgb2JqID0ge307XG4gICAgICAgIG9iai50ZXh0ID0gdGhpcy5fdGV4dDtcbiAgICAgICAgb2JqLncgPSB0aGlzLl93O1xuICAgICAgICBvYmouaCA9IHRoaXMuX2g7XG4gICAgICAgIG9iai5mb250U3R5bGUgPSB0aGlzLl9mb250U3R5bGU7XG4gICAgICAgIG9iai5mb250U2l6ZSA9IHRoaXMuX2ZvbnRTaXplO1xuICAgICAgICBvYmouZm9udEZhY2UgPSB0aGlzLl9mb250RmFjZTtcbiAgICAgICAgb2JqLndvcmRXcmFwID0gdGhpcy5fd29yZFdyYXA7XG4gICAgICAgIG9iai53b3JkV3JhcFdpZHRoID0gdGhpcy5fd29yZFdyYXBXaWR0aDtcbiAgICAgICAgb2JqLndvcmRCcmVhayA9IHRoaXMuX3dvcmRCcmVhaztcbiAgICAgICAgb2JqLnRleHRPdmVyZmxvdyA9IHRoaXMuX3RleHRPdmVyZmxvdztcbiAgICAgICAgb2JqLmxpbmVIZWlnaHQgPSB0aGlzLl9saW5lSGVpZ2h0O1xuICAgICAgICBvYmoudGV4dEJhc2VsaW5lID0gdGhpcy5fdGV4dEJhc2VsaW5lO1xuICAgICAgICBvYmoudGV4dEFsaWduID0gdGhpcy5fdGV4dEFsaWduO1xuICAgICAgICBvYmoudmVydGljYWxBbGlnbiA9IHRoaXMuX3ZlcnRpY2FsQWxpZ247XG4gICAgICAgIG9iai5vZmZzZXRZID0gdGhpcy5fb2Zmc2V0WTtcbiAgICAgICAgb2JqLm1heExpbmVzID0gdGhpcy5fbWF4TGluZXM7XG4gICAgICAgIG9iai5tYXhMaW5lc1N1ZmZpeCA9IHRoaXMuX21heExpbmVzU3VmZml4O1xuICAgICAgICBvYmoucHJlY2lzaW9uID0gdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICBvYmoudGV4dENvbG9yID0gdGhpcy5fdGV4dENvbG9yO1xuICAgICAgICBvYmoucGFkZGluZ0xlZnQgPSB0aGlzLl9wYWRkaW5nTGVmdDtcbiAgICAgICAgb2JqLnBhZGRpbmdSaWdodCA9IHRoaXMuX3BhZGRpbmdSaWdodDtcbiAgICAgICAgb2JqLnNoYWRvdyA9IHRoaXMuX3NoYWRvdztcbiAgICAgICAgb2JqLnNoYWRvd0NvbG9yID0gdGhpcy5fc2hhZG93Q29sb3I7XG4gICAgICAgIG9iai5zaGFkb3dPZmZzZXRYID0gdGhpcy5fc2hhZG93T2Zmc2V0WDtcbiAgICAgICAgb2JqLnNoYWRvd09mZnNldFkgPSB0aGlzLl9zaGFkb3dPZmZzZXRZO1xuICAgICAgICBvYmouc2hhZG93Qmx1ciA9IHRoaXMuX3NoYWRvd0JsdXI7XG4gICAgICAgIG9iai5oaWdobGlnaHQgPSB0aGlzLl9oaWdobGlnaHQ7XG4gICAgICAgIG9iai5oaWdobGlnaHRIZWlnaHQgPSB0aGlzLl9oaWdobGlnaHRIZWlnaHQ7XG4gICAgICAgIG9iai5oaWdobGlnaHRDb2xvciA9IHRoaXMuX2hpZ2hsaWdodENvbG9yO1xuICAgICAgICBvYmouaGlnaGxpZ2h0T2Zmc2V0ID0gdGhpcy5faGlnaGxpZ2h0T2Zmc2V0O1xuICAgICAgICBvYmouaGlnaGxpZ2h0UGFkZGluZ0xlZnQgPSB0aGlzLl9oaWdobGlnaHRQYWRkaW5nTGVmdDtcbiAgICAgICAgb2JqLmhpZ2hsaWdodFBhZGRpbmdSaWdodCA9IHRoaXMuX2hpZ2hsaWdodFBhZGRpbmdSaWdodDtcbiAgICAgICAgb2JqLmxldHRlclNwYWNpbmcgPSB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xuICAgICAgICBvYmoudGV4dEluZGVudCA9IHRoaXMuX3RleHRJbmRlbnQ7XG4gICAgICAgIG9iai5jdXRTeCA9IHRoaXMuX2N1dFN4O1xuICAgICAgICBvYmouY3V0RXggPSB0aGlzLl9jdXRFeDtcbiAgICAgICAgb2JqLmN1dFN5ID0gdGhpcy5fY3V0U3k7XG4gICAgICAgIG9iai5jdXRFeSA9IHRoaXMuX2N1dEV5O1xuICAgICAgICBvYmouYWR2YW5jZWRSZW5kZXJlciA9IHRoaXMuX2FkdmFuY2VkUmVuZGVyZXI7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG5cbn1cblxuLy8gQmVjYXVzZSB0aGVyZSBhcmUgc28gbWFueSBwcm9wZXJ0aWVzLCB3ZSBwcmVmZXIgdG8gdXNlIHRoZSBwcm90b3R5cGUgZm9yIGRlZmF1bHQgdmFsdWVzLlxuLy8gVGhpcyBjYXVzZXMgYSBkZWNyZWFzZSBpbiBwZXJmb3JtYW5jZSwgYnV0IGFsc28gYSBkZWNyZWFzZSBpbiBtZW1vcnkgdXNhZ2UuXG5sZXQgcHJvdG8gPSBUZXh0VGV4dHVyZS5wcm90b3R5cGU7XG5wcm90by5fdGV4dCA9IFwiXCI7XG5wcm90by5fdyA9IDA7XG5wcm90by5faCA9IDA7XG5wcm90by5fZm9udFN0eWxlID0gXCJub3JtYWxcIjtcbnByb3RvLl9mb250U2l6ZSA9IDQwO1xucHJvdG8uX2ZvbnRGYWNlID0gbnVsbDtcbnByb3RvLl93b3JkV3JhcCA9IHRydWU7XG5wcm90by5fd29yZFdyYXBXaWR0aCA9IDA7XG5wcm90by5fd29yZEJyZWFrID0gZmFsc2U7XG5wcm90by5fdGV4dE92ZXJmbG93ID0gXCJcIjtcbnByb3RvLl9saW5lSGVpZ2h0ID0gbnVsbDtcbnByb3RvLl90ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbnByb3RvLl90ZXh0QWxpZ24gPSBcImxlZnRcIjtcbnByb3RvLl92ZXJ0aWNhbEFsaWduID0gXCJ0b3BcIjtcbnByb3RvLl9vZmZzZXRZID0gbnVsbDtcbnByb3RvLl9tYXhMaW5lcyA9IDA7XG5wcm90by5fbWF4TGluZXNTdWZmaXggPSBcIi4uXCI7XG5wcm90by5fdGV4dENvbG9yID0gMHhGRkZGRkZGRjtcbnByb3RvLl9wYWRkaW5nTGVmdCA9IDA7XG5wcm90by5fcGFkZGluZ1JpZ2h0ID0gMDtcbnByb3RvLl9zaGFkb3cgPSBmYWxzZTtcbnByb3RvLl9zaGFkb3dDb2xvciA9IDB4RkYwMDAwMDA7XG5wcm90by5fc2hhZG93T2Zmc2V0WCA9IDA7XG5wcm90by5fc2hhZG93T2Zmc2V0WSA9IDA7XG5wcm90by5fc2hhZG93Qmx1ciA9IDU7XG5wcm90by5faGlnaGxpZ2h0ID0gZmFsc2U7XG5wcm90by5faGlnaGxpZ2h0SGVpZ2h0ID0gMDtcbnByb3RvLl9oaWdobGlnaHRDb2xvciA9IDB4RkYwMDAwMDA7XG5wcm90by5faGlnaGxpZ2h0T2Zmc2V0ID0gMDtcbnByb3RvLl9oaWdobGlnaHRQYWRkaW5nTGVmdCA9IDA7XG5wcm90by5faGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ID0gMDtcbnByb3RvLl9sZXR0ZXJTcGFjaW5nID0gMDtcbnByb3RvLl90ZXh0SW5kZW50ID0gMDtcbnByb3RvLl9jdXRTeCA9IDA7XG5wcm90by5fY3V0RXggPSAwO1xucHJvdG8uX2N1dFN5ID0gMDtcbnByb3RvLl9jdXRFeSA9IDA7XG5wcm90by5fYWR2YW5jZWRSZW5kZXJlciA9IGZhbHNlO1xuXG5cbmltcG9ydCBUZXh0VGV4dHVyZVJlbmRlcmVyIGZyb20gXCIuL1RleHRUZXh0dXJlUmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgVGV4dFRleHR1cmVSZW5kZXJlckFkdmFuY2VkIGZyb20gXCIuL1RleHRUZXh0dXJlUmVuZGVyZXJBZHZhbmNlZC5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRUZXh0dXJlUmVuZGVyZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UsIGNhbnZhcywgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fc3RhZ2UgPSBzdGFnZTtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgZ2V0UHJlY2lzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3MucHJlY2lzaW9uO1xuICAgIH07XG5cbiAgICBzZXRGb250UHJvcGVydGllcygpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gVXRpbHMuaXNTcGFyayA/IHRoaXMuX3N0YWdlLnBsYXRmb3JtLmdldEZvbnRTZXR0aW5nKHRoaXMpIDogdGhpcy5fZ2V0Rm9udFNldHRpbmcoKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC50ZXh0QmFzZWxpbmUgPSB0aGlzLl9zZXR0aW5ncy50ZXh0QmFzZWxpbmU7XG4gICAgfTtcblxuICAgIF9nZXRGb250U2V0dGluZygpIHtcbiAgICAgICAgbGV0IGZmID0gdGhpcy5fc2V0dGluZ3MuZm9udEZhY2U7XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZmKSkge1xuICAgICAgICAgICAgZmYgPSBbZmZdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZmcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGZmLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZmW2ldID09PSBcInNlcmlmXCIgfHwgZmZbaV0gPT09IFwic2Fucy1zZXJpZlwiKSB7XG4gICAgICAgICAgICAgICAgZmZzLnB1c2goZmZbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZnMucHVzaChgXCIke2ZmW2ldfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYCR7dGhpcy5fc2V0dGluZ3MuZm9udFN0eWxlfSAke3RoaXMuX3NldHRpbmdzLmZvbnRTaXplICogdGhpcy5nZXRQcmVjaXNpb24oKX1weCAke2Zmcy5qb2luKFwiLFwiKX1gXG4gICAgfVxuXG4gICAgX2xvYWQoKSB7XG4gICAgICAgIGlmIChVdGlscy5pc1dlYiAmJiBkb2N1bWVudC5mb250cykge1xuICAgICAgICAgICAgY29uc3QgZm9udFNldHRpbmcgPSB0aGlzLl9nZXRGb250U2V0dGluZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmZvbnRzLmNoZWNrKGZvbnRTZXR0aW5nLCB0aGlzLl9zZXR0aW5ncy50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgYSBwcm9taXNlIHRoYXQgd2FpdHMgZm9yIGxvYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5mb250cy5sb2FkKGZvbnRTZXR0aW5nLCB0aGlzLl9zZXR0aW5ncy50ZXh0KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCBsb2FkIHRoZSBmYWxsYmFjayBmb250LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdbTGlnaHRuaW5nXSBGb250IGxvYWQgZXJyb3InLCBlcnIsIGZvbnRTZXR0aW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvY3VtZW50LmZvbnRzLmNoZWNrKGZvbnRTZXR0aW5nLCB0aGlzLl9zZXR0aW5ncy50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW0xpZ2h0bmluZ10gRm9udCBub3QgZm91bmQnLCBmb250U2V0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIENhbid0IGNoZWNrIGZvbnQgbG9hZGluZyBmb3IgXCIgKyBmb250U2V0dGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkcmF3KCkge1xuICAgICAgICAvLyBXZSBkbyBub3QgdXNlIGEgcHJvbWlzZSBzbyB0aGF0IGxvYWRpbmcgaXMgcGVyZm9ybWVkIHN5bmNyb25vdXMgd2hlbiBwb3NzaWJsZS5cbiAgICAgICAgY29uc3QgbG9hZFByb21pc2UgPSB0aGlzLl9sb2FkKCk7XG4gICAgICAgIGlmICghbG9hZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5pc1NwYXJrID8gdGhpcy5fc3RhZ2UucGxhdGZvcm0uZHJhd1RleHQodGhpcykgOiB0aGlzLl9kcmF3KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmlzU3BhcmsgPyB0aGlzLl9zdGFnZS5wbGF0Zm9ybS5kcmF3VGV4dCh0aGlzKSA6IHRoaXMuX2RyYXcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NhbGN1bGF0ZVJlbmRlckluZm8oKSB7XG4gICAgICAgIGxldCByZW5kZXJJbmZvID0ge307XG5cbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5nZXRQcmVjaXNpb24oKTtcblxuICAgICAgICBjb25zdCBwYWRkaW5nTGVmdCA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdMZWZ0ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBwYWRkaW5nUmlnaHQgPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nUmlnaHQgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fc2V0dGluZ3MuZm9udFNpemUgKiBwcmVjaXNpb247XG4gICAgICAgIGxldCBvZmZzZXRZID0gdGhpcy5fc2V0dGluZ3Mub2Zmc2V0WSA9PT0gbnVsbCA/IG51bGwgOiAodGhpcy5fc2V0dGluZ3Mub2Zmc2V0WSAqIHByZWNpc2lvbik7XG4gICAgICAgIGxldCBsaW5lSGVpZ2h0ID0gdGhpcy5fc2V0dGluZ3MubGluZUhlaWdodCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMuX3NldHRpbmdzLncgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLl9zZXR0aW5ncy5oICogcHJlY2lzaW9uO1xuICAgICAgICBsZXQgd29yZFdyYXBXaWR0aCA9IHRoaXMuX3NldHRpbmdzLndvcmRXcmFwV2lkdGggKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dFN4ID0gdGhpcy5fc2V0dGluZ3MuY3V0U3ggKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dEV4ID0gdGhpcy5fc2V0dGluZ3MuY3V0RXggKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dFN5ID0gdGhpcy5fc2V0dGluZ3MuY3V0U3kgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGN1dEV5ID0gdGhpcy5fc2V0dGluZ3MuY3V0RXkgKiBwcmVjaXNpb247XG4gICAgICAgIGNvbnN0IGxldHRlclNwYWNpbmcgPSAodGhpcy5fc2V0dGluZ3MubGV0dGVyU3BhY2luZyB8fCAwKSAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgdGV4dEluZGVudCA9IHRoaXMuX3NldHRpbmdzLnRleHRJbmRlbnQgKiBwcmVjaXNpb247XG5cbiAgICAgICAgLy8gU2V0IGZvbnQgcHJvcGVydGllcy5cbiAgICAgICAgdGhpcy5zZXRGb250UHJvcGVydGllcygpO1xuXG4gICAgICAgIC8vIFRvdGFsIHdpZHRoLlxuICAgICAgICBsZXQgd2lkdGggPSB3IHx8ICgyMDQ4IC8gdGhpcy5nZXRQcmVjaXNpb24oKSk7XG5cbiAgICAgICAgLy8gSW5uZXIgd2lkdGguXG4gICAgICAgIGxldCBpbm5lcldpZHRoID0gd2lkdGggLSAocGFkZGluZ0xlZnQpO1xuICAgICAgICBpZiAoaW5uZXJXaWR0aCA8IDEwKSB7XG4gICAgICAgICAgICB3aWR0aCArPSAoMTAgLSBpbm5lcldpZHRoKTtcbiAgICAgICAgICAgIGlubmVyV2lkdGggKz0gKDEwIC0gaW5uZXJXaWR0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgIHdvcmRXcmFwV2lkdGggPSBpbm5lcldpZHRoXG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXh0IG92ZXJmbG93XG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy50ZXh0T3ZlcmZsb3cgJiYgIXRoaXMuX3NldHRpbmdzLndvcmRXcmFwKSB7XG4gICAgICAgICAgICBsZXQgc3VmZml4O1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9zZXR0aW5ncy50ZXh0T3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjbGlwJzpcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VsbGlwc2lzJzpcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5fc2V0dGluZ3MubWF4TGluZXNTdWZmaXg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCA9IHRoaXMuX3NldHRpbmdzLnRleHRPdmVyZmxvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldHRpbmdzLnRleHQgPSB0aGlzLndyYXBXb3JkKHRoaXMuX3NldHRpbmdzLnRleHQsIHdvcmRXcmFwV2lkdGggLSB0ZXh0SW5kZW50LCBzdWZmaXgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3b3JkIHdyYXBcbiAgICAgICAgLy8gcHJlc2VydmUgb3JpZ2luYWwgdGV4dFxuICAgICAgICBsZXQgbGluZXNJbmZvO1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Mud29yZFdyYXApIHtcbiAgICAgICAgICAgIGxpbmVzSW5mbyA9IHRoaXMud3JhcFRleHQodGhpcy5fc2V0dGluZ3MudGV4dCwgd29yZFdyYXBXaWR0aCwgbGV0dGVyU3BhY2luZywgdGV4dEluZGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lc0luZm8gPSB7bDogdGhpcy5fc2V0dGluZ3MudGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyksIG46IFtdfTtcbiAgICAgICAgICAgIGxldCBpLCBuID0gbGluZXNJbmZvLmwubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZXNJbmZvLm4ucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGluZXMgPSBsaW5lc0luZm8ubDtcblxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MubWF4TGluZXMgJiYgbGluZXMubGVuZ3RoID4gdGhpcy5fc2V0dGluZ3MubWF4TGluZXMpIHtcbiAgICAgICAgICAgIGxldCB1c2VkTGluZXMgPSBsaW5lcy5zbGljZSgwLCB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lcyk7XG5cbiAgICAgICAgICAgIGxldCBvdGhlckxpbmVzID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5tYXhMaW5lc1N1ZmZpeCkge1xuICAgICAgICAgICAgICAgIC8vIFdyYXAgYWdhaW4gd2l0aCBtYXggbGluZXMgc3VmZml4IGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgbGV0IHcgPSB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lc1N1ZmZpeCA/IHRoaXMubWVhc3VyZVRleHQodGhpcy5fc2V0dGluZ3MubWF4TGluZXNTdWZmaXgpIDogMDtcbiAgICAgICAgICAgICAgICBsZXQgYWwgPSB0aGlzLndyYXBUZXh0KHVzZWRMaW5lc1t1c2VkTGluZXMubGVuZ3RoIC0gMV0sIHdvcmRXcmFwV2lkdGggLSB3LCBsZXR0ZXJTcGFjaW5nLCB0ZXh0SW5kZW50KTtcbiAgICAgICAgICAgICAgICB1c2VkTGluZXNbdXNlZExpbmVzLmxlbmd0aCAtIDFdID0gYWwubFswXSArIHRoaXMuX3NldHRpbmdzLm1heExpbmVzU3VmZml4O1xuICAgICAgICAgICAgICAgIG90aGVyTGluZXMgPSBbYWwubC5sZW5ndGggPiAxID8gYWwubFsxXSA6ICcnXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3RoZXJMaW5lcyA9IFsnJ107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlLWFzc2VtYmxlIHRoZSByZW1haW5pbmcgdGV4dC5cbiAgICAgICAgICAgIGxldCBpLCBuID0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgbGV0IG0gPSBsaW5lc0luZm8ubi5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lczsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIG90aGVyTGluZXNbal0gKz0gKG90aGVyTGluZXNbal0gPyBcIiBcIiA6IFwiXCIpICsgbGluZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGkgKyAxIDwgbSAmJiBsaW5lc0luZm8ubltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVySW5mby5yZW1haW5pbmdUZXh0ID0gb3RoZXJMaW5lcy5qb2luKFwiXFxuXCIpO1xuXG4gICAgICAgICAgICByZW5kZXJJbmZvLm1vcmVUZXh0TGluZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICBsaW5lcyA9IHVzZWRMaW5lcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlckluZm8ubW9yZVRleHRMaW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgcmVuZGVySW5mby5yZW1haW5pbmdUZXh0ID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0ZXh0IHdpZHRoXG4gICAgICAgIGxldCBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgICBsZXQgbGluZVdpZHRocyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbGluZVdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChsaW5lc1tpXSwgbGV0dGVyU3BhY2luZykgKyAoaSA9PT0gMCA/IHRleHRJbmRlbnQgOiAwKTtcbiAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVySW5mby5saW5lV2lkdGhzID0gbGluZVdpZHRocztcblxuICAgICAgICBpZiAoIXcpIHtcbiAgICAgICAgICAgIC8vIEF1dG8tc2V0IHdpZHRoIHRvIG1heCB0ZXh0IGxlbmd0aC5cbiAgICAgICAgICAgIHdpZHRoID0gbWF4TGluZVdpZHRoICsgcGFkZGluZ0xlZnQgKyBwYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgICBpbm5lcldpZHRoID0gbWF4TGluZVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRleHQgaGVpZ2h0XG4gICAgICAgIGxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0IHx8IGZvbnRTaXplO1xuXG4gICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYmFzZWxpbmVPZmZzZXQgPSAodGhpcy5fc2V0dGluZ3MudGV4dEJhc2VsaW5lICE9ICdib3R0b20nKSA/IDAuNSAqIGZvbnRTaXplIDogMDtcbiAgICAgICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQgKiAobGluZXMubGVuZ3RoIC0gMSkgKyBiYXNlbGluZU9mZnNldCArIE1hdGgubWF4KGxpbmVIZWlnaHQsIGZvbnRTaXplKSArIG9mZnNldFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0WSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2Zmc2V0WSA9IGZvbnRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVySW5mby53ID0gd2lkdGg7XG4gICAgICAgIHJlbmRlckluZm8uaCA9IGhlaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5saW5lcyA9IGxpbmVzO1xuICAgICAgICByZW5kZXJJbmZvLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcblxuICAgICAgICBpZiAoIXdpZHRoKSB7XG4gICAgICAgICAgICAvLyBUbyBwcmV2ZW50IGNhbnZhcyBlcnJvcnMuXG4gICAgICAgICAgICB3aWR0aCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gVG8gcHJldmVudCBjYW52YXMgZXJyb3JzLlxuICAgICAgICAgICAgaGVpZ2h0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXRTeCB8fCBjdXRFeCkge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLm1pbih3aWR0aCwgY3V0RXggLSBjdXRTeCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3V0U3kgfHwgY3V0RXkpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWluKGhlaWdodCwgY3V0RXkgLSBjdXRTeSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJJbmZvLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlbmRlckluZm8uaW5uZXJXaWR0aCA9IGlubmVyV2lkdGg7XG4gICAgICAgIHJlbmRlckluZm8uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHJlbmRlckluZm8uY3V0U3ggPSBjdXRTeDtcbiAgICAgICAgcmVuZGVySW5mby5jdXRTeSA9IGN1dFN5O1xuICAgICAgICByZW5kZXJJbmZvLmN1dEV4ID0gY3V0RXg7XG4gICAgICAgIHJlbmRlckluZm8uY3V0RXkgPSBjdXRFeTtcbiAgICAgICAgcmVuZGVySW5mby5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5saW5lV2lkdGhzID0gbGluZVdpZHRocztcbiAgICAgICAgcmVuZGVySW5mby5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICAgICAgcmVuZGVySW5mby5wYWRkaW5nTGVmdCA9IHBhZGRpbmdMZWZ0O1xuICAgICAgICByZW5kZXJJbmZvLnBhZGRpbmdSaWdodCA9IHBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZztcbiAgICAgICAgcmVuZGVySW5mby50ZXh0SW5kZW50ID0gdGV4dEluZGVudDtcblxuICAgICAgICByZXR1cm4gcmVuZGVySW5mbztcbiAgICB9XG5cbiAgICBfZHJhdygpIHtcbiAgICAgICAgY29uc3QgcmVuZGVySW5mbyA9IHRoaXMuX2NhbGN1bGF0ZVJlbmRlckluZm8oKTtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5nZXRQcmVjaXNpb24oKTtcblxuICAgICAgICAvLyBBZGQgZXh0cmEgbWFyZ2luIHRvIHByZXZlbnQgaXNzdWUgd2l0aCBjbGlwcGVkIHRleHQgd2hlbiBzY2FsaW5nLlxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBNYXRoLmNlaWwocmVuZGVySW5mby53aWR0aCArIHRoaXMuX3N0YWdlLmdldE9wdGlvbigndGV4dFJlbmRlcklzc3VlTWFyZ2luJykpO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKHJlbmRlckluZm8uaGVpZ2h0KTtcblxuICAgICAgICAvLyBDYW52YXMgY29udGV4dCBoYXMgYmVlbiByZXNldC5cbiAgICAgICAgdGhpcy5zZXRGb250UHJvcGVydGllcygpO1xuXG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmZvbnRTaXplID49IDEyOCkge1xuICAgICAgICAgICAgLy8gV3BlV2ViS2l0IGJ1ZzogbXVzdCBmb3JjZSBjb21wb3NpdGluZyBiZWNhdXNlIGNhaXJvLXRyYXBzLWNvbXBvc2l0b3Igd2lsbCBub3Qgd29yayB3aXRoIHRleHQgZmlyc3QuXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0Lmdsb2JhbEFscGhhID0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoMCwgMCwgMC4wMSwgMC4wMSk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0Lmdsb2JhbEFscGhhID0gMS4wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlckluZm8uY3V0U3ggfHwgcmVuZGVySW5mby5jdXRTeSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUoLXJlbmRlckluZm8uY3V0U3gsIC1yZW5kZXJJbmZvLmN1dFN5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsaW5lUG9zaXRpb25YO1xuICAgICAgICBsZXQgbGluZVBvc2l0aW9uWTtcblxuICAgICAgICBsZXQgZHJhd0xpbmVzID0gW107XG5cbiAgICAgICAgLy8gRHJhdyBsaW5lcyBsaW5lIGJ5IGxpbmUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gcmVuZGVySW5mby5saW5lcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBpID09PSAwID8gcmVuZGVySW5mby50ZXh0SW5kZW50IDogMDtcblxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGV4dCBpcyBhbGlnbmVkIHRvIHRvcFxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9IChpICogcmVuZGVySW5mby5saW5lSGVpZ2h0KSArIHJlbmRlckluZm8ub2Zmc2V0WTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnZlcnRpY2FsQWxpZ24gPT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25ZICs9IChyZW5kZXJJbmZvLmxpbmVIZWlnaHQgLSByZW5kZXJJbmZvLmZvbnRTaXplKSAvIDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3NldHRpbmdzLnZlcnRpY2FsQWxpZ24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25ZICs9IHJlbmRlckluZm8ubGluZUhlaWdodCAtIHJlbmRlckluZm8uZm9udFNpemU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy50ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IChyZW5kZXJJbmZvLmlubmVyV2lkdGggLSByZW5kZXJJbmZvLmxpbmVXaWR0aHNbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9zZXR0aW5ncy50ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgbGluZVBvc2l0aW9uWCArPSAoKHJlbmRlckluZm8uaW5uZXJXaWR0aCAtIHJlbmRlckluZm8ubGluZVdpZHRoc1tpXSkgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gcmVuZGVySW5mby5wYWRkaW5nTGVmdDtcblxuICAgICAgICAgICAgZHJhd0xpbmVzLnB1c2goe3RleHQ6IHJlbmRlckluZm8ubGluZXNbaV0sIHg6IGxpbmVQb3NpdGlvblgsIHk6IGxpbmVQb3NpdGlvblksIHc6IHJlbmRlckluZm8ubGluZVdpZHRoc1tpXX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGlnaGxpZ2h0LlxuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgY29sb3IgPSB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRDb2xvciB8fCAweDAwMDAwMDAwO1xuXG4gICAgICAgICAgICBsZXQgaGxIZWlnaHQgPSAodGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0SGVpZ2h0ICogcHJlY2lzaW9uIHx8IHJlbmRlckluZm8uZm9udFNpemUgKiAxLjUpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0T2Zmc2V0ICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgY29uc3QgaGxQYWRkaW5nTGVmdCA9ICh0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRQYWRkaW5nTGVmdCAhPT0gbnVsbCA/IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ICogcHJlY2lzaW9uIDogcmVuZGVySW5mby5wYWRkaW5nTGVmdCk7XG4gICAgICAgICAgICBjb25zdCBobFBhZGRpbmdSaWdodCA9ICh0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRQYWRkaW5nUmlnaHQgIT09IG51bGwgPyB0aGlzLl9zZXR0aW5ncy5oaWdobGlnaHRQYWRkaW5nUmlnaHQgKiBwcmVjaXNpb24gOiByZW5kZXJJbmZvLnBhZGRpbmdSaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKGNvbG9yKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhd0xpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRyYXdMaW5lID0gZHJhd0xpbmVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QoKGRyYXdMaW5lLnggLSBobFBhZGRpbmdMZWZ0KSwgKGRyYXdMaW5lLnkgLSByZW5kZXJJbmZvLm9mZnNldFkgKyBvZmZzZXQpLCAoZHJhd0xpbmUudyArIGhsUGFkZGluZ1JpZ2h0ICsgaGxQYWRkaW5nTGVmdCksIGhsSGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRleHQgc2hhZG93LlxuICAgICAgICBsZXQgcHJldlNoYWRvd1NldHRpbmdzID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3NldHRpbmdzLnNoYWRvdykge1xuICAgICAgICAgICAgcHJldlNoYWRvd1NldHRpbmdzID0gW3RoaXMuX2NvbnRleHQuc2hhZG93Q29sb3IsIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WCwgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRZLCB0aGlzLl9jb250ZXh0LnNoYWRvd0JsdXJdO1xuXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0NvbG9yID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHRoaXMuX3NldHRpbmdzLnNoYWRvd0NvbG9yKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd09mZnNldFggKiBwcmVjaXNpb247XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFkgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dPZmZzZXRZICogcHJlY2lzaW9uO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dCbHVyID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93Qmx1ciAqIHByZWNpc2lvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFN0eWxlID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHRoaXMuX3NldHRpbmdzLnRleHRDb2xvcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gZHJhd0xpbmVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IGRyYXdMaW5lID0gZHJhd0xpbmVzW2ldO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVySW5mby5sZXR0ZXJTcGFjaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dChkcmF3TGluZS50ZXh0LCBkcmF3TGluZS54LCBkcmF3TGluZS55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dFNwbGl0ID0gZHJhd0xpbmUudGV4dC5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgbGV0IHggPSBkcmF3TGluZS54O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gdGV4dFNwbGl0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxUZXh0KHRleHRTcGxpdFtpXSwgeCwgZHJhd0xpbmUueSk7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gdGhpcy5tZWFzdXJlVGV4dCh0ZXh0U3BsaXRbaV0sIHJlbmRlckluZm8ubGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZTaGFkb3dTZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dDb2xvciA9IHByZXZTaGFkb3dTZXR0aW5nc1swXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHByZXZTaGFkb3dTZXR0aW5nc1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WSA9IHByZXZTaGFkb3dTZXR0aW5nc1syXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Qmx1ciA9IHByZXZTaGFkb3dTZXR0aW5nc1szXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJJbmZvLmN1dFN4IHx8IHJlbmRlckluZm8uY3V0U3kpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQudHJhbnNsYXRlKHJlbmRlckluZm8uY3V0U3gsIHJlbmRlckluZm8uY3V0U3kpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXJJbmZvID0gcmVuZGVySW5mbztcbiAgICB9O1xuXG4gICAgd3JhcFdvcmQod29yZCwgd29yZFdyYXBXaWR0aCwgc3VmZml4KSB7XG4gICAgICAgIGNvbnN0IHN1ZmZpeFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChzdWZmaXgpLndpZHRoO1xuICAgICAgICBjb25zdCB3b3JkTGVuID0gd29yZC5sZW5ndGhcbiAgICAgICAgY29uc3Qgd29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkKS53aWR0aDtcblxuICAgICAgICAvKiBJZiB3b3JkIGZpdHMgd3JhcFdpZHRoLCBkbyBub3RoaW5nICovXG4gICAgICAgIGlmICh3b3JkV2lkdGggPD0gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHdvcmQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBNYWtlIGluaXRpYWwgZ3Vlc3MgZm9yIHRleHQgY3V0dG9mZiAqL1xuICAgICAgICBsZXQgY3V0b2ZmSW5kZXggPSBNYXRoLmZsb29yKCh3b3JkV3JhcFdpZHRoICogd29yZExlbikgLyB3b3JkV2lkdGgpO1xuICAgICAgICBsZXQgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSkud2lkdGggKyBzdWZmaXhXaWR0aDtcblxuICAgICAgICAvKiBJbiBjYXNlIGd1ZXNzIHdhcyBvdmVyZXN0aW1hdGVkLCBzaHJpbmsgaXQgbGV0dGVyIGJ5IGxldHRlci4gKi9cbiAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgd2hpbGUgKGN1dG9mZkluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRydW5jV29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkpLndpZHRoICsgc3VmZml4V2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRvZmZJbmRleCAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAvKiBJbiBjYXNlIGd1ZXNzIHdhcyB1bmRlcmVzdGltYXRlZCwgZXh0ZW5kIGl0IGxldHRlciBieSBsZXR0ZXIuICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoY3V0b2ZmSW5kZXggPCB3b3JkTGVuKSB7XG4gICAgICAgICAgICAgICAgdHJ1bmNXb3JkV2lkdGggPSB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSkud2lkdGggKyBzdWZmaXhXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAodHJ1bmNXb3JkV2lkdGggPCB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1dG9mZkluZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseSwgd2hlbiBib3VuZCBpcyBjcm9zc2VkLCByZXRyYWN0IGxhc3QgbGV0dGVyLlxuICAgICAgICAgICAgICAgICAgICBjdXRvZmZJbmRleCAtPTE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIElmIHdyYXBXaWR0aCBpcyB0b28gc2hvcnQgdG8gZXZlbiBjb250YWluIHN1ZmZpeCBhbG9uZSwgcmV0dXJuIGVtcHR5IHN0cmluZyAqL1xuICAgICAgICByZXR1cm4gd29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpICsgKHdvcmRXcmFwV2lkdGggPj0gc3VmZml4V2lkdGggPyBzdWZmaXggOiAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBuZXdsaW5lcyB0byBhIHN0cmluZyB0byBoYXZlIGl0IG9wdGltYWxseSBmaXQgaW50byB0aGUgaG9yaXpvbnRhbFxuICAgICAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB3cmFwVGV4dCh0ZXh0LCB3b3JkV3JhcFdpZHRoLCBsZXR0ZXJTcGFjaW5nLCBpbmRlbnQgPSAwKSB7XG4gICAgICAgIC8vIEdyZWVkeSB3cmFwcGluZyBhbGdvcml0aG0gdGhhdCB3aWxsIHdyYXAgd29yZHMgYXMgdGhlIGxpbmUgZ3Jvd3MgbG9uZ2VyLlxuICAgICAgICAvLyB0aGFuIGl0cyBob3Jpem9udGFsIGJvdW5kcy5cbiAgICAgICAgbGV0IGxpbmVzID0gdGV4dC5zcGxpdCgvXFxyP1xcbi9nKTtcbiAgICAgICAgbGV0IGFsbExpbmVzID0gW107XG4gICAgICAgIGxldCByZWFsTmV3bGluZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdExpbmVzID0gW107XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBsZXQgc3BhY2VMZWZ0ID0gd29yZFdyYXBXaWR0aCAtIGluZGVudDtcbiAgICAgICAgICAgIGxldCB3b3JkcyA9IGxpbmVzW2ldLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdvcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dCh3b3Jkc1tqXSwgbGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZFdpZHRoV2l0aFNwYWNlID0gd29yZFdpZHRoICsgdGhpcy5tZWFzdXJlVGV4dCgnICcsbGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDAgfHwgd29yZFdpZHRoV2l0aFNwYWNlID4gc3BhY2VMZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcHJpbnRpbmcgdGhlIG5ld2xpbmUgaWYgaXQncyB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgbGluZSB0aGF0IGlzLlxuICAgICAgICAgICAgICAgICAgICAvLyBncmVhdGVyIHRoYW4gdGhlIHdvcmQgd3JhcCB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gd29yZHNbal07XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlTGVmdCA9IHdvcmRXcmFwV2lkdGggLSB3b3JkV2lkdGggLSAoaiA9PT0gMCA/IGluZGVudCA6IDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3BhY2VMZWZ0IC09IHdvcmRXaWR0aFdpdGhTcGFjZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgJyArIHdvcmRzW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICAgICAgICAgIGFsbExpbmVzID0gYWxsTGluZXMuY29uY2F0KHJlc3VsdExpbmVzKTtcblxuICAgICAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcmVhbE5ld2xpbmVzLnB1c2goYWxsTGluZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7bDogYWxsTGluZXMsIG46IHJlYWxOZXdsaW5lc307XG4gICAgfTtcblxuICAgIG1lYXN1cmVUZXh0KHdvcmQsIHNwYWNlID0gMCkge1xuICAgICAgICBpZiAoIXNwYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkKS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd29yZC5zcGxpdCgnJykucmVkdWNlKChhY2MsIGNoYXIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MgKyB0aGlzLl9jb250ZXh0Lm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoICsgc3BhY2U7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuLi90cmVlL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHRUZXh0dXJlUmVuZGVyZXJBZHZhbmNlZCB7XG5cbiAgICBjb25zdHJ1Y3RvcihzdGFnZSwgY2FudmFzLCBzZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9zdGFnZSA9IHN0YWdlO1xuICAgICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG5cbiAgICBnZXRQcmVjaXNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXR0aW5ncy5wcmVjaXNpb247XG4gICAgfTtcblxuICAgIHNldEZvbnRQcm9wZXJ0aWVzKCkge1xuICAgICAgICBjb25zdCBmb250ID0gVXRpbHMuaXNTcGFyayA/IHRoaXMuX3N0YWdlLnBsYXRmb3JtLmdldEZvbnRTZXR0aW5nKHRoaXMpIDogdGhpcy5fZ2V0Rm9udFNldHRpbmcoKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgICAgdGhpcy5fY29udGV4dC50ZXh0QmFzZWxpbmUgPSB0aGlzLl9zZXR0aW5ncy50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHJldHVybiBmb250O1xuICAgIH07XG5cbiAgICBfZ2V0Rm9udFNldHRpbmcoKSB7XG4gICAgICAgIGxldCBmZiA9IHRoaXMuX3NldHRpbmdzLmZvbnRGYWNlO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShmZikpIHtcbiAgICAgICAgICAgIGZmID0gW2ZmXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmZnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBmZi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmZltpXSA9PT0gXCJzZXJpZlwiIHx8IGZmW2ldID09PSBcInNhbnMtc2VyaWZcIikge1xuICAgICAgICAgICAgICAgIGZmcy5wdXNoKGZmW2ldKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmZzLnB1c2goYFwiJHtmZltpXX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuX3NldHRpbmdzLmZvbnRTdHlsZX0gJHt0aGlzLl9zZXR0aW5ncy5mb250U2l6ZSAqIHRoaXMuZ2V0UHJlY2lzaW9uKCl9cHggJHtmZnMuam9pbihcIixcIil9YFxuICAgIH1cblxuICAgIF9sb2FkKCkge1xuICAgICAgICBpZiAoVXRpbHMuaXNXZWIgJiYgZG9jdW1lbnQuZm9udHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbnRTZXR0aW5nID0gdGhpcy5fZ2V0Rm9udFNldHRpbmcoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5mb250cy5jaGVjayhmb250U2V0dGluZywgdGhpcy5fc2V0dGluZ3MudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgcHJvbWlzZSB0aGF0IHdhaXRzIGZvciBsb2FkaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZm9udHMubG9hZChmb250U2V0dGluZywgdGhpcy5fc2V0dGluZ3MudGV4dCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgbG9hZCB0aGUgZmFsbGJhY2sgZm9udC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRm9udCBsb2FkIGVycm9yJywgZXJyLCBmb250U2V0dGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5mb250cy5jaGVjayhmb250U2V0dGluZywgdGhpcy5fc2V0dGluZ3MudGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ZvbnQgbm90IGZvdW5kJywgZm9udFNldHRpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW4ndCBjaGVjayBmb250IGxvYWRpbmcgZm9yIFwiICsgZm9udFNldHRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHJhdygpIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIHByb21pc2Ugc28gdGhhdCBsb2FkaW5nIGlzIHBlcmZvcm1lZCBzeW5jcm9ub3VzIHdoZW4gcG9zc2libGUuXG4gICAgICAgIGNvbnN0IGxvYWRQcm9taXNlID0gdGhpcy5fbG9hZCgpO1xuICAgICAgICBpZiAoIWxvYWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuaXNTcGFyayA/IHRoaXMuX3N0YWdlLnBsYXRmb3JtLmRyYXdUZXh0KHRoaXMpIDogdGhpcy5fZHJhdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvYWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5pc1NwYXJrID8gdGhpcy5fc3RhZ2UucGxhdGZvcm0uZHJhd1RleHQodGhpcykgOiB0aGlzLl9kcmF3KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jYWxjdWxhdGVSZW5kZXJJbmZvKCkge1xuICAgICAgICBsZXQgcmVuZGVySW5mbyA9IHt9O1xuXG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IHRoaXMuZ2V0UHJlY2lzaW9uKCk7XG5cbiAgICAgICAgY29uc3QgcGFkZGluZ0xlZnQgPSB0aGlzLl9zZXR0aW5ncy5wYWRkaW5nTGVmdCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcGFkZGluZ1JpZ2h0ID0gdGhpcy5fc2V0dGluZ3MucGFkZGluZ1JpZ2h0ICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3NldHRpbmdzLmZvbnRTaXplICogcHJlY2lzaW9uO1xuICAgICAgICAvLyBjb25zdCBvZmZzZXRZID0gdGhpcy5fc2V0dGluZ3Mub2Zmc2V0WSA9PT0gbnVsbCA/IG51bGwgOiAodGhpcy5fc2V0dGluZ3Mub2Zmc2V0WSAqIHByZWNpc2lvbik7XG4gICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB0aGlzLl9zZXR0aW5ncy5saW5lSGVpZ2h0ICogcHJlY2lzaW9uIHx8IGZvbnRTaXplO1xuICAgICAgICBjb25zdCB3ID0gdGhpcy5fc2V0dGluZ3MudyAhPSAwID8gdGhpcy5fc2V0dGluZ3MudyAqIHByZWNpc2lvbiA6IDIwNDggLyBwcmVjaXNpb247XG4gICAgICAgIC8vIGNvbnN0IGggPSB0aGlzLl9zZXR0aW5ncy5oICogcHJlY2lzaW9uO1xuICAgICAgICBjb25zdCB3b3JkV3JhcFdpZHRoID0gdGhpcy5fc2V0dGluZ3Mud29yZFdyYXBXaWR0aCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0U3ggPSB0aGlzLl9zZXR0aW5ncy5jdXRTeCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0RXggPSB0aGlzLl9zZXR0aW5ncy5jdXRFeCAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0U3kgPSB0aGlzLl9zZXR0aW5ncy5jdXRTeSAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgY3V0RXkgPSB0aGlzLl9zZXR0aW5ncy5jdXRFeSAqIHByZWNpc2lvbjtcbiAgICAgICAgY29uc3QgbGV0dGVyU3BhY2luZyA9IHRoaXMuX3NldHRpbmdzLmxldHRlclNwYWNpbmcgfHwgMDtcblxuICAgICAgICAvLyBTZXQgZm9udCBwcm9wZXJ0aWVzLlxuICAgICAgICByZW5kZXJJbmZvLmJhc2VGb250ID0gdGhpcy5zZXRGb250UHJvcGVydGllcygpO1xuXG4gICAgICAgIHJlbmRlckluZm8udyA9IHc7XG4gICAgICAgIHJlbmRlckluZm8ud2lkdGggPSB3O1xuICAgICAgICByZW5kZXJJbmZvLnRleHQgPSB0aGlzLl9zZXR0aW5ncy50ZXh0O1xuICAgICAgICByZW5kZXJJbmZvLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgICAgcmVuZGVySW5mby5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICByZW5kZXJJbmZvLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmxldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICByZW5kZXJJbmZvLnRleHRBbGlnbiA9IHRoaXMuX3NldHRpbmdzLnRleHRBbGlnbjtcbiAgICAgICAgcmVuZGVySW5mby50ZXh0Q29sb3IgPSB0aGlzLl9zZXR0aW5ncy50ZXh0Q29sb3I7XG4gICAgICAgIHJlbmRlckluZm8udmVydGljYWxBbGlnbiA9IHRoaXMuX3NldHRpbmdzLnZlcnRpY2FsQWxpZ247XG4gICAgICAgIHJlbmRlckluZm8uaGlnaGxpZ2h0ID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmhpZ2hsaWdodENvbG9yID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0Q29sb3I7XG4gICAgICAgIHJlbmRlckluZm8uaGlnaGxpZ2h0SGVpZ2h0ID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0SGVpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0UGFkZGluZ0xlZnQ7XG4gICAgICAgIHJlbmRlckluZm8uaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ID0gdGhpcy5fc2V0dGluZ3MuaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0O1xuICAgICAgICByZW5kZXJJbmZvLmhpZ2hsaWdodE9mZnNldCA9IHRoaXMuX3NldHRpbmdzLmhpZ2hsaWdodE9mZnNldDtcbiAgICAgICAgcmVuZGVySW5mby5wYWRkaW5nTGVmdCA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdMZWZ0O1xuICAgICAgICByZW5kZXJJbmZvLnBhZGRpbmdSaWdodCA9IHRoaXMuX3NldHRpbmdzLnBhZGRpbmdSaWdodDtcbiAgICAgICAgcmVuZGVySW5mby5tYXhMaW5lcyA9IHRoaXMuX3NldHRpbmdzLm1heExpbmVzO1xuICAgICAgICByZW5kZXJJbmZvLm1heExpbmVzU3VmZml4ID0gdGhpcy5fc2V0dGluZ3MubWF4TGluZXNTdWZmaXg7XG4gICAgICAgIHJlbmRlckluZm8udGV4dE92ZXJmbG93ID0gdGhpcy5fc2V0dGluZ3MudGV4dE92ZXJmbG93O1xuICAgICAgICByZW5kZXJJbmZvLndvcmRXcmFwID0gdGhpcy5fc2V0dGluZ3Mud29yZFdyYXA7XG4gICAgICAgIHJlbmRlckluZm8ud29yZFdyYXBXaWR0aCA9IHdvcmRXcmFwV2lkdGg7XG4gICAgICAgIHJlbmRlckluZm8uc2hhZG93ID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93O1xuICAgICAgICByZW5kZXJJbmZvLnNoYWRvd0NvbG9yID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93Q29sb3I7XG4gICAgICAgIHJlbmRlckluZm8uc2hhZG93T2Zmc2V0WCA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd09mZnNldFg7XG4gICAgICAgIHJlbmRlckluZm8uc2hhZG93T2Zmc2V0WSA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd09mZnNldFk7XG4gICAgICAgIHJlbmRlckluZm8uc2hhZG93Qmx1ciA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd0JsdXI7XG4gICAgICAgIHJlbmRlckluZm8uY3V0U3ggPSBjdXRTeDtcbiAgICAgICAgcmVuZGVySW5mby5jdXRFeCA9IGN1dEV4O1xuICAgICAgICByZW5kZXJJbmZvLmN1dFN5ID0gY3V0U3k7XG4gICAgICAgIHJlbmRlckluZm8uY3V0RXkgPSBjdXRFeTtcbiAgICAgICAgcmVuZGVySW5mby50ZXh0SW5kZW50ID0gdGhpcy5fc2V0dGluZ3MudGV4dEluZGVudCAqIHByZWNpc2lvbjtcbiAgICAgICAgcmVuZGVySW5mby53b3JkQnJlYWsgPSB0aGlzLl9zZXR0aW5ncy53b3JkQnJlYWs7XG5cbiAgICAgICAgbGV0IHRleHQgPSByZW5kZXJJbmZvLnRleHQ7XG4gICAgICAgIGxldCB3cmFwV2lkdGggPSByZW5kZXJJbmZvLndvcmRXcmFwID8gKHJlbmRlckluZm8ud29yZFdyYXBXaWR0aCB8fCByZW5kZXJJbmZvLndpZHRoKSA6IHJlbmRlckluZm8ud2lkdGg7XG5cbiAgICAgICAgLy8gVGV4dCBvdmVyZmxvd1xuICAgICAgICBpZiAocmVuZGVySW5mby50ZXh0T3ZlcmZsb3cgJiYgIXJlbmRlckluZm8ud29yZFdyYXApIHtcbiAgICAgICAgICAgIGxldCBzdWZmaXg7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3NldHRpbmdzLnRleHRPdmVyZmxvdykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NsaXAnOlxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZWxsaXBzaXMnOlxuICAgICAgICAgICAgICAgICAgICBzdWZmaXggPSB0aGlzLl9zZXR0aW5ncy5tYXhMaW5lc1N1ZmZpeDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5fc2V0dGluZ3MudGV4dE92ZXJmbG93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dCA9IHRoaXMud3JhcFdvcmQodGV4dCwgd29yZFdyYXBXaWR0aCB8fCByZW5kZXJJbmZvLncsIHN1ZmZpeCk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ID0gdGhpcy50b2tlbml6ZSh0ZXh0KTtcbiAgICAgICAgdGV4dCA9IHRoaXMucGFyc2UodGV4dCk7XG4gICAgICAgIHRleHQgPSB0aGlzLm1lYXN1cmUodGV4dCwgbGV0dGVyU3BhY2luZywgcmVuZGVySW5mby5iYXNlRm9udCk7XG5cbiAgICAgICAgaWYgKHJlbmRlckluZm8udGV4dEluZGVudCkge1xuICAgICAgICAgICAgdGV4dCA9IHRoaXMuaW5kZW50KHRleHQsIHJlbmRlckluZm8udGV4dEluZGVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVySW5mby53b3JkQnJlYWspIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlZHVjZSgoYWNjLCB0KSA9PiBhY2MuY29uY2F0KHRoaXMud29yZEJyZWFrKHQsIHdyYXBXaWR0aCwgcmVuZGVySW5mby5iYXNlRm9udCkpLCBbXSlcbiAgICAgICAgICAgIHRoaXMucmVzZXRGb250U3R5bGUoKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRldGFpbGVkIGRyYXdpbmcgaW5mb3JtYXRpb25cbiAgICAgICAgbGV0IHggPSBwYWRkaW5nTGVmdDtcbiAgICAgICAgbGV0IGxpbmVObyA9IDA7XG5cbiAgICAgICAgZm9yIChjb25zdCB0IG9mIHRleHQpIHtcbiAgICAgICAgICAgIC8vIFdyYXAgdGV4dFxuICAgICAgICAgICAgaWYgKHJlbmRlckluZm8ud29yZFdyYXAgJiYgeCArIHQud2lkdGggPiB3cmFwV2lkdGggfHwgdC50ZXh0ID09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgeCA9IHBhZGRpbmdMZWZ0O1xuICAgICAgICAgICAgICAgIGxpbmVObyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdC5saW5lTm8gPSBsaW5lTm87XG5cbiAgICAgICAgICAgIGlmICh0LnRleHQgPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdC54ID0geDtcbiAgICAgICAgICAgIHggKz0gdC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJJbmZvLmxpbmVOdW0gPSBsaW5lTm8gKyAxO1xuXG4gICAgICAgIC8vIFZlcnRpY2FsIGFsaWduXG4gICAgICAgIGxldCB2YU9mZnNldCA9IDA7XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLnZlcnRpY2FsQWxpZ24gPT0gJ21pZGRsZScpIHtcbiAgICAgICAgICAgIHZhT2Zmc2V0ICs9IChyZW5kZXJJbmZvLmxpbmVIZWlnaHQgLSByZW5kZXJJbmZvLmZvbnRTaXplKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc2V0dGluZ3MudmVydGljYWxBbGlnbiA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgdmFPZmZzZXQgKz0gcmVuZGVySW5mby5saW5lSGVpZ2h0IC0gcmVuZGVySW5mby5mb250U2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBsaW5lcyBpbmZvcm1hdGlvblxuICAgICAgICByZW5kZXJJbmZvLmxpbmVzID0gW11cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJJbmZvLmxpbmVOdW07IGkrKykge1xuICAgICAgICAgICAgcmVuZGVySW5mby5saW5lc1tpXSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IHJlbmRlckluZm8ubGluZUhlaWdodCAqIGkgKyB2YU9mZnNldCxcbiAgICAgICAgICAgICAgICB0ZXh0OiBbXSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHQgb2YgdGV4dCkge1xuICAgICAgICAgICAgcmVuZGVySW5mby5saW5lc1t0LmxpbmVOb10udGV4dC5wdXNoKHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlsdGVyIG91dCB3aGl0ZSBzcGFjZXMgYXQgYmVnaW5uaW5nIGFuZCBlbmQgb2YgZWFjaCBsaW5lXG4gICAgICAgIGZvciAoY29uc3QgbCBvZiByZW5kZXJJbmZvLmxpbmVzKSB7XG4gICAgICAgICAgICBpZiAobC50ZXh0Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0V29yZCA9IGwudGV4dFswXS50ZXh0O1xuICAgICAgICAgICAgY29uc3QgbGFzdFdvcmQgPSBsLnRleHRbbC50ZXh0Lmxlbmd0aCAtIDFdLnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChmaXJzdFdvcmQgPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBsLnRleHQuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0V29yZCA9PSAnICcgfHwgbGFzdFdvcmQgPT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBsLnRleHQucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBsaW5lIHdpZHRoXG4gICAgICAgIGZvciAobGV0IGwgb2YgcmVuZGVySW5mby5saW5lcykge1xuICAgICAgICAgICAgbC53aWR0aCA9IGwudGV4dC5yZWR1Y2UoKGFjYywgdCkgPT4gYWNjICsgdC53aWR0aCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZW5kZXJJbmZvLndpZHRoID0gdGhpcy5fc2V0dGluZ3MudyAhPSAwID8gdGhpcy5fc2V0dGluZ3MudyAqIHByZWNpc2lvbiA6IE1hdGgubWF4KC4uLnJlbmRlckluZm8ubGluZXMubWFwKChsKSA9PiBsLndpZHRoKSkgKyBwYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlbmRlckluZm8udyA9IHJlbmRlckluZm8ud2lkdGg7XG5cbiAgICAgICAgLy8gQXBwbHkgbWF4TGluZXNTdWZmaXhcbiAgICAgICAgaWYgKHJlbmRlckluZm8ubWF4TGluZXMgJiYgcmVuZGVySW5mby5saW5lTnVtID4gcmVuZGVySW5mby5tYXhMaW5lcyAmJiByZW5kZXJJbmZvLm1heExpbmVzU3VmZml4KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHJlbmRlckluZm8ubWF4TGluZXMgLSAxO1xuICAgICAgICAgICAgbGV0IGxhc3RMaW5lVGV4dCA9IHRleHQuZmlsdGVyKCh0KSA9PiB0LmxpbmVObyA9PSBpbmRleClcbiAgICAgICAgICAgIGxldCBzdWZmaXggPSByZW5kZXJJbmZvLm1heExpbmVzU3VmZml4O1xuICAgICAgICAgICAgc3VmZml4ID0gdGhpcy50b2tlbml6ZShzdWZmaXgpO1xuICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5wYXJzZShzdWZmaXgpO1xuICAgICAgICAgICAgc3VmZml4ID0gdGhpcy5tZWFzdXJlKHN1ZmZpeCwgcmVuZGVySW5mby5sZXR0ZXJTcGFjaW5nLCByZW5kZXJJbmZvLmJhc2VGb250KVswXTtcbiAgICAgICAgICAgIHN1ZmZpeC5saW5lTm8gPSBpbmRleDtcbiAgICAgICAgICAgIGlmIChsYXN0TGluZVRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4LnggPSBsYXN0TGluZVRleHRbbGFzdExpbmVUZXh0Lmxlbmd0aCAtIDFdLnggKyBsYXN0TGluZVRleHRbbGFzdExpbmVUZXh0Lmxlbmd0aCAtIDFdLndpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWZmaXgueCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TGluZVRleHQucHVzaChzdWZmaXgpXG5cbiAgICAgICAgICAgIGxldCBfdyA9IGxhc3RMaW5lVGV4dC5yZWR1Y2UoKGFjYywgdCkgPT4gYWNjICsgdC53aWR0aCwgMCk7XG4gICAgICAgICAgICB3aGlsZSAoX3cgPiByZW5kZXJJbmZvLndpZHRoIHx8IGxhc3RMaW5lVGV4dFtsYXN0TGluZVRleHQubGVuZ3RoIC0gMl0udGV4dCA9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBsYXN0TGluZVRleHQuc3BsaWNlKGxhc3RMaW5lVGV4dC5sZW5ndGggLSAyLCAxKTtcbiAgICAgICAgICAgICAgICBfdyA9IGxhc3RMaW5lVGV4dC5yZWR1Y2UoKGFjYywgdCkgPT4gYWNjICsgdC53aWR0aCwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGxhc3RMaW5lVGV4dFtsYXN0TGluZVRleHQubGVuZ3RoIC0gMl0gfHwge3g6IDAsIHdpZHRoOiAwfVxuICAgICAgICAgICAgICAgIHN1ZmZpeC54ID0gcHJldi54ICsgcHJldi53aWR0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExpbmVUZXh0Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJJbmZvLmxpbmVzW2luZGV4XS50ZXh0ID0gbGFzdExpbmVUZXh0O1xuICAgICAgICAgICAgcmVuZGVySW5mby5saW5lc1tpbmRleF0ud2lkdGggPSBfdztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zZXR0aW5ncy5oKSB7XG4gICAgICAgICAgICByZW5kZXJJbmZvLmggPSB0aGlzLl9zZXR0aW5ncy5oO1xuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlckluZm8ubWF4TGluZXMgJiYgcmVuZGVySW5mby5tYXhMaW5lcyA8IHJlbmRlckluZm8ubGluZU51bSkge1xuICAgICAgICAgICAgcmVuZGVySW5mby5oID0gcmVuZGVySW5mby5tYXhMaW5lcyAqIHJlbmRlckluZm8ubGluZUhlaWdodCArIGZvbnRTaXplIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlckluZm8uaCA9IHJlbmRlckluZm8ubGluZU51bSAqIHJlbmRlckluZm8ubGluZUhlaWdodCArIGZvbnRTaXplIC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhvcml6b250YWwgYWxpZ25tZW50IG9mZnNldFxuICAgICAgICBpZiAocmVuZGVySW5mby50ZXh0QWxpZ24gPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGwgb2YgcmVuZGVySW5mby5saW5lcykge1xuICAgICAgICAgICAgICAgIGwueCA9IChyZW5kZXJJbmZvLndpZHRoIC0gbC53aWR0aCAtIHBhZGRpbmdMZWZ0KSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVySW5mby50ZXh0QWxpZ24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgZm9yIChsZXQgbCBvZiByZW5kZXJJbmZvLmxpbmVzKSB7XG4gICAgICAgICAgICAgICAgbC54ID0gcmVuZGVySW5mby53aWR0aCAtIGwud2lkdGggLSBwYWRkaW5nTGVmdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJJbmZvO1xuICAgIH1cblxuICAgIF9kcmF3KCkge1xuICAgICAgICBjb25zdCByZW5kZXJJbmZvID0gdGhpcy5fY2FsY3VsYXRlUmVuZGVySW5mbygpO1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSB0aGlzLmdldFByZWNpc2lvbigpO1xuICAgICAgICBjb25zdCBwYWRkaW5nTGVmdCA9IHJlbmRlckluZm8ucGFkZGluZ0xlZnQgKiBwcmVjaXNpb247XG5cbiAgICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICAgIGxldCBjYW52YXNXaWR0aCA9IHJlbmRlckluZm8udyB8fCByZW5kZXJJbmZvLndpZHRoO1xuICAgICAgICBpZiAocmVuZGVySW5mby5jdXRTeCB8fCByZW5kZXJJbmZvLmN1dEV4KSB7XG4gICAgICAgICAgICBjYW52YXNXaWR0aCA9IE1hdGgubWluKHJlbmRlckluZm8udywgcmVuZGVySW5mby5jdXRFeCAtIHJlbmRlckluZm8uY3V0U3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNhbnZhc0hlaWdodCA9IHJlbmRlckluZm8uaDtcbiAgICAgICAgaWYgKHJlbmRlckluZm8uY3V0U3kgfHwgcmVuZGVySW5mby5jdXRFeSkge1xuICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gTWF0aC5taW4ocmVuZGVySW5mby5oLCByZW5kZXJJbmZvLmN1dEV5IC0gcmVuZGVySW5mby5jdXRTeSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBNYXRoLmNlaWwoY2FudmFzV2lkdGggKyB0aGlzLl9zdGFnZS5nZXRPcHRpb24oJ3RleHRSZW5kZXJJc3N1ZU1hcmdpbicpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChjYW52YXNIZWlnaHQpO1xuXG4gICAgICAgIC8vIENhbnZhcyBjb250ZXh0IGhhcyBiZWVuIHJlc2V0LlxuICAgICAgICB0aGlzLnNldEZvbnRQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgaWYgKHJlbmRlckluZm8uZm9udFNpemUgPj0gMTI4KSB7XG4gICAgICAgICAgICAvLyBXcGVXZWJLaXQgYnVnOiBtdXN0IGZvcmNlIGNvbXBvc2l0aW5nIGJlY2F1c2UgY2Fpcm8tdHJhcHMtY29tcG9zaXRvciB3aWxsIG5vdCB3b3JrIHdpdGggdGV4dCBmaXJzdC5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZ2xvYmFsQWxwaGEgPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCgwLCAwLCAwLjAxLCAwLjAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZ2xvYmFsQWxwaGEgPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXRcbiAgICAgICAgaWYgKHJlbmRlckluZm8uY3V0U3ggfHwgcmVuZGVySW5mby5jdXRTeSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC50cmFuc2xhdGUoLXJlbmRlckluZm8uY3V0U3gsIC1yZW5kZXJJbmZvLmN1dFN5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhpZ2hsaWdodFxuICAgICAgICBpZiAocmVuZGVySW5mby5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhsQ29sb3IgPSByZW5kZXJJbmZvLmhpZ2hsaWdodENvbG9yIHx8IDB4MDAwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBobEhlaWdodCA9IHJlbmRlckluZm8uaGlnaGxpZ2h0SGVpZ2h0ID8gcmVuZGVySW5mby5oaWdobGlnaHRIZWlnaHQgKiBwcmVjaXNpb24gOiAgcmVuZGVySW5mby5mb250U2l6ZSAqIDEuNTtcbiAgICAgICAgICAgIGNvbnN0IGhsT2Zmc2V0ID0gcmVuZGVySW5mby5oaWdobGlnaHRPZmZzZXQgPyByZW5kZXJJbmZvLmhpZ2hsaWdodE9mZnNldCAqIHByZWNpc2lvbiA6IDA7XG4gICAgICAgICAgICBjb25zdCBobFBhZGRpbmdMZWZ0ID0gKHJlbmRlckluZm8uaGlnaGxpZ2h0UGFkZGluZ0xlZnQgIT09IG51bGwgPyByZW5kZXJJbmZvLmhpZ2hsaWdodFBhZGRpbmdMZWZ0ICogcHJlY2lzaW9uIDogcmVuZGVySW5mby5wYWRkaW5nTGVmdCk7XG4gICAgICAgICAgICBjb25zdCBobFBhZGRpbmdSaWdodCA9IChyZW5kZXJJbmZvLmhpZ2hsaWdodFBhZGRpbmdSaWdodCAhPT0gbnVsbCA/IHJlbmRlckluZm8uaGlnaGxpZ2h0UGFkZGluZ1JpZ2h0ICogcHJlY2lzaW9uIDogcmVuZGVySW5mby5wYWRkaW5nUmlnaHQpO1xuXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyhobENvbG9yKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVOdW0gPSByZW5kZXJJbmZvLm1heExpbmVzID8gTWF0aC5taW4ocmVuZGVySW5mby5tYXhMaW5lcywgcmVuZGVySW5mby5saW5lTnVtKSA6IHJlbmRlckluZm8ubGluZU51bTsgXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVOdW07IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSByZW5kZXJJbmZvLmxpbmVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZmlsbFJlY3QobC54IC0gaGxQYWRkaW5nTGVmdCArIHBhZGRpbmdMZWZ0LCBsLnkgKyBobE9mZnNldCwgbC53aWR0aCArIGhsUGFkZGluZ0xlZnQgKyBobFBhZGRpbmdSaWdodCwgaGxIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGV4dCBzaGFkb3cuXG4gICAgICAgIGxldCBwcmV2U2hhZG93U2V0dGluZ3MgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fc2V0dGluZ3Muc2hhZG93KSB7XG4gICAgICAgICAgICBwcmV2U2hhZG93U2V0dGluZ3MgPSBbdGhpcy5fY29udGV4dC5zaGFkb3dDb2xvciwgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRYLCB0aGlzLl9jb250ZXh0LnNoYWRvd09mZnNldFksIHRoaXMuX2NvbnRleHQuc2hhZG93Qmx1cl07XG5cbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Q29sb3IgPSBTdGFnZVV0aWxzLmdldFJnYmFTdHJpbmcodGhpcy5fc2V0dGluZ3Muc2hhZG93Q29sb3IpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dPZmZzZXRYID0gdGhpcy5fc2V0dGluZ3Muc2hhZG93T2Zmc2V0WCAqIHByZWNpc2lvbjtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WSA9IHRoaXMuX3NldHRpbmdzLnNoYWRvd09mZnNldFkgKiBwcmVjaXNpb247XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNoYWRvd0JsdXIgPSB0aGlzLl9zZXR0aW5ncy5zaGFkb3dCbHVyICogcHJlY2lzaW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyB0ZXh0XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh0aGlzLl9zZXR0aW5ncy50ZXh0Q29sb3IpO1xuICAgICAgICBsZXQgY3VycmVudENvbG9yID0gZGVmYXVsdENvbG9yO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IGRlZmF1bHRDb2xvcjtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHJlbmRlckluZm8ubGluZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBsaW5lLnRleHQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbHggPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHQudGV4dCA9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVuZGVySW5mby5tYXhMaW5lcyAmJiB0LmxpbmVObyA+PSByZW5kZXJJbmZvLm1heExpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0LmNvbG9yICE9IGN1cnJlbnRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29sb3IgPSB0LmNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZpbGxTdHlsZSA9IGN1cnJlbnRDb2xvcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZXh0LmZvbnQgPSB0LmZvbnRTdHlsZTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgd2l0aCBsZXR0ZXIgc3BhY2luZ1xuICAgICAgICAgICAgICAgIGlmICh0LmxldHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbCBvZiB0LmxldHRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF94ID0gcmVuZGVySW5mby5saW5lc1t0LmxpbmVOb10ueCArIHQueCArIGx4O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dChsLnRleHQsIF94LCByZW5kZXJJbmZvLmxpbmVzW3QubGluZU5vXS55ICsgcmVuZGVySW5mby5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBseCArPSBsLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RhbmRhcmQgZHJhd2luZ1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IF94ID0gcmVuZGVySW5mby5saW5lc1t0LmxpbmVOb10ueCArIHQueDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dCh0LnRleHQsIF94LCByZW5kZXJJbmZvLmxpbmVzW3QubGluZU5vXS55ICsgcmVuZGVySW5mby5mb250U2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXQgdGV4dCBzaGFkb3dcbiAgICAgICAgaWYgKHByZXZTaGFkb3dTZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zaGFkb3dDb2xvciA9IHByZXZTaGFkb3dTZXR0aW5nc1swXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WCA9IHByZXZTaGFkb3dTZXR0aW5nc1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93T2Zmc2V0WSA9IHByZXZTaGFkb3dTZXR0aW5nc1syXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2hhZG93Qmx1ciA9IHByZXZTaGFkb3dTZXR0aW5nc1szXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IGN1dCB0cmFuc2xhdGlvblxuICAgICAgICBpZiAocmVuZGVySW5mby5jdXRTeCB8fCByZW5kZXJJbmZvLmN1dFN5KSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnRyYW5zbGF0ZShyZW5kZXJJbmZvLmN1dFN4LCByZW5kZXJJbmZvLmN1dFN5KTtcbiAgICAgICAgfVxuIFxuICAgICAgICAvLyBQb3N0cHJvY2VzcyByZW5kZXJJbmZvLmxpbmVzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBzdGFuZGFyZCB2ZXJzaW9uXG4gICAgICAgIHJlbmRlckluZm8ubGluZXMgPSByZW5kZXJJbmZvLmxpbmVzLm1hcCgobCkgPT4gbC50ZXh0LnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgKyB2LnRleHQsICcnKSk7XG4gICAgICAgIGlmIChyZW5kZXJJbmZvLm1heExpbmVzKSB7XG4gICAgICAgICAgICByZW5kZXJJbmZvLmxpbmVzID0gcmVuZGVySW5mby5saW5lcy5zbGljZSgwLCByZW5kZXJJbmZvLm1heExpbmVzKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5yZW5kZXJJbmZvID0gcmVuZGVySW5mbztcblxuICAgIH07XG5cbiAgICBtZWFzdXJlVGV4dCh3b3JkLCBzcGFjZSA9IDApIHtcbiAgICAgICAgaWYgKCFzcGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZCkud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmQuc3BsaXQoJycpLnJlZHVjZSgoYWNjLCBjaGFyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYWNjICsgdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dChjaGFyKS53aWR0aCArIHNwYWNlO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICB0b2tlbml6ZSh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlID0vIHxcXG58PGk+fDxcXC9pPnw8Yj58PFxcL2I+fDxjb2xvcj0wW3hYXVswLTlhLWZBLUZdezh9Pnw8XFwvY29sb3I+L2dcbiAgICBcbiAgICAgICAgY29uc3QgZGVsaW1ldGVycyA9IHRleHQubWF0Y2gocmUpIHx8IFtdO1xuICAgICAgICBjb25zdCB3b3JkcyA9IHRleHQuc3BsaXQocmUpIHx8IFtdO1xuICAgIFxuICAgICAgICBsZXQgZmluYWwgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZmluYWwucHVzaCh3b3Jkc1tpXSwgZGVsaW1ldGVyc1tpXSlcbiAgICAgICAgfVxuICAgICAgICBmaW5hbC5wb3AoKVxuICAgICAgICByZXR1cm4gZmluYWwuZmlsdGVyKCh3b3JkKSA9PiB3b3JkICE9ICcnKTtcbiAgICBcbiAgICB9XG4gICAgXG4gICAgcGFyc2UodG9rZW5zKSB7XG4gICAgICAgIGxldCBpdGFsaWMgPSAwO1xuICAgICAgICBsZXQgYm9sZCA9IDA7XG4gICAgICAgIGxldCBjb2xvclN0YWNrID0gW1N0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyh0aGlzLl9zZXR0aW5ncy50ZXh0Q29sb3IpXTtcbiAgICAgICAgbGV0IGNvbG9yID0gMDtcblxuICAgICAgICBjb25zdCBjb2xvclJlZ2V4cCA9IC88Y29sb3I9KD88Y29sb3I+MFt4WF1bMC05YS1mQS1GXXs4fSkvO1xuICAgIFxuICAgICAgICByZXR1cm4gdG9rZW5zLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQgPT0gJzxpPicpIHtcbiAgICAgICAgICAgICAgICBpdGFsaWMgKz0gMTtcbiAgICAgICAgICAgICAgICB0ID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT0gJzwvaT4nICYmIGl0YWxpYyA+IDApIHtcbiAgICAgICAgICAgICAgICBpdGFsaWMgLT0gMTtcbiAgICAgICAgICAgICAgICB0ID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT0gJzxiPicpIHtcbiAgICAgICAgICAgICAgICBib2xkICs9IDE7XG4gICAgICAgICAgICAgICAgdCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09ICc8L2I+JyAmJiBib2xkID4gMCkge1xuICAgICAgICAgICAgICAgIGJvbGQgLT0gMTtcbiAgICAgICAgICAgICAgICB0ID0gJyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQgPT0gJzwvY29sb3I+Jykge1xuICAgICAgICAgICAgICAgIGlmIChjb2xvclN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdCA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb2xvclJlZ2V4cC50ZXN0KHQpKSB7XG4gICAgICAgICAgICAgICAgY29sb3JTdGFjay5wdXNoKFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZyhwYXJzZUludChjb2xvclJlZ2V4cC5leGVjKHQpLmdyb3Vwc1snY29sb3InXSkpKTtcbiAgICAgICAgICAgICAgICBjb2xvciArPSAxO1xuICAgICAgICAgICAgICAgIHQgPSAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiB0LFxuICAgICAgICAgICAgICAgIGl0YWxpYzogaXRhbGljLFxuICAgICAgICAgICAgICAgIGJvbGQ6IGJvbGQsXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yU3RhY2tbY29sb3JdLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKChvKSA9PiBvLnRleHQgIT0gJycpO1xuICAgIH1cblxuICAgIGFwcGx5Rm9udFN0eWxlKHdvcmQsIGJhc2VGb250KSB7XG4gICAgICAgIGxldCBmb250ID0gYmFzZUZvbnQ7XG4gICAgICAgIGlmICh3b3JkLmJvbGQpIHtcbiAgICAgICAgICAgIGZvbnQgPSAnYm9sZCAnICsgZm9udDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29yZC5pdGFsaWMpIHtcbiAgICAgICAgICAgIGZvbnQgPSAnaXRhbGljICcgKyBmb250O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZm9udCA9IGZvbnRcbiAgICAgICAgd29yZC5mb250U3R5bGUgPSBmb250O1xuICAgIH1cblxuICAgIHJlc2V0Rm9udFN0eWxlKGJhc2VGb250KSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuZm9udCA9IGJhc2VGb250O1xuICAgIH1cblxuICAgIG1lYXN1cmUocGFyc2VkLCBsZXR0ZXJTcGFjaW5nID0gMCwgYmFzZUZvbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5hcHBseUZvbnRTdHlsZShwLCBiYXNlRm9udCk7XG4gICAgICAgICAgICBwLndpZHRoID0gdGhpcy5tZWFzdXJlVGV4dChwLnRleHQsIGxldHRlclNwYWNpbmcpO1xuXG4gICAgICAgICAgICAvLyBMZXR0ZXIgYnkgbGV0dGVyIGRldGFpbCBmb3IgbGV0dGVyIHNwYWNpbmdcbiAgICAgICAgICAgIGlmIChsZXR0ZXJTcGFjaW5nID4gMCkge1xuICAgICAgICAgICAgICAgIHAubGV0dGVycyA9IHAudGV4dC5zcGxpdCgnJykubWFwKChsKSA9PiB7cmV0dXJuIHt0ZXh0OiBsfX0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGwgb2YgcC5sZXR0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGwud2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGwudGV4dCwgbGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldEZvbnRTdHlsZShiYXNlRm9udCk7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuXG4gICAgaW5kZW50KHBhcnNlZCwgdGV4dEluZGVudCkge1xuICAgICAgICBwYXJzZWQuc3BsaWNlKDAsIDAsIHt0ZXh0OiBcIlwiLCB3aWR0aDogdGV4dEluZGVudH0pO1xuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cblxuICAgIHdyYXBXb3JkKHdvcmQsIHdvcmRXcmFwV2lkdGgsIHN1ZmZpeCkge1xuICAgICAgICBjb25zdCBzdWZmaXhXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQoc3VmZml4KS53aWR0aDtcbiAgICAgICAgY29uc3Qgd29yZExlbiA9IHdvcmQubGVuZ3RoXG4gICAgICAgIGNvbnN0IHdvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZCkud2lkdGg7XG5cbiAgICAgICAgLyogSWYgd29yZCBmaXRzIHdyYXBXaWR0aCwgZG8gbm90aGluZyAqL1xuICAgICAgICBpZiAod29yZFdpZHRoIDw9IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB3b3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogTWFrZSBpbml0aWFsIGd1ZXNzIGZvciB0ZXh0IGN1dHRvZmYgKi9cbiAgICAgICAgbGV0IGN1dG9mZkluZGV4ID0gTWF0aC5mbG9vcigod29yZFdyYXBXaWR0aCAqIHdvcmRMZW4pIC8gd29yZFdpZHRoKTtcbiAgICAgICAgbGV0IHRydW5jV29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkpLndpZHRoICsgc3VmZml4V2lkdGg7XG5cbiAgICAgICAgLyogSW4gY2FzZSBndWVzcyB3YXMgb3ZlcmVzdGltYXRlZCwgc2hyaW5rIGl0IGxldHRlciBieSBsZXR0ZXIuICovXG4gICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgIHdoaWxlIChjdXRvZmZJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICB0cnVuY1dvcmRXaWR0aCA9IHRoaXMuX2NvbnRleHQubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgY3V0b2ZmSW5kZXgpKS53aWR0aCArIHN1ZmZpeFdpZHRoO1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3V0b2ZmSW5kZXggLT0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLyogSW4gY2FzZSBndWVzcyB3YXMgdW5kZXJlc3RpbWF0ZWQsIGV4dGVuZCBpdCBsZXR0ZXIgYnkgbGV0dGVyLiAqL1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUgKGN1dG9mZkluZGV4IDwgd29yZExlbikge1xuICAgICAgICAgICAgICAgIHRydW5jV29yZFdpZHRoID0gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBjdXRvZmZJbmRleCkpLndpZHRoICsgc3VmZml4V2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoIDwgd29yZFdyYXBXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXRvZmZJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIHdoZW4gYm91bmQgaXMgY3Jvc3NlZCwgcmV0cmFjdCBsYXN0IGxldHRlci5cbiAgICAgICAgICAgICAgICAgICAgY3V0b2ZmSW5kZXggLT0xO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJZiB3cmFwV2lkdGggaXMgdG9vIHNob3J0IHRvIGV2ZW4gY29udGFpbiBzdWZmaXggYWxvbmUsIHJldHVybiBlbXB0eSBzdHJpbmcgKi9cbiAgICAgICAgcmV0dXJuIHdvcmQuc3Vic3RyaW5nKDAsIGN1dG9mZkluZGV4KSArICh3b3JkV3JhcFdpZHRoID49IHN1ZmZpeFdpZHRoID8gc3VmZml4IDogJycpXG4gICAgfVxuXG4gICAgX2dldEJyZWFrSW5kZXgod29yZCwgd2lkdGgpIHtcbiAgICAgICAgY29uc3Qgd29yZExlbiA9IHdvcmQubGVuZ3RoO1xuICAgICAgICBjb25zdCB3b3JkV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KHdvcmQpO1xuXG4gICAgICAgIGlmICh3b3JkV2lkdGggPD0gd2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7YnJlYWtJbmRleDogd29yZC5sZW5ndGgsIHRydW5jV29yZFdpZHRoOiB3b3JkV2lkdGh9O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGJyZWFrSW5kZXggPSBNYXRoLmZsb29yKCh3aWR0aCAqIHdvcmRMZW4pIC8gd29yZFdpZHRoKTtcbiAgICAgICAgbGV0IHRydW5jV29yZFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBicmVha0luZGV4KSlcblxuICAgICAgICAvKiBJbiBjYXNlIGd1ZXNzIHdhcyBvdmVyZXN0aW1hdGVkLCBzaHJpbmsgaXQgbGV0dGVyIGJ5IGxldHRlci4gKi9cbiAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgIHdoaWxlIChicmVha0luZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIHRydW5jV29yZFdpZHRoID0gdGhpcy5tZWFzdXJlVGV4dCh3b3JkLnN1YnN0cmluZygwLCBicmVha0luZGV4KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRydW5jV29yZFdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtJbmRleCAtPSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAvKiBJbiBjYXNlIGd1ZXNzIHdhcyB1bmRlcmVzdGltYXRlZCwgZXh0ZW5kIGl0IGxldHRlciBieSBsZXR0ZXIuICovXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoYnJlYWtJbmRleCA8IHdvcmRMZW4pIHtcbiAgICAgICAgICAgICAgICB0cnVuY1dvcmRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgYnJlYWtJbmRleCkpO1xuICAgICAgICAgICAgICAgIGlmICh0cnVuY1dvcmRXaWR0aCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5hbGx5LCB3aGVuIGJvdW5kIGlzIGNyb3NzZWQsIHJldHJhY3QgbGFzdCBsZXR0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrSW5kZXggLT0xO1xuICAgICAgICAgICAgICAgICAgICB0cnVuY1dvcmRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQod29yZC5zdWJzdHJpbmcoMCwgYnJlYWtJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHticmVha0luZGV4LCB0cnVuY1dvcmRXaWR0aH07XG5cbiAgICB9XG5cbiAgICB3b3JkQnJlYWsod29yZCwgd2lkdGgsIGJhc2VGb250KSB7XG4gICAgICAgIGlmICghd29yZC50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gd29yZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwbHlGb250U3R5bGUod29yZCwgYmFzZUZvbnQpXG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGxldCB0ZXh0ID0gd29yZC50ZXh0O1xuICAgICAgICBpZiAoIXdvcmQubGV0dGVycykge1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7YnJlYWtJbmRleCwgdHJ1bmNXb3JkV2lkdGh9ID0gdGhpcy5fZ2V0QnJlYWtJbmRleCh0ZXh0LCB3aWR0aCk7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7Li4ud29yZH0pO1xuICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRleHQgPSB0ZXh0LnNsaWNlKDAsIGJyZWFrSW5kZXgpO1xuICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLndpZHRoID0gdHJ1bmNXb3JkV2lkdGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoYnJlYWtJbmRleCA9PT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoYnJlYWtJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG90YWxXaWR0aCA9IDA7XG4gICAgICAgICAgICBsZXQgbGV0dGVycyA9IFtdO1xuICAgICAgICAgICAgbGV0IGJyZWFrSW5kZXggPSAwO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsIG9mIHdvcmQubGV0dGVycykge1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbFdpZHRoICsgbC53aWR0aCA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHsuLi53b3JkfSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRleHQgPSB0ZXh0LnNsaWNlKDAsIGJyZWFrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS53aWR0aCA9IHRvdGFsV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLmxldHRlcnMgPSBsZXR0ZXJzO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShicmVha0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldHRlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVha0luZGV4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGxldHRlcnMucHVzaChsKTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxXaWR0aCArPSBsLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaCh7Li4ud29yZH0pO1xuICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLnRleHQgPSB0ZXh0LnNsaWNlKDAsIGJyZWFrSW5kZXgpO1xuICAgICAgICAgICAgICAgIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdLndpZHRoID0gdG90YWxXaWR0aDtcbiAgICAgICAgICAgICAgICBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXS5sZXR0ZXJzID0gbGV0dGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG59IiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi90cmVlL1V0aWxzLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNdWx0aVNwbGluZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICB9XG5cbiAgICBfY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX3AgPSBbXTtcbiAgICAgICAgdGhpcy5fcGUgPSBbXTtcbiAgICAgICAgdGhpcy5faWRwID0gW107XG4gICAgICAgIHRoaXMuX2YgPSBbXTtcbiAgICAgICAgdGhpcy5fdiA9IFtdO1xuICAgICAgICB0aGlzLl9sdiA9IFtdO1xuICAgICAgICB0aGlzLl9zbSA9IFtdO1xuICAgICAgICB0aGlzLl9zID0gW107XG4gICAgICAgIHRoaXMuX3ZlID0gW107XG4gICAgICAgIHRoaXMuX3NtZSA9IFtdO1xuICAgICAgICB0aGlzLl9zZSA9IFtdO1xuXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgcGFyc2UocmdiYSwgZGVmKSB7XG4gICAgICAgIGxldCBpLCBuO1xuICAgICAgICBpZiAoIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbChkZWYpKSB7XG4gICAgICAgICAgICBkZWYgPSB7MDogZGVmfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlZmF1bHRTbW9vdGhuZXNzID0gMC41O1xuXG4gICAgICAgIGxldCBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGVmKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqID0gZGVmW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKCFVdGlscy5pc09iamVjdExpdGVyYWwob2JqKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB7djogb2JqfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBwID0gcGFyc2VGbG9hdChrZXkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJzbVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTbW9vdGhuZXNzID0gb2JqLnY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNOYU4ocCkgJiYgcCA+PSAwICYmIHAgPD0gMikge1xuICAgICAgICAgICAgICAgICAgICBvYmoucCA9IHA7XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLmYgPSBVdGlscy5pc0Z1bmN0aW9uKG9iai52KTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLmx2ID0gb2JqLmYgPyBvYmoudigwLCAwKSA6IG9iai52O1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IGJ5IHByb2dyZXNzIHZhbHVlLlxuICAgICAgICBpdGVtcyA9IGl0ZW1zLnNvcnQoZnVuY3Rpb24oYSwgYikge3JldHVybiBhLnAgLSBiLnB9KTtcblxuICAgICAgICBuID0gaXRlbXMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBsYXN0ID0gKGkgPT09IG4gLSAxKTtcbiAgICAgICAgICAgIGlmICghaXRlbXNbaV0uaGFzT3duUHJvcGVydHkoJ3BlJykpIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9ncmVzcy5cbiAgICAgICAgICAgICAgICBpdGVtc1tpXS5wZSA9IGxhc3QgPyAoaXRlbXNbaV0ucCA8PSAxID8gMSA6IDIgLyogc3VwcG9ydCBvbmV0b3R3byBzdG9wICovKSA6IGl0ZW1zW2kgKyAxXS5wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG11bHRpcGxlIGl0ZW1zIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gaSA8IG4gLSAxID8gaXRlbXNbaSArIDFdLnAgOiAxO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc1tpXS5wZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5wZSA9IG1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbXNbaV0ucGUgPT09IGl0ZW1zW2ldLnApIHtcbiAgICAgICAgICAgICAgICBpdGVtc1tpXS5pZHAgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpdGVtc1tpXS5pZHAgPSAxIC8gKGl0ZW1zW2ldLnBlIC0gaXRlbXNbaV0ucCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2xvciBtZXJnZXI6IHdlIG5lZWQgdG8gc3BsaXQvY29tYmluZSBSR0JBIGNvbXBvbmVudHMuXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGJlemllciBoZWxwZXIgdmFsdWVzLjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKCFpdGVtc1tpXS5oYXNPd25Qcm9wZXJ0eSgnc20nKSkge1xuICAgICAgICAgICAgICAgIC8vIFNtb290aG5lc3MuO1xuICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnNtID0gZGVmYXVsdFNtb290aG5lc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW1zW2ldLmhhc093blByb3BlcnR5KCdzJykpIHtcbiAgICAgICAgICAgICAgICAvLyBTbG9wZS47XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgaSA9PT0gbiAtIDEgfHwgKGl0ZW1zW2ldLnAgPT09IDEgLyogZm9yIG9uZXRvdHdvICovKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIHNsb3BlIGF0IHN0YXJ0IGFuZCBlbmQuO1xuICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5zID0gcmdiYSA/IFswLCAwLCAwLCAwXSA6IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGkgPSBpdGVtc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5pID0gaXRlbXNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGkucCA9PT0gbmkucCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ucyA9IHJnYmEgPyBbMCwgMCwgMCwgMF0gOiAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJnYmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuYyA9IE11bHRpU3BsaW5lLmdldFJnYmFDb21wb25lbnRzKG5pLmx2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYyA9IE11bHRpU3BsaW5lLmdldFJnYmFDb21wb25lbnRzKHBpLmx2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gMSAvIChuaS5wIC0gcGkucCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ucyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCAqIChuY1swXSAtIHBjWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCAqIChuY1sxXSAtIHBjWzFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCAqIChuY1syXSAtIHBjWzJdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZCAqIChuY1szXSAtIHBjWzNdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnMgPSAobmkubHYgLSBwaS5sdikgLyAobmkucCAtIHBpLnApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB2YWx1ZSBmdW5jdGlvbi47XG4gICAgICAgICAgICBpZiAoIWl0ZW1zW2ldLmYpIHtcblxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gKGkgPT09IG4gLSAxKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zW2ldLmhhc093blByb3BlcnR5KCd2ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnZlID0gbGFzdCA/IGl0ZW1zW2ldLmx2IDogaXRlbXNbaSArIDFdLmx2O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IGludGVycG9sYXRlIG9uIG51bWVyaWMgdmFsdWVzLiBOb24tbnVtZXJpYyB2YWx1ZXMgYXJlIHNldCBsaXRlcmFsbHkgd2hlbiByZWFjaGVkIHRpbWUuXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKGl0ZW1zW2ldLnYpICYmIFV0aWxzLmlzTnVtYmVyKGl0ZW1zW2ldLmx2KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zW2ldLmhhc093blByb3BlcnR5KCdzbWUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0uc21lID0gbGFzdCA/IGRlZmF1bHRTbW9vdGhuZXNzIDogaXRlbXNbaSArIDFdLnNtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbXNbaV0uaGFzT3duUHJvcGVydHkoJ3NlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLnNlID0gbGFzdCA/IChyZ2JhID8gWzAsIDAsIDAsIDBdIDogMCkgOiBpdGVtc1tpICsgMV0ucztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHNwbGluZS47XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZ2JhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS52ID0gTXVsdGlTcGxpbmUuZ2V0U3BsaW5lUmdiYVZhbHVlRnVuY3Rpb24oaXRlbXNbaV0udiwgaXRlbXNbaV0udmUsIGl0ZW1zW2ldLnAsIGl0ZW1zW2ldLnBlLCBpdGVtc1tpXS5zbSwgaXRlbXNbaV0uc21lLCBpdGVtc1tpXS5zLCBpdGVtc1tpXS5zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS52ID0gTXVsdGlTcGxpbmUuZ2V0U3BsaW5lVmFsdWVGdW5jdGlvbihpdGVtc1tpXS52LCBpdGVtc1tpXS52ZSwgaXRlbXNbaV0ucCwgaXRlbXNbaV0ucGUsIGl0ZW1zW2ldLnNtLCBpdGVtc1tpXS5zbWUsIGl0ZW1zW2ldLnMsIGl0ZW1zW2ldLnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zW2ldLmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZChpdGVtc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfYWRkKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5fcC5wdXNoKGl0ZW0ucCB8fCAwKTtcbiAgICAgICAgdGhpcy5fcGUucHVzaChpdGVtLnBlIHx8IDApO1xuICAgICAgICB0aGlzLl9pZHAucHVzaChpdGVtLmlkcCB8fCAwKTtcbiAgICAgICAgdGhpcy5fZi5wdXNoKGl0ZW0uZiB8fCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3YucHVzaChpdGVtLmhhc093blByb3BlcnR5KCd2JykgPyBpdGVtLnYgOiAwIC8qIHYgbWlnaHQgYmUgZmFsc2Ugb3IgbnVsbCAqLyApO1xuICAgICAgICB0aGlzLl9sdi5wdXNoKGl0ZW0ubHYgfHwgMCk7XG4gICAgICAgIHRoaXMuX3NtLnB1c2goaXRlbS5zbSB8fCAwKTtcbiAgICAgICAgdGhpcy5fcy5wdXNoKGl0ZW0ucyB8fCAwKTtcbiAgICAgICAgdGhpcy5fdmUucHVzaChpdGVtLnZlIHx8IDApO1xuICAgICAgICB0aGlzLl9zbWUucHVzaChpdGVtLnNtZSB8fCAwKTtcbiAgICAgICAgdGhpcy5fc2UucHVzaChpdGVtLnNlIHx8IDApO1xuICAgICAgICB0aGlzLl9sZW5ndGgrKztcbiAgICB9XG5cbiAgICBfZ2V0SXRlbShwKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl9sZW5ndGg7XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHAgPCB0aGlzLl9wWzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcFtpXSA8PSBwICYmIHAgPCB0aGlzLl9wZVtpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG4gLSAxO1xuICAgIH1cblxuICAgIGdldFZhbHVlKHApIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuX2dldEl0ZW0ocCk7XG4gICAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9mW2ldKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbyA9IE1hdGgubWluKDEsIE1hdGgubWF4KDAsIChwIC0gdGhpcy5fcFtpXSkgKiB0aGlzLl9pZHBbaV0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdltpXShvKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRSZ2JhQ29tcG9uZW50cyhhcmdiKSB7XG4gICAgICAgIGxldCByID0gKChhcmdiIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnID0gKChhcmdiIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYiA9IGFyZ2IgJSAyNTY7XG4gICAgICAgIGxldCBhID0gKChhcmdiIC8gMTY3NzcyMTYpIHwgMCk7XG4gICAgICAgIHJldHVybiBbciwgZywgYiwgYV07XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRTcGxpbmVWYWx1ZUZ1bmN0aW9uKHYxLCB2MiwgcDEsIHAyLCBvMSwgaTIsIHMxLCBzMikge1xuICAgICAgICAvLyBOb3JtYWxpemUgc2xvcGVzIGJlY2F1c2Ugd2UgdXNlIGEgc3BsaW5lIHRoYXQgZ29lcyBmcm9tIDAgdG8gMS5cbiAgICAgICAgbGV0IGRwID0gcDIgLSBwMTtcbiAgICAgICAgczEgKj0gZHA7XG4gICAgICAgIHMyICo9IGRwO1xuXG4gICAgICAgIGxldCBoZWxwZXJzID0gTXVsdGlTcGxpbmUuZ2V0U3BsaW5lSGVscGVycyh2MSwgdjIsIG8xLCBpMiwgczEsIHMyKTtcbiAgICAgICAgaWYgKCFoZWxwZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gMCkgcmV0dXJuIHYxO1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAxKSByZXR1cm4gdjI7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdjIgKiBwICsgdjEgKiAoMSAtIHApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAwKSByZXR1cm4gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDEpIHJldHVybiB2MjtcbiAgICAgICAgICAgICAgICByZXR1cm4gTXVsdGlTcGxpbmUuY2FsY3VsYXRlU3BsaW5lKGhlbHBlcnMsIHApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0U3BsaW5lUmdiYVZhbHVlRnVuY3Rpb24odjEsIHYyLCBwMSwgcDIsIG8xLCBpMiwgczEsIHMyKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBzbG9wZXMgYmVjYXVzZSB3ZSB1c2UgYSBzcGxpbmUgdGhhdCBnb2VzIGZyb20gMCB0byAxLlxuICAgICAgICBsZXQgZHAgPSBwMiAtIHAxO1xuICAgICAgICBzMVswXSAqPSBkcDtcbiAgICAgICAgczFbMV0gKj0gZHA7XG4gICAgICAgIHMxWzJdICo9IGRwO1xuICAgICAgICBzMVszXSAqPSBkcDtcbiAgICAgICAgczJbMF0gKj0gZHA7XG4gICAgICAgIHMyWzFdICo9IGRwO1xuICAgICAgICBzMlsyXSAqPSBkcDtcbiAgICAgICAgczJbM10gKj0gZHA7XG5cbiAgICAgICAgbGV0IGN2MSA9IE11bHRpU3BsaW5lLmdldFJnYmFDb21wb25lbnRzKHYxKTtcbiAgICAgICAgbGV0IGN2MiA9IE11bHRpU3BsaW5lLmdldFJnYmFDb21wb25lbnRzKHYyKTtcblxuICAgICAgICBsZXQgaGVscGVycyA9IFtcbiAgICAgICAgICAgIE11bHRpU3BsaW5lLmdldFNwbGluZUhlbHBlcnMoY3YxWzBdLCBjdjJbMF0sIG8xLCBpMiwgczFbMF0sIHMyWzBdKSxcbiAgICAgICAgICAgIE11bHRpU3BsaW5lLmdldFNwbGluZUhlbHBlcnMoY3YxWzFdLCBjdjJbMV0sIG8xLCBpMiwgczFbMV0sIHMyWzFdKSxcbiAgICAgICAgICAgIE11bHRpU3BsaW5lLmdldFNwbGluZUhlbHBlcnMoY3YxWzJdLCBjdjJbMl0sIG8xLCBpMiwgczFbMl0sIHMyWzJdKSxcbiAgICAgICAgICAgIE11bHRpU3BsaW5lLmdldFNwbGluZUhlbHBlcnMoY3YxWzNdLCBjdjJbM10sIG8xLCBpMiwgczFbM10sIHMyWzNdKVxuICAgICAgICBdO1xuXG4gICAgICAgIGlmICghaGVscGVyc1swXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICAgICAgLy8gTGluZWFyLlxuICAgICAgICAgICAgICAgIGlmIChwID09PSAwKSByZXR1cm4gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDEpIHJldHVybiB2MjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBNdWx0aVNwbGluZS5tZXJnZUNvbG9ycyh2MiwgdjEsIHApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChwID09PSAwKSByZXR1cm4gdjE7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IDEpIHJldHVybiB2MjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBNdWx0aVNwbGluZS5nZXRBcmdiTnVtYmVyKFtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oMjU1LCBNdWx0aVNwbGluZS5jYWxjdWxhdGVTcGxpbmUoaGVscGVyc1swXSwgcCkpLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbigyNTUsIE11bHRpU3BsaW5lLmNhbGN1bGF0ZVNwbGluZShoZWxwZXJzWzFdLCBwKSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKDI1NSwgTXVsdGlTcGxpbmUuY2FsY3VsYXRlU3BsaW5lKGhlbHBlcnNbMl0sIHApKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oMjU1LCBNdWx0aVNwbGluZS5jYWxjdWxhdGVTcGxpbmUoaGVscGVyc1szXSwgcCkpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBoZWxwZXJzIHRvIGJlIHVzZWQgaW4gdGhlIHNwbGluZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdjFcbiAgICAgKiAgIEZyb20gdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYyXG4gICAgICogICBUbyB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbzFcbiAgICAgKiAgIEZyb20gc21vb3RobmVzcyAoMCA9IGxpbmVhciwgMSA9IHNtb290aCkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHMxXG4gICAgICogICBGcm9tIHNsb3BlICgwID0gaG9yaXpvbnRhbCwgaW5maW5pdGUgPSB2ZXJ0aWNhbCkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGkyXG4gICAgICogICBUbyBzbW9vdGhuZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzMlxuICAgICAqICAgVG8gc2xvcGUuXG4gICAgICogQHJldHVybnMge051bWJlcltdfVxuICAgICAqICAgVGhlIGhlbHBlciB2YWx1ZXMgdG8gYmUgc3VwcGxpZWQgdG8gdGhlIHNwbGluZSBmdW5jdGlvbi5cbiAgICAgKiAgIElmIHRoZSBjb25maWd1cmF0aW9uIGlzIGFjdHVhbGx5IGxpbmVhciwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0U3BsaW5lSGVscGVycyh2MSwgdjIsIG8xLCBpMiwgczEsIHMyKSB7XG4gICAgICAgIGlmICghbzEgJiYgIWkyKSB7XG4gICAgICAgICAgICAvLyBMaW5lYXIuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEN1YmljIGJlemllciBwb2ludHMuXG4gICAgICAgIC8vIGh0dHA6Ly9jdWJpYy1iZXppZXIuY29tL1xuICAgICAgICBsZXQgY3N4ID0gbzE7XG4gICAgICAgIGxldCBjc3kgPSB2MSArIHMxICogbzE7XG4gICAgICAgIGxldCBjZXggPSAxIC0gaTI7XG4gICAgICAgIGxldCBjZXkgPSB2MiAtIHMyICogaTI7XG5cbiAgICAgICAgbGV0IHhhID0gMyAqIGNzeCAtIDMgKiBjZXggKyAxO1xuICAgICAgICBsZXQgeGIgPSAtNiAqIGNzeCArIDMgKiBjZXg7XG4gICAgICAgIGxldCB4YyA9IDMgKiBjc3g7XG5cbiAgICAgICAgbGV0IHlhID0gMyAqIGNzeSAtIDMgKiBjZXkgKyB2MiAtIHYxO1xuICAgICAgICBsZXQgeWIgPSAzICogKGNleSArIHYxKSAtIDYgKiBjc3k7XG4gICAgICAgIGxldCB5YyA9IDMgKiAoY3N5IC0gdjEpO1xuICAgICAgICBsZXQgeWQgPSB2MTtcblxuICAgICAgICByZXR1cm4gW3hhLCB4YiwgeGMsIHlhLCB5YiwgeWMsIHlkXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgaW50ZXJtZWRpYXRlIHNwbGluZSB2YWx1ZSBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIGhlbHBlcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gaGVscGVyc1xuICAgICAqICAgT2J0YWluZWQgZnJvbSBnZXRTcGxpbmVIZWxwZXJzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVTcGxpbmUoaGVscGVycywgcCkge1xuICAgICAgICBsZXQgeGEgPSBoZWxwZXJzWzBdO1xuICAgICAgICBsZXQgeGIgPSBoZWxwZXJzWzFdO1xuICAgICAgICBsZXQgeGMgPSBoZWxwZXJzWzJdO1xuICAgICAgICBsZXQgeWEgPSBoZWxwZXJzWzNdO1xuICAgICAgICBsZXQgeWIgPSBoZWxwZXJzWzRdO1xuICAgICAgICBsZXQgeWMgPSBoZWxwZXJzWzVdO1xuICAgICAgICBsZXQgeWQgPSBoZWxwZXJzWzZdO1xuXG4gICAgICAgIGlmICh4YSA9PT0gLTIgJiYgeWEgPT09IC0yICYmIHhjID09PSAwICYmIHljID09PSAwKSB7XG4gICAgICAgICAgICAvLyBMaW5lYXIuXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdCBmb3IgcC5cbiAgICAgICAgbGV0IHQgPSAwLjUsIGNieCwgZHg7XG5cbiAgICAgICAgZm9yIChsZXQgaXQgPSAwOyBpdCA8IDIwOyBpdCsrKSB7XG4gICAgICAgICAgICAvLyBDdWJpYyBiZXppZXIgZnVuY3Rpb246IGYodCk9dCoodCoodCphK2IpK2MpLlxuICAgICAgICAgICAgY2J4ID0gdCAqICh0ICogKHQgKiB4YSArIHhiKSArIHhjKTtcblxuICAgICAgICAgICAgZHggPSBwIC0gY2J4O1xuICAgICAgICAgICAgaWYgKGR4ID4gLTFlLTggJiYgZHggPCAxZS04KSB7XG4gICAgICAgICAgICAgICAgLy8gU29sdXRpb24gZm91bmQhXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQgKiAodCAqICh0ICogeWEgKyB5YikgKyB5YykgKyB5ZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3ViaWMgYmV6aWVyIGRlcml2YXRpdmUgZnVuY3Rpb246IGYnKHQpPXQqKHQqKDMqYSkrMipiKStjXG4gICAgICAgICAgICBsZXQgY2J4ZCA9IHQgKiAodCAqICgzICogeGEpICsgMiAqIHhiKSArIHhjO1xuXG4gICAgICAgICAgICBpZiAoY2J4ZCA+IDFlLTEwICYmIGNieGQgPCAxZS0xMCkge1xuICAgICAgICAgICAgICAgIC8vIFByb2JsZW1hdGljLiBGYWxsIGJhY2sgdG8gYmluYXJ5IHNlYXJjaCBtZXRob2QuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHQgKz0gZHggLyBjYnhkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmFsbGJhY2s6IGJpbmFyeSBzZWFyY2ggbWV0aG9kLiBUaGlzIGlzIG1vcmUgcmVsaWFibGUgd2hlbiB0aGVyZSBhcmUgbmVhci0wIHNsb3Blcy5cbiAgICAgICAgbGV0IG1pblQgPSAwO1xuICAgICAgICBsZXQgbWF4VCA9IDE7XG4gICAgICAgIGZvciAobGV0IGl0ID0gMDsgaXQgPCAyMDsgaXQrKykge1xuICAgICAgICAgICAgdCA9IDAuNSAqIChtaW5UICsgbWF4VCk7XG5cbiAgICAgICAgICAgIC8vIEN1YmljIGJlemllciBmdW5jdGlvbjogZih0KT10Kih0Kih0KmErYikrYykrZC5cbiAgICAgICAgICAgIGNieCA9IHQgKiAodCAqICh0ICogeGEgKyB4YikgKyB4Yyk7XG5cbiAgICAgICAgICAgIGR4ID0gcCAtIGNieDtcbiAgICAgICAgICAgIGlmIChkeCA+IC0xZS04ICYmIGR4IDwgMWUtOCkge1xuICAgICAgICAgICAgICAgIC8vIFNvbHV0aW9uIGZvdW5kIVxuICAgICAgICAgICAgICAgIHJldHVybiB0ICogKHQgKiAodCAqIHlhICsgeWIpICsgeWMpICsgeWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBtYXhUID0gdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluVCA9IHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuXG4gICAgc3RhdGljIG1lcmdlQ29sb3JzKGMxLCBjMiwgcCkge1xuICAgICAgICBsZXQgcjEgPSAoKGMxIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnMSA9ICgoYzEgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiMSA9IGMxICUgMjU2O1xuICAgICAgICBsZXQgYTEgPSAoKGMxIC8gMTY3NzcyMTYpIHwgMCk7XG5cbiAgICAgICAgbGV0IHIyID0gKChjMiAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZzIgPSAoKGMyIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYjIgPSBjMiAlIDI1NjtcbiAgICAgICAgbGV0IGEyID0gKChjMiAvIDE2Nzc3MjE2KSB8IDApO1xuXG4gICAgICAgIGxldCByID0gcjEgKiBwICsgcjIgKiAoMSAtIHApO1xuICAgICAgICBsZXQgZyA9IGcxICogcCArIGcyICogKDEgLSBwKTtcbiAgICAgICAgbGV0IGIgPSBiMSAqIHAgKyBiMiAqICgxIC0gcCk7XG4gICAgICAgIGxldCBhID0gYTEgKiBwICsgYTIgKiAoMSAtIHApO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEpICogMTY3NzcyMTYgKyBNYXRoLnJvdW5kKHIpICogNjU1MzYgKyBNYXRoLnJvdW5kKGcpICogMjU2ICsgTWF0aC5yb3VuZChiKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldEFyZ2JOdW1iZXIocmdiYSkge1xuICAgICAgICByZ2JhWzBdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzBdKSk7XG4gICAgICAgIHJnYmFbMV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMV0pKTtcbiAgICAgICAgcmdiYVsyXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVsyXSkpO1xuICAgICAgICByZ2JhWzNdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzNdKSk7XG4gICAgICAgIGxldCB2ID0gKChyZ2JhWzNdIHwgMCkgPDwgMjQpICsgKChyZ2JhWzBdIHwgMCkgPDwgMTYpICsgKChyZ2JhWzFdIHwgMCkgPDwgOCkgKyAocmdiYVsyXSB8IDApO1xuICAgICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgICAgIHYgPSAweEZGRkZGRkZGICsgdiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi4vdHJlZS9VdGlscy5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqTWVyZ2VyIHtcblxuICAgIHN0YXRpYyBpc01mKGYpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmlzRnVuY3Rpb24oZikgJiYgZi5fX21mO1xuICAgIH1cblxuICAgIHN0YXRpYyBtZihmKSB7XG4gICAgICAgIC8vIFNldCBhcyBtZXJnZSBmdW5jdGlvbi5cbiAgICAgICAgZi5fX21mID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgc3RhdGljIG1lcmdlKGEsIGIpIHtcbiAgICAgICAgY29uc3QgYWtzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgIGNvbnN0IGJrcyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgICAgIGlmICghYmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgaW5kZXggYXJyYXkgZm9yIGFsbCBlbGVtZW50cy5cbiAgICAgICAgY29uc3QgYWkgPSB7fTtcbiAgICAgICAgY29uc3QgYmkgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBia3MubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBia3NbaV07XG4gICAgICAgICAgICBhaVtrZXldID0gLTE7XG4gICAgICAgICAgICBiaVtrZXldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFrcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGFrc1tpXTtcbiAgICAgICAgICAgIGFpW2tleV0gPSBpO1xuICAgICAgICAgICAgaWYgKGJpW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJpW2tleV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFrc2wgPSBha3MubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGJrcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGJrc1tpXTtcblxuICAgICAgICAgICAgLy8gUHJlcGVuZCBhbGwgaXRlbXMgaW4gYSB0aGF0IGFyZSBub3QgaW4gYiAtIGJlZm9yZSB0aGUgbm93IGFkZGVkIGIgYXR0cmlidXRlLlxuICAgICAgICAgICAgY29uc3QgYUluZGV4ID0gYWlba2V5XTtcbiAgICAgICAgICAgIGxldCBjdXJJbmRleCA9IGFJbmRleDtcbiAgICAgICAgICAgIHdoaWxlKC0tY3VySW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFrZXkgPSBha3NbY3VySW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChiaVtha2V5XSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBmb3VuZD8gU3RvcCBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgeWV0IGZvdW5kIGJ1dCBleGlzdHMgaW4gYj8gQWxzbyBzdG9wIHByb2Nlc3Npbmc6IHdhaXQgdW50aWwgd2UgZmluZCBpdCBpbiBiLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSgrK2N1ckluZGV4IDwgYUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWtleSA9IGFrc1tjdXJJbmRleF07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2FrZXldID0gYVtha2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYnYgPSBiW2tleV07XG4gICAgICAgICAgICBjb25zdCBhdiA9IGFba2V5XTtcbiAgICAgICAgICAgIGxldCByO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNNZihidikpIHtcbiAgICAgICAgICAgICAgICByID0gYnYoYXYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbChhdikgfHwgIVV0aWxzLmlzT2JqZWN0TGl0ZXJhbChidikpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IGJ2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBPYmpNZXJnZXIubWVyZ2UoYXYsIGJ2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gbWFya2VkIGFzIHVuZGVmaW5lZCwgcHJvcGVydHkgaXMgZGVsZXRlZC5cbiAgICAgICAgICAgIGlmIChyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcHBlbmQgcmVtYWluaW5nIGZpbmFsIGl0ZW1zIGluIGEuXG4gICAgICAgIGxldCBjdXJJbmRleCA9IGFrc2w7XG4gICAgICAgIHdoaWxlKC0tY3VySW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgYWtleSA9IGFrc1tjdXJJbmRleF07XG4gICAgICAgICAgICBpZiAoYmlbYWtleV0gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUoKytjdXJJbmRleCA8IGFrc2wpIHtcbiAgICAgICAgICAgIGNvbnN0IGFrZXkgPSBha3NbY3VySW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0W2FrZXldID0gYVtha2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGxpc3Qgb2YgY2hpbGRyZW4gZm9yIGFuIGVsZW1lbnQuXG4gKi9cblxuaW1wb3J0IE9iamVjdExpc3QgZnJvbSBcIi4uL3RyZWUvT2JqZWN0TGlzdC5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0TGlzdFByb3h5IGV4dGVuZHMgT2JqZWN0TGlzdCB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIH1cblxuICAgIG9uQWRkKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRBdChpdGVtLCBpbmRleCk7XG4gICAgfVxuXG4gICAgb25SZW1vdmUoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUF0KGluZGV4KTtcbiAgICB9XG5cbiAgICBvblN5bmMocmVtb3ZlZCwgYWRkZWQsIG9yZGVyKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5fc2V0QnlBcnJheShvcmRlcik7XG4gICAgfVxuXG4gICAgb25TZXQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnNldEF0KGl0ZW0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBvbk1vdmUoaXRlbSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5zZXRBdChpdGVtLCB0b0luZGV4KTtcbiAgICB9XG5cbiAgICBjcmVhdGVJdGVtKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0LmNyZWF0ZUl0ZW0ob2JqZWN0KTtcbiAgICB9XG5cbiAgICBpc0l0ZW0ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQuaXNJdGVtKG9iamVjdCk7XG4gICAgfVxuXG59XG5cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBsaXN0IG9mIGNoaWxkcmVuIGZvciBhbiBlbGVtZW50LlxuICovXG5cbmltcG9ydCBPYmplY3RMaXN0UHJveHkgZnJvbSBcIi4vT2JqZWN0TGlzdFByb3h5Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPYmplY3RMaXN0V3JhcHBlciBleHRlbmRzIE9iamVjdExpc3RQcm94eSB7XG5cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHdyYXApIHtcbiAgICAgICAgc3VwZXIodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fd3JhcCA9IHdyYXA7XG4gICAgfVxuXG4gICAgd3JhcChpdGVtKSB7XG4gICAgICAgIGxldCB3cmFwcGVyID0gdGhpcy5fd3JhcChpdGVtKTtcbiAgICAgICAgaXRlbS5fd3JhcHBlciA9IHdyYXBwZXI7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIG9uQWRkKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLndyYXAoaXRlbSk7XG4gICAgICAgIHN1cGVyLm9uQWRkKGl0ZW0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBvblJlbW92ZShpdGVtLCBpbmRleCkge1xuICAgICAgICBzdXBlci5vblJlbW92ZShpdGVtLCBpbmRleCk7XG4gICAgfVxuXG4gICAgb25TeW5jKHJlbW92ZWQsIGFkZGVkLCBvcmRlcikge1xuICAgICAgICBhZGRlZC5mb3JFYWNoKGEgPT4gdGhpcy53cmFwKGEpKTtcbiAgICAgICAgb3JkZXIgPSBvcmRlci5tYXAoYSA9PiBhLl93cmFwcGVyKTtcbiAgICAgICAgc3VwZXIub25TeW5jKHJlbW92ZWQsIGFkZGVkLCBvcmRlcik7XG4gICAgfVxuXG4gICAgb25TZXQoaXRlbSwgaW5kZXgpIHtcbiAgICAgICAgaXRlbSA9IHRoaXMud3JhcChpdGVtKTtcbiAgICAgICAgc3VwZXIub25TZXQoaXRlbSwgaW5kZXgpO1xuICAgIH1cblxuICAgIG9uTW92ZShpdGVtLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgc3VwZXIub25Nb3ZlKGl0ZW0sIGZyb21JbmRleCwgdG9JbmRleCk7XG4gICAgfVxuXG59XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgVXRpbHMgZnJvbSBcIi4uL3RyZWUvVXRpbHMubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi4vdHJlZS9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IFN0YXRpY0NhbnZhc1RleHR1cmUgZnJvbSBcIi4uL3RleHR1cmVzL1N0YXRpY0NhbnZhc1RleHR1cmUubWpzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVG9vbHMge1xuXG4gICAgc3RhdGljIGdldENhbnZhc1RleHR1cmUoY2FudmFzRmFjdG9yeSwgbG9va3VwSWQpIHtcbiAgICAgICAgcmV0dXJuIHt0eXBlOiBTdGF0aWNDYW52YXNUZXh0dXJlLCBjb250ZW50OiB7ZmFjdG9yeTogY2FudmFzRmFjdG9yeSwgbG9va3VwSWQ6IGxvb2t1cElkfX1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0Um91bmRSZWN0KHcsIGgsIHJhZGl1cywgc3Ryb2tlV2lkdGgsIHN0cm9rZUNvbG9yLCBmaWxsLCBmaWxsQ29sb3IpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJhZGl1cykpe1xuICAgICAgICAgICAgLy8gdXBwZXItbGVmdCwgdXBwZXItcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLWxlZnQuXG4gICAgICAgICAgICByYWRpdXMgPSBbcmFkaXVzLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmYWN0b3J5ID0gKGNiLCBzdGFnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzU3BhcmspIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5wbGF0Zm9ybS5jcmVhdGVSb3VuZFJlY3QoY2IsIHN0YWdlLCB3LCBoLCByYWRpdXMsIHN0cm9rZVdpZHRoLCBzdHJva2VDb2xvciwgZmlsbCwgZmlsbENvbG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2IobnVsbCwgdGhpcy5jcmVhdGVSb3VuZFJlY3Qoc3RhZ2UsIHcsIGgsIHJhZGl1cywgc3Ryb2tlV2lkdGgsIHN0cm9rZUNvbG9yLCBmaWxsLCBmaWxsQ29sb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGlkID0gJ3JlY3QnICsgW3csIGgsIHN0cm9rZVdpZHRoLCBzdHJva2VDb2xvciwgZmlsbCA/IDEgOiAwLCBmaWxsQ29sb3JdLmNvbmNhdChyYWRpdXMpLmpvaW4oXCIsXCIpO1xuICAgICAgICByZXR1cm4gVG9vbHMuZ2V0Q2FudmFzVGV4dHVyZShmYWN0b3J5LCBpZCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZVJvdW5kUmVjdChzdGFnZSwgdywgaCwgcmFkaXVzLCBzdHJva2VXaWR0aCwgc3Ryb2tlQ29sb3IsIGZpbGwsIGZpbGxDb2xvcikge1xuICAgICAgICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSBmaWxsID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoID09PSB1bmRlZmluZWQpIHN0cm9rZVdpZHRoID0gMDtcblxuICAgICAgICBsZXQgY2FudmFzID0gc3RhZ2UucGxhdGZvcm0uZ2V0RHJhd2luZ0NhbnZhcygpO1xuICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHcgKyBzdHJva2VXaWR0aCArIDI7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoICsgc3Ryb2tlV2lkdGggKyAyO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgbGV0IHggPSAwLjUgKiBzdHJva2VXaWR0aCArIDEsIHkgPSAwLjUgKiBzdHJva2VXaWR0aCArIDE7XG5cbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzWzBdLCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1c1sxXSwgeSk7XG4gICAgICAgIGN0eC5hcmNUbyh4ICsgdywgeSwgeCArIHcsIHkgKyByYWRpdXNbMV0sIHJhZGl1c1sxXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyBoIC0gcmFkaXVzWzJdKTtcbiAgICAgICAgY3R4LmFyY1RvKHggKyB3LCB5ICsgaCwgeCArIHcgLSByYWRpdXNbMl0sIHkgKyBoLCByYWRpdXNbMl0pO1xuICAgICAgICBjdHgubGluZVRvKHggKyByYWRpdXNbM10sIHkgKyBoKTtcbiAgICAgICAgY3R4LmFyY1RvKHgsIHkgKyBoLCB4LCB5ICsgaCAtIHJhZGl1c1szXSwgcmFkaXVzWzNdKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4LCB5ICsgcmFkaXVzWzBdKTtcbiAgICAgICAgY3R4LmFyY1RvKHgsIHksIHggKyByYWRpdXNbMF0sIHksIHJhZGl1c1swXSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzTnVtYmVyKGZpbGxDb2xvcikpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKGZpbGxDb2xvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNOdW1iZXIoc3Ryb2tlQ29sb3IpKSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gU3RhZ2VVdGlscy5nZXRSZ2JhU3RyaW5nKHN0cm9rZUNvbG9yKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U2hhZG93UmVjdCh3LCBoLCByYWRpdXMgPSAwLCBibHVyID0gNSwgbWFyZ2luID0gYmx1ciAqIDIpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJhZGl1cykpe1xuICAgICAgICAgICAgLy8gdXBwZXItbGVmdCwgdXBwZXItcmlnaHQsIGJvdHRvbS1yaWdodCwgYm90dG9tLWxlZnQuXG4gICAgICAgICAgICByYWRpdXMgPSBbcmFkaXVzLCByYWRpdXMsIHJhZGl1cywgcmFkaXVzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmYWN0b3J5ID0gKGNiLCBzdGFnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzU3BhcmspIHtcbiAgICAgICAgICAgICAgICBzdGFnZS5wbGF0Zm9ybS5jcmVhdGVTaGFkb3dSZWN0KGNiLCBzdGFnZSwgdywgaCwgcmFkaXVzLCBibHVyLCBtYXJnaW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCB0aGlzLmNyZWF0ZVNoYWRvd1JlY3Qoc3RhZ2UsIHcsIGgsIHJhZGl1cywgYmx1ciwgbWFyZ2luKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBpZCA9ICdzaGFkb3cnICsgW3csIGgsIGJsdXIsIG1hcmdpbl0uY29uY2F0KHJhZGl1cykuam9pbihcIixcIik7XG4gICAgICAgIHJldHVybiBUb29scy5nZXRDYW52YXNUZXh0dXJlKGZhY3RvcnksIGlkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlU2hhZG93UmVjdChzdGFnZSwgdywgaCwgcmFkaXVzLCBibHVyLCBtYXJnaW4pIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHN0YWdlLnBsYXRmb3JtLmdldERyYXdpbmdDYW52YXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSB3ICsgbWFyZ2luICogMjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGggKyBtYXJnaW4gKiAyO1xuXG4gICAgICAgIC8vIFdwZVdlYktpdCBidWc6IHdlIGV4cGVyaWVuY2VkIHByb2JsZW1zIHdpdGhvdXQgdGhpcyB3aXRoIHNoYWRvd3MgaW4gbm9uY29tcG9zaXRlZHdlYmdsIG1vZGUuXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuMDE7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAwLjAxLCAwLjAxKTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMS4wO1xuXG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZygweEZGRkZGRkZGKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFN0YWdlVXRpbHMuZ2V0UmdiYVN0cmluZygweEZGRkZGRkZGKTtcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBibHVyO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9ICh3ICsgMTApICsgbWFyZ2luO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IG1hcmdpbjtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnN0IHggPSAtKHcgKyAxMCk7XG4gICAgICAgIGNvbnN0IHkgPSAwO1xuXG4gICAgICAgIGN0eC5tb3ZlVG8oeCArIHJhZGl1c1swXSwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXNbMV0sIHkpO1xuICAgICAgICBjdHguYXJjVG8oeCArIHcsIHksIHggKyB3LCB5ICsgcmFkaXVzWzFdLCByYWRpdXNbMV0pO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3LCB5ICsgaCAtIHJhZGl1c1syXSk7XG4gICAgICAgIGN0eC5hcmNUbyh4ICsgdywgeSArIGgsIHggKyB3IC0gcmFkaXVzWzJdLCB5ICsgaCwgcmFkaXVzWzJdKTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzWzNdLCB5ICsgaCk7XG4gICAgICAgIGN0eC5hcmNUbyh4LCB5ICsgaCwgeCwgeSArIGggLSByYWRpdXNbM10sIHJhZGl1c1szXSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSArIHJhZGl1c1swXSk7XG4gICAgICAgIGN0eC5hcmNUbyh4LCB5LCB4ICsgcmFkaXVzWzBdLCB5LCByYWRpdXNbMF0pO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG5cbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U3ZnVGV4dHVyZSh1cmwsIHcsIGgpIHtcbiAgICAgICAgbGV0IGZhY3RvcnkgPSAoY2IsIHN0YWdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNTcGFyaykge1xuICAgICAgICAgICAgICAgIHN0YWdlLnBsYXRmb3JtLmNyZWF0ZVN2ZyhjYiwgc3RhZ2UsIHVybCwgdywgaCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlU3ZnKGNiLCBzdGFnZSwgdXJsLCB3LCBoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGlkID0gJ3N2ZycgKyBbdywgaCwgdXJsXS5qb2luKFwiLFwiKTtcbiAgICAgICAgcmV0dXJuIFRvb2xzLmdldENhbnZhc1RleHR1cmUoZmFjdG9yeSwgaWQpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGVTdmcoY2IsIHN0YWdlLCB1cmwsIHcsIGgpIHtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHN0YWdlLnBsYXRmb3JtLmdldERyYXdpbmdDYW52YXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBsZXQgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3O1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGg7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNiKG51bGwsIGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaW1nLm9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT24gdGhlIFBTNCBwbGF0Zm9ybSBzZXR0aW5nIHRoZSBgY3Jvc3NPcmlnaW5gIGF0dHJpYnV0ZSBvbiBpbWFnZXNcbiAgICAgICAgLy8gY2FuIGNhdXNlIENPUlMgZmFpbHVyZXMuXG4gICAgICAgIGlmICghVXRpbHMuaXNQUzQpIHtcbiAgICAgICAgICAgIGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XG4gICAgICAgIH1cblxuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuY2xhc3MgVXRpbHMge1xuXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgKHZhbHVlICUgMSkgPT09IDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNPYmplY3RMaXRlcmFsKHZhbHVlKXtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdFxuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBcnJheUluZGV4KGluZGV4LCBhcnIpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmdldE1vZHVsb0luZGV4KGluZGV4LCBhcnIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZXF1YWxWYWx1ZXModjEsIHYyKSB7XG4gICAgICAgIGlmICgodHlwZW9mIHYxKSAhPT0gKHR5cGVvZiB2MikpIHJldHVybiBmYWxzZVxuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYxKSkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2MikgJiYgVXRpbHMuZXF1YWxPYmplY3RMaXRlcmFscyh2MSwgdjIpXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2MSkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYyKSAmJiBVdGlscy5lcXVhbEFycmF5cyh2MSwgdjIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdjEgPT09IHYyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZXF1YWxPYmplY3RMaXRlcmFscyhvYmoxLCBvYmoyKSB7XG4gICAgICAgIGxldCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICAgICAgICBsZXQga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgICAgICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0ga2V5czEubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrMSA9IGtleXMxW2ldO1xuICAgICAgICAgICAgY29uc3QgazIgPSBrZXlzMltpXTtcbiAgICAgICAgICAgIGlmIChrMSAhPT0gazIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdjEgPSBvYmoxW2sxXTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gb2JqMltrMl07XG5cbiAgICAgICAgICAgIGlmICghVXRpbHMuZXF1YWxWYWx1ZXModjEsIHYyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsQXJyYXlzKHYxLCB2Mikge1xuICAgICAgICBpZiAodjEubGVuZ3RoICE9PSB2Mi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdjEubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXF1YWxWYWx1ZXModjFbaV0sIHYyW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBNYWludGFpbnMgdGhlIHN0YXRlIG9mIGEgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlxuICovXG5jbGFzcyBXZWJHTFN0YXRlIHtcblxuICAgIGNvbnN0cnVjdG9yKGlkLCBnbCkge1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9nbCA9IGdsO1xuICAgICAgICB0aGlzLl9wcm9ncmFtID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9idWZmZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9mcmFtZWJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmJ1ZmZlcnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLy8gQ29udGFpbnMgdmVydGV4IGF0dHJpYnV0ZSBkZWZpbml0aW9uIGFycmF5cyAoZW5hYmxlZCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpLlxuICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWJzID0gbmV3IEFycmF5KDE2KTtcbiAgICAgICAgdGhpcy5fbm9uRGVmYXVsdEZsYWdzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBuZXcgQXJyYXkoOCk7XG4gICAgICAgIHRoaXMuX21heFRleHR1cmUgPSAwO1xuICAgICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlID0gZ2wuVEVYVFVSRTA7XG4gICAgICAgIHRoaXMuX3BpeGVsU3RvcmVpID0gbmV3IEFycmF5KDUpO1xuICAgIH1cblxuICAgIF9nZXREZWZhdWx0RmxhZyhjYXApIHtcbiAgICAgICAgcmV0dXJuIChjYXAgPT09IHRoaXMuX2dsLkRJVEhFUik7XG4gICAgfVxuXG4gICAgc2V0RmxhZyhjYXAsIHYpIHtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZ2V0RGVmYXVsdEZsYWcoY2FwKTtcbiAgICAgICAgaWYgKHYgPT09IGRlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vbkRlZmF1bHRGbGFncy5kZWxldGUoY2FwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbm9uRGVmYXVsdEZsYWdzLmhhcyhjYXApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9uRGVmYXVsdEZsYWdzLmFkZChjYXApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRCdWZmZXIodGFyZ2V0LCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gdGhpcy5fYnVmZmVycy5nZXQodGFyZ2V0KSAhPT0gYnVmZmVyO1xuICAgICAgICB0aGlzLl9idWZmZXJzLnNldCh0YXJnZXQsIGJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKGNoYW5nZSAmJiAodGFyZ2V0ID09PSB0aGlzLl9nbC5BUlJBWV9CVUZGRVIpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBhcnJheSBidWZmZXIgaXMgY2hhbmdlZCBhbGwgYXR0cmlidXRlcyBhcmUgY2xlYXJlZC5cbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfVxuXG4gICAgc2V0RnJhbWVidWZmZXIodGFyZ2V0LCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gdGhpcy5fZnJhbWVidWZmZXJzLmdldCh0YXJnZXQpICE9PSBidWZmZXI7XG4gICAgICAgIHRoaXMuX2ZyYW1lYnVmZmVycy5zZXQodGFyZ2V0LCBidWZmZXIpO1xuICAgICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cblxuICAgIHNldFJlbmRlcmJ1ZmZlcih0YXJnZXQsIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLl9yZW5kZXJidWZmZXJzLmdldCh0YXJnZXQpICE9PSBidWZmZXI7XG4gICAgICAgIHRoaXMuX3JlbmRlcmJ1ZmZlcnMuc2V0KHRhcmdldCwgYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICBzZXRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gdGhpcy5fcHJvZ3JhbSAhPT0gcHJvZ3JhbTtcbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIHJldHVybiBjaGFuZ2VcbiAgICB9XG5cbiAgICBzZXRTZXR0aW5nKGZ1bmMsIHYpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuX3NldHRpbmdzLmdldChmdW5jKTtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gIXMgfHwgIVV0aWxzLmVxdWFsVmFsdWVzKHMsIHYpO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncy5zZXQoZnVuYywgdik7XG4gICAgICAgIHJldHVybiBjaGFuZ2VcbiAgICB9XG5cbiAgICBkaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgdmEgPSB0aGlzLl92ZXJ0ZXhBdHRyaWJzW2luZGV4XTtcbiAgICAgICAgaWYgKHZhICYmIHZhWzVdKSB7XG4gICAgICAgICAgICB2YVs1XSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHZhID0gdGhpcy5fdmVydGV4QXR0cmlic1tpbmRleF07XG4gICAgICAgIGlmICh2YSkge1xuICAgICAgICAgICAgaWYgKCF2YVswXSkge1xuICAgICAgICAgICAgICAgIHZhWzBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYnNbaW5kZXhdID0gWzAsIDAsIDAsIDAsIDAsIHRydWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIHByb3BzKSB7XG4gICAgICAgIGxldCB2YSA9IHRoaXMuX3ZlcnRleEF0dHJpYnNbaW5kZXhdO1xuICAgICAgICBsZXQgZXF1YWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhKSB7XG4gICAgICAgICAgICBlcXVhbCA9IHZhWzBdID09PSBwcm9wc1swXSAmJlxuICAgICAgICAgICAgICAgIHZhWzFdID09PSBwcm9wc1sxXSAmJlxuICAgICAgICAgICAgICAgIHZhWzJdID09PSBwcm9wc1syXSAmJlxuICAgICAgICAgICAgICAgIHZhWzNdID09PSBwcm9wc1szXSAmJlxuICAgICAgICAgICAgICAgIHZhWzRdID09PSBwcm9wc1s0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcXVhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHNbNV0gPSB2YSA/IHZhWzVdIDogZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEFjdGl2ZVRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5fYWN0aXZlVGV4dHVyZSAhPT0gdGV4dHVyZTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZSA9IHRleHR1cmU7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cblxuICAgIGJpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSkge1xuICAgICAgICBjb25zdCBhY3RpdmVJbmRleCA9IFdlYkdMU3RhdGUuX2dldFRleHR1cmVJbmRleCh0aGlzLl9hY3RpdmVUZXh0dXJlKTtcbiAgICAgICAgdGhpcy5fbWF4VGV4dHVyZSA9IE1hdGgubWF4KHRoaXMuX21heFRleHR1cmUsIGFjdGl2ZUluZGV4ICsgMSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLl90ZXh0dXJlc1thY3RpdmVJbmRleF07XG4gICAgICAgIGNvbnN0IHRhcmdldEluZGV4ID0gV2ViR0xTdGF0ZS5fZ2V0VGV4dHVyZVRhcmdldEluZGV4KHRhcmdldCk7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFt0YXJnZXRJbmRleF0gPT09IHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50W3RhcmdldEluZGV4XSA9IHRleHR1cmU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXNbYWN0aXZlSW5kZXhdID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXNbYWN0aXZlSW5kZXhdW3RhcmdldEluZGV4XSA9IHRleHR1cmU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQaXhlbFN0b3JlaShwbmFtZSwgcGFyYW0pIHtcbiAgICAgICAgY29uc3QgaSA9IFdlYkdMU3RhdGUuX2dldFBpeGVsU3RvcmVpSW5kZXgocG5hbWUpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSAhVXRpbHMuZXF1YWxWYWx1ZXModGhpcy5fcGl4ZWxTdG9yZWlbaV0sIHBhcmFtKTtcbiAgICAgICAgdGhpcy5fcGl4ZWxTdG9yZWlbaV0gPSBwYXJhbTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICBtaWdyYXRlKHMpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gV2FybmluZzogbWlncmF0ZSBzaG91bGQgY2FsbCB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIG1ldGhvZHMgZGlyZWN0bHkuXG5cbiAgICAgICAgdGhpcy5fbWlncmF0ZUZsYWdzKHQsIHMpO1xuXG4gICAgICAgIC8vIHVzZVByb2dyYW1cbiAgICAgICAgaWYgKHMuX3Byb2dyYW0gIT09IHQuX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMuX2dsLl91c2VQcm9ncmFtKHMuX3Byb2dyYW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWlncmF0ZUZyYW1lYnVmZmVycyh0LCBzKTtcbiAgICAgICAgdGhpcy5fbWlncmF0ZVJlbmRlcmJ1ZmZlcnModCwgcyk7XG5cbiAgICAgICAgY29uc3QgYnVmZmVyc0NoYW5nZWQgPSB0aGlzLl9taWdyYXRlQnVmZmVycyh0LCBzKTtcbiAgICAgICAgdGhpcy5fbWlncmF0ZUF0dHJpYnV0ZXModCwgcywgYnVmZmVyc0NoYW5nZWQpO1xuXG4gICAgICAgIHRoaXMuX21pZ3JhdGVGbGFncyh0LCBzKTtcblxuICAgICAgICB0aGlzLl9taWdyYXRlU2V0dGluZ3ModCwgcyk7XG5cbiAgICAgICAgdGhpcy5fbWlncmF0ZVBpeGVsU3RvcmVpKHQsIHMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fbWlncmF0ZVRleHR1cmVzKHQsIHMpO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBfbWlncmF0ZVBpeGVsU3RvcmVpKHQsIHMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0Ll9waXhlbFN0b3JlaS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0Ll9waXhlbFN0b3JlaVtpXSAhPT0gcy5fcGl4ZWxTdG9yZWlbaV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHMuX3BpeGVsU3RvcmVpW2ldICE9PSB1bmRlZmluZWQgPyBzLl9waXhlbFN0b3JlaVtpXSA6IFdlYkdMU3RhdGUuX2dldERlZmF1bHRQaXhlbFN0b3JlaUJ5SW5kZXgoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX3BpeGVsU3RvcmVpKFdlYkdMU3RhdGUuX2dldFBpeGVsU3RvcmVpQnlJbmRleChpKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21pZ3JhdGVUZXh0dXJlcyh0LCBzKSB7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHQuX21heFRleHR1cmUsIHMuX21heFRleHR1cmUpO1xuXG4gICAgICAgIGxldCBhY3RpdmVUZXh0dXJlID0gdC5fYWN0aXZlVGV4dHVyZTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzVGFyZ2V0cyA9IHMuX3RleHR1cmVzW2ldO1xuICAgICAgICAgICAgY29uc3QgdFRhcmdldHMgPSB0Ll90ZXh0dXJlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVOdW1iID0gV2ViR0xTdGF0ZS5fZ2V0VGV4dHVyZUJ5SW5kZXgoaSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE1heCA9IE1hdGgubWF4KHRUYXJnZXRzID8gdFRhcmdldHMubGVuZ3RoIDogMCwgc1RhcmdldHMgPyBzVGFyZ2V0cy5sZW5ndGggOiAwKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBuID0gdGFyZ2V0TWF4OyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gV2ViR0xTdGF0ZS5fZ2V0VGV4dHVyZVRhcmdldEJ5SW5kZXgoaik7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVRleHR1cmUgIT09IHRleHR1cmVOdW1iKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9hY3RpdmVUZXh0dXJlKHRleHR1cmVOdW1iKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGV4dHVyZSA9IHRleHR1cmVOdW1iO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSAoc1RhcmdldHMgJiYgc1RhcmdldHNbal0pIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2JpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocy5fYWN0aXZlVGV4dHVyZSAhPT0gYWN0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fZ2wuX2FjdGl2ZVRleHR1cmUocy5fYWN0aXZlVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbWlncmF0ZUJ1ZmZlcnModCwgcykge1xuICAgICAgICBzLl9idWZmZXJzLmZvckVhY2goKGZyYW1lYnVmZmVyLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0Ll9idWZmZXJzLmdldCh0YXJnZXQpICE9PSBmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl9iaW5kQnVmZmVyKHRhcmdldCwgZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0Ll9idWZmZXJzLmZvckVhY2goKGJ1ZmZlciwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBiID0gcy5fYnVmZmVycy5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYmluZEJ1ZmZlcih0YXJnZXQsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChzLl9idWZmZXJzLmdldCh0aGlzLl9nbC5BUlJBWV9CVUZGRVIpICE9PSB0Ll9idWZmZXJzLmdldCh0aGlzLl9nbC5BUlJBWV9CVUZGRVIpKVxuICAgIH1cblxuICAgIF9taWdyYXRlRnJhbWVidWZmZXJzKHQsIHMpIHtcbiAgICAgICAgcy5fZnJhbWVidWZmZXJzLmZvckVhY2goKGZyYW1lYnVmZmVyLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0Ll9mcmFtZWJ1ZmZlcnMuZ2V0KHRhcmdldCkgIT09IGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2JpbmRGcmFtZWJ1ZmZlcih0YXJnZXQsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdC5fZnJhbWVidWZmZXJzLmZvckVhY2goKGZyYW1lYnVmZmVyLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZiID0gcy5fZnJhbWVidWZmZXJzLmdldCh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKGZiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYmluZEZyYW1lYnVmZmVyKHRhcmdldCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9taWdyYXRlUmVuZGVyYnVmZmVycyh0LCBzKSB7XG4gICAgICAgIHMuX3JlbmRlcmJ1ZmZlcnMuZm9yRWFjaCgocmVuZGVyYnVmZmVyLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0Ll9yZW5kZXJidWZmZXJzLmdldCh0YXJnZXQpICE9PSByZW5kZXJidWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbC5fYmluZFJlbmRlcmJ1ZmZlcih0YXJnZXQsIHJlbmRlcmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHQuX3JlbmRlcmJ1ZmZlcnMuZm9yRWFjaCgocmVuZGVyYnVmZmVyLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZiID0gcy5fcmVuZGVyYnVmZmVycy5nZXQodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChmYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2JpbmRSZW5kZXJidWZmZXIodGFyZ2V0LCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX21pZ3JhdGVBdHRyaWJ1dGVzKHQsIHMsIGJ1ZmZlcnNDaGFuZ2VkKSB7XG5cbiAgICAgICAgaWYgKCFidWZmZXJzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdC5fdmVydGV4QXR0cmlicy5mb3JFYWNoKChhdHRyaWIsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzLl92ZXJ0ZXhBdHRyaWJzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCAnZGVsZXRlJyBhIHZlcnRleCBhdHRyaWIgc28gd2UnbGwgZGlzYWJsZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2Rpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHMuX3ZlcnRleEF0dHJpYnMuZm9yRWFjaCgoYXR0cmliLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsLl92ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBhdHRyaWJbMF0sIGF0dHJpYlsxXSwgYXR0cmliWzJdLCBhdHRyaWJbNF0pO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJbNV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2VuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYnVmZmVycyBhcmUgY2hhbmdlZCwgcHJldmlvdXMgYXR0cmlidXRlcyB3ZXJlIHJlc2V0IGF1dG9tYXRpY2FsbHkuXG4gICAgICAgICAgICBzLl92ZXJ0ZXhBdHRyaWJzLmZvckVhY2goKGF0dHJpYiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmliWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzZXQgdmVydGV4IGF0dHJpYiBwb2ludGVyIHdoZW4gaXQgd2FzIGp1c3QgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dsLl92ZXJ0ZXhBdHRyaWJQb2ludGVyKGluZGV4LCBhdHRyaWJbMF0sIGF0dHJpYlsxXSwgYXR0cmliWzJdLCBhdHRyaWJbM10sIGF0dHJpYls0XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJbNV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2VuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9taWdyYXRlU2V0dGluZ3ModCwgcykge1xuICAgICAgICBjb25zdCBkZWZhdWx0cyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0RGVmYXVsdFNldHRpbmdzKCk7XG4gICAgICAgIHQuX3NldHRpbmdzLmZvckVhY2goKHZhbHVlLCBmdW5jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZnVuYy5uYW1lIHx8IGZ1bmMueG5hbWU7XG4gICAgICAgICAgICBpZiAoIXMuX3NldHRpbmdzLmhhcyhmdW5jKSkge1xuICAgICAgICAgICAgICAgIGxldCBhcmdzID0gZGVmYXVsdHMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzKHRoaXMuX2dsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFjdHVhbGx5IHNldHRpbmcgdGhlIHNldHRpbmcgZm9yIG9wdGltaXphdGlvbiBwdXJwb3Nlcy5cbiAgICAgICAgICAgICAgICBzLl9zZXR0aW5ncy5zZXQoZnVuYywgYXJncyk7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLl9nbCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzLl9zZXR0aW5ncy5mb3JFYWNoKCh2YWx1ZSwgZnVuYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdFZhbHVlID0gdC5fc2V0dGluZ3MuZ2V0KGZ1bmMpO1xuICAgICAgICAgICAgaWYgKCF0VmFsdWUgfHwgIVV0aWxzLmVxdWFsVmFsdWVzKHRWYWx1ZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLl9nbCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfbWlncmF0ZUZsYWdzKHQsIHMpIHtcbiAgICAgICAgdC5fbm9uRGVmYXVsdEZsYWdzLmZvckVhY2goc2V0dGluZyA9PiB7XG4gICAgICAgICAgICBpZiAoIXMuX25vbkRlZmF1bHRGbGFncy5oYXMoc2V0dGluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZ2V0RGVmYXVsdEZsYWcoc2V0dGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2wuX2VuYWJsZShzZXR0aW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZGlzYWJsZShzZXR0aW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzLl9ub25EZWZhdWx0RmxhZ3MuZm9yRWFjaChzZXR0aW5nID0+IHtcbiAgICAgICAgICAgIGlmICghdC5fbm9uRGVmYXVsdEZsYWdzLmhhcyhzZXR0aW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9nZXREZWZhdWx0RmxhZyhzZXR0aW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZGlzYWJsZShzZXR0aW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbC5fZW5hYmxlKHNldHRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldERlZmF1bHRTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZhdWx0U2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRTZXR0aW5ncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLl9kZWZhdWx0U2V0dGluZ3M7XG4gICAgICAgICAgICBjb25zdCBnID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGQuc2V0KFwidmlld3BvcnRcIiwgZnVuY3Rpb24oZ2wpIHtyZXR1cm4gWzAsMCxnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHRdfSk7XG4gICAgICAgICAgICBkLnNldChcInNjaXNzb3JcIiwgZnVuY3Rpb24oZ2wpIHtyZXR1cm4gWzAsMCxnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHRdfSk7XG4gICAgICAgICAgICBkLnNldChcImJsZW5kQ29sb3JcIiwgWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiYmxlbmRFcXVhdGlvblwiLCBbZy5GVU5DX0FERF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJibGVuZEVxdWF0aW9uU2VwYXJhdGVcIiwgW2cuRlVOQ19BREQsIGcuRlVOQ19BRERdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiYmxlbmRGdW5jXCIsIFtnLk9ORSwgZy5aRVJPXSk7XG4gICAgICAgICAgICBkLnNldChcImJsZW5kRnVuY1NlcGFyYXRlXCIsIFtnLk9ORSwgZy5aRVJPLCBnLk9ORSwgZy5aRVJPXSk7XG4gICAgICAgICAgICBkLnNldChcImNsZWFyQ29sb3JcIiwgWzAsIDAsIDAsIDBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiY2xlYXJEZXB0aFwiLCBbMV0pO1xuICAgICAgICAgICAgZC5zZXQoXCJjbGVhclN0ZW5jaWxcIiwgWzBdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiY29sb3JNYXNrXCIsIFt0cnVlLCB0cnVlLCB0cnVlLCB0cnVlXSk7XG4gICAgICAgICAgICBkLnNldChcImN1bGxGYWNlXCIsIFtnLkJBQ0tdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiZGVwdGhGdW5jXCIsIFtnLkxFU1NdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiZGVwdGhNYXNrXCIsIFt0cnVlXSk7XG4gICAgICAgICAgICBkLnNldChcImRlcHRoUmFuZ2VcIiwgWzAsIDFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiZnJvbnRGYWNlXCIsIFtnLkNDV10pO1xuICAgICAgICAgICAgZC5zZXQoXCJsaW5lV2lkdGhcIiwgWzFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwicG9seWdvbk9mZnNldFwiLCBbMCwgMF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJzYW1wbGVDb3ZlcmFnZVwiLCBbMSwgZmFsc2VdKTtcbiAgICAgICAgICAgIGQuc2V0KFwic3RlbmNpbEZ1bmNcIiwgW2cuQUxXQVlTLCAwLCAxXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsRnVuY1NlcGFyYXRlRnJvbnRcIiwgW2cuQUxXQVlTLCAwLCAxXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsRnVuY1NlcGFyYXRlQmFja1wiLCBbZy5BTFdBWVMsIDAsIDFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxGdW5jU2VwYXJhdGVGcm9udEFuZEJhY2tcIiwgW2cuQUxXQVlTLCAwLCAxXSk7XG4gICAgICAgICAgICBkLnNldChcInN0ZW5jaWxNYXNrXCIsIFsxXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsTWFza1NlcGFyYXRlRnJvbnRcIiwgWzFdKTtcbiAgICAgICAgICAgIGQuc2V0KFwiX3N0ZW5jaWxNYXNrU2VwYXJhdGVCYWNrXCIsIFsxXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsTWFza1NlcGFyYXRlRnJvbnRBbmRCYWNrXCIsIFsxXSk7XG4gICAgICAgICAgICBkLnNldChcInN0ZW5jaWxPcFwiLCBbZy5LRUVQLCBnLktFRVAsIGcuS0VFUF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbE9wU2VwYXJhdGVGcm9udFwiLCBbZy5LRUVQLCBnLktFRVAsIGcuS0VFUF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJfc3RlbmNpbE9wU2VwYXJhdGVCYWNrXCIsIFtnLktFRVAsIGcuS0VFUCwgZy5LRUVQXSk7XG4gICAgICAgICAgICBkLnNldChcIl9zdGVuY2lsT3BTZXBhcmF0ZUZyb250QW5kQmFja1wiLCBbZy5LRUVQLCBnLktFRVAsIGcuS0VFUF0pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWIxZlwiLCBbXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjFmdlwiLCBbXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjJmXCIsIFtdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliMmZ2XCIsIFtdKTtcbiAgICAgICAgICAgIGQuc2V0KFwidmVydGV4QXR0cmliM2ZcIiwgW10pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWIzZnZcIiwgW10pO1xuICAgICAgICAgICAgZC5zZXQoXCJ2ZXJ0ZXhBdHRyaWI0ZlwiLCBbXSk7XG4gICAgICAgICAgICBkLnNldChcInZlcnRleEF0dHJpYjRmdlwiLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRTZXR0aW5nc1xuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0VGV4dHVyZVRhcmdldEluZGV4KHRhcmdldCkge1xuICAgICAgICBzd2l0Y2godGFyZ2V0KSB7XG4gICAgICAgICAgICBjYXNlIDB4MERFMTpcbiAgICAgICAgICAgICAgICAvKiBURVhUVVJFXzJEICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIDB4ODUxMzpcbiAgICAgICAgICAgICAgICAvKiBURVhUVVJFX0NVQkVfTUFQICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFNob3VsZG4ndCBoYXBwZW4uXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHRleHR1cmUgdGFyZ2V0OiAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0VGV4dHVyZVRhcmdldEJ5SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJlVGFyZ2V0SW5kaWNlcykge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZVRhcmdldEluZGljZXMgPSBbMHgwREUxLCAweDg1MTNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlVGFyZ2V0SW5kaWNlc1tpbmRleF1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2dldFRleHR1cmVJbmRleChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggLSAweDg0QzAgLyogR0xfVEVYVFVSRTAgKi87XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRUZXh0dXJlQnlJbmRleChpbmRleCkge1xuICAgICAgICByZXR1cm4gaW5kZXggKyAweDg0QzA7XG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXRQaXhlbFN0b3JlaUluZGV4KHBuYW1lKSB7XG4gICAgICAgIHN3aXRjaChwbmFtZSkge1xuICAgICAgICAgICAgY2FzZSAweDBEMDU6XG4gICAgICAgICAgICAgICAgLyogUEFDS19BTElHTk1FTlQgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMHgwQ0Y1OlxuICAgICAgICAgICAgICAgIC8qIFVOUEFDS19BTElHTk1FTlQgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgMHg5MjQwOlxuICAgICAgICAgICAgICAgIC8qIFVOUEFDS19GTElQX1lfV0VCR0wgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIGNhc2UgMHg5MjQxOlxuICAgICAgICAgICAgICAgIC8qIFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgY2FzZSAweDkyNDM6XG4gICAgICAgICAgICAgICAgLyogVU5QQUNLX0NPTE9SU1BBQ0VfQ09OVkVSU0lPTl9XRUJHTCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiA0O1xuICAgICAgICAgICAgICAgIC8vQHRvZG86IHN1cHBvcnQgV2ViR0wyIHByb3BlcnRpZXMsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViR0xSZW5kZXJpbmdDb250ZXh0L3BpeGVsU3RvcmVpXG4gICAgICAgICAgICBjYXNlIDB4OTI0NTpcbiAgICAgICAgICAgICAgICAvKiBVTlBBQ0tfRkxJUF9CTFVFX1JFRCAqL1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBTaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwaXhlbHN0b3JlaTogJyArIHBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBfZ2V0UGl4ZWxTdG9yZWlCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5fcGl4ZWxTdG9yZWlJbmRpY2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9waXhlbFN0b3JlaUluZGljZXMgPSBbMHgwRDA1LCAweDBDRjUsIDB4OTI0MCwgMHg5MjQxLCAweDkyNDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbFN0b3JlaUluZGljZXNbaW5kZXhdXG4gICAgfVxuXG4gICAgc3RhdGljIF9nZXREZWZhdWx0UGl4ZWxTdG9yZWlCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5fcGl4ZWxTdG9yZWlEZWZhdWx0cykge1xuICAgICAgICAgICAgdGhpcy5fcGl4ZWxTdG9yZWlEZWZhdWx0cyA9IFs0LCA0LCBmYWxzZSwgZmFsc2UsIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUuQlJPV1NFUl9ERUZBVUxUX1dFQkdMXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxTdG9yZWlEZWZhdWx0c1tpbmRleF1cbiAgICB9XG59XG5cbmNsYXNzIFdlYkdMU3RhdGVNYW5hZ2VyIHtcblxuICAgIF9pbml0U3RhdGVNYW5hZ2VyKGlkID0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVzID0ge307XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fZ2V0U3RhdGUoaWQpO1xuICAgIH1cblxuICAgIF9nZXRTdGF0ZShpZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlc1tpZF0pIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlc1tpZF0gPSBuZXcgV2ViR0xTdGF0ZShpZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlc1tpZF07XG4gICAgfVxuXG4gICAgc3dpdGNoU3RhdGUoaWQgPSBcImRlZmF1bHRcIikge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuX2lkICE9PSBpZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLl9nZXRTdGF0ZShpZCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5taWdyYXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkdXNlUHJvZ3JhbShwcm9ncmFtKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRQcm9ncmFtKHByb2dyYW0pKVxuICAgICAgICAgICAgdGhpcy5fdXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB9XG5cbiAgICAkYmluZEJ1ZmZlcih0YXJnZXQsIGZiKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRCdWZmZXIodGFyZ2V0LCBmYikpXG4gICAgICAgICAgICB0aGlzLl9iaW5kQnVmZmVyKHRhcmdldCwgZmIpO1xuICAgIH1cblxuICAgICRiaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmYikge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0RnJhbWVidWZmZXIodGFyZ2V0LCBmYikpXG4gICAgICAgICAgICB0aGlzLl9iaW5kRnJhbWVidWZmZXIodGFyZ2V0LCBmYik7XG4gICAgfVxuXG4gICAgJGJpbmRSZW5kZXJidWZmZXIodGFyZ2V0LCBmYikge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0UmVuZGVyYnVmZmVyKHRhcmdldCwgZmIpKVxuICAgICAgICAgICAgdGhpcy5fYmluZFJlbmRlcmJ1ZmZlcih0YXJnZXQsIGZiKTtcbiAgICB9XG5cbiAgICAkZW5hYmxlKGNhcCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0RmxhZyhjYXAsIHRydWUpKVxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlKGNhcCk7XG4gICAgfVxuXG4gICAgJGRpc2FibGUoY2FwKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRGbGFnKGNhcCwgZmFsc2UpKVxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZShjYXApO1xuICAgIH1cblxuICAgICR2aWV3cG9ydCh4LCB5LCB3LCBoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZpZXdwb3J0LCBbeCwgeSwgdywgaF0pKVxuICAgICAgICAgICAgdGhpcy5fdmlld3BvcnQoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgJHNjaXNzb3IoeCwgeSwgdywgaCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9zY2lzc29yLCBbeCwgeSwgdywgaF0pKVxuICAgICAgICAgICAgdGhpcy5fc2Npc3Nvcih4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICAkZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpKVxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICB9XG5cbiAgICAkZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KSlcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVZlcnRleEF0dHJpYkFycmF5KGluZGV4KTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnZlcnRleEF0dHJpYlBvaW50ZXIoaW5kZXgsIFtzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUsIG9mZnNldF0pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliUG9pbnRlcihpbmRleCwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlLCBvZmZzZXQpO1xuICAgIH1cblxuICAgICRhY3RpdmVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldEFjdGl2ZVRleHR1cmUodGV4dHVyZSkpXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cblxuICAgICRiaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLmJpbmRUZXh0dXJlKHRhcmdldCwgdGV4dHVyZSkpXG4gICAgICAgICAgICB0aGlzLl9iaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpO1xuICAgIH1cblxuICAgICRwaXhlbFN0b3JlaShwbmFtZSwgcGFyYW0pIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFBpeGVsU3RvcmVpKHBuYW1lLCBwYXJhbSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsU3RvcmVpKHBuYW1lLCBwYXJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkc3RlbmNpbEZ1bmNTZXBhcmF0ZShmYWNlLCBmdW5jLCByZWYsIG1hc2spIHtcbiAgICAgICAgbGV0IGY7XG4gICAgICAgIHN3aXRjaChmYWNlKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuRlJPTlQ6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxGdW5jU2VwYXJhdGVGcm9udDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5CQUNLOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsRnVuY1NlcGFyYXRlQmFjaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgdGhpcy5GUk9OVF9BTkRfQkFDSzpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbEZ1bmNTZXBhcmF0ZUZyb250QW5kQmFjaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKGYsIFtmdW5jLCByZWYsIG1hc2tdKSlcbiAgICAgICAgICAgIGYuYXBwbHkodGhpcywgW2Z1bmMsIHJlZiwgbWFza10pO1xuICAgIH1cblxuICAgIF9zdGVuY2lsRnVuY1NlcGFyYXRlRnJvbnQoZnVuYywgcmVmLCBtYXNrKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxGdW5jU2VwYXJhdGUodGhpcy5GUk9OVCwgZnVuYywgcmVmLCBtYXNrKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbEZ1bmNTZXBhcmF0ZUJhY2soZnVuYywgcmVmLCBtYXNrKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxGdW5jU2VwYXJhdGUodGhpcy5CQUNLLCBmdW5jLCByZWYsIG1hc2spO1xuICAgIH1cblxuICAgIF9zdGVuY2lsRnVuY1NlcGFyYXRlRnJvbnRBbmRCYWNrKGZ1bmMsIHJlZiwgbWFzaykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsRnVuY1NlcGFyYXRlKHRoaXMuRlJPTlRfQU5EX0JBQ0ssIGZ1bmMsIHJlZiwgbWFzayk7XG4gICAgfVxuXG4gICAgJHN0ZW5jaWxNYXNrU2VwYXJhdGUoZmFjZSwgbWFzaykge1xuICAgICAgICBsZXQgZjtcbiAgICAgICAgc3dpdGNoKGZhY2UpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5GUk9OVDpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbE1hc2tTZXBhcmF0ZUZyb250O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLkJBQ0s6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxNYXNrU2VwYXJhdGVCYWNrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLkZST05UX0FORF9CQUNLOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsTWFza1NlcGFyYXRlRnJvbnRBbmRCYWNrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcoZiwgW21hc2tdKSlcbiAgICAgICAgICAgIGYuYXBwbHkodGhpcywgW21hc2tdKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbE1hc2tTZXBhcmF0ZUZyb250KG1hc2spIHtcbiAgICAgICAgdGhpcy5fc3RlbmNpbE1hc2tTZXBhcmF0ZSh0aGlzLkZST05ULCBtYXNrKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbE1hc2tTZXBhcmF0ZUJhY2sobWFzaykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsTWFza1NlcGFyYXRlKHRoaXMuQkFDSywgbWFzayk7XG4gICAgfVxuXG4gICAgX3N0ZW5jaWxNYXNrU2VwYXJhdGVGcm9udEFuZEJhY2sobWFzaykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsTWFza1NlcGFyYXRlKHRoaXMuRlJPTlRfQU5EX0JBQ0ssIG1hc2spO1xuICAgIH1cblxuICAgICRzdGVuY2lsT3BTZXBhcmF0ZShmYWNlLCBmYWlsLCB6ZmFpbCwgenBhc3MpIHtcbiAgICAgICAgbGV0IGY7XG4gICAgICAgIHN3aXRjaChmYWNlKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuRlJPTlQ6XG4gICAgICAgICAgICAgICAgZiA9IHRoaXMuX3N0ZW5jaWxPcFNlcGFyYXRlRnJvbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuQkFDSzpcbiAgICAgICAgICAgICAgICBmID0gdGhpcy5fc3RlbmNpbE9wU2VwYXJhdGVCYWNrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLkZST05UX0FORF9CQUNLOlxuICAgICAgICAgICAgICAgIGYgPSB0aGlzLl9zdGVuY2lsT3BTZXBhcmF0ZUZyb250QW5kQmFjaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKGYsIFtmYWlsLCB6ZmFpbCwgenBhc3NdKSlcbiAgICAgICAgICAgIGYuYXBwbHkodGhpcywgW2ZhaWwsIHpmYWlsLCB6cGFzc10pO1xuICAgIH1cblxuICAgIF9zdGVuY2lsT3BTZXBhcmF0ZUZyb250KGZhaWwsIHpmYWlsLCB6cGFzcykge1xuICAgICAgICB0aGlzLl9zdGVuY2lsT3BTZXBhcmF0ZSh0aGlzLkZST05ULCBmYWlsLCB6ZmFpbCwgenBhc3MpO1xuICAgIH1cblxuICAgIF9zdGVuY2lsT3BTZXBhcmF0ZUJhY2soZmFpbCwgemZhaWwsIHpwYXNzKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxPcFNlcGFyYXRlKHRoaXMuQkFDSywgZmFpbCwgemZhaWwsIHpwYXNzKTtcbiAgICB9XG5cbiAgICBfc3RlbmNpbE9wU2VwYXJhdGVGcm9udEFuZEJhY2soZmFpbCwgemZhaWwsIHpwYXNzKSB7XG4gICAgICAgIHRoaXMuX3N0ZW5jaWxPcFNlcGFyYXRlKHRoaXMuRlJPTlRfQU5EX0JBQ0ssIGZhaWwsIHpmYWlsLCB6cGFzcyk7XG4gICAgfVxuXG4gICAgJGJsZW5kQ29sb3IocmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fYmxlbmRDb2xvciwgW3JlZCwgZ3JlZW4sIGJsdWUsIGFscGhhXSkpXG4gICAgICAgICAgICB0aGlzLl9ibGVuZENvbG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKTtcbiAgICB9XG5cbiAgICAkYmxlbmRFcXVhdGlvbihtb2RlKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2JsZW5kRXF1YXRpb24sIFttb2RlXSkpXG4gICAgICAgICAgICB0aGlzLl9ibGVuZEVxdWF0aW9uKG1vZGUpO1xuICAgIH1cblxuICAgICRibGVuZEVxdWF0aW9uU2VwYXJhdGUobW9kZVJHQiwgbW9kZUFscGhhKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2JsZW5kRXF1YXRpb25TZXBhcmF0ZSwgW21vZGVSR0IsIG1vZGVBbHBoYV0pKVxuICAgICAgICAgICAgdGhpcy5fYmxlbmRFcXVhdGlvblNlcGFyYXRlKG1vZGVSR0IsIG1vZGVBbHBoYSk7XG4gICAgfVxuXG4gICAgJGJsZW5kRnVuYyhzZmFjdG9yLCBkZmFjdG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2JsZW5kRnVuYywgW3NmYWN0b3IsIGRmYWN0b3JdKSlcbiAgICAgICAgICAgIHRoaXMuX2JsZW5kRnVuYyhzZmFjdG9yLCBkZmFjdG9yKTtcbiAgICB9XG5cbiAgICAkYmxlbmRGdW5jU2VwYXJhdGUoc3JjUkdCLCBkc3RSR0IsIHNyY0FscGhhLCBkc3RBbHBoYSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9ibGVuZEZ1bmNTZXBhcmF0ZSwgW3NyY1JHQiwgZHN0UkdCLCBzcmNBbHBoYSwgZHN0QWxwaGFdKSlcbiAgICAgICAgICAgIHRoaXMuX2JsZW5kRnVuY1NlcGFyYXRlKHNyY1JHQiwgZHN0UkdCLCBzcmNBbHBoYSwgZHN0QWxwaGEpO1xuICAgIH1cblxuICAgICRjbGVhckNvbG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX2NsZWFyQ29sb3IsIFtyZWQsIGdyZWVuLCBibHVlLCBhbHBoYV0pKVxuICAgICAgICAgICAgdGhpcy5fY2xlYXJDb2xvcihyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSk7XG4gICAgfVxuXG4gICAgJGNsZWFyRGVwdGgoZGVwdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fY2xlYXJEZXB0aCwgW2RlcHRoXSkpXG4gICAgICAgICAgICB0aGlzLl9jbGVhckRlcHRoKGRlcHRoKTtcbiAgICB9XG5cbiAgICAkY2xlYXJTdGVuY2lsKHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fY2xlYXJTdGVuY2lsLCBbc10pKVxuICAgICAgICAgICAgdGhpcy5fY2xlYXJTdGVuY2lsKHMpO1xuICAgIH1cblxuICAgICRjb2xvck1hc2socmVkLCBncmVlbiwgYmx1ZSwgYWxwaGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fY29sb3JNYXNrLCBbcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGFdKSlcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yTWFzayhyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSk7XG4gICAgfVxuXG4gICAgJGN1bGxGYWNlKG1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fY3VsbEZhY2UsIFttb2RlXSkpXG4gICAgICAgICAgICB0aGlzLl9jdWxsRmFjZShtb2RlKTtcbiAgICB9XG5cbiAgICAkZGVwdGhGdW5jKGZ1bmMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fZGVwdGhGdW5jLCBbZnVuY10pKVxuICAgICAgICAgICAgdGhpcy5fZGVwdGhGdW5jKGZ1bmMpO1xuICAgIH1cblxuICAgICRkZXB0aE1hc2soZmxhZykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9kZXB0aE1hc2ssIFtmbGFnXSkpXG4gICAgICAgICAgICB0aGlzLl9kZXB0aE1hc2soZmxhZyk7XG4gICAgfVxuXG4gICAgJGRlcHRoUmFuZ2Uoek5lYXIsIHpGYXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fZGVwdGhSYW5nZSwgW3pOZWFyLCB6RmFyXSkpXG4gICAgICAgICAgICB0aGlzLl9kZXB0aFJhbmdlKHpOZWFyLCB6RmFyKTtcbiAgICB9XG5cbiAgICAkZnJvbnRGYWNlKG1vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fZnJvbnRGYWNlLCBbbW9kZV0pKVxuICAgICAgICAgICAgdGhpcy5fZnJvbnRGYWNlKG1vZGUpO1xuICAgIH1cblxuICAgICRsaW5lV2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fbGluZVdpZHRoLCBbd2lkdGhdKSlcbiAgICAgICAgICAgIHRoaXMuX2xpbmVXaWR0aCh3aWR0aCk7XG4gICAgfVxuXG4gICAgJHBvbHlnb25PZmZzZXQoZmFjdG9yLCB1bml0cykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9wb2x5Z29uT2Zmc2V0LCBbZmFjdG9yLCB1bml0c10pKVxuICAgICAgICAgICAgdGhpcy5fcG9seWdvbk9mZnNldChmYWN0b3IsIHVuaXRzKTtcbiAgICB9XG5cbiAgICAkc2FtcGxlQ292ZXJhZ2UodmFsdWUsIGludmVydCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9zYW1wbGVDb3ZlcmFnZSwgW3ZhbHVlLCBpbnZlcnRdKSlcbiAgICAgICAgICAgIHRoaXMuX3NhbXBsZUNvdmVyYWdlKHZhbHVlLCBpbnZlcnQpO1xuICAgIH1cblxuICAgICRzdGVuY2lsRnVuYyhmdW5jLCByZWYsIG1hc2spIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fc3RlbmNpbEZ1bmMsIFtmdW5jLCByZWYsIG1hc2tdKSlcbiAgICAgICAgICAgIHRoaXMuX3N0ZW5jaWxGdW5jKGZ1bmMsIHJlZiwgbWFzayk7XG4gICAgfVxuXG4gICAgJHN0ZW5jaWxNYXNrKG1hc2spIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fc3RlbmNpbE1hc2ssIFttYXNrXSkpXG4gICAgICAgICAgICB0aGlzLl9zdGVuY2lsTWFzayhtYXNrKTtcbiAgICB9XG5cbiAgICAkc3RlbmNpbE9wKGZhaWwsIHpmYWlsLCB6cGFzcykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl9zdGVuY2lsT3AsIFtmYWlsLCB6ZmFpbCwgenBhc3NdKSlcbiAgICAgICAgICAgIHRoaXMuX3N0ZW5jaWxPcChmYWlsLCB6ZmFpbCwgenBhc3MpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWIxZihpbmR4LCB4KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjFmLCBbaW5keCwgeF0pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliMWYoaW5keCwgeCk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjFmdihpbmR4LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliMWZ2LCBbaW5keCwgdmFsdWVzXSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWIxZnYoaW5keCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliMmYoaW5keCwgeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWIyZiwgW2luZHgsIHgsIHldKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjJmKGluZHgsIHgsIHkpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWIyZnYoaW5keCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjJmdiwgW2luZHgsIHZhbHVlc10pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliMmZ2KGluZHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjNmKGluZHgsIHgsIHksIHopIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliM2YsIFtpbmR4LCB4LCB5LCB6XSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWIzZihpbmR4LCB4LCB5LCB6KTtcbiAgICB9XG5cbiAgICAkdmVydGV4QXR0cmliM2Z2KGluZHgsIHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUuc2V0U2V0dGluZyh0aGlzLl92ZXJ0ZXhBdHRyaWIzZnYsIFtpbmR4LCB2YWx1ZXNdKSlcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEF0dHJpYjNmdihpbmR4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgICR2ZXJ0ZXhBdHRyaWI0ZihpbmR4LCB4LCB5LCB6LCB3KSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZS5zZXRTZXR0aW5nKHRoaXMuX3ZlcnRleEF0dHJpYjRmLCBbaW5keCwgeCwgeSwgeiwgd10pKVxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QXR0cmliNGYoaW5keCwgeCwgeSwgeiwgdyk7XG4gICAgfVxuXG4gICAgJHZlcnRleEF0dHJpYjRmdihpbmR4LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlLnNldFNldHRpbmcodGhpcy5fdmVydGV4QXR0cmliNGZ2LCBbaW5keCwgdmFsdWVzXSkpXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhBdHRyaWI0ZnYoaW5keCwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJpbmcgY29udGV4dCBmb3IgY29udGV4dCBzaGFyaW5nLlxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqL1xuICAgIHN0YXRpYyBlbmFibGUoZ2wsIGlkID0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhXZWJHTFN0YXRlTWFuYWdlci5wcm90b3R5cGUpO1xuICAgICAgICBjb25zdCBXZWJHTFJlbmRlcmluZ0NvbnRleHRQcm90byA9IGdsLl9fcHJvdG9fXztcbiAgICAgICAgbmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRob2QgPSBXZWJHTFN0YXRlTWFuYWdlci5wcm90b3R5cGVbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcIiRcIikge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChnbFtuYW1lXSAhPT0gbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbFtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnbFtuYW1lXS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBDaHJvbWUgV2ViR0wgSW5zcGVjdG9yIHBsdWdpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbFtuYW1lXS54bmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnbFsnXycgKyBuYW1lXSA9IGdsW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGdsW25hbWVdID0gbWV0aG9kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgV2ViR0xTdGF0ZU1hbmFnZXIucHJvdG90eXBlLl9pbml0U3RhdGVNYW5hZ2VyLmNhbGwoZ2wsIGlkKTtcblxuICAgICAgICByZXR1cm4gZ2w7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdlYkdMU3RhdGVNYW5hZ2VyO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZSB7XG5cbiAgICBzdGF0aWMgZGVmYXVsdFNldHRlcihvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBwYXRjaE9iamVjdChvYmosIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICghVXRpbHMuaXNPYmplY3RMaXRlcmFsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltMaWdodG5pbmddIFNldHRpbmdzIG11c3QgYmUgb2JqZWN0IGxpdGVyYWxcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmFtZXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5hbWVzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gbmFtZXNbaV07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoT2JqZWN0UHJvcGVydHkob2JqLCBuYW1lLCBzZXR0aW5nc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcGF0Y2hPYmplY3RQcm9wZXJ0eShvYmosIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXR0ZXIgPSBvYmouc2V0U2V0dGluZyB8fCBCYXNlLmRlZmF1bHRTZXR0ZXI7XG5cbiAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcIl9cIikge1xuICAgICAgICAgICAgLy8gRGlzYWxsb3cgcGF0Y2hpbmcgcHJpdmF0ZSB2YXJpYWJsZXMuXG4gICAgICAgICAgICBpZiAobmFtZSAhPT0gXCJfX2NyZWF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltMaWdodG5pbmddIFBhdGNoIG9mIHByaXZhdGUgcHJvcGVydHkgJ1wiICsgbmFtZSArIFwiJyBpcyBub3QgYWxsb3dlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuYW1lICE9PSBcInR5cGVcIikge1xuICAgICAgICAgICAgLy8gVHlwZSBpcyBhIHJlc2VydmVkIGtleXdvcmQgdG8gc3BlY2lmeSB0aGUgY2xhc3MgdHlwZSBvbiBjcmVhdGlvbi5cbiAgICAgICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKHZhbHVlKSAmJiB2YWx1ZS5fX2xvY2FsKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9jYWwgZnVuY3Rpb24gKEJhc2UubG9jYWwocyA9PiBzLnNvbWV0aGluZykpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5fX2xvY2FsKG9iaik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRlcihvYmosIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBsb2NhbChmdW5jKSB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYW4gb2JqZWN0IHNldHRpbmcsIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSB0YXJnZXQgb2JqZWN0LlxuICAgICAgICBmdW5jLl9fbG9jYWwgPSB0cnVlO1xuICAgIH1cblxuXG59XG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi9VdGlscy5tanNcIjtcblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBSZW5kZXIgdHJlZSBub2RlLlxuICovXG5cbmltcG9ydCBTdGFnZVV0aWxzIGZyb20gXCIuL1N0YWdlVXRpbHMubWpzXCI7XG5pbXBvcnQgRWxlbWVudENvcmUgZnJvbSBcIi4vY29yZS9FbGVtZW50Q29yZS5tanNcIjtcbmltcG9ydCBCYXNlIGZyb20gXCIuL0Jhc2UubWpzXCI7XG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi9VdGlscy5tanNcIjtcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSBcIi4uL0V2ZW50RW1pdHRlci5tanNcIjtcbmltcG9ydCBTaGFkZXIgZnJvbSBcIi4vU2hhZGVyLm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgICAgICB0aGlzLl9faWQgPSBFbGVtZW50LmlkKys7XG5cbiAgICAgICAgdGhpcy5fX3N0YXJ0KCk7XG5cbiAgICAgICAgLy8gRXZlbnRFbWl0dGVyIGNvbnN0cnVjdG9yLlxuICAgICAgICB0aGlzLl9oYXNFdmVudExpc3RlbmVycyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX19jb3JlID0gbmV3IEVsZW1lbnRDb3JlKHRoaXMpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0aGF0IGNhbiBiZSB1c2VkIHdoaWxlIG1lcmdpbmcgdHJlZXMuXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fcmVmID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZWxlbWVudCBpcyBhdHRhY2hlZCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2YgdGhlIHN0YWdlIHJvb3QuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX2F0dGFjaGVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVsZW1lbnQgaXMgZW5hYmxlZCB3aGVuIGl0IGlzIGF0dGFjaGVkIGFuZCBpdCBpcyB2aXNpYmxlICh3b3JsZEFscGhhID4gMCkuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX2VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gZWxlbWVudCBpcyBhY3RpdmUgd2hlbiBpdCBpcyBlbmFibGVkIGFuZCBpdCBpcyB3aXRoaW4gYm91bmRzLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX19hY3RpdmUgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fcGFyZW50ID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgdGhhdCBpcyBjdXJyZW50bHkgc2V0LlxuICAgICAgICAgKiBAdHlwZSB7VGV4dHVyZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX190ZXh0dXJlID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgdGV4dHVyZS4gV2hpbGUgdGhpcy50ZXh0dXJlIGlzIGxvYWRpbmcsIHRoaXMgb25lIG1heSBiZSBkaWZmZXJlbnQuXG4gICAgICAgICAqIEB0eXBlIHtUZXh0dXJlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWdzIHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkvc2VhcmNoIGZvciBhIHNwZWNpZmljIGVsZW1lbnQuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmdbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX190YWdzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRyZWUncyB0YWdzIG1hcHBpbmcuXG4gICAgICAgICAqIFRoaXMgY29udGFpbnMgYWxsIGVsZW1lbnRzIGZvciBhbGwga25vd24gdGFncywgYXQgYWxsIHRpbWVzLlxuICAgICAgICAgKiBAdHlwZSB7TWFwfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX3RyZWVUYWdzID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHRhZyBjb250ZXh0OiB0YWdnZWQgZWxlbWVudHMgaW4gdGhpcyBicmFuY2ggd2lsbCBub3QgYmUgcmVhY2hhYmxlIGZyb20gYW5jZXN0b3JzIG9mIHRoaXMgZWxlbWVudHMuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX3RhZ1Jvb3QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogKExhenktaW5pdGlhbGlzZWQpIGxpc3Qgb2YgY2hpbGRyZW4gb3duZWQgYnkgdGhpcyBlbGVtZW50cy5cbiAgICAgICAgICogQHR5cGUge0VsZW1lbnRDaGlsZExpc3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fY2hpbGRMaXN0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl93ID0gMDtcblxuICAgICAgICB0aGlzLl9oID0gMDtcbiAgICB9XG5cbiAgICBfX3N0YXJ0KCkge1xuICAgIH1cblxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgICB9XG5cbiAgICBzZXQgcmVmKHJlZikge1xuICAgICAgICBpZiAodGhpcy5fX3JlZiAhPT0gcmVmKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyY29kZSA9IHJlZi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgaWYgKCFVdGlscy5pc1VjQ2hhcihjaGFyY29kZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiUmVmIG11c3Qgc3RhcnQgd2l0aCBhbiB1cHBlciBjYXNlIGNoYXJhY3RlcjogXCIgKyByZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX19yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhZyh0aGlzLl9fcmVmKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fcGFyZW50Ll9fY2hpbGRMaXN0LmNsZWFyUmVmKHRoaXMuX19yZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX3JlZiA9IHJlZjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19yZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUYWcodGhpcy5fX3JlZik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX19wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3BhcmVudC5fX2NoaWxkTGlzdC5zZXRSZWYodGhpcy5fX3JlZiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19yZWY7XG4gICAgfVxuXG4gICAgZ2V0IGNvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZTtcbiAgICB9XG5cbiAgICBzZXRBc1Jvb3QoKSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnNldEFzUm9vdCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVBdHRhY2hlZEZsYWcoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRW5hYmxlZEZsYWcoKTtcbiAgICB9XG5cbiAgICBnZXQgaXNSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuaXNSb290O1xuICAgIH1cblxuICAgIF9zZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9fcGFyZW50ID09PSBwYXJlbnQpIHJldHVybjtcblxuICAgICAgICBpZiAodGhpcy5fX3BhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdW5zZXRUYWdzUGFyZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fcGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRhZ3NQYXJlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUF0dGFjaGVkRmxhZygpO1xuICAgICAgICB0aGlzLl91cGRhdGVFbmFibGVkRmxhZygpO1xuICAgICAgICB0aGlzLl91cGRhdGVDb2xsaXNpb24oKTtcblxuICAgICAgICBpZiAodGhpcy5pc1Jvb3QgJiYgcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiUm9vdCBzaG91bGQgbm90IGJlIGFkZGVkIGFzIGEgY2hpbGQhIFJlc3VsdHMgYXJlIHVuc3BlY2lmaWVkIVwiKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXREZXB0aCgpIHtcbiAgICAgICAgbGV0IGRlcHRoID0gMDtcblxuICAgICAgICBsZXQgcCA9IHRoaXMuX19wYXJlbnQ7XG4gICAgICAgIHdoaWxlKHApIHtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgICAgICBwID0gcC5fX3BhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXB0aDtcbiAgICB9O1xuXG4gICAgZ2V0QW5jZXN0b3IobCkge1xuICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChsID4gMCAmJiBwLl9fcGFyZW50KSB7XG4gICAgICAgICAgICBwID0gcC5fX3BhcmVudDtcbiAgICAgICAgICAgIGwtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9O1xuXG4gICAgZ2V0QW5jZXN0b3JzKCkge1xuICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgICAgIGEucHVzaChwKTtcbiAgICAgICAgICAgIHAgPSBwLl9fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGdldEFuY2VzdG9yQXREZXB0aChkZXB0aCkge1xuICAgICAgICBsZXQgbGV2ZWxzID0gdGhpcy5nZXREZXB0aCgpIC0gZGVwdGg7XG4gICAgICAgIGlmIChsZXZlbHMgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmNlc3RvcihsZXZlbHMpO1xuICAgIH07XG5cbiAgICBpc0FuY2VzdG9yT2YoYykge1xuICAgICAgICBsZXQgcCA9IGM7XG4gICAgICAgIHdoaWxlKHAgPSBwLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMgPT09IHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGdldFNoYXJlZEFuY2VzdG9yKGMpIHtcbiAgICAgICAgbGV0IG8xID0gdGhpcztcbiAgICAgICAgbGV0IG8yID0gYztcbiAgICAgICAgbGV0IGwxID0gbzEuZ2V0RGVwdGgoKTtcbiAgICAgICAgbGV0IGwyID0gbzIuZ2V0RGVwdGgoKTtcbiAgICAgICAgaWYgKGwxID4gbDIpIHtcbiAgICAgICAgICAgIG8xID0gbzEuZ2V0QW5jZXN0b3IobDEgLSBsMik7XG4gICAgICAgIH0gZWxzZSBpZiAobDIgPiBsMSkge1xuICAgICAgICAgICAgbzIgPSBvMi5nZXRBbmNlc3RvcihsMiAtIGwxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChvMSA9PT0gbzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbzE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG8xID0gbzEuX19wYXJlbnQ7XG4gICAgICAgICAgICBvMiA9IG8yLl9fcGFyZW50O1xuICAgICAgICB9IHdoaWxlIChvMSAmJiBvMik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGdldCBhdHRhY2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19hdHRhY2hlZDtcbiAgICB9XG5cbiAgICBnZXQgZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmFibGVkO1xuICAgIH1cblxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fYWN0aXZlO1xuICAgIH1cblxuICAgIF9pc0F0dGFjaGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX19wYXJlbnQgPyB0aGlzLl9fcGFyZW50Ll9fYXR0YWNoZWQgOiAodGhpcy5zdGFnZS5yb290ID09PSB0aGlzKSk7XG4gICAgfTtcblxuICAgIF9pc0VuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS52aXNpYmxlICYmICh0aGlzLl9fY29yZS5hbHBoYSA+IDApICYmICh0aGlzLl9fcGFyZW50ID8gdGhpcy5fX3BhcmVudC5fX2VuYWJsZWQgOiAodGhpcy5zdGFnZS5yb290ID09PSB0aGlzKSk7XG4gICAgfTtcblxuICAgIF9pc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRW5hYmxlZCgpICYmIHRoaXMud2l0aGluQm91bmRzTWFyZ2luO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSAnYXR0YWNoZWQnIGZsYWcgZm9yIHRoaXMgYnJhbmNoLlxuICAgICAqL1xuICAgIF91cGRhdGVBdHRhY2hlZEZsYWcoKSB7XG4gICAgICAgIGxldCBuZXdBdHRhY2hlZCA9IHRoaXMuX2lzQXR0YWNoZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX19hdHRhY2hlZCAhPT0gbmV3QXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19hdHRhY2hlZCA9IG5ld0F0dGFjaGVkO1xuXG4gICAgICAgICAgICBpZiAobmV3QXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblNldHVwKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmdldCgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5fdXBkYXRlQXR0YWNoZWRGbGFnKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQXR0YWNoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGV0YWNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgJ2VuYWJsZWQnIGZsYWcgZm9yIHRoaXMgYnJhbmNoLlxuICAgICAqL1xuICAgIF91cGRhdGVFbmFibGVkRmxhZygpIHtcbiAgICAgICAgbGV0IG5ld0VuYWJsZWQgPSB0aGlzLl9pc0VuYWJsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX19lbmFibGVkICE9PSBuZXdFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAobmV3RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRW5hYmxlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEVuYWJsZWRGbGFnKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRGlzYWJsZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl91bnNldEVuYWJsZWRGbGFnKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmdldCgpO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbGV0IG0gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKG0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5fdXBkYXRlRW5hYmxlZEZsYWcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBfc2V0RW5hYmxlZEZsYWcoKSB7XG4gICAgICAgIHRoaXMuX19lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBGb3JjZSByZS1jaGVjayBvZiB0ZXh0dXJlIGJlY2F1c2UgZGltZW5zaW9ucyBtaWdodCBoYXZlIGNoYW5nZWQgKGN1dHRpbmcpLlxuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRleHR1cmVDb29yZHMoKTtcblxuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX190ZXh0dXJlLmFkZEVsZW1lbnQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy53aXRoaW5Cb3VuZHNNYXJnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEFjdGl2ZUZsYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fY29yZS5zaGFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb3JlLnNoYWRlci5hZGRFbGVtZW50KHRoaXMuX19jb3JlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgX3Vuc2V0RW5hYmxlZEZsYWcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnNldEFjdGl2ZUZsYWcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fX3RleHR1cmUucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fY29yZS5zaGFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb3JlLnNoYWRlci5yZW1vdmVFbGVtZW50KHRoaXMuX19jb3JlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl90ZXh0dXJpemVyKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cml6ZXIuZmlsdGVycy5mb3JFYWNoKGZpbHRlciA9PiBmaWx0ZXIucmVtb3ZlRWxlbWVudCh0aGlzLl9fY29yZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBfc2V0QWN0aXZlRmxhZygpIHtcbiAgICAgICAgdGhpcy5fX2FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBtdXN0IGhhcHBlbiBiZWZvcmUgZW5hYmxpbmcgdGhlIHRleHR1cmUsIGJlY2F1c2UgaXQgbWF5IGFscmVhZHkgYmUgbG9hZGVkIG9yIGxvYWQgZGlyZWN0bHkuXG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fX3RleHR1cmUuaW5jQWN0aXZlQ291bnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29uQWN0aXZlKCk7XG4gICAgfVxuXG4gICAgX3Vuc2V0QWN0aXZlRmxhZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGV4dHVyZS5kZWNBY3RpdmVDb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVUZXh0dXJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFzVGV4dHVyaXplcigpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cml6ZXIuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25JbmFjdGl2ZSgpO1xuICAgIH1cblxuICAgIF9vblNldHVwKCkge1xuICAgIH1cblxuICAgIF9vbkF0dGFjaCgpIHtcbiAgICB9XG5cbiAgICBfb25EZXRhY2goKSB7XG4gICAgfVxuXG4gICAgX29uRW5hYmxlZCgpIHtcbiAgICB9XG5cbiAgICBfb25EaXNhYmxlZCgpIHtcbiAgICB9XG5cbiAgICBfb25BY3RpdmUoKSB7XG4gICAgfVxuXG4gICAgX29uSW5hY3RpdmUoKSB7XG4gICAgfVxuXG4gICAgX29uUmVzaXplKCkge1xuICAgIH1cblxuICAgIF9nZXRSZW5kZXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3cpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUuZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gVGV4dHVyZSBhbHJlYWR5IGxvYWRlZCwgYnV0IG5vdCB5ZXQgdXBkYXRlZCAocHJvYmFibHkgYmVjYXVzZSB0aGlzIGVsZW1lbnQgaXMgbm90IGFjdGl2ZSkuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3RleHR1cmUuZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9nZXRSZW5kZXJIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlLmdldFJlbmRlckhlaWdodCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyBUZXh0dXJlIGFscmVhZHkgbG9hZGVkLCBidXQgbm90IHlldCB1cGRhdGVkIChwcm9iYWJseSBiZWNhdXNlIHRoaXMgZWxlbWVudCBpcyBub3QgYWN0aXZlKS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdGV4dHVyZS5nZXRSZW5kZXJIZWlnaHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCByZW5kZXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX19lbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgd2lkdGggaXMgb25seSBtYWludGFpbmVkIGlmIHRoaXMgZWxlbWVudCBpcyBlbmFibGVkLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmdldFJlbmRlcldpZHRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UmVuZGVyV2lkdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZW5kZXJIZWlnaHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9fZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmdldFJlbmRlckhlaWdodCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJlbmRlckhlaWdodCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZpbmFsWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLng7XG4gICAgfVxuXG4gICAgZ2V0IGZpbmFsWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnk7XG4gICAgfVxuXG4gICAgZ2V0IGZpbmFsVygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnc7XG4gICAgfVxuXG4gICAgZ2V0IGZpbmFsSCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmg7XG4gICAgfVxuXG4gICAgdGV4dHVyZUlzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3RleHR1cmUgJiYgdGhpcy5fX3RleHR1cmUuaXNMb2FkZWQoKTtcbiAgICB9XG5cbiAgICBsb2FkVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGV4dHVyZS5sb2FkKCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fX3RleHR1cmUuaXNVc2VkKCkgfHwgIXRoaXMuX2lzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZGluZyB0aGUgdGV4dHVyZSB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIHRoZSBkaW1lbnNpb25zIG9mIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSB1cGRhdGUgdGhlbSwgc28gdGhhdCBjYWxjcyBjYW4gYmUgcGVyZm9ybWVkIGltbWVkaWF0ZWx5IGluIHVzZXJsYW5kLlxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9lbmFibGVUZXh0dXJlRXJyb3IoKSB7XG4gICAgICAgIC8vIHR4RXJyb3IgZXZlbnQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgYmUgcmUtdHJpZ2dlcmVkIHdoZW4gYSBlbGVtZW50IGJlY29tZXMgYWN0aXZlLlxuICAgICAgICBjb25zdCBsb2FkRXJyb3IgPSB0aGlzLl9fdGV4dHVyZS5sb2FkRXJyb3I7XG4gICAgICAgIGlmIChsb2FkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndHhFcnJvcicsIGxvYWRFcnJvciwgdGhpcy5fX3RleHR1cmUuX3NvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZW5hYmxlVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldERpc3BsYXllZFRleHR1cmUodGhpcy5fX3RleHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXRhaW4gdGhlIG9sZCAnZ2hvc3QnIGltYWdlIGFzIGl0IHdhc24ndCB2aXNpYmxlIGFueXdheS5cbiAgICAgICAgICAgIHRoaXMuX3NldERpc3BsYXllZFRleHR1cmUobnVsbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVRleHR1cmVFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rpc2FibGVUZXh0dXJlKCkge1xuICAgICAgICAvLyBXZSBkaXNhYmxlIHRoZSBkaXNwbGF5ZWQgdGV4dHVyZSBiZWNhdXNlLCB3aGVuIHRoZSB0ZXh0dXJlIGNoYW5nZXMgd2hpbGUgaW52aXNpYmxlLCB3ZSBzaG91bGQgdXNlIHRoYXQgdywgaCxcbiAgICAgICAgLy8gbXcsIG1oIGZvciBjaGVja2luZyB3aXRoaW4gYm91bmRzLlxuICAgICAgICB0aGlzLl9zZXREaXNwbGF5ZWRUZXh0dXJlKG51bGwpO1xuICAgIH1cblxuICAgIGdldCB0ZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3RleHR1cmU7XG4gICAgfVxuXG4gICAgc2V0IHRleHR1cmUodikge1xuICAgICAgICBsZXQgdGV4dHVyZTtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgaWYgKHYudHlwZSkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgdi50eXBlKHRoaXMuc3RhZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGV4dHVyZSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXYpIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHYuaXNUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZSA9IHY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHYuaXNUZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBTb3VyY2VUZXh0dXJlKHRoaXMuc3RhZ2UpO1xuICAgICAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZVNvdXJjZSA9IHY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTGlnaHRuaW5nXSBQbGVhc2Ugc3BlY2lmeSBhIHRleHR1cmUgdHlwZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJldlRleHR1cmUgPSB0aGlzLl9fdGV4dHVyZTtcbiAgICAgICAgaWYgKHRleHR1cmUgIT09IHByZXZUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGV4dHVyZSA9IHRleHR1cmU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdGV4dHVyZS5hZGRFbGVtZW50KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLndpdGhpbkJvdW5kc01hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX190ZXh0dXJlLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXREaXNwbGF5ZWRUZXh0dXJlKHRoaXMuX190ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlVGV4dHVyZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGN1cnJlbnQgdGV4dHVyZSBpcyBjbGVhcmVkIHdoZW4gdGhlIHRleHR1cmUgaXMgZXhwbGljaXRseSBzZXQgdG8gbnVsbC5cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXREaXNwbGF5ZWRUZXh0dXJlKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldlRleHR1cmUgJiYgcHJldlRleHR1cmUgIT09IHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgcHJldlRleHR1cmUucmVtb3ZlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGRpc3BsYXllZFRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZTtcbiAgICB9XG5cbiAgICBfc2V0RGlzcGxheWVkVGV4dHVyZSh2KSB7XG4gICAgICAgIGxldCBwcmV2VGV4dHVyZSA9IHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlO1xuXG4gICAgICAgIGlmIChwcmV2VGV4dHVyZSAmJiAodiAhPT0gcHJldlRleHR1cmUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX3RleHR1cmUgIT09IHByZXZUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9sZCBkaXNwbGF5ZWQgdGV4dHVyZSBpcyBkZXByZWNhdGVkLlxuICAgICAgICAgICAgICAgIHByZXZUZXh0dXJlLnJlbW92ZUVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmV2U291cmNlID0gdGhpcy5fX2NvcmUuZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA/IHRoaXMuX19jb3JlLmRpc3BsYXllZFRleHR1cmVTb3VyY2UuX3NvdXJjZSA6IG51bGw7XG4gICAgICAgIGNvbnN0IHNvdXJjZUNoYW5nZWQgPSAodiA/IHYuX3NvdXJjZSA6IG51bGwpICE9PSBwcmV2U291cmNlO1xuXG4gICAgICAgIHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlID0gdjtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHJlZmVyZW5jZSB0aGUgZGlzcGxheWVkIHRleHR1cmUgYmVjYXVzZSBpdCB3YXMgYWxyZWFkeSByZWZlcmVuY2VkICh0aGlzLnRleHR1cmUgPT09IHRoaXMuZGlzcGxheWVkVGV4dHVyZSkuXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGV4dHVyZUNvb3JkcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb3JlLnNldERpc3BsYXllZFRleHR1cmVTb3VyY2UodGhpcy5fX2Rpc3BsYXllZFRleHR1cmUuX3NvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fY29yZS5zZXREaXNwbGF5ZWRUZXh0dXJlU291cmNlKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndHhMb2FkZWQnLCB0aGlzLl9fZGlzcGxheWVkVGV4dHVyZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndHhVbmxvYWRlZCcsIHRoaXMuX19kaXNwbGF5ZWRUZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uVGV4dHVyZVNvdXJjZUxvYWRlZCgpIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBlbGVtZW50IGlzIGVuYWJsZWQsIGJ1dCB3ZSBvbmx5IHdhbnQgdG8gc2V0IGRpc3BsYXllZCB0ZXh0dXJlIGZvciBhY3RpdmUgZWxlbWVudHMuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgLy8gV2UgbWF5IGJlIGRlYWxpbmcgd2l0aCBhIHRleHR1cmUgcmVsb2FkaW5nLCBzbyB3ZSBtdXN0IGZvcmNlIHVwZGF0ZS5cbiAgICAgICAgICAgIHRoaXMuX3NldERpc3BsYXllZFRleHR1cmUodGhpcy5fX3RleHR1cmUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIG9uVGV4dHVyZVNvdXJjZUxvYWRFcnJvcihlKSB7XG4gICAgICAgIHRoaXMuZW1pdCgndHhFcnJvcicsIGUsIHRoaXMuX190ZXh0dXJlLl9zb3VyY2UpO1xuICAgIH07XG5cbiAgICBmb3JjZVJlbmRlclVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcbiAgICB9XG5cbiAgICBvbkRpc3BsYXllZFRleHR1cmVDbGlwcGluZ0NoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGV4dHVyZUNvb3JkcygpO1xuICAgIH07XG5cbiAgICBvblByZWNpc2lvbkNoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB9O1xuXG4gICAgb25EaW1lbnNpb25zQ2hhbmdlZCh3LCBoKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUgaW5zdGFuY2VvZiBUZXh0VGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLncgPSB3O1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmggPSBoO1xuICAgICAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgICAgIHRoaXMuaCA9IGg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlRGltZW5zaW9ucygpIHtcbiAgICAgICAgbGV0IHcgPSB0aGlzLl9nZXRSZW5kZXJXaWR0aCgpO1xuICAgICAgICBsZXQgaCA9IHRoaXMuX2dldFJlbmRlckhlaWdodCgpO1xuXG4gICAgICAgIGxldCB1bmtub3duU2l6ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoIXcgfHwgIWgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fX2Rpc3BsYXllZFRleHR1cmUgJiYgdGhpcy5fX3RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSAnbWF4IHdpZHRoJyByZXBsYWNlbWVudCBpbnN0ZWFkIGluIHRoZSBFbGVtZW50Q29yZSBjYWxjcy5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBpdCBpcyBhYmxlIHRvIGRldGVybWluZSB3aXRoaW5Cb3VuZHMuXG4gICAgICAgICAgICAgICAgdyA9IHcgfHwgdGhpcy5fX3RleHR1cmUubXc7XG4gICAgICAgICAgICAgICAgaCA9IGggfHwgdGhpcy5fX3RleHR1cmUubWg7XG5cbiAgICAgICAgICAgICAgICBpZiAoKCF3IHx8ICFoKSAmJiB0aGlzLl9fdGV4dHVyZS5pc0F1dG9zaXplVGV4dHVyZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd25TaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX2NvcmUuc2V0RGltZW5zaW9ucyh3LCBoLCB1bmtub3duU2l6ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uUmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlVGV4dHVyZUNvb3JkcygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheWVkVGV4dHVyZSAmJiB0aGlzLmRpc3BsYXllZFRleHR1cmUuX3NvdXJjZSkge1xuICAgICAgICAgICAgbGV0IGRpc3BsYXllZFRleHR1cmUgPSB0aGlzLmRpc3BsYXllZFRleHR1cmU7XG4gICAgICAgICAgICBsZXQgZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA9IHRoaXMuZGlzcGxheWVkVGV4dHVyZS5fc291cmNlO1xuXG4gICAgICAgICAgICBsZXQgdHgxID0gMCwgdHkxID0gMCwgdHgyID0gMS4wLCB0eTIgPSAxLjA7XG4gICAgICAgICAgICBpZiAoZGlzcGxheWVkVGV4dHVyZS5jbGlwcGluZykge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRleHR1cmUgY2xpcHBpbmcuXG4gICAgICAgICAgICAgICAgbGV0IHcgPSBkaXNwbGF5ZWRUZXh0dXJlU291cmNlLmdldFJlbmRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgbGV0IGggPSBkaXNwbGF5ZWRUZXh0dXJlU291cmNlLmdldFJlbmRlckhlaWdodCgpO1xuICAgICAgICAgICAgICAgIGxldCBpdywgaWgsIHJ3LCByaDtcbiAgICAgICAgICAgICAgICBpdyA9IDEgLyB3O1xuICAgICAgICAgICAgICAgIGloID0gMSAvIGg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlzcGxheWVkVGV4dHVyZS5wdykge1xuICAgICAgICAgICAgICAgICAgICBydyA9IChkaXNwbGF5ZWRUZXh0dXJlLnB3KSAqIGl3O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ3ID0gKHcgLSBkaXNwbGF5ZWRUZXh0dXJlLnB4KSAqIGl3O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5ZWRUZXh0dXJlLnBoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJoID0gZGlzcGxheWVkVGV4dHVyZS5waCAqIGloO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJoID0gKGggLSBkaXNwbGF5ZWRUZXh0dXJlLnB5KSAqIGloO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGl3ICo9IChkaXNwbGF5ZWRUZXh0dXJlLnB4KTtcbiAgICAgICAgICAgICAgICBpaCAqPSAoZGlzcGxheWVkVGV4dHVyZS5weSk7XG5cbiAgICAgICAgICAgICAgICB0eDEgPSBpdztcbiAgICAgICAgICAgICAgICB0eTEgPSBpaDtcbiAgICAgICAgICAgICAgICB0eDIgPSB0eDIgKiBydyArIGl3O1xuICAgICAgICAgICAgICAgIHR5MiA9IHR5MiAqIHJoICsgaWg7XG5cbiAgICAgICAgICAgICAgICB0eDEgPSBNYXRoLm1heCgwLCB0eDEpO1xuICAgICAgICAgICAgICAgIHR5MSA9IE1hdGgubWF4KDAsIHR5MSk7XG4gICAgICAgICAgICAgICAgdHgyID0gTWF0aC5taW4oMSwgdHgyKTtcbiAgICAgICAgICAgICAgICB0eTIgPSBNYXRoLm1pbigxLCB0eTIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlzcGxheWVkVGV4dHVyZVNvdXJjZS5fZmxpcFRleHR1cmVZKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlbXB0eSA9IHR5MjtcbiAgICAgICAgICAgICAgICB0eTIgPSB0eTE7XG4gICAgICAgICAgICAgICAgdHkxID0gdGVtcHR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2V0VGV4dHVyZUNvb3Jkcyh0eDEsIHR5MSwgdHgyLCB0eTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q29ybmVyUG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuZ2V0Q29ybmVyUG9pbnRzKCk7XG4gICAgfVxuXG4gICAgX3Vuc2V0VGFnc1BhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX190YWdzKSB7XG4gICAgICAgICAgICB0aGlzLl9fdGFncy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0cmVlVGFncy5cbiAgICAgICAgICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHAgPSBwLl9fcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRUcmVlVGFncyA9IHAuX190cmVlVGFncy5nZXQodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50VHJlZVRhZ3MuZGVsZXRlKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLl9fdGFnUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0YWdzID0gbnVsbDtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBpZiAodGhpcy5fX3RyZWVUYWdzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX190YWdSb290KSB7XG4gICAgICAgICAgICAgICAgdGFncyA9IFV0aWxzLml0ZXJhdG9yVG9BcnJheSh0aGlzLl9fdHJlZVRhZ3Mua2V5cygpKTtcbiAgICAgICAgICAgICAgICBuID0gdGFncy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0YWdTZXQgPSB0aGlzLl9fdHJlZVRhZ3MuZ2V0KHRhZ3NbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSB0cmVlVGFncy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgocCA9IHAuX19wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudFRyZWVUYWdzID0gcC5fX3RyZWVUYWdzLmdldCh0YWdzW2ldKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1NldC5mb3JFYWNoKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFRyZWVUYWdzLmRlbGV0ZShjb21wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLl9fdGFnUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgX3NldFRhZ3NQYXJlbnQoKSB7XG4gICAgICAgIC8vIEp1c3QgY29weSBvdmVyIHRoZSAnbG9jYWwnIHRhZ3MuXG4gICAgICAgIGlmICh0aGlzLl9fdGFncykge1xuICAgICAgICAgICAgdGhpcy5fX3RhZ3MuZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChwID0gcC5fX3BhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXAuX190cmVlVGFncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5fX3RyZWVUYWdzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBwLl9fdHJlZVRhZ3MuZ2V0KHRhZyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuX190cmVlVGFncy5zZXQodGFnLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHMuYWRkKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLl9fdGFnUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9fdHJlZVRhZ3MgJiYgdGhpcy5fX3RyZWVUYWdzLnNpemUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fX3RhZ1Jvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fdHJlZVRhZ3MuZm9yRWFjaCgodGFnU2V0LCB0YWcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXAuX190YWdSb290ICYmIChwID0gcC5fX3BhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLl9fdGFnUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBjb3B5IGFsbCBzdWJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwLl9fdHJlZVRhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLl9fdHJlZVRhZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzID0gcC5fX3RyZWVUYWdzLmdldCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLl9fdHJlZVRhZ3Muc2V0KHRhZywgcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ1NldC5mb3JFYWNoKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcy5hZGQoY29tcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgX2dldEJ5VGFnKHRhZykge1xuICAgICAgICBpZiAoIXRoaXMuX190cmVlVGFncykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ID0gdGhpcy5fX3RyZWVUYWdzLmdldCh0YWcpO1xuICAgICAgICByZXR1cm4gdCA/IFV0aWxzLnNldFRvQXJyYXkodCkgOiBbXTtcbiAgICB9O1xuXG4gICAgZ2V0VGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX190YWdzID8gdGhpcy5fX3RhZ3MgOiBbXTtcbiAgICB9O1xuXG4gICAgc2V0VGFncyh0YWdzKSB7XG4gICAgICAgIHRhZ3MgPSB0YWdzLnJlZHVjZSgoYWNjLCB0YWcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHRhZy5zcGxpdCgnICcpKTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGlmICh0aGlzLl9fcmVmKSB7XG4gICAgICAgICAgICB0YWdzLnB1c2godGhpcy5fX3JlZik7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaSwgbiA9IHRhZ3MubGVuZ3RoO1xuICAgICAgICBsZXQgcmVtb3ZlcyA9IFtdO1xuICAgICAgICBsZXQgYWRkcyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzVGFnKHRhZ3NbaV0pKSB7XG4gICAgICAgICAgICAgICAgYWRkcy5wdXNoKHRhZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRUYWdzID0gdGhpcy50YWdzIHx8IFtdO1xuICAgICAgICBuID0gY3VycmVudFRhZ3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFncy5pbmRleE9mKGN1cnJlbnRUYWdzW2ldKSA9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZXMucHVzaChjdXJyZW50VGFnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVtb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWcocmVtb3Zlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYWRkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hZGRUYWcoYWRkc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRUYWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcuaW5kZXhPZignICcpID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzVWNDaGFyKHRhZy5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJUYWcgbWF5IG5vdCBzdGFydCB3aXRoIGFuIHVwcGVyIGNhc2UgY2hhcmFjdGVyLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fYWRkVGFnKHRhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0YWdzID0gdGFnLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbSA9IHRhZ3MubGVuZ3RoOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFnID0gdGFnc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc1VjQ2hhcih0YWcuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIlRhZyBtYXkgbm90IHN0YXJ0IHdpdGggYW4gdXBwZXIgY2FzZSBjaGFyYWN0ZXIuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRhZyh0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FkZFRhZyh0YWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fdGFncykge1xuICAgICAgICAgICAgdGhpcy5fX3RhZ3MgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fX3RhZ3MuaW5kZXhPZih0YWcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5fX3RhZ3MucHVzaCh0YWcpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdG8gdHJlZVRhZ3MgaGllcmFyY2h5LlxuICAgICAgICAgICAgbGV0IHAgPSB0aGlzLl9fcGFyZW50O1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcC5fX3RyZWVUYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLl9fdHJlZVRhZ3MgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHAuX190cmVlVGFncy5nZXQodGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5fX3RyZWVUYWdzLnNldCh0YWcsIHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcy5hZGQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB9IHdoaWxlICghcC5fX3RhZ1Jvb3QgJiYgKHAgPSBwLl9fcGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVUYWcodGFnKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5fX3RhZ3MuaW5kZXhPZih0YWcpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX190YWdzLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdHJlZVRhZ3MgaGllcmFyY2h5LlxuICAgICAgICAgICAgbGV0IHAgPSB0aGlzLl9fcGFyZW50O1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gcC5fX3RyZWVUYWdzLmdldCh0YWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICghcC5fX3RhZ1Jvb3QgJiYgKHAgPSBwLl9fcGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNUYWcodGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fX3RhZ3MgJiYgKHRoaXMuX190YWdzLmluZGV4T2YodGFnKSAhPT0gLTEpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9uZSBvZiB0aGUgZWxlbWVudHMgZnJvbSB0aGUgc3VidHJlZSB0aGF0IGhhdmUgdGhpcyB0YWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuICAgIF90YWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcuaW5kZXhPZihcIi5cIikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdGFnKHRhZylbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX3RyZWVUYWdzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHQgPSB0aGlzLl9fdHJlZVRhZ3MuZ2V0KHRhZyk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHQudmFsdWVzKCkubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbSA/IGl0ZW0udmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCB0YWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWc7XG4gICAgfVxuXG4gICAgc2V0IHRhZyh0KSB7XG4gICAgICAgIHRoaXMudGFncyA9IHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgZWxlbWVudHMgZnJvbSB0aGUgc3VidHJlZSB0aGF0IGhhdmUgdGhpcyB0YWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gICAgICovXG4gICAgbXRhZyh0YWcpIHtcbiAgICAgICAgbGV0IGlkeCA9IHRhZy5pbmRleE9mKFwiLlwiKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgcGFydHMgPSB0YWcuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGxldCByZXMgPSB0aGlzLl9nZXRCeVRhZyhwYXJ0c1swXSk7XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICAgICAgbGV0IGMgPSBwYXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCAmJiBsZXZlbCA8IGMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzbiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBuID0gcmVzLmxlbmd0aDsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICAgICAgICByZXNuID0gcmVzbi5jb25jYXQocmVzW2pdLl9nZXRCeVRhZyhwYXJ0c1tsZXZlbF0pKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXMgPSByZXNuO1xuICAgICAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJ5VGFnKHRhZyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3RhZyh0YWcsIHNldHRpbmdzKSB7XG4gICAgICAgIGxldCB0ID0gdGhpcy5tdGFnKHRhZyk7XG4gICAgICAgIGxldCBuID0gdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBCYXNlLnBhdGNoT2JqZWN0KHRbaV0sIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB0YWdSb290KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3RhZ1Jvb3Q7XG4gICAgfVxuXG4gICAgc2V0IHRhZ1Jvb3Qodikge1xuICAgICAgICBpZiAodGhpcy5fX3RhZ1Jvb3QgIT09IHYpIHtcbiAgICAgICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFRhZ3NQYXJlbnQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5zZXRUYWdzUGFyZW50KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX190YWdSb290ID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbChwYXRoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSB0aGlzLnNlbGVjdChwYXRoKTtcbiAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3QocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RvcnMgPSBwYXRoLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBsZXQgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5jb25jYXQodGhpcy5fc2VsZWN0KHNlbGVjdG9yc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3QocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2VsZWN0KHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHJldHVybiBbdGhpc107XG5cblxuICAgICAgICBsZXQgcG9pbnRJZHggPSBwYXRoLmluZGV4T2YoXCIuXCIpO1xuICAgICAgICBsZXQgYXJyb3dJZHggPSBwYXRoLmluZGV4T2YoXCI+XCIpO1xuICAgICAgICBpZiAocG9pbnRJZHggPT09IC0xICYmIGFycm93SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gUXVpY2sgY2FzZS5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLm10YWcocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlY3QgYnkgZmlyc3QgY2hhci5cbiAgICAgICAgbGV0IGlzUmVmO1xuICAgICAgICBpZiAoYXJyb3dJZHggPT09IDApIHtcbiAgICAgICAgICAgIGlzUmVmID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludElkeCA9PT0gMCkge1xuICAgICAgICAgICAgaXNSZWYgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlzUmVmID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0Q2hpbGRzKHBhdGgsIGlzUmVmKTtcbiAgICB9XG5cbiAgICBfc2VsZWN0Q2hpbGRzKHBhdGgsIGlzUmVmKSB7XG4gICAgICAgIGNvbnN0IHBvaW50SWR4ID0gcGF0aC5pbmRleE9mKFwiLlwiKTtcbiAgICAgICAgY29uc3QgYXJyb3dJZHggPSBwYXRoLmluZGV4T2YoXCI+XCIpO1xuXG4gICAgICAgIGlmIChwb2ludElkeCA9PT0gLTEgJiYgYXJyb3dJZHggPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLmdldEJ5UmVmKHBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWYgPyBbcmVmXSA6IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tdGFnKHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChhcnJvd0lkeCA9PT0gLTEpIHx8IChwb2ludElkeCAhPT0gLTEgJiYgcG9pbnRJZHggPCBhcnJvd0lkeCkpIHtcbiAgICAgICAgICAgIGxldCBuZXh0O1xuICAgICAgICAgICAgY29uc3Qgc3RyID0gcGF0aC5zdWJzdHIoMCwgcG9pbnRJZHgpO1xuICAgICAgICAgICAgaWYgKGlzUmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5nZXRCeVJlZihzdHIpO1xuICAgICAgICAgICAgICAgIG5leHQgPSByZWYgPyBbcmVmXSA6IFtdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdGhpcy5tdGFnKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG90YWwgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHN1YlBhdGggPSBwYXRoLnN1YnN0cihwb2ludElkeCArIDEpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBuZXh0Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWwuY29uY2F0KG5leHRbaV0uX3NlbGVjdENoaWxkcyhzdWJQYXRoLCBmYWxzZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICBjb25zdCBzdHIgPSBwYXRoLnN1YnN0cigwLCBhcnJvd0lkeCk7XG4gICAgICAgICAgICBpZiAoaXNSZWYpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLmdldEJ5UmVmKHN0cik7XG4gICAgICAgICAgICAgICAgbmV4dCA9IHJlZiA/IFtyZWZdIDogW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLm10YWcoc3RyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0b3RhbCA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc3ViUGF0aCA9IHBhdGguc3Vic3RyKGFycm93SWR4ICsgMSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IG5leHQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgPSB0b3RhbC5jb25jYXQobmV4dFtpXS5fc2VsZWN0Q2hpbGRzKHN1YlBhdGgsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEJ5UmVmKHJlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZExpc3QuZ2V0QnlSZWYocmVmKTtcbiAgICB9XG5cbiAgICBnZXRMb2NhdGlvblN0cmluZygpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGkgPSB0aGlzLl9fcGFyZW50ID8gdGhpcy5fX3BhcmVudC5fY2hpbGRyZW4uZ2V0SW5kZXgodGhpcykgOiBcIlJcIjtcbiAgICAgICAgbGV0IGxvY2FsVGFncyA9IHRoaXMuZ2V0VGFncygpO1xuICAgICAgICBsZXQgc3RyID0gdGhpcy5fX3BhcmVudCA/IHRoaXMuX19wYXJlbnQuZ2V0TG9jYXRpb25TdHJpbmcoKTogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICBzdHIgKz0gXCI6W1wiICsgaSArIFwiXVwiICsgdGhpcy5yZWY7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxUYWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RyICs9IFwiOltcIiArIGkgKyBcIl1cIiArIGxvY2FsVGFncy5qb2luKFwiLFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciArPSBcIjpbXCIgKyBpICsgXCJdI1wiICsgdGhpcy5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgb2JqID0gdGhpcy5nZXRTZXR0aW5ncygpO1xuICAgICAgICByZXR1cm4gRWxlbWVudC5nZXRQcmV0dHlTdHJpbmcob2JqLCBcIlwiKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFByZXR0eVN0cmluZyhvYmosIGluZGVudCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW47XG4gICAgICAgIGRlbGV0ZSBvYmouY2hpbGRyZW47XG5cblxuICAgICAgICAvLyBDb252ZXJ0IHNpbmd1bGFyIGpzb24gc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgICBsZXQgY29sb3JLZXlzID0gW1wiY29sb3JcIiwgXCJjb2xvclVsXCIsIFwiY29sb3JVclwiLCBcImNvbG9yQmxcIiwgXCJjb2xvckJyXCJdO1xuICAgICAgICBsZXQgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgaWYgKGNvbG9yS2V5cy5pbmRleE9mKGspICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkNPTE9SW1wiICsgdi50b1N0cmluZygxNikgKyBcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1wiQ09MT1JcXFsoW2EtZjAtOV17MSw4fSlcXF1cIi9nLCBcIjB4JDFcIik7XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRTdHIgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVmcyA9IE9iamVjdC5rZXlzKGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICBjaGlsZFN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSByZWZzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFN0ciArPSBgXFxuJHtpbmRlbnR9ICBcIiR7cmVmc1tpXX1cIjpgXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZHJlbltyZWZzW2ldXS5yZWY7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkU3RyICs9IEVsZW1lbnQuZ2V0UHJldHR5U3RyaW5nKGNoaWxkcmVuW3JlZnNbaV1dLCBpbmRlbnQgKyBcIiAgXCIpICsgKGkgPCBuIC0gMSA/IFwiLFwiIDogXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc0VtcHR5ID0gKHN0ciA9PT0gXCJ7fVwiKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDAsIHN0ci5sZW5ndGggLSAxKSArIChpc0VtcHR5ID8gXCJcIiA6IFwiLFwiKSArIGNoaWxkU3RyICsgXCJcXG5cIiArIGluZGVudCArIFwifVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaGlsZFN0ciA9IFwiW1wiO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkU3RyICs9IEVsZW1lbnQuZ2V0UHJldHR5U3RyaW5nKGNoaWxkcmVuW2ldLCBpbmRlbnQgKyBcIiAgXCIpICsgKGkgPCBuIC0gMSA/IFwiLFwiIDogXCJcIikgKyBcIlxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZFN0ciArPSBpbmRlbnQgKyBcIl19XCI7XG4gICAgICAgICAgICAgICAgbGV0IGlzRW1wdHkgPSAoc3RyID09PSBcInt9XCIpO1xuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHIoMCwgc3RyLmxlbmd0aCAtIDEpICsgKGlzRW1wdHkgPyBcIlwiIDogXCIsXCIpICsgXCJcXFwiY2hpbGRyZW5cXFwiOlxcblwiICsgaW5kZW50ICsgY2hpbGRTdHIgKyBcIn1cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgbGV0IHNldHRpbmdzID0gdGhpcy5nZXROb25EZWZhdWx0cygpO1xuXG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmdldCgpO1xuICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGxldCBuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEFycmF5ID0gW107XG4gICAgICAgICAgICAgICAgbGV0IG1pc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEFycmF5LnB1c2goY2hpbGRyZW5baV0uZ2V0U2V0dGluZ3MoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1pc3NpbmcgPSBtaXNzaW5nIHx8ICFjaGlsZHJlbltpXS5yZWY7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFtaXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNoaWxkcmVuID0ge31cbiAgICAgICAgICAgICAgICAgICAgY2hpbGRBcnJheS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmNoaWxkcmVuW2NoaWxkLnJlZl0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLmlkID0gdGhpcy5pZDtcblxuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgZ2V0Tm9uRGVmYXVsdHMoKSB7XG4gICAgICAgIGxldCBzZXR0aW5ncyA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBFbGVtZW50KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50eXBlID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX19yZWYpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnJlZiA9IHRoaXMuX19yZWY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fX3RhZ3MgJiYgdGhpcy5fX3RhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50YWdzID0gdGhpcy5fX3RhZ3M7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy54ICE9PSAwKSBzZXR0aW5ncy54ID0gdGhpcy54O1xuICAgICAgICBpZiAodGhpcy55ICE9PSAwKSBzZXR0aW5ncy55ID0gdGhpcy55O1xuICAgICAgICBpZiAodGhpcy53ICE9PSAwKSBzZXR0aW5ncy53ID0gdGhpcy53O1xuICAgICAgICBpZiAodGhpcy5oICE9PSAwKSBzZXR0aW5ncy5oID0gdGhpcy5oO1xuXG4gICAgICAgIGlmICh0aGlzLnNjYWxlWCA9PT0gdGhpcy5zY2FsZVkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlWCAhPT0gMSkgc2V0dGluZ3Muc2NhbGUgPSB0aGlzLnNjYWxlWDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjYWxlWCAhPT0gMSkgc2V0dGluZ3Muc2NhbGVYID0gdGhpcy5zY2FsZVg7XG4gICAgICAgICAgICBpZiAodGhpcy5zY2FsZVkgIT09IDEpIHNldHRpbmdzLnNjYWxlWSA9IHRoaXMuc2NhbGVZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGl2b3RYID09PSB0aGlzLnBpdm90WSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGl2b3RYICE9PSAwLjUpIHNldHRpbmdzLnBpdm90ID0gdGhpcy5waXZvdFg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waXZvdFggIT09IDAuNSkgc2V0dGluZ3MucGl2b3RYID0gdGhpcy5waXZvdFg7XG4gICAgICAgICAgICBpZiAodGhpcy5waXZvdFkgIT09IDAuNSkgc2V0dGluZ3MucGl2b3RZID0gdGhpcy5waXZvdFk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tb3VudFggPT09IHRoaXMubW91bnRZKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb3VudFggIT09IDApIHNldHRpbmdzLm1vdW50ID0gdGhpcy5tb3VudFg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tb3VudFggIT09IDApIHNldHRpbmdzLm1vdW50WCA9IHRoaXMubW91bnRYO1xuICAgICAgICAgICAgaWYgKHRoaXMubW91bnRZICE9PSAwKSBzZXR0aW5ncy5tb3VudFkgPSB0aGlzLm1vdW50WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFscGhhICE9PSAxKSBzZXR0aW5ncy5hbHBoYSA9IHRoaXMuYWxwaGE7XG5cbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUpIHNldHRpbmdzLnZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5yb3RhdGlvbiAhPT0gMCkgc2V0dGluZ3Mucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbG9yVWwgPT09IHRoaXMuY29sb3JVciAmJiB0aGlzLmNvbG9yQmwgPT09IHRoaXMuY29sb3JCciAmJiB0aGlzLmNvbG9yVWwgPT09IHRoaXMuY29sb3JCbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JVbCAhPT0gMHhGRkZGRkZGRikgc2V0dGluZ3MuY29sb3IgPSB0aGlzLmNvbG9yVWwudG9TdHJpbmcoMTYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JVbCAhPT0gMHhGRkZGRkZGRikgc2V0dGluZ3MuY29sb3JVbCA9IHRoaXMuY29sb3JVbC50b1N0cmluZygxNik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvclVyICE9PSAweEZGRkZGRkZGKSBzZXR0aW5ncy5jb2xvclVyID0gdGhpcy5jb2xvclVyLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yQmwgIT09IDB4RkZGRkZGRkYpIHNldHRpbmdzLmNvbG9yQmwgPSB0aGlzLmNvbG9yQmwudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JCciAhPT0gMHhGRkZGRkZGRikgc2V0dGluZ3MuY29sb3JCciA9IHRoaXMuY29sb3JCci50b1N0cmluZygxNik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy56SW5kZXgpIHNldHRpbmdzLnpJbmRleCA9IHRoaXMuekluZGV4O1xuXG4gICAgICAgIGlmICh0aGlzLmZvcmNlWkluZGV4Q29udGV4dCkgc2V0dGluZ3MuZm9yY2VaSW5kZXhDb250ZXh0ID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jbGlwcGluZykgc2V0dGluZ3MuY2xpcHBpbmcgPSB0aGlzLmNsaXBwaW5nO1xuXG4gICAgICAgIGlmICghdGhpcy5jbGlwYm94KSBzZXR0aW5ncy5jbGlwYm94ID0gdGhpcy5jbGlwYm94O1xuXG4gICAgICAgIGlmICh0aGlzLl9fdGV4dHVyZSkge1xuICAgICAgICAgICAgbGV0IHRuZCA9IHRoaXMuX190ZXh0dXJlLmdldE5vbkRlZmF1bHRzKCk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModG5kKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy50ZXh0dXJlID0gdG5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyICYmIFV0aWxzLmlzRnVuY3Rpb24odGhpcy5zaGFkZXIuZ2V0Tm9uRGVmYXVsdHMpKSB7XG4gICAgICAgICAgICBsZXQgdG5kID0gdGhpcy5zaGFkZXIuZ2V0Tm9uRGVmYXVsdHMoKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0bmQpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnNoYWRlciA9IHRuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9oYXNUZXh0dXJpemVyKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cml6ZXIuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJlbmRlclRvVGV4dHVyZSA9IHRoaXMudGV4dHVyaXplci5lbmFibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyaXplci5sYXp5KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucmVuZGVyVG9UZXh0dXJlTGF6eSA9IHRoaXMudGV4dHVyaXplci5sYXp5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyaXplci5jb2xvcml6ZSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmNvbG9yaXplUmVzdWx0VGV4dHVyZSA9IHRoaXMudGV4dHVyaXplci5jb2xvcml6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cml6ZXIucmVuZGVyT2Zmc2NyZWVuKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucmVuZGVyT2Zmc2NyZWVuID0gdGhpcy50ZXh0dXJpemVyLnJlbmRlck9mZnNjcmVlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldEdldHRlcihwcm9wZXJ0eVBhdGgpIHtcbiAgICAgICAgbGV0IGdldHRlciA9IEVsZW1lbnQuUFJPUF9HRVRURVJTLmdldChwcm9wZXJ0eVBhdGgpO1xuICAgICAgICBpZiAoIWdldHRlcikge1xuICAgICAgICAgICAgZ2V0dGVyID0gbmV3IEZ1bmN0aW9uKCdvYmonLCAncmV0dXJuIG9iai4nICsgcHJvcGVydHlQYXRoKTtcbiAgICAgICAgICAgIEVsZW1lbnQuUFJPUF9HRVRURVJTLnNldChwcm9wZXJ0eVBhdGgsIGdldHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldHRlcjtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U2V0dGVyKHByb3BlcnR5UGF0aCkge1xuICAgICAgICBsZXQgc2V0dGVyID0gRWxlbWVudC5QUk9QX1NFVFRFUlMuZ2V0KHByb3BlcnR5UGF0aCk7XG4gICAgICAgIGlmICghc2V0dGVyKSB7XG4gICAgICAgICAgICBzZXR0ZXIgPSBuZXcgRnVuY3Rpb24oJ29iaicsICd2JywgJ29iai4nICsgcHJvcGVydHlQYXRoICsgJyA9IHYnKTtcbiAgICAgICAgICAgIEVsZW1lbnQuUFJPUF9TRVRURVJTLnNldChwcm9wZXJ0eVBhdGgsIHNldHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRlcjtcbiAgICB9XG5cbiAgICBnZXQgd2l0aGluQm91bmRzTWFyZ2luKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuX3dpdGhpbkJvdW5kc01hcmdpbjtcbiAgICB9XG5cbiAgICBfZW5hYmxlV2l0aGluQm91bmRzTWFyZ2luKCkge1xuICAgICAgICAvLyBJZmYgZW5hYmxlZCwgdGhpcyB0b2dnbGVzIHRoZSBhY3RpdmUgZmxhZy5cbiAgICAgICAgaWYgKHRoaXMuX19lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRBY3RpdmVGbGFnKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlzYWJsZVdpdGhpbkJvdW5kc01hcmdpbigpIHtcbiAgICAgICAgLy8gSWZmIGFjdGl2ZSwgdGhpcyB0b2dnbGVzIHRoZSBhY3RpdmUgZmxhZy5cbiAgICAgICAgaWYgKHRoaXMuX19hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc2V0QWN0aXZlRmxhZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IGJvdW5kc01hcmdpbih2KSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2KSAmJiB2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib3VuZHNNYXJnaW4gc2hvdWxkIGJlIGFuIGFycmF5IG9mIGxlZnQtdG9wLXJpZ2h0LWJvdHRvbSB2YWx1ZXMgb3IgbnVsbCAoaW5oZXJpdCBtYXJnaW4pXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jb3JlLmJvdW5kc01hcmdpbiA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGJvdW5kc01hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmJvdW5kc01hcmdpbjtcbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLm9mZnNldFg7XG4gICAgfVxuXG4gICAgc2V0IHgodikge1xuICAgICAgICB0aGlzLl9fY29yZS5vZmZzZXRYID0gdjtcbiAgICB9XG5cbiAgICBnZXQgeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLm9mZnNldFk7XG4gICAgfVxuXG4gICAgc2V0IHkodikge1xuICAgICAgICB0aGlzLl9fY29yZS5vZmZzZXRZID0gdjtcbiAgICB9XG5cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfVxuXG4gICAgc2V0IHcodikge1xuICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbih2KSkge1xuICAgICAgICAgICAgdGhpcy5fdyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9fY29yZS5mdW5jVyA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ID0gTWF0aC5tYXgodiwgMCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fdyAhPT0gdikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb3JlLmRpc2FibGVGdW5jVygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3cgPSB2O1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICB9XG5cbiAgICBzZXQgaCh2KSB7XG4gICAgICAgIGlmIChVdGlscy5pc0Z1bmN0aW9uKHYpKSB7XG4gICAgICAgICAgICB0aGlzLl9oID0gMDtcbiAgICAgICAgICAgIHRoaXMuX19jb3JlLmZ1bmNIID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYgPSBNYXRoLm1heCh2LCAwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9oICE9PSB2KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvcmUuZGlzYWJsZUZ1bmNIKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faCA9IHY7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNvbGxpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpc2lvbjtcbiAgICB9XG5cbiAgICBzZXQgY29sbGlzaW9uKHYpIHtcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uID0gdjtcbiAgICB9XG5cbiAgICBfdXBkYXRlQ29sbGlzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jb2xsaXNpb24gJiYgdGhpcy5fX3BhcmVudCAmJiB0aGlzLl9fcGFyZW50LmNvbGxpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcmsgY29sbGlzaW9uIGFzIDIgdG8gaW5kaWNhdGUgYXRsZWFzdCBvbmUgZGVzY2VuZGFudCBoYXMgY29sbGlzaW9uIGVuYWJsZWQuXG4gICAgICAgICAgICAgKiBUaGlzIG5hcnJvd3MgZG93biB0aGUgc2VhcmNoIGZvciBlbGVtZW50cyB3aXRoIGFjdGl2ZSBjb2xsaXNpb24uXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5fX3BhcmVudC5jb2xsaXNpb24gPSAyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnNjYWxlWDtcbiAgICB9XG5cbiAgICBzZXQgc2NhbGVYKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuc2NhbGVYID0gdjtcbiAgICB9XG5cbiAgICBnZXQgc2NhbGVZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuc2NhbGVZO1xuICAgIH1cblxuICAgIHNldCBzY2FsZVkodikge1xuICAgICAgICB0aGlzLl9fY29yZS5zY2FsZVkgPSB2O1xuICAgIH1cblxuICAgIGdldCBzY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnNjYWxlO1xuICAgIH1cblxuICAgIHNldCBzY2FsZSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnNjYWxlID0gdjtcbiAgICB9XG5cbiAgICBnZXQgcGl2b3RYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUucGl2b3RYO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFgodikge1xuICAgICAgICB0aGlzLl9fY29yZS5waXZvdFggPSB2O1xuICAgIH1cblxuICAgIGdldCBwaXZvdFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5waXZvdFk7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90WSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLnBpdm90WSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUucGl2b3Q7XG4gICAgfVxuXG4gICAgc2V0IHBpdm90KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUucGl2b3QgPSB2O1xuICAgIH1cblxuICAgIGdldCBtb3VudFgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5tb3VudFg7XG4gICAgfVxuXG4gICAgc2V0IG1vdW50WCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm1vdW50WCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IG1vdW50WSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLm1vdW50WTtcbiAgICB9XG5cbiAgICBzZXQgbW91bnRZKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUubW91bnRZID0gdjtcbiAgICB9XG5cbiAgICBnZXQgbW91bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5tb3VudDtcbiAgICB9XG5cbiAgICBzZXQgbW91bnQodikge1xuICAgICAgICB0aGlzLl9fY29yZS5tb3VudCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUucm90YXRpb247XG4gICAgfVxuXG4gICAgc2V0IHJvdGF0aW9uKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUucm90YXRpb24gPSB2O1xuICAgIH1cblxuICAgIGdldCBhbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLmFscGhhO1xuICAgIH1cblxuICAgIHNldCBhbHBoYSh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmFscGhhID0gdjtcbiAgICB9XG5cbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jb3JlLnZpc2libGU7XG4gICAgfVxuXG4gICAgc2V0IHZpc2libGUodikge1xuICAgICAgICB0aGlzLl9fY29yZS52aXNpYmxlID0gdjtcbiAgICB9XG4gICAgXG4gICAgZ2V0IGNvbG9yVWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5jb2xvclVsO1xuICAgIH1cblxuICAgIHNldCBjb2xvclVsKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuY29sb3JVbCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yVXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5jb2xvclVyO1xuICAgIH1cblxuICAgIHNldCBjb2xvclVyKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuY29sb3JVciA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5jb2xvckJsO1xuICAgIH1cblxuICAgIHNldCBjb2xvckJsKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuY29sb3JCbCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yQnIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5jb2xvckJyO1xuICAgIH1cblxuICAgIHNldCBjb2xvckJyKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuY29sb3JCciA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuY29sb3JVbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3Iodikge1xuICAgICAgICBpZiAodGhpcy5jb2xvclVsICE9PSB2IHx8IHRoaXMuY29sb3JVciAhPT0gdiB8fCB0aGlzLmNvbG9yQmwgIT09IHYgfHwgdGhpcy5jb2xvckJyICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yVWwgPSB2O1xuICAgICAgICAgICAgdGhpcy5jb2xvclVyID0gdjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCbCA9IHY7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnIgPSB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGNvbG9yVG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvclVsO1xuICAgIH1cblxuICAgIHNldCBjb2xvclRvcCh2KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9yVWwgIT09IHYgfHwgdGhpcy5jb2xvclVyICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yVWwgPSB2O1xuICAgICAgICAgICAgdGhpcy5jb2xvclVyID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjb2xvckJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JCbDtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JCb3R0b20odikge1xuICAgICAgICBpZiAodGhpcy5jb2xvckJsICE9PSB2IHx8IHRoaXMuY29sb3JCciAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5jb2xvckJsID0gdjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCciA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29sb3JMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvclVsO1xuICAgIH1cblxuICAgIHNldCBjb2xvckxlZnQodikge1xuICAgICAgICBpZiAodGhpcy5jb2xvclVsICE9PSB2IHx8IHRoaXMuY29sb3JCbCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5jb2xvclVsID0gdjtcbiAgICAgICAgICAgIHRoaXMuY29sb3JCbCA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29sb3JSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JVcjtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JSaWdodCh2KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbG9yVXIgIT09IHYgfHwgdGhpcy5jb2xvckJyICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yVXIgPSB2O1xuICAgICAgICAgICAgdGhpcy5jb2xvckJyID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB6SW5kZXgoKSB7cmV0dXJuIHRoaXMuX19jb3JlLnpJbmRleH1cbiAgICBzZXQgekluZGV4KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuekluZGV4ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgZm9yY2VaSW5kZXhDb250ZXh0KCkge3JldHVybiB0aGlzLl9fY29yZS5mb3JjZVpJbmRleENvbnRleHR9XG4gICAgc2V0IGZvcmNlWkluZGV4Q29udGV4dCh2KSB7XG4gICAgICAgIHRoaXMuX19jb3JlLmZvcmNlWkluZGV4Q29udGV4dCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNsaXBwaW5nKCkge3JldHVybiB0aGlzLl9fY29yZS5jbGlwcGluZ31cbiAgICBzZXQgY2xpcHBpbmcodikge1xuICAgICAgICB0aGlzLl9fY29yZS5jbGlwcGluZyA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGNsaXBib3goKSB7cmV0dXJuIHRoaXMuX19jb3JlLmNsaXBib3h9XG4gICAgc2V0IGNsaXBib3godikge1xuICAgICAgICB0aGlzLl9fY29yZS5jbGlwYm94ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgdGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFncygpO1xuICAgIH1cblxuICAgIHNldCB0YWdzKHYpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHYpKSB2ID0gW3ZdO1xuICAgICAgICB0aGlzLnNldFRhZ3Modik7XG4gICAgfVxuXG4gICAgc2V0IHQodikge1xuICAgICAgICB0aGlzLnRhZ3MgPSB2O1xuICAgIH1cblxuICAgIGdldCBfY2hpbGRyZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2NoaWxkTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5fX2NoaWxkTGlzdCA9IG5ldyBFbGVtZW50Q2hpbGRMaXN0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fX2NoaWxkTGlzdDtcbiAgICB9XG5cbiAgICBnZXQgY2hpbGRMaXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FsbG93Q2hpbGRyZW5BY2Nlc3MoKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIkRpcmVjdCBhY2Nlc3MgdG8gY2hpbGRyZW4gaXMgbm90IGFsbG93ZWQgaW4gXCIgKyB0aGlzLmdldExvY2F0aW9uU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgICB9XG5cbiAgICBoYXNDaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG93Q2hpbGRyZW5BY2Nlc3MoKSAmJiB0aGlzLl9fY2hpbGRMaXN0ICYmICh0aGlzLl9fY2hpbGRMaXN0Lmxlbmd0aCA+IDApO1xuICAgIH1cblxuICAgIF9hbGxvd0NoaWxkcmVuQWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkTGlzdC5nZXQoKTtcbiAgICB9XG5cbiAgICBzZXQgY2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3QucGF0Y2goY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGFkZChvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkTGlzdC5hKG8pO1xuICAgIH1cblxuICAgIGdldCBwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3BhcmVudDtcbiAgICB9XG5cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX3BhcmVudDtcbiAgICB9XG5cbiAgICBnZXQgc3JjKCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlICYmIHRoaXMudGV4dHVyZSBpbnN0YW5jZW9mIEltYWdlVGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZS5fc3JjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBzcmModikge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IEltYWdlVGV4dHVyZSh0aGlzLnN0YWdlKTtcbiAgICAgICAgdGV4dHVyZS5zcmMgPSB2O1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgIH1cblxuICAgIHNldCBtdyh2KSB7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5tdyA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKCdQbGVhc2Ugc2V0IG13IGFmdGVyIHNldHRpbmcgYSB0ZXh0dXJlLicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IG1oKHYpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlLm1oID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoJ1BsZWFzZSBzZXQgbWggYWZ0ZXIgc2V0dGluZyBhIHRleHR1cmUuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcmVjdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnRleHR1cmUgPT09IHRoaXMuc3RhZ2UucmVjdGFuZ2xlVGV4dHVyZSk7XG4gICAgfVxuXG4gICAgc2V0IHJlY3Qodikge1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5zdGFnZS5yZWN0YW5nbGVUZXh0dXJlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGVuYWJsZVRleHRUZXh0dXJlKCkge1xuICAgICAgICBpZiAoIXRoaXMudGV4dHVyZSB8fCAhKHRoaXMudGV4dHVyZSBpbnN0YW5jZW9mIFRleHRUZXh0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gbmV3IFRleHRUZXh0dXJlKHRoaXMuc3RhZ2UpO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMudGV4dHVyZS53ICYmICF0aGlzLnRleHR1cmUuaCkge1xuICAgICAgICAgICAgICAgIC8vIEluaGVyaXQgZGltZW5zaW9ucyBmcm9tIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdXNlcmxhbmQgdG8gc2V0IGRpbWVuc2lvbnMgb2YgdGhlIEVsZW1lbnQgYW5kIHRoZW4gbGF0ZXIgc3BlY2lmeSB0aGUgdGV4dC5cbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUudyA9IHRoaXMudztcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuaCA9IHRoaXMuaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlO1xuICAgIH1cblxuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0dXJlICYmICh0aGlzLnRleHR1cmUgaW5zdGFuY2VvZiBUZXh0VGV4dHVyZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRleHR1cmU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCB0ZXh0KHYpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUgfHwgISh0aGlzLnRleHR1cmUgaW5zdGFuY2VvZiBUZXh0VGV4dHVyZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlVGV4dFRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuaXNTdHJpbmcodikpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS50ZXh0ID0gdjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZS5wYXRjaCh2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBvblVwZGF0ZShmKSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm9uVXBkYXRlID0gZjtcbiAgICB9XG5cbiAgICBzZXQgb25BZnRlckNhbGNzKGYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUub25BZnRlckNhbGNzID0gZjtcbiAgICB9XG5cbiAgICBzZXQgb25BZnRlclVwZGF0ZShmKSB7XG4gICAgICAgIHRoaXMuX19jb3JlLm9uQWZ0ZXJVcGRhdGUgPSBmO1xuICAgIH1cblxuICAgIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgdXBkYXRlIGxvb3AgaXMgcnVuLlxuICAgICAgICB0aGlzLl9fY29yZS5fc2V0SGFzVXBkYXRlcygpO1xuICAgIH1cblxuICAgIGdldCBzaGFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5zaGFkZXI7XG4gICAgfVxuXG4gICAgc2V0IHNoYWRlcih2KSB7XG4gICAgICAgIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodikgJiYgIXYudHlwZSkge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBwcm9wZXJ0aWVzIG9uIGFuIGV4aXN0aW5nIHNoYWRlci5cbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGVyLnBhdGNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gU2hhZGVyLmNyZWF0ZSh0aGlzLnN0YWdlLCB2KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX19lbmFibGVkICYmIHRoaXMuX19jb3JlLnNoYWRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19jb3JlLnNoYWRlci5yZW1vdmVFbGVtZW50KHRoaXMuX19jb3JlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2hhZGVyID0gc2hhZGVyO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX2VuYWJsZWQgJiYgdGhpcy5fX2NvcmUuc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2NvcmUuc2hhZGVyLmFkZEVsZW1lbnQodGhpcy5fX2NvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2hhc1RleHR1cml6ZXIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX19jb3JlLl90ZXh0dXJpemVyO1xuICAgIH1cblxuICAgIGdldCByZW5kZXJUb1RleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ0dFxuICAgIH1cblxuICAgIHNldCByZW5kZXJUb1RleHR1cmUodikge1xuICAgICAgICB0aGlzLnJ0dCA9IHZcbiAgICB9XG5cbiAgICBnZXQgcnR0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzVGV4dHVyaXplcigpICYmIHRoaXMudGV4dHVyaXplci5lbmFibGVkO1xuICAgIH1cblxuICAgIHNldCBydHQodikge1xuICAgICAgICB0aGlzLnRleHR1cml6ZXIuZW5hYmxlZCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHJ0dExhenkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNUZXh0dXJpemVyKCkgJiYgdGhpcy50ZXh0dXJpemVyLmxhenk7XG4gICAgfVxuXG4gICAgc2V0IHJ0dExhenkodikge1xuICAgICAgICB0aGlzLnRleHR1cml6ZXIubGF6eSA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlck9mZnNjcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1RleHR1cml6ZXIoKSAmJiB0aGlzLnRleHR1cml6ZXIucmVuZGVyT2Zmc2NyZWVuO1xuICAgIH1cblxuICAgIHNldCByZW5kZXJPZmZzY3JlZW4odikge1xuICAgICAgICB0aGlzLnRleHR1cml6ZXIucmVuZGVyT2Zmc2NyZWVuID0gdjtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JpemVSZXN1bHRUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzVGV4dHVyaXplcigpICYmIHRoaXMudGV4dHVyaXplci5jb2xvcml6ZTtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JpemVSZXN1bHRUZXh0dXJlKHYpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJpemVyLmNvbG9yaXplID0gdjtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJpemVyLl9nZXRUZXh0dXJlU291cmNlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHRleHR1cml6ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS50ZXh0dXJpemVyO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIGxldCBwYXRocyA9IE9iamVjdC5rZXlzKHNldHRpbmdzKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHBhdGhzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IHBhdGggPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBzZXR0aW5nc1twYXRoXTtcblxuICAgICAgICAgICAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1VjQ2hhcihmaXJzdENoYXJDb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlZi5cbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuZ2V0QnlSZWYocGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gbGlzdCBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhdGNoIHRoaXMgY2FzZSB0byBjYXB0dXJlIGNyZWF0ZU1vZGUgZmxhZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jaGlsZExpc3QuY3JlYXRlSXRlbSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnBhdGNoKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuaXNFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5yZWYgPSBwYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTGlzdC5hKGMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudC5jaGlsZExpc3QucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc09iamVjdExpdGVyYWwodikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnBhdGNoKHYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYuaXNFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGVsZW1lbnQgYnkgbmV3IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB2LnJlZiA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTGlzdC5yZXBsYWNlKHYsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlIGZvciBwYXRoOiBcIiArIHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICBCYXNlLnBhdGNoT2JqZWN0UHJvcGVydHkodGhpcywgcGF0aCwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhyb3dFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyBcIiAoXCIgKyB0aGlzLmdldExvY2F0aW9uU3RyaW5nKCkgKyBcIik6IFwiICsgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgYW5pbWF0aW9uKHNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWdlLmFuaW1hdGlvbnMuY3JlYXRlQW5pbWF0aW9uKHRoaXMsIHNldHRpbmdzKTtcbiAgICB9XG5cbiAgICB0cmFuc2l0aW9uKHByb3BlcnR5LCBzZXR0aW5ncyA9IG51bGwpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNpdGlvbihwcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUcmFuc2l0aW9uKHByb3BlcnR5LCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAvLyBXZSBkbyBub3QgY3JlYXRlL3JldHVybiB0aGUgdHJhbnNpdGlvbiwgYmVjYXVzZSBpdCB3b3VsZCB1bmRvIHRoZSAnbGF6eSB0cmFuc2l0aW9uIGNyZWF0aW9uJyBvcHRpbWl6YXRpb24uXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCB0cmFuc2l0aW9ucyhvYmplY3QpIHtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICBrZXlzLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uKHByb3BlcnR5LCBvYmplY3RbcHJvcGVydHldKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0IHNtb290aChvYmplY3QpIHtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgICAgICBrZXlzLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U21vb3RoKHByb3BlcnR5LCB2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNtb290aChwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmYXN0Rm9yd2FyZChwcm9wZXJ0eSkge1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5fdHJhbnNpdGlvbnNbcHJvcGVydHldO1xuICAgICAgICAgICAgaWYgKHQgJiYgdC5pc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICB0LmZpbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFRyYW5zaXRpb24ocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdCA9IHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKCF0KSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgZGVmYXVsdCB0cmFuc2l0aW9uLlxuICAgICAgICAgICAgdCA9IG5ldyBUcmFuc2l0aW9uKHRoaXMuc3RhZ2UudHJhbnNpdGlvbnMsIHRoaXMuc3RhZ2UudHJhbnNpdGlvbnMuZGVmYXVsdFRyYW5zaXRpb25TZXR0aW5ncywgdGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9IGVsc2UgaWYgKHQuaXNUcmFuc2l0aW9uU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIC8vIFVwZ3JhZGUgdG8gJ3JlYWwnIHRyYW5zaXRpb24uXG4gICAgICAgICAgICB0ID0gbmV3IFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS50cmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgcHJvcGVydHlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvbnNbcHJvcGVydHldID0gdDtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgX3NldFRyYW5zaXRpb24ocHJvcGVydHksIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICghc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVRyYW5zaXRpb24ocHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHBsYWluIG9iamVjdCB0byBwcm9wZXIgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gdGhpcy5zdGFnZS50cmFuc2l0aW9ucy5jcmVhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuaXNUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gUnVudGltZSBzZXR0aW5ncyBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgY3VycmVudC5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsbHksIG9ubHkgc2V0IHRoZSBzZXR0aW5ncyBhbmQgdXBncmFkZSB0byBhICdyZWFsJyB0cmFuc2l0aW9uIHdoZW4gaXQgaXMgdXNlZC5cbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uc1twcm9wZXJ0eV0gPSBzZXR0aW5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZW1vdmVUcmFuc2l0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFuc2l0aW9ucykge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RyYW5zaXRpb25zW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNtb290aChwcm9wZXJ0eSwgdikge1xuICAgICAgICBsZXQgdCA9IHRoaXMuX2dldFRyYW5zaXRpb24ocHJvcGVydHkpO1xuICAgICAgICBpZiAodCAmJiB0LmlzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHQudGFyZ2V0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFNtb290aChwcm9wZXJ0eSwgdiwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUcmFuc2l0aW9uKHByb3BlcnR5LCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHQgPSB0aGlzLl9nZXRUcmFuc2l0aW9uKHByb3BlcnR5KTtcbiAgICAgICAgdC5zdGFydCh2KTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuXG4gICAgZ2V0IGZsZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY29yZS5mbGV4O1xuICAgIH1cblxuICAgIHNldCBmbGV4KHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuZmxleCA9IHY7XG4gICAgfVxuXG4gICAgZ2V0IGZsZXhJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NvcmUuZmxleEl0ZW07XG4gICAgfVxuXG4gICAgc2V0IGZsZXhJdGVtKHYpIHtcbiAgICAgICAgdGhpcy5fX2NvcmUuZmxleEl0ZW0gPSB2O1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0NvbG9yUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcImNvbG9yXCIpID49IDA7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldE1lcmdlcihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0NvbG9yUHJvcGVydHkocHJvcGVydHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RhZ2VVdGlscy5tZXJnZUNvbG9ycztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdGFnZVV0aWxzLm1lcmdlTnVtYmVycztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcmVmID0gW2Ake3RoaXMuY29uc3RydWN0b3IubmFtZX1gXTtcbiAgICAgICAgY29uc3QgdHJlZSA9IHt9O1xuICAgICAgICB0cmVlW3JlZl0gPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBFbGVtZW50LmNvbGxlY3RDaGlsZHJlbih0cmVlW3JlZl0sIHRoaXMuX19jaGlsZExpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJlZVtyZWZdID0gey4uLkVsZW1lbnQuZ2V0UHJvcGVydGllcyh0aGlzKX07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGNvbGxlY3RDaGlsZHJlbih0cmVlLCBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBjaGlsZExpc3QgPSBjaGlsZHJlbjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBjaGlsZExpc3QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gY2hpbGRMaXN0LmdldEF0KGkpO1xuICAgICAgICAgICAgY29uc3QgcmVmID0gYCR7ZWxlbWVudC5fX3JlZiB8fCBgRWxlbWVudC0ke2VsZW1lbnQuaWR9YH1gO1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcyhlbGVtZW50KTtcblxuICAgICAgICAgICAgdHJlZVtyZWZdID0gey4uLnByb3BlcnRpZXN9O1xuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgdHJlZVtyZWZdLmNoaWxkcmVuID0ge307XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsZWN0Q2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgIHRyZWVbcmVmXS5jaGlsZHJlbiwgZWxlbWVudC5fX2NoaWxkTGlzdFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UHJvcGVydGllcyhlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICAgIGNvbnN0IGxpc3QgPSBbXG4gICAgICAgICAgICBcImFscGhhXCIsIFwiYWN0aXZlXCIsIFwiYXR0YWNoZWRcIiwgXCJib3VuZHNNYXJnaW5cIiwgXCJjb2xvclwiLCBcImNsaXBwaW5nXCIsIFwiZW5hYmxlZFwiLCBcImhcIiwgXCJpZFwiLCBcImlzQ29tcG9uZW50XCIsXG4gICAgICAgICAgICBcIm1vdW50XCIsIFwibW91bnRZXCIsIFwibW91bnRYXCIsIFwicGl2b3RcIiwgXCJwaXZvdFhcIiwgXCJwaXZvdFlcIiwgXCJyZWZcIiwgXCJyZW5kZXJPZlNjcmVlblwiLCBcInJlbmRlclRvVGV4dHVyZVwiLCBcInNjYWxlXCIsXG4gICAgICAgICAgICBcInNjYWxlWFwiLCBcInNjYWxlWVwiLCBcInN0YXRlXCIsIFwidGFnXCIsIFwidmlzaWJsZVwiLCBcIndcIiwgXCJ4XCIsIFwieVwiLCBcInpJbmRleFwiLFxuICAgICAgICAgICAgXCIhIWZsZXhcIiwgXCIhIWZsZXhJdGVtXCIsIFwiaGFzRm9jdXMoKVwiLCBcImhhc0ZpbmFsRm9jdXMoKVwiXG4gICAgICAgIF07XG4gICAgICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgICAgbGV0IGtleSA9IGxpc3Rbbl07XG4gICAgICAgICAgICBjb25zdCBnZXRCb29sZWFuID0gL14hezJ9LztcbiAgICAgICAgICAgIGNvbnN0IGlzRnVuY3Rpb24gPSAvXFwoXFwpJC87XG5cbiAgICAgICAgICAgIGlmIChnZXRCb29sZWFuLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleS5zdWJzdHJpbmcoMiwga2V5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9ICEhZWxlbWVudFtrZXldO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleS5zdWJzdHJpbmcoMCwga2V5Lmxlbmd0aCAtIDIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudFtrZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IGVsZW1lbnRba2V5XSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IGVsZW1lbnRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gey4uLnByb3BzLCAuLi5lbGVtZW50LmdldE5vbkRlZmF1bHRzKCl9O1xuICAgIH1cbn1cblxuLy8gVGhpcyBnaXZlcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBiZW5lZml0IGNvbXBhcmVkIHRvIGV4dGVuZGluZyBFdmVudEVtaXR0ZXIuXG5FdmVudEVtaXR0ZXIuYWRkQXNNaXhpbihFbGVtZW50KTtcblxuRWxlbWVudC5wcm90b3R5cGUuaXNFbGVtZW50ID0gMTtcblxuRWxlbWVudC5pZCA9IDE7XG5cbi8vIEdldHRlcnMgcmV1c2VkIHdoZW4gcmVmZXJlbmNpbmcgZWxlbWVudCAoc3Vib2JqZWN0KSBwcm9wZXJ0aWVzIGJ5IGEgcHJvcGVydHkgcGF0aCwgYXMgdXNlZCBpbiBhIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uICgneCcsICd0ZXh0dXJlLngnLCBldGMpLlxuRWxlbWVudC5QUk9QX0dFVFRFUlMgPSBuZXcgTWFwKCk7XG5cbi8vIFNldHRlcnMgcmV1c2VkIHdoZW4gcmVmZXJlbmNpbmcgZWxlbWVudCAoc3Vib2JqZWN0KSBwcm9wZXJ0aWVzIGJ5IGEgcHJvcGVydHkgcGF0aCwgYXMgdXNlZCBpbiBhIHRyYW5zaXRpb24gb3IgYW5pbWF0aW9uICgneCcsICd0ZXh0dXJlLngnLCBldGMpLlxuRWxlbWVudC5QUk9QX1NFVFRFUlMgPSBuZXcgTWFwKCk7XG5cbmltcG9ydCBUZXh0dXJlIGZyb20gXCIuL1RleHR1cmUubWpzXCI7XG5pbXBvcnQgSW1hZ2VUZXh0dXJlIGZyb20gXCIuLi90ZXh0dXJlcy9JbWFnZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgVGV4dFRleHR1cmUgZnJvbSBcIi4uL3RleHR1cmVzL1RleHRUZXh0dXJlLm1qc1wiO1xuaW1wb3J0IFNvdXJjZVRleHR1cmUgZnJvbSBcIi4uL3RleHR1cmVzL1NvdXJjZVRleHR1cmUubWpzXCI7XG5pbXBvcnQgVHJhbnNpdGlvbiBmcm9tIFwiLi4vYW5pbWF0aW9uL1RyYW5zaXRpb24ubWpzXCI7XG5pbXBvcnQgRWxlbWVudENoaWxkTGlzdCBmcm9tIFwiLi9FbGVtZW50Q2hpbGRMaXN0Lm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBsaXN0IG9mIGNoaWxkcmVuIGZvciBhbiBlbGVtZW50LlxuICovXG5cbmltcG9ydCBPYmplY3RMaXN0IGZyb20gXCIuL09iamVjdExpc3QubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnRDaGlsZExpc3QgZXh0ZW5kcyBPYmplY3RMaXN0IHtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgX2Nvbm5lY3RQYXJlbnQoaXRlbSkge1xuICAgICAgICBjb25zdCBwcmV2UGFyZW50ID0gaXRlbS5wYXJlbnQ7XG4gICAgICAgIGlmIChwcmV2UGFyZW50ICYmIHByZXZQYXJlbnQgIT09IHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgaW4gcHJldmlvdXMgY2hpbGQgbGlzdCwgd2l0aG91dFxuICAgICAgICAgICAgY29uc3QgcHJldkNoaWxkTGlzdCA9IGl0ZW0ucGFyZW50LmNoaWxkTGlzdDtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHJldkNoaWxkTGlzdC5nZXRJbmRleChpdGVtKTtcblxuICAgICAgICAgICAgaWYgKGl0ZW0ucmVmKSB7XG4gICAgICAgICAgICAgICAgcHJldkNoaWxkTGlzdC5fcmVmc1tpdGVtLnJlZl0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2Q2hpbGRMaXN0Ll9pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAvLyBBbHNvIGNsZWFuIHVwIGVsZW1lbnQgY29yZS5cbiAgICAgICAgICAgIHByZXZQYXJlbnQuY29yZS5yZW1vdmVDaGlsZEF0KGluZGV4KTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5fc2V0UGFyZW50KHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdlIGFyZSBleHBlY3RpbmcgdGhlIGNhbGxlciB0byBzeW5jIGl0IHRvIHRoZSBjb3JlLlxuICAgIH1cblxuICAgIG9uQWRkKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RQYXJlbnQoaXRlbSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY29yZS5hZGRDaGlsZEF0KGluZGV4LCBpdGVtLmNvcmUpO1xuICAgIH1cblxuICAgIG9uUmVtb3ZlKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGl0ZW0uX3NldFBhcmVudChudWxsKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jb3JlLnJlbW92ZUNoaWxkQXQoaW5kZXgpO1xuICAgIH1cblxuICAgIG9uU3luYyhyZW1vdmVkLCBhZGRlZCwgb3JkZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSByZW1vdmVkLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcmVtb3ZlZFtpXS5fc2V0UGFyZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gYWRkZWQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0UGFyZW50KGFkZGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ2MgPSBpID0+IGkuY29yZTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jb3JlLnN5bmNDaGlsZHJlbihyZW1vdmVkLm1hcChnYyksIGFkZGVkLm1hcChnYyksIG9yZGVyLm1hcChnYykpO1xuICAgIH1cblxuICAgIG9uU2V0KGl0ZW0sIGluZGV4LCBwcmV2SXRlbSkge1xuICAgICAgICBwcmV2SXRlbS5fc2V0UGFyZW50KG51bGwpO1xuXG4gICAgICAgIHRoaXMuX2Nvbm5lY3RQYXJlbnQoaXRlbSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY29yZS5zZXRDaGlsZEF0KGluZGV4LCBpdGVtLmNvcmUpO1xuICAgIH1cblxuICAgIG9uTW92ZShpdGVtLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jb3JlLm1vdmVDaGlsZChmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgIH1cblxuICAgIGNyZWF0ZUl0ZW0ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBvYmplY3QudHlwZSh0aGlzLl9lbGVtZW50LnN0YWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LnN0YWdlLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzSXRlbShvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdC5pc0VsZW1lbnQ7XG4gICAgfVxuXG59XG5cblxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIGEgbGlzdCBvZiBvYmplY3RzLlxuICogT2JqZWN0cyBtYXkgYmUgcGF0Y2hlZC4gVGhlbiwgdGhleSBjYW4gYmUgcmVmZXJlbmNlZCB1c2luZyB0aGUgJ3JlZicgKHN0cmluZykgcHJvcGVydHkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9iamVjdExpc3Qge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHRoaXMuX3JlZnMgPSB7fVxuICAgIH1cblxuICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgIH1cblxuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zWzBdO1xuICAgIH1cblxuICAgIGdldCBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoID8gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5hZGRBdChpdGVtLCB0aGlzLl9pdGVtcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIGFkZEF0KGl0ZW0sIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDw9IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbyA9IGl0ZW07XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuY3JlYXRlSXRlbShvKTtcbiAgICAgICAgICAgICAgICBpdGVtLnBhdGNoKG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdChpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZzW2l0ZW0ucmVmXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkFkZChpdGVtLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZEF0OiBUaGUgaW5kZXggJyArIGluZGV4ICsgJyBpcyBvdXQgb2YgYm91bmRzICcgKyB0aGlzLl9pdGVtcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVwbGFjZUJ5UmVmKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0ucmVmKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSB0aGlzLmdldEJ5UmVmKGl0ZW0ucmVmKTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdJdGVtKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBsYWNlQnlSZWY6IG5vIGl0ZW0gZm91bmQgd2l0aCByZWZlcmVuY2U6ICcgKyBpdGVtLnJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2UoaXRlbSwgZXhpc3RpbmdJdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVwbGFjZUJ5UmVmOiBubyByZWYgc3BlY2lmaWVkIGluIGl0ZW0nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEF0KGl0ZW0sIHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG5cbiAgICB9XG5cbiAgICByZXBsYWNlKGl0ZW0sIHByZXZJdGVtKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbmRleChwcmV2SXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVwbGFjZTogVGhlIHByZXZpb3VzIGl0ZW0gZG9lcyBub3QgZXhpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0KGl0ZW0sIGluZGV4KTtcbiAgICB9XG5cbiAgICBzZXRBdChpdGVtLCBpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbyA9IGl0ZW07XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuY3JlYXRlSXRlbShvKTtcbiAgICAgICAgICAgICAgICBpdGVtLnBhdGNoKG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tSW5kZXggPSBjdXJyZW50SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNwbGljZShpbmRleCwgMCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTW92ZShpdGVtLCBmcm9tSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtc1tpbmRleF0ucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZzW3RoaXMuX2l0ZW1zW2luZGV4XS5yZWZdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkl0ZW0gPSB0aGlzLl9pdGVtc1tpbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldDogb3ZlcndyaXRlIGN1cnJlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNbaW5kZXhdID0gaXRlbTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWZzW2l0ZW0ucmVmXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5vblNldChpdGVtLCBpbmRleCwgcHJldkl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRBdDogVGhlIGluZGV4ICcgKyBpbmRleCArICcgaXMgb3V0IG9mIGJvdW5kcyAnICsgdGhpcy5faXRlbXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEF0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1tpbmRleF07XG4gICAgfVxuXG4gICAgZ2V0SW5kZXgoaXRlbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihpdGVtKTtcbiAgICB9XG5cbiAgICByZW1vdmUoaXRlbSkge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9pdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQXQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlbW92ZUF0KGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZzW2l0ZW0ucmVmXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgdGhpcy5vblJlbW92ZShpdGVtLCBpbmRleCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZW1vdmVBdDogVGhlIGluZGV4ICR7aW5kZXh9IGlzIG91dCBvZiBib3VuZHMgJHt0aGlzLl9pdGVtcy5sZW5ndGggLSAxfWApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNsZWFyKCkge1xuICAgICAgICBsZXQgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5faXRlbXM7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcmVmcyA9IHt9XG4gICAgICAgICAgICB0aGlzLm9uU3luYyhwcmV2LCBbXSwgW10pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGEobykge1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKG8pKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuY3JlYXRlSXRlbShvKTtcbiAgICAgICAgICAgIGMucGF0Y2gobyk7XG4gICAgICAgICAgICB0aGlzLmFkZChjKTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gby5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmEob1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSXRlbShvKSkge1xuICAgICAgICAgICAgdGhpcy5hZGQobyk7XG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xuICAgIH1cblxuICAgIF9nZXRSZWZzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmcztcbiAgICB9XG5cbiAgICBnZXRCeVJlZihyZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZnNbcmVmXTtcbiAgICB9XG5cbiAgICBjbGVhclJlZihyZWYpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3JlZnNbcmVmXTtcbiAgICB9XG5cbiAgICBzZXRSZWYocmVmLCBjaGlsZCkge1xuICAgICAgICB0aGlzLl9yZWZzW3JlZl0gPSBjaGlsZDtcbiAgICB9XG5cbiAgICBwYXRjaChzZXR0aW5ncykge1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0QnlPYmplY3Qoc2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3MpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRCeUFycmF5KHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRCeU9iamVjdChzZXR0aW5ncykge1xuICAgICAgICAvLyBPdmVycnVsZSBzZXR0aW5ncyBvZiBrbm93biByZWZlcmVuY2VkIGl0ZW1zLlxuICAgICAgICBsZXQgcmVmcyA9IHRoaXMuX2dldFJlZnMoKTtcbiAgICAgICAgbGV0IGNyZWZzID0gT2JqZWN0LmtleXMoc2V0dGluZ3MpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGNyZWZzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IGNyZWYgPSBjcmVmc1tpXTtcbiAgICAgICAgICAgIGxldCBzID0gc2V0dGluZ3NbY3JlZl07XG5cbiAgICAgICAgICAgIGxldCBjID0gcmVmc1tjcmVmXTtcbiAgICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSXRlbShzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHByZXZpb3VzIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIHMucmVmID0gY3JlZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQocyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBpdGVtLlxuICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jcmVhdGVJdGVtKHMpO1xuICAgICAgICAgICAgICAgICAgICBjLnJlZiA9IGNyZWY7XG4gICAgICAgICAgICAgICAgICAgIGMucGF0Y2gocyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJdGVtKHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjICE9PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHByZXZpb3VzIGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5nZXRJbmRleChjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMucmVmID0gY3JlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXQocywgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMucGF0Y2gocyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2VxdWFsc0FycmF5KGFycmF5KSB7XG4gICAgICAgIGxldCBzYW1lID0gdHJ1ZTtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgKGkgPCBuKSAmJiBzYW1lOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzYW1lID0gc2FtZSAmJiAodGhpcy5faXRlbXNbaV0gPT09IGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FtZTtcbiAgICB9XG5cbiAgICBfc2V0QnlBcnJheShhcnJheSkge1xuICAgICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgZmlyc3QgY2hlY2sgaWYgdGhlIGFycmF5cyBtYXRjaCBleGFjdGx5IGFuZCBiYWlsIG91dCBpZiB0aGV5IGRvLlxuICAgICAgICBpZiAodGhpcy5fZXF1YWxzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5faXRlbXNbaV0ubWFya2VyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWZzO1xuICAgICAgICBsZXQgbmV3SXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzID0gYXJyYXlbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5pc0l0ZW0ocykpIHtcbiAgICAgICAgICAgICAgICBzLm1hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2gocyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjcmVmID0gcy5yZWY7XG4gICAgICAgICAgICAgICAgbGV0IGM7XG4gICAgICAgICAgICAgICAgaWYgKGNyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZzKSByZWZzID0gdGhpcy5fZ2V0UmVmcygpO1xuICAgICAgICAgICAgICAgICAgICBjID0gcmVmc1tjcmVmXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBpdGVtLlxuICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5jcmVhdGVJdGVtKHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGMubWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbChzKSkge1xuICAgICAgICAgICAgICAgICAgICBjLnBhdGNoKHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRJdGVtcyhuZXdJdGVtcyk7XG4gICAgfVxuXG4gICAgX3NldEl0ZW1zKG5ld0l0ZW1zKSB7XG4gICAgICAgIGxldCBwcmV2SXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgICAgICAgdGhpcy5faXRlbXMgPSBuZXdJdGVtcztcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW1zLlxuICAgICAgICBsZXQgcmVtb3ZlZCA9IHByZXZJdGVtcy5maWx0ZXIoaXRlbSA9PiB7bGV0IG0gPSBpdGVtLm1hcmtlcjsgZGVsZXRlIGl0ZW0ubWFya2VyOyByZXR1cm4gbX0pO1xuICAgICAgICBsZXQgYWRkZWQgPSBuZXdJdGVtcy5maWx0ZXIoaXRlbSA9PiAocHJldkl0ZW1zLmluZGV4T2YoaXRlbSkgPT09IC0xKSk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoIHx8IGFkZGVkLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgcmVmcy5cbiAgICAgICAgICAgIHRoaXMuX3JlZnMgPSB7fVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9pdGVtcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVmID0gdGhpcy5faXRlbXNbaV0ucmVmO1xuICAgICAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmc1tyZWZdID0gdGhpcy5faXRlbXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblN5bmMocmVtb3ZlZCwgYWRkZWQsIG5ld0l0ZW1zKTtcbiAgICB9XG5cbiAgICBzb3J0KGYpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9pdGVtcy5zbGljZSgpO1xuICAgICAgICBpdGVtcy5zb3J0KGYpO1xuICAgICAgICB0aGlzLl9zZXRCeUFycmF5KGl0ZW1zKTtcbiAgICB9XG5cbiAgICBvbkFkZChpdGVtLCBpbmRleCkge1xuICAgIH1cblxuICAgIG9uUmVtb3ZlKGl0ZW0sIGluZGV4KSB7XG4gICAgfVxuXG4gICAgb25TeW5jKHJlbW92ZWQsIGFkZGVkLCBvcmRlcikge1xuICAgIH1cblxuICAgIG9uU2V0KGl0ZW0sIGluZGV4LCBwcmV2SXRlbSkge1xuICAgIH1cblxuICAgIG9uTW92ZShpdGVtLCBmcm9tSW5kZXgsIHRvSW5kZXgpIHtcbiAgICB9XG5cbiAgICBjcmVhdGVJdGVtKG9iamVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RMaXN0LmNyZWF0ZUl0ZW0gbXVzdCBjcmVhdGUgYW5kIHJldHVybiBhIG5ldyBvYmplY3RcIik7XG4gICAgfVxuXG4gICAgaXNJdGVtKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaChmKTtcbiAgICB9XG5cbn1cblxuaW1wb3J0IFV0aWxzIGZyb20gXCIuL1V0aWxzLm1qc1wiO1xuXG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi9VdGlscy5tanNcIjtcbmltcG9ydCBCYXNlIGZyb20gXCIuL0Jhc2UubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYWRlciB7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb3JlQ29udGV4dCkge1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuY3R4ID0gY29yZUNvbnRleHQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAoZW5hYmxlZCkgZWxlbWVudHMgdGhhdCB1c2UgdGhpcyBzaGFkZXIuXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8RWxlbWVudENvcmU+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZShzdGFnZSwgdikge1xuICAgICAgICBsZXQgc2hhZGVyO1xuICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3RMaXRlcmFsKHYpKSB7XG4gICAgICAgICAgICBpZiAodi50eXBlKSB7XG4gICAgICAgICAgICAgICAgc2hhZGVyID0gc3RhZ2UucmVuZGVyZXIuY3JlYXRlU2hhZGVyKHN0YWdlLmN0eCwgdik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgQmFzZS5wYXRjaE9iamVjdChzaGFkZXIsIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNoYWRlciA9IHN0YWdlLmN0eC5yZW5kZXJTdGF0ZS5kZWZhdWx0U2hhZGVyO1xuICAgICAgICB9IGVsc2UgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2hhZGVyID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2LmlzU2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGFnZS5yZW5kZXJlci5pc1ZhbGlkU2hhZGVyVHlwZSh2LmNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiW0xpZ2h0bmluZ10gSW52YWxpZCBzaGFkZXIgdHlwZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNoYWRlciA9IHY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJbTGlnaHRuaW5nXSBQbGVhc2Ugc3BlY2lmeSBhIHNoYWRlciB0eXBlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRXZWJHTCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0QzJkKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGFkZEVsZW1lbnQoZWxlbWVudENvcmUpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMuYWRkKGVsZW1lbnRDb3JlKTtcbiAgICB9XG5cbiAgICByZW1vdmVFbGVtZW50KGVsZW1lbnRDb3JlKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLmRlbGV0ZShlbGVtZW50Q29yZSk7XG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVkcmF3KCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnRDb3JlID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnRDb3JlLnNldEhhc1JlbmRlclVwZGF0ZXMoMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBhdGNoKHNldHRpbmdzKSB7XG4gICAgICAgIEJhc2UucGF0Y2hPYmplY3QodGhpcywgc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHVzZURlZmF1bHQoKSB7XG4gICAgICAgIC8vIFNob3VsZCByZXR1cm4gdHJ1ZSBpZiB0aGlzIHNoYWRlciBpcyBjb25maWd1cmVkICh1c2luZyBpdCdzIHByb3BlcnRpZXMpIHRvIG5vdCBoYXZlIGFueSBlZmZlY3QuXG4gICAgICAgIC8vIFRoaXMgbWF5IGFsbG93IHRoZSByZW5kZXIgZW5naW5lIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHNoYWRlciBwcm9ncmFtIHN3aXRjaGVzIG9yIGV2ZW4gdGV4dHVyZSBjb3BpZXMuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhZGRFbXB0eSgpIHtcbiAgICAgICAgLy8gRHJhd3MgdGhpcyBzaGFkZXIgZXZlbiBpZiB0aGVyZSBhcmUgbm8gcXVhZHMgdG8gYmUgYWRkZWQuXG4gICAgICAgIC8vIFRoaXMgaXMgaGFuZHkgZm9yIGN1c3RvbSBzaGFkZXJzLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gbm8gbW9yZSBlbmFibGVkIGVsZW1lbnRzIGhhdmUgdGhpcyBzaGFkZXIuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2hhZGVyKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQXBwbGljYXRpb24gcmVuZGVyIHRyZWUuXG4gKi9cblxuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tIFwiLi4vRXZlbnRFbWl0dGVyLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuL1V0aWxzLm1qc1wiO1xuaW1wb3J0IFdlYkdMUmVuZGVyZXIgZnJvbSBcIi4uL3JlbmRlcmVyL3dlYmdsL1dlYkdMUmVuZGVyZXIubWpzXCI7XG5pbXBvcnQgQzJkUmVuZGVyZXIgZnJvbSBcIi4uL3JlbmRlcmVyL2MyZC9DMmRSZW5kZXJlci5tanNcIjtcbmltcG9ydCBTcGFya1JlbmRlcmVyIGZyb20gXCIuLi9yZW5kZXJlci9zcGFyay9TcGFya1JlbmRlcmVyLm1qc1wiO1xuaW1wb3J0IFBsYXRmb3JtTG9hZGVyIGZyb20gXCIuLi9wbGF0Zm9ybXMvUGxhdGZvcm1Mb2FkZXIubWpzXCI7XG5pbXBvcnQgV2ViR0xTdGF0ZU1hbmFnZXIgZnJvbSBcIi4uL3Rvb2xzL1dlYkdMU3RhdGVNYW5hZ2VyLm1qc1wiO1xuaW1wb3J0IFNoYWRlciBmcm9tIFwiLi9TaGFkZXIubWpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWdlIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuX3VzZWRNZW1vcnkgPSAwO1xuICAgICAgICB0aGlzLl9sYXN0R2NGcmFtZSA9IDA7XG5cbiAgICAgICAgY29uc3QgcGxhdGZvcm1UeXBlID0gU3RhZ2UucGxhdGZvcm0gPyBTdGFnZS5wbGF0Zm9ybSA6IFBsYXRmb3JtTG9hZGVyLmxvYWQob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgcGxhdGZvcm1UeXBlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm0uaW5pdCkge1xuICAgICAgICAgICAgdGhpcy5wbGF0Zm9ybS5pbml0KHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIHRoaXMuYzJkID0gbnVsbDtcblxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRPcHRpb24oJ2NvbnRleHQnKTtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0LnVzZVByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsID0gY29udGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jMmQgPSBjb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzV2ViICYmICghU3RhZ2UuaXNXZWJnbFN1cHBvcnRlZCgpIHx8IHRoaXMuZ2V0T3B0aW9uKCdjYW52YXMyZCcpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYzJkID0gdGhpcy5wbGF0Zm9ybS5jcmVhdGVDYW52YXNDb250ZXh0KHRoaXMuZ2V0T3B0aW9uKCd3JyksIHRoaXMuZ2V0T3B0aW9uKCdoJykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdsID0gdGhpcy5wbGF0Zm9ybS5jcmVhdGVXZWJHTENvbnRleHQodGhpcy5nZXRPcHRpb24oJ3cnKSwgdGhpcy5nZXRPcHRpb24oJ2gnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nbCkge1xuICAgICAgICAgICAgLy8gV3JhcCBpbiBXZWJHTFN0YXRlTWFuYWdlci5cbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgdW5uZWNlc3NhcnkgZG91YmxlIFdlYkdMIGNvbW1hbmRzIGZyb20gYmVpbmcgZXhlY3V0ZWQsIGFuZCBhbGxvd3MgY29udGV4dCBzd2l0Y2hpbmcuXG4gICAgICAgICAgICAvLyBDb250ZXh0IHN3aXRjaGluZyBpcyBuZWNlc3Nhcnkgd2hlbiByZXVzaW5nIHRoZSBzYW1lIGNvbnRleHQgZm9yIFRocmVlLmpzLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSB1c2VyIG11c3QgbWFrZSBzdXJlIHRoYXQgdGhlIFdlYkdMIGNvbnRleHQgaXMgdW50b3VjaGVkIGJlZm9yZSBjcmVhdGluZyB0aGUgYXBwbGljYXRpb24sXG4gICAgICAgICAgICAvLyAgd2hlbiBtYW51YWxseSBwYXNzaW5nIG92ZXIgYSBjYW52YXMgb3IgY29udGV4dCBpbiB0aGUgb3B0aW9ucy5cbiAgICAgICAgICAgIFdlYkdMU3RhdGVNYW5hZ2VyLmVuYWJsZSh0aGlzLmdsLCBcImxpZ2h0bmluZ1wiKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9kZSA9IHRoaXMuZ2wgPyAwIDogMTtcblxuICAgICAgICAvLyBPdmVycmlkZSB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAgICBpZiAodGhpcy5nZXRDYW52YXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy53ID0gdGhpcy5nZXRDYW52YXMoKS53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuaCA9IHRoaXMuZ2V0Q2FudmFzKCkuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21vZGUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChVdGlscy5pc1NwYXJrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgU3BhcmtSZW5kZXJlcih0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IEMyZFJlbmRlcmVyKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRDbGVhckNvbG9yKHRoaXMuZ2V0T3B0aW9uKCdjbGVhckNvbG9yJykpO1xuXG4gICAgICAgIHRoaXMuZnJhbWVDb3VudGVyID0gMDtcblxuICAgICAgICB0aGlzLnRyYW5zaXRpb25zID0gbmV3IFRyYW5zaXRpb25NYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9uTWFuYWdlcih0aGlzKTtcblxuICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbmV3IFRleHR1cmVNYW5hZ2VyKHRoaXMpO1xuICAgICAgICB0aGlzLnRleHR1cmVUaHJvdHRsZXIgPSBuZXcgVGV4dHVyZVRocm90dGxlcih0aGlzKTtcblxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmR0ID0gMDtcblxuICAgICAgICAvLyBQcmVsb2FkIHJlY3RhbmdsZSB0ZXh0dXJlLCBzbyB0aGF0IHdlIGNhbiBza2lwIHNvbWUgYm9yZGVyIGNoZWNrcyBmb3IgbG9hZGluZyB0ZXh0dXJlcy5cbiAgICAgICAgdGhpcy5yZWN0YW5nbGVUZXh0dXJlID0gbmV3IFJlY3RhbmdsZVRleHR1cmUodGhpcyk7XG4gICAgICAgIHRoaXMucmVjdGFuZ2xlVGV4dHVyZS5sb2FkKCk7XG5cbiAgICAgICAgLy8gTmV2ZXIgY2xlYW4gdXAgYmVjYXVzZSB3ZSB1c2UgaXQgYWxsIHRoZSB0aW1lLlxuICAgICAgICB0aGlzLnJlY3RhbmdsZVRleHR1cmUuc291cmNlLnBlcm1hbmVudCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jdHggPSBuZXcgQ29yZUNvbnRleHQodGhpcyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzV2ViZ2xTdXBwb3J0ZWQoKSB7XG4gICAgICAgIGlmIChVdGlscy5pc05vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIXdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVuZGVyaW5nIG1vZGUuXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiAgMDogV2ViR0xcbiAgICAgKiAgMTogQ2FudmFzMmRcbiAgICAgKi9cbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vZGU7XG4gICAgfVxuXG4gICAgaXNXZWJnbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gMDtcbiAgICB9XG5cbiAgICBpc0MyZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gMTtcbiAgICB9XG5cbiAgICBnZXRPcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9uc1tuYW1lXTtcbiAgICB9XG5cbiAgICBfc2V0T3B0aW9ucyhvKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcblxuICAgICAgICBsZXQgb3B0ID0gKG5hbWUsIGRlZikgPT4ge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gb1tuYW1lXTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zW25hbWVdID0gZGVmO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHQoJ2NhbnZhcycsIG51bGwpO1xuICAgICAgICBvcHQoJ2NvbnRleHQnLCBudWxsKTtcbiAgICAgICAgb3B0KCd3JywgMTkyMCk7XG4gICAgICAgIG9wdCgnaCcsIDEwODApO1xuICAgICAgICBvcHQoJ3NyY0Jhc2VQYXRoJywgbnVsbCk7XG4gICAgICAgIG9wdCgnbWVtb3J5UHJlc3N1cmUnLCAyNGU2KTtcbiAgICAgICAgb3B0KCdidWZmZXJNZW1vcnknLCAyZTYpO1xuICAgICAgICBvcHQoJ3RleHRSZW5kZXJJc3N1ZU1hcmdpbicsIDApO1xuICAgICAgICBvcHQoJ2ZvbnRTaGFycCcse3ByZWNpc2lvbjowLjY2NjY2NjY2NjcsIGZvbnRTaXplOiAyNH0pXG4gICAgICAgIG9wdCgnY2xlYXJDb2xvcicsIFswLCAwLCAwLCAwXSk7XG4gICAgICAgIG9wdCgnZGVmYXVsdEZvbnRGYWNlJywgJ3NhbnMtc2VyaWYnKTtcbiAgICAgICAgb3B0KCdmaXhlZER0JywgMCk7XG4gICAgICAgIG9wdCgndXNlSW1hZ2VXb3JrZXInLCB0cnVlKTtcbiAgICAgICAgb3B0KCdhdXRvc3RhcnQnLCB0cnVlKTtcbiAgICAgICAgb3B0KCdwcmVjaXNpb24nLCAxKTtcbiAgICAgICAgb3B0KCdjYW52YXMyZCcsIGZhbHNlKTtcbiAgICAgICAgb3B0KCdwbGF0Zm9ybScsIG51bGwpO1xuICAgICAgICBvcHQoJ3JlYWRQaXhlbHNCZWZvcmVEcmF3JywgZmFsc2UpO1xuICAgIH1cblxuICAgIHNldEFwcGxpY2F0aW9uKGFwcCkge1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gYXBwO1xuICAgIH1cblxuICAgIGluaXQoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb24uZ2V0T3B0aW9uKCdkZWJ1ZycpICYmIHRoaXMucGxhdGZvcm0uX2ltYWdlV29ya2VyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0xpZ2h0bmluZ10gVXNpbmcgaW1hZ2Ugd29ya2VyIScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb24uZ2V0T3B0aW9uKCdkZWJ1ZycpICYmIHRoaXMuYzJkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0xpZ2h0bmluZ10gVXNpbmcgY2FudmFzMmQgcmVuZGVyZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24uc2V0QXNSb290KCk7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbignYXV0b3N0YXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMucGxhdGZvcm0uc3RhcnRMb29wKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBsYXRmb3JtLnN0b3BMb29wKCk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0uZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmN0eC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5zdG9wTG9vcCgpO1xuICAgIH1cblxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5zdGFydExvb3AoKTtcbiAgICB9XG5cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb247XG4gICAgfVxuXG4gICAgZ2V0Q2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZSA/IHRoaXMuYzJkLmNhbnZhcyA6IHRoaXMuZ2wuY2FudmFzO1xuICAgIH1cblxuICAgIGdldFJlbmRlclByZWNpc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMucHJlY2lzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIGEgdGV4dHVyZSBmb3IgdXBkYXRpbmcgaXQncyBzb3VyY2UgdXBvbiB0aGUgbmV4dCBkcmF3RnJhbWUuXG4gICAgICogQHBhcmFtIHRleHR1cmVcbiAgICAgKi9cbiAgICBhZGRVcGRhdGVTb3VyY2VUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0aW5nRnJhbWUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gY2FsbGVkIGZyb20gdGhlIHVwbG9hZCBsb29wLCB3ZSBtdXN0IGltbWVkaWF0ZWx5IGxvYWQgdGhlIHRleHR1cmUgaW4gb3JkZXIgdG8gYXZvaWQgYSAnZmxhc2gnLlxuICAgICAgICAgICAgdGV4dHVyZS5fcGVyZm9ybVVwZGF0ZVNvdXJjZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMuYWRkKHRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlVXBkYXRlU291cmNlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMuZGVsZXRlKHRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzVXBkYXRlU291cmNlVGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMgJiYgdGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMuaGFzKHRleHR1cmUpKTtcbiAgICB9XG5cbiAgICBkcmF3RnJhbWUoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHRoaXMucGxhdGZvcm0uZ2V0SHJUaW1lKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZml4ZWREdCkge1xuICAgICAgICAgICAgdGhpcy5kdCA9IHRoaXMuX29wdGlvbnMuZml4ZWREdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHQgPSAoIXRoaXMuc3RhcnRUaW1lKSA/IC4wMiA6IC4wMDEgKiAodGhpcy5jdXJyZW50VGltZSAtIHRoaXMuc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnZnJhbWVTdGFydCcpO1xuXG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTb3VyY2VUZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuICAgICAgICAgICAgICAgIHRleHR1cmUuX3BlcmZvcm1VcGRhdGVTb3VyY2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU291cmNlVGV4dHVyZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmN0eC5oYXNSZW5kZXJVcGRhdGVzKCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIG1heSBjYXVzZSB0ZXh0dXJlcyB0byBiZSBsb2FkZWQgaW4gc3luYywgc28gYnkgcHJvY2Vzc2luZyB0aGVtIGhlcmUgd2UgbWF5IGJlIGFibGUgdG8gc2hvdyB0aGVtXG4gICAgICAgIC8vIGR1cmluZyB0aGUgY3VycmVudCBmcmFtZSBhbHJlYWR5LlxuICAgICAgICB0aGlzLnRleHR1cmVUaHJvdHRsZXIucHJvY2Vzc1NvbWUoKTtcblxuICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN0eC51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY3R4LnJlbmRlcigpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRpbmdGcmFtZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5uZXh0RnJhbWUoY2hhbmdlcyk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdmcmFtZUVuZCcpO1xuXG4gICAgICAgIHRoaXMuZnJhbWVDb3VudGVyKys7XG4gICAgfVxuXG4gICAgaXNVcGRhdGluZ0ZyYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRpbmdGcmFtZTtcbiAgICB9XG5cbiAgICByZW5kZXJGcmFtZSgpIHtcbiAgICAgICAgdGhpcy5jdHguZnJhbWUoKTtcbiAgICB9XG5cbiAgICBmb3JjZVJlbmRlclVwZGF0ZSgpIHtcbiAgICAgICAgLy8gRW5mb3JjZSByZS1yZW5kZXJpbmcuXG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5jb3JlLl9wYXJlbnQuc2V0SGFzUmVuZGVyVXBkYXRlcygxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldENsZWFyQ29sb3IoY2xlYXJDb2xvcikge1xuICAgICAgICB0aGlzLmZvcmNlUmVuZGVyVXBkYXRlKCk7XG4gICAgICAgIGlmIChjbGVhckNvbG9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEbyBub3QgY2xlYXIuXG4gICAgICAgICAgICB0aGlzLl9jbGVhckNvbG9yID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNsZWFyQ29sb3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhckNvbG9yID0gY2xlYXJDb2xvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyQ29sb3IgPSBTdGFnZVV0aWxzLmdldFJnYmFDb21wb25lbnRzTm9ybWFsaXplZChjbGVhckNvbG9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENsZWFyQ29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbGVhckNvbG9yO1xuICAgIH1cblxuICAgIGNyZWF0ZUVsZW1lbnQoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50KHNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNyZWF0ZVNoYWRlcihzZXR0aW5ncykge1xuICAgICAgICByZXR1cm4gU2hhZGVyLmNyZWF0ZSh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgZWxlbWVudChzZXR0aW5ncykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuaXNFbGVtZW50KSByZXR1cm4gc2V0dGluZ3M7XG5cbiAgICAgICAgbGV0IGVsZW1lbnQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy50eXBlKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gbmV3IHNldHRpbmdzLnR5cGUodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gbmV3IEVsZW1lbnQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnBhdGNoKHNldHRpbmdzKTtcblxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICBjKHNldHRpbmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQoc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGdldCB3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy53O1xuICAgIH1cblxuICAgIGdldCBoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5oO1xuICAgIH1cblxuICAgIGdldCBjb29yZHNXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudyAvIHRoaXMuX29wdGlvbnMucHJlY2lzaW9uO1xuICAgIH1cblxuICAgIGdldCBjb29yZHNIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmggLyB0aGlzLl9vcHRpb25zLnByZWNpc2lvbjtcbiAgICB9XG5cbiAgICBhZGRNZW1vcnlVc2FnZShkZWx0YSkge1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ICs9IGRlbHRhO1xuICAgICAgICBpZiAodGhpcy5fbGFzdEdjRnJhbWUgIT09IHRoaXMuZnJhbWVDb3VudGVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlZE1lbW9yeSA+IHRoaXMuZ2V0T3B0aW9uKCdtZW1vcnlQcmVzc3VyZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nYyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VzZWRNZW1vcnkgPiB0aGlzLmdldE9wdGlvbignbWVtb3J5UHJlc3N1cmUnKSAtIDJlNikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUb28gZmV3IHJlbGVhc2VkLiBBZ2dyZXNzaXZlIGNsZWFudXAuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2ModHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHVzZWRNZW1vcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91c2VkTWVtb3J5O1xuICAgIH1cblxuICAgIGdjKGFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RHY0ZyYW1lICE9PSB0aGlzLmZyYW1lQ291bnRlcikge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEdjRnJhbWUgPSB0aGlzLmZyYW1lQ291bnRlcjtcbiAgICAgICAgICAgIGNvbnN0IG1lbW9yeVVzYWdlQmVmb3JlID0gdGhpcy5fdXNlZE1lbW9yeTtcbiAgICAgICAgICAgIHRoaXMuZ2NUZXh0dXJlTWVtb3J5KGFnZ3Jlc3NpdmUpO1xuICAgICAgICAgICAgdGhpcy5nY1JlbmRlclRleHR1cmVNZW1vcnkoYWdncmVzc2l2ZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdjKGFnZ3Jlc3NpdmUpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbi5nZXRPcHRpb24oJ2RlYnVnJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0xpZ2h0bmluZ10gR0Mke2FnZ3Jlc3NpdmUgPyBcIlthZ2dyZXNzaXZlXVwiIDogXCJcIn0hIEZyYW1lICR7dGhpcy5fbGFzdEdjRnJhbWV9IEZyZWVkICR7KChtZW1vcnlVc2FnZUJlZm9yZSAtIHRoaXMuX3VzZWRNZW1vcnkpIC8gMWU2KS50b0ZpeGVkKDIpfU1QIGZyb20gR1BVIG1lbW9yeS4gUmVtYWluaW5nOiAkeyh0aGlzLl91c2VkTWVtb3J5IC8gMWU2KS50b0ZpeGVkKDIpfU1QYCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3RoZXIgPSB0aGlzLl91c2VkTWVtb3J5IC0gdGhpcy50ZXh0dXJlTWFuYWdlci51c2VkTWVtb3J5IC0gdGhpcy5jdHgudXNlZE1lbW9yeTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW0xpZ2h0bmluZ10gVGV4dHVyZXM6ICR7KHRoaXMudGV4dHVyZU1hbmFnZXIudXNlZE1lbW9yeSAvIDFlNikudG9GaXhlZCgyKX1NUCwgUmVuZGVyIFRleHR1cmVzOiAkeyh0aGlzLmN0eC51c2VkTWVtb3J5IC8gMWU2KS50b0ZpeGVkKDIpfU1QLCBSZW5kZXJlciBjYWNoZXM6ICR7KG90aGVyIC8gMWU2KS50b0ZpeGVkKDIpfU1QYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnY1RleHR1cmVNZW1vcnkoYWdncmVzc2l2ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChhZ2dyZXNzaXZlICYmIHRoaXMuY3R4LnJvb3QudmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgQUxMIHRleHR1cmVzIGFyZSBjbGVhbmVkO1xuICAgICAgICAgICAgdGhpcy5jdHgucm9vdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLmdjKCk7XG4gICAgICAgICAgICB0aGlzLmN0eC5yb290LnZpc2libGUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5nYygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2NSZW5kZXJUZXh0dXJlTWVtb3J5KGFnZ3Jlc3NpdmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoYWdncmVzc2l2ZSAmJiB0aGlzLnJvb3QudmlzaWJsZSkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgQUxMIHJlbmRlciB0ZXh0dXJlcyBhcmUgY2xlYW5lZDtcbiAgICAgICAgICAgIHRoaXMucm9vdC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmN0eC5mcmVlVW51c2VkUmVuZGVyVGV4dHVyZXMoMCk7XG4gICAgICAgICAgICB0aGlzLnJvb3QudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN0eC5mcmVlVW51c2VkUmVuZGVyVGV4dHVyZXMoMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXREcmF3aW5nQ2FudmFzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbGF0Zm9ybS5nZXREcmF3aW5nQ2FudmFzKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLmN0eC51cGRhdGUoKVxuICAgIH1cblxuICAgIGFkZFNlcnZpY2VQcm92aWRlcihzZXJ2aWNlcHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzU3BhcmspIHtcbiAgICAgICAgICAgIHRoaXMucGxhdGZvcm0uYWRkU2VydmljZVByb3ZpZGVyKHNlcnZpY2Vwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDaGlsZHJlbkJ5UG9zaXRpb24oeCwgeSl7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMucm9vdC5jb3JlLnVwZGF0ZSgpO1xuICAgICAgICB0aGlzLnJvb3QuY29yZS5jb2xsZWN0QXRDb29yZCh4LHksY2hpbGRyZW4pO1xuXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG59XG5cbmltcG9ydCBFbGVtZW50IGZyb20gXCIuL0VsZW1lbnQubWpzXCI7XG5pbXBvcnQgU3RhZ2VVdGlscyBmcm9tIFwiLi9TdGFnZVV0aWxzLm1qc1wiO1xuaW1wb3J0IFRleHR1cmVNYW5hZ2VyIGZyb20gXCIuL1RleHR1cmVNYW5hZ2VyLm1qc1wiO1xuaW1wb3J0IFRleHR1cmVUaHJvdHRsZXIgZnJvbSBcIi4vVGV4dHVyZVRocm90dGxlci5tanNcIjtcbmltcG9ydCBDb3JlQ29udGV4dCBmcm9tIFwiLi9jb3JlL0NvcmVDb250ZXh0Lm1qc1wiO1xuaW1wb3J0IFRyYW5zaXRpb25NYW5hZ2VyIGZyb20gXCIuLi9hbmltYXRpb24vVHJhbnNpdGlvbk1hbmFnZXIubWpzXCI7XG5pbXBvcnQgQW5pbWF0aW9uTWFuYWdlciBmcm9tIFwiLi4vYW5pbWF0aW9uL0FuaW1hdGlvbk1hbmFnZXIubWpzXCI7XG5pbXBvcnQgUmVjdGFuZ2xlVGV4dHVyZSBmcm9tIFwiLi4vdGV4dHVyZXMvUmVjdGFuZ2xlVGV4dHVyZS5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YWdlVXRpbHMge1xuXG4gICAgc3RhdGljIG1lcmdlTnVtYmVycyh2MSwgdjIsIHApIHtcbiAgICAgICAgcmV0dXJuIHYxICogcCArIHYyICogKDEgLSBwKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIHJnYihyLCBnLCBiKSB7XG4gICAgICAgIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGIgKyAoMjU1ICogMTY3NzcyMTYpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgcmdiYShyLCBnLCBiLCBhKSB7XG4gICAgICAgIHJldHVybiAociA8PCAxNikgKyAoZyA8PCA4KSArIGIgKyAoKChhICogMjU1KSB8IDApICogMTY3NzcyMTYpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0UmdiU3RyaW5nKGNvbG9yKSB7XG4gICAgICAgIGxldCByID0gKChjb2xvciAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZyA9ICgoY29sb3IgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiID0gY29sb3IgJSAyNTY7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnKSc7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRSZ2JhU3RyaW5nKGNvbG9yKSB7XG4gICAgICAgIGxldCByID0gKChjb2xvciAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZyA9ICgoY29sb3IgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiID0gY29sb3IgJSAyNTY7XG4gICAgICAgIGxldCBhID0gKChjb2xvciAvIDE2Nzc3MjE2KSB8IDApIC8gMjU1O1xuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEudG9GaXhlZCg0KSArICcpJztcbiAgICB9O1xuXG4gICAgc3RhdGljIGdldFJnYmFTdHJpbmdGcm9tQXJyYXkoY29sb3IpIHtcbiAgICAgICAgbGV0IHIgPSBNYXRoLmZsb29yKGNvbG9yWzBdICogMjU1KTtcbiAgICAgICAgbGV0IGcgPSBNYXRoLmZsb29yKGNvbG9yWzFdICogMjU1KTtcbiAgICAgICAgbGV0IGIgPSBNYXRoLmZsb29yKGNvbG9yWzJdICogMjU1KTtcbiAgICAgICAgbGV0IGEgPSBNYXRoLmZsb29yKGNvbG9yWzNdICogMjU1KSAvIDI1NTtcbiAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyByICsgJywnICsgZyArICcsJyArIGIgKyAnLCcgKyBhLnRvRml4ZWQoNCkgKyAnKSc7XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRSZ2JhQ29tcG9uZW50c05vcm1hbGl6ZWQoYXJnYikge1xuICAgICAgICBsZXQgciA9ICgoYXJnYiAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZyA9ICgoYXJnYiAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIgPSBhcmdiICUgMjU2O1xuICAgICAgICBsZXQgYSA9ICgoYXJnYiAvIDE2Nzc3MjE2KSB8IDApO1xuICAgICAgICByZXR1cm4gW3IgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTUsIGEgLyAyNTVdO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0UmdiQ29tcG9uZW50c05vcm1hbGl6ZWQoYXJnYikge1xuICAgICAgICBsZXQgciA9ICgoYXJnYiAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZyA9ICgoYXJnYiAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIgPSBhcmdiICUgMjU2O1xuICAgICAgICByZXR1cm4gW3IgLyAyNTUsIGcgLyAyNTUsIGIgLyAyNTVdO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0UmdiYUNvbXBvbmVudHMoYXJnYikge1xuICAgICAgICBsZXQgciA9ICgoYXJnYiAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZyA9ICgoYXJnYiAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgbGV0IGIgPSBhcmdiICUgMjU2O1xuICAgICAgICBsZXQgYSA9ICgoYXJnYiAvIDE2Nzc3MjE2KSB8IDApO1xuICAgICAgICByZXR1cm4gW3IsIGcsIGIsIGFdO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0QXJnYk51bWJlcihyZ2JhKSB7XG4gICAgICAgIHJnYmFbMF0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbMF0pKTtcbiAgICAgICAgcmdiYVsxXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgcmdiYVsxXSkpO1xuICAgICAgICByZ2JhWzJdID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCByZ2JhWzJdKSk7XG4gICAgICAgIHJnYmFbM10gPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHJnYmFbM10pKTtcbiAgICAgICAgbGV0IHYgPSAoKHJnYmFbM10gfCAwKSA8PCAyNCkgKyAoKHJnYmFbMF0gfCAwKSA8PCAxNikgKyAoKHJnYmFbMV0gfCAwKSA8PCA4KSArIChyZ2JhWzJdIHwgMCk7XG4gICAgICAgIGlmICh2IDwgMCkge1xuICAgICAgICAgICAgdiA9IDB4RkZGRkZGRkYgKyB2ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xuXG4gICAgc3RhdGljIG1lcmdlQ29sb3JzKGMxLCBjMiwgcCkge1xuICAgICAgICBsZXQgcjEgPSAoKGMxIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBnMSA9ICgoYzEgLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgIGxldCBiMSA9IGMxICUgMjU2O1xuICAgICAgICBsZXQgYTEgPSAoKGMxIC8gMTY3NzcyMTYpIHwgMCk7XG5cbiAgICAgICAgbGV0IHIyID0gKChjMiAvIDY1NTM2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgZzIgPSAoKGMyIC8gMjU2KSB8IDApICUgMjU2O1xuICAgICAgICBsZXQgYjIgPSBjMiAlIDI1NjtcbiAgICAgICAgbGV0IGEyID0gKChjMiAvIDE2Nzc3MjE2KSB8IDApO1xuXG4gICAgICAgIGxldCByID0gcjEgKiBwICsgcjIgKiAoMSAtIHApO1xuICAgICAgICBsZXQgZyA9IGcxICogcCArIGcyICogKDEgLSBwKTtcbiAgICAgICAgbGV0IGIgPSBiMSAqIHAgKyBiMiAqICgxIC0gcCk7XG4gICAgICAgIGxldCBhID0gYTEgKiBwICsgYTIgKiAoMSAtIHApO1xuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGEpICogMTY3NzcyMTYgKyBNYXRoLnJvdW5kKHIpICogNjU1MzYgKyBNYXRoLnJvdW5kKGcpICogMjU2ICsgTWF0aC5yb3VuZChiKTtcbiAgICB9O1xuXG4gICAgc3RhdGljIG1lcmdlTXVsdGlDb2xvcnMoYywgcCkge1xuICAgICAgICBsZXQgciA9IDAsIGcgPSAwLCBiID0gMCwgYSA9IDAsIHQgPSAwO1xuICAgICAgICBsZXQgbiA9IGMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgbGV0IHIxID0gKChjW2ldIC8gNjU1MzYpIHwgMCkgJSAyNTY7XG4gICAgICAgICAgICBsZXQgZzEgPSAoKGNbaV0gLyAyNTYpIHwgMCkgJSAyNTY7XG4gICAgICAgICAgICBsZXQgYjEgPSBjW2ldICUgMjU2O1xuICAgICAgICAgICAgbGV0IGExID0gKChjW2ldIC8gMTY3NzcyMTYpIHwgMCk7XG4gICAgICAgICAgICByICs9IHIxICogcFtpXTtcbiAgICAgICAgICAgIGcgKz0gZzEgKiBwW2ldO1xuICAgICAgICAgICAgYiArPSBiMSAqIHBbaV07XG4gICAgICAgICAgICBhICs9IGExICogcFtpXTtcbiAgICAgICAgICAgIHQgKz0gcFtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHQgPSAxIC8gdDtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSAqIHQpICogMTY3NzcyMTYgKyBNYXRoLnJvdW5kKHIgKiB0KSAqIDY1NTM2ICsgTWF0aC5yb3VuZChnICogdCkgKiAyNTYgKyBNYXRoLnJvdW5kKGIgKiB0KTtcbiAgICB9O1xuXG4gICAgc3RhdGljIG1lcmdlTXVsdGlDb2xvcnNFcXVhbChjKSB7XG4gICAgICAgIGxldCByID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMCwgdCA9IDA7XG4gICAgICAgIGxldCBuID0gYy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcjEgPSAoKGNbaV0gLyA2NTUzNikgfCAwKSAlIDI1NjtcbiAgICAgICAgICAgIGxldCBnMSA9ICgoY1tpXSAvIDI1NikgfCAwKSAlIDI1NjtcbiAgICAgICAgICAgIGxldCBiMSA9IGNbaV0gJSAyNTY7XG4gICAgICAgICAgICBsZXQgYTEgPSAoKGNbaV0gLyAxNjc3NzIxNikgfCAwKTtcbiAgICAgICAgICAgIHIgKz0gcjE7XG4gICAgICAgICAgICBnICs9IGcxO1xuICAgICAgICAgICAgYiArPSBiMTtcbiAgICAgICAgICAgIGEgKz0gYTE7XG4gICAgICAgICAgICB0ICs9IDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHQgPSAxIC8gdDtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoYSAqIHQpICogMTY3NzcyMTYgKyBNYXRoLnJvdW5kKHIgKiB0KSAqIDY1NTM2ICsgTWF0aC5yb3VuZChnICogdCkgKiAyNTYgKyBNYXRoLnJvdW5kKGIgKiB0KTtcbiAgICB9O1xuXG4gICAgc3RhdGljIG1lcmdlQ29sb3JBbHBoYShjLCBhbHBoYSkge1xuICAgICAgICBsZXQgYSA9ICgoYyAvIDE2Nzc3MjE2IHwgMCkgKiBhbHBoYSkgfCAwO1xuICAgICAgICByZXR1cm4gKCgoKChjID4+IDE2KSAmIDB4ZmYpICogYSkgLyAyNTUpICYgMHhmZikgK1xuICAgICAgICAgICAgKCgoKGMgJiAweGZmMDApICogYSkgLyAyNTUpICYgMHhmZjAwKSArXG4gICAgICAgICAgICAoKCgoKGMgJiAweGZmKSA8PCAxNikgKiBhKSAvIDI1NSkgJiAweGZmMDAwMCkgK1xuICAgICAgICAgICAgKGEgPDwgMjQpO1xuICAgIH07XG5cbiAgICBzdGF0aWMgcmFkKGRlZykge1xuICAgICAgICByZXR1cm4gZGVnICogKE1hdGguUEkgLyAxODApO1xuICAgIH07XG5cbiAgICBzdGF0aWMgZ2V0VGltaW5nQmV6aWVyKGEsIGIsIGMsIGQpIHtcbiAgICAgICAgbGV0IHhjID0gMy4wICogYTtcbiAgICAgICAgbGV0IHhiID0gMy4wICogKGMgLSBhKSAtIHhjO1xuICAgICAgICBsZXQgeGEgPSAxLjAgLSB4YyAtIHhiO1xuICAgICAgICBsZXQgeWMgPSAzLjAgKiBiO1xuICAgICAgICBsZXQgeWIgPSAzLjAgKiAoZCAtIGIpIC0geWM7XG4gICAgICAgIGxldCB5YSA9IDEuMCAtIHljIC0geWI7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICBpZiAodGltZSA+PSAxLjApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aW1lIDw9IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHQgPSAwLjUsIGNieCwgY2J4ZCwgZHg7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGl0ID0gMDsgaXQgPCAyMDsgaXQrKykge1xuICAgICAgICAgICAgICAgIGNieCA9IHQgKiAodCAqICh0ICogeGEgKyB4YikgKyB4Yyk7XG4gICAgICAgICAgICAgICAgZHggPSB0aW1lIC0gY2J4O1xuICAgICAgICAgICAgICAgIGlmIChkeCA+IC0xZS04ICYmIGR4IDwgMWUtOCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAqICh0ICogKHQgKiB5YSArIHliKSArIHljKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDdWJpYyBiZXppZXIgZGVyaXZhdGl2ZS5cbiAgICAgICAgICAgICAgICBjYnhkID0gdCAqICh0ICogKDMgKiB4YSkgKyAyICogeGIpICsgeGM7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2J4ZCA+IDFlLTEwICYmIGNieGQgPCAxZS0xMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9ibGVtYXRpYy4gRmFsbCBiYWNrIHRvIGJpbmFyeSBzZWFyY2ggbWV0aG9kLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0ICs9IGR4IC8gY2J4ZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGJpbmFyeSBzZWFyY2ggbWV0aG9kLiBUaGlzIGlzIG1vcmUgcmVsaWFibGUgd2hlbiB0aGVyZSBhcmUgbmVhci0wIHNsb3Blcy5cbiAgICAgICAgICAgIGxldCBtaW5UID0gMDtcbiAgICAgICAgICAgIGxldCBtYXhUID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IGl0ID0gMDsgaXQgPCAyMDsgaXQrKykge1xuICAgICAgICAgICAgICAgIHQgPSAwLjUgKiAobWluVCArIG1heFQpO1xuXG4gICAgICAgICAgICAgICAgY2J4ID0gdCAqICh0ICogKHQgKiB4YSArIHhiKSArIHhjKTtcblxuICAgICAgICAgICAgICAgIGR4ID0gdGltZSAtIGNieDtcbiAgICAgICAgICAgICAgICBpZiAoZHggPiAtMWUtOCAmJiBkeCA8IDFlLTgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29sdXRpb24gZm91bmQhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ICogKHQgKiAodCAqIHlhICsgeWIpICsgeWMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4VCA9IHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluVCA9IHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHN0YXRpYyBnZXRUaW1pbmdGdW5jdGlvbihzdHIpIHtcbiAgICAgICAgc3dpdGNoIChzdHIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcImVhc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhZ2VVdGlscy5nZXRUaW1pbmdCZXppZXIoMC4yNSwgMC4xLCAwLjI1LCAxLjApO1xuICAgICAgICAgICAgY2FzZSBcImVhc2UtaW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhZ2VVdGlscy5nZXRUaW1pbmdCZXppZXIoMC40MiwgMCwgMS4wLCAxLjApO1xuICAgICAgICAgICAgY2FzZSBcImVhc2Utb3V0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0YWdlVXRpbHMuZ2V0VGltaW5nQmV6aWVyKDAsIDAsIDAuNTgsIDEuMCk7XG4gICAgICAgICAgICBjYXNlIFwiZWFzZS1pbi1vdXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RhZ2VVdGlscy5nZXRUaW1pbmdCZXppZXIoMC40MiwgMCwgMC41OCwgMS4wKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdGVwLXN0YXJ0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSBcInN0ZXAtZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lID09PSAxID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGV0IHMgPSBcImN1YmljLWJlemllcihcIjtcbiAgICAgICAgICAgICAgICBpZiAoc3RyICYmIHN0ci5pbmRleE9mKHMpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0cyA9IHN0ci5zdWJzdHIocy5sZW5ndGgsIHN0ci5sZW5ndGggLSBzLmxlbmd0aCAtIDEpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW0xpZ2h0bmluZ10gVW5rbm93biB0aW1pbmcgZnVuY3Rpb246IFwiICsgc3RyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHVzZSBsaW5lYXIuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgYSA9IHBhcnNlRmxvYXQocGFydHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYiA9IHBhcnNlRmxvYXQocGFydHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYyA9IHBhcnNlRmxvYXQocGFydHNbMl0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHBhcnNlRmxvYXQocGFydHNbM10pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oYSkgfHwgaXNOYU4oYikgfHwgaXNOYU4oYykgfHwgaXNOYU4oZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIFVua25vd24gdGltaW5nIGZ1bmN0aW9uOiBcIiArIHN0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogdXNlIGxpbmVhci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0YWdlVXRpbHMuZ2V0VGltaW5nQmV6aWVyKGEsIGIsIGMsIGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltMaWdodG5pbmddIFVua25vd24gdGltaW5nIGZ1bmN0aW9uOiBcIiArIHN0cik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiB1c2UgbGluZWFyLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1N0YWdlfSBzdGFnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgICAgICB0aGlzLm1hbmFnZXIgPSB0aGlzLnN0YWdlLnRleHR1cmVNYW5hZ2VyO1xuXG4gICAgICAgIHRoaXMuaWQgPSBUZXh0dXJlLmlkKys7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBlbmFibGVkIGVsZW1lbnRzIHRoYXQgdXNlIHRoaXMgdGV4dHVyZSBvYmplY3QgKGVpdGhlciBhcyB0ZXh0dXJlIG9yIGRpc3BsYXllZFRleHR1cmUpLlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEVsZW1lbnQ+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBlbmFibGVkIGVsZW1lbnRzIHRoYXQgYXJlIGFjdGl2ZS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjdGl2ZUNvdW50ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFzc29jaWF0ZWQgdGV4dHVyZSBzb3VyY2UuXG4gICAgICAgICAqIFNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgICAgICAgICogQHR5cGUge1RleHR1cmVTb3VyY2V9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlc2l6ZSBtb2RlIGNhbiBiZSBzZXQgdG8gY292ZXIgb3IgY29udGFpbiBhIGNlcnRhaW4gYXJlYS5cbiAgICAgICAgICogSXQgd2lsbCByZXNldCB0aGUgdGV4dHVyZSBjbGlwcGluZyBzZXR0aW5ncy5cbiAgICAgICAgICogV2hlbiBtYW51YWwgdGV4dHVyZSBjbGlwcGluZyBpcyBwZXJmb3JtZWQsIHRoZSByZXNpemVNb2RlIGlzIHJlc2V0LlxuICAgICAgICAgKiBAdHlwZSB7e3R5cGU6IHN0cmluZywgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcmVzaXplTW9kZSA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIGNsaXBwaW5nIHgtb2Zmc2V0LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5feCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIGNsaXBwaW5nIHktb2Zmc2V0LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5feSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIGNsaXBwaW5nIHdpZHRoLiBJZiAwIHRoZW4gZnVsbCB3aWR0aC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3cgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSBjbGlwcGluZyBoZWlnaHQuIElmIDAgdGhlbiBmdWxsIGhlaWdodC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ggPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgcHJlY2lzaW9uICgwLjUgPSBmdXp6eSwgMSA9IG5vcm1hbCwgMiA9IHNoYXJwIGV2ZW4gd2hlbiBzY2FsZWQgdHdpY2UsIGV0Yy4pLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gMTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIChtYXhpbXVtKSBleHBlY3RlZCB0ZXh0dXJlIHNvdXJjZSB3aWR0aC4gVXNlZCBmb3Igd2l0aGluIGJvdW5kcyBkZXRlcm1pbmF0aW9uIHdoaWxlIHRleHR1cmUgaXMgbm90IHlldCBsb2FkZWQuXG4gICAgICAgICAqIElmIG5vdCBzZXQsIDIwNDggaXMgdXNlZCBieSBFbGVtZW50Q29yZS51cGRhdGUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm13ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIChtYXhpbXVtKSBleHBlY3RlZCB0ZXh0dXJlIHNvdXJjZSBoZWlnaHQuIFVzZWQgZm9yIHdpdGhpbiBib3VuZHMgZGV0ZXJtaW5hdGlvbiB3aGlsZSB0ZXh0dXJlIGlzIG5vdCB5ZXQgbG9hZGVkLlxuICAgICAgICAgKiBJZiBub3Qgc2V0LCAyMDQ4IGlzIHVzZWQgYnkgRWxlbWVudENvcmUudXBkYXRlLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyBpZiBUZXh0dXJlLnByb3RvdHlwZS50ZXh0dXJlIHVzZXMgY2xpcHBpbmcuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGlwcGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRleHR1cmUgbXVzdCB1cGRhdGUgKHdoZW4gaXQgYmVjb21lcyB1c2VkIGFnYWluKS5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tdXN0VXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIGdldCBzb3VyY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tdXN0VXBkYXRlIHx8IHRoaXMuc3RhZ2UuaGFzVXBkYXRlU291cmNlVGV4dHVyZSh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNvdXJjZSh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UucmVtb3ZlVXBkYXRlU291cmNlVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlO1xuICAgIH1cblxuICAgIGFkZEVsZW1lbnQodikge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudHMuaGFzKHYpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmFkZCh2KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc291cmNlLmFkZFRleHR1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodi5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY0FjdGl2ZUNvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVFbGVtZW50KHYpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuZGVsZXRlKHYpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zb3VyY2UucmVtb3ZlVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjQWN0aXZlQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGluY0FjdGl2ZUNvdW50KCkge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0ZXh0dXJlIHNvdXJjZSdzIGFjdGl2ZUNvdW50IGhhcyB0cmFuc2ZlcnJlZCBvd25lcnNoaXAuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuXG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrRm9yTmV3ZXJSZXVzYWJsZVRleHR1cmVTb3VyY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FjdGl2ZUNvdW50Kys7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5iZWNvbWVzVXNlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVjQWN0aXZlQ291bnQoKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlOyAvLyBGb3JjZSB1cGRhdGluZyB0aGUgc291cmNlLlxuICAgICAgICB0aGlzLl9hY3RpdmVDb3VudC0tO1xuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmJlY29tZXNVbnVzZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlY29tZXNVc2VkKCkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlLmluY0FjdGl2ZVRleHR1cmVDb3VudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25Mb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVzaXplTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlSZXNpemVNb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9uVGV4dHVyZVNvdXJjZUxvYWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfY2hlY2tGb3JOZXdlclJldXNhYmxlVGV4dHVyZVNvdXJjZSgpIHtcbiAgICAgICAgLy8gV2hlbiB0aGlzIHNvdXJjZSBiZWNhbWUgdW51c2VkIGFuZCBjbGVhbmVkIHVwLCBpdCBtYXkgaGF2ZSBkaXNhcHBlYXJlZCBmcm9tIHRoZSByZXVzYWJsZSB0ZXh0dXJlIG1hcC5cbiAgICAgICAgLy8gSW4gdGhlIG1lYW50aW1lIGFub3RoZXIgdGV4dHVyZSBtYXkgaGF2ZSBiZWVuIGdlbmVyYXRlZCBsb2FkZWQgd2l0aCB0aGUgc2FtZSBsb29rdXAgaWQuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGNhc2UsIHVzZSB0aGF0IG9uZSBpbnN0ZWFkIHRvIG1ha2Ugc3VyZSBvbmx5IG9uZSBhY3RpdmUgdGV4dHVyZSBzb3VyY2UgcGVyIGxvb2t1cCBpZCBleGlzdHMuXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoIXNvdXJjZS5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCByZXVzYWJsZSA9IHRoaXMuX2dldFJldXNhYmxlVGV4dHVyZVNvdXJjZSgpO1xuICAgICAgICAgICAgaWYgKHJldXNhYmxlICYmIHJldXNhYmxlLmlzTG9hZGVkKCkgJiYgKHJldXNhYmxlICE9PSBzb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVwbGFjZVRleHR1cmVTb3VyY2UocmV1c2FibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVJlc2l6ZU1vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJlY29tZXNVbnVzZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UuZGVjQWN0aXZlVGV4dHVyZUNvdW50KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1VzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVDb3VudCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9va3VwIGlkIGZvciB0aGUgY3VycmVudCB0ZXh0dXJlIHNldHRpbmdzLCB0byBiZSBhYmxlIHRvIHJldXNlIGl0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICBfZ2V0TG9va3VwSWQoKSB7XG4gICAgICAgIC8vIERlZmF1bHQ6IGRvIG5vdCByZXVzZSB0ZXh0dXJlLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBsb2FkZXIgZnVuY3Rpb24gdGhhdCBpcyBhYmxlIHRvIGdlbmVyYXRlIHRoZSB0ZXh0dXJlIGZvciB0aGUgY3VycmVudCBzZXR0aW5ncyBvZiB0aGlzIHRleHR1cmUuXG4gICAgICogSXQgc2hvdWxkIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBzaW5nbGUgY2FsbGJhY2sgYXJndW1lbnQuXG4gICAgICogVGhhdCBjYWxsYmFjayBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XG4gICAgICogICAtIGVyclxuICAgICAqICAgLSBvcHRpb25zOiBvYmplY3RcbiAgICAgKiAgICAgLSBzb3VyY2U6IEFycmF5QnVmZmVyfFdlYkdsVGV4dHVyZXxJbWFnZURhdGF8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fEltYWdlQml0bWFwXG4gICAgICogICAgIC0gdzogTnVtYmVyXG4gICAgICogICAgIC0gaDogTnVtYmVyXG4gICAgICogICAgIC0gcGVybWFuZW50OiBCb29sZWFuXG4gICAgICogICAgIC0gaGFzQWxwaGE6IGJvb2xlYW5cbiAgICAgKiAgICAgLSBwZXJtdWx0aXBseUFscGhhOiBib29sZWFuXG4gICAgICogICAgIC0gZmxpcEJsdWVSZWQ6IGJvb2xlYW5cbiAgICAgKiAgICAgLSByZW5kZXJJbmZvOiBvYmplY3RcbiAgICAgKiBUaGUgbG9hZGVyIGl0c2VsZiBtYXkgcmV0dXJuIGEgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBsb2FkaW5nIG9mIHRoZSB0ZXh0dXJlIGlzIGNhbmNlbGxlZC4gVGhpcyBjYW4gYmUgdXNlZFxuICAgICAqIHRvIHN0b3AgZmV0Y2hpbmcgYW4gaW1hZ2Ugd2hlbiBpdCBpcyBubyBsb25nZXIgaW4gZWxlbWVudCwgZm9yIGV4YW1wbGUuXG4gICAgICovXG4gICAgX2dldFNvdXJjZUxvYWRlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGV4dHVyZS5nZW5lcmF0ZSBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgICB9XG5cbiAgICBnZXQgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldElzVmFsaWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0ZXh0dXJlIGlzIG5vdCAndmFsaWQnLCBubyBzb3VyY2UgY2FuIGJlIGNyZWF0ZWQgZm9yIGl0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIF9nZXRJc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG11c3QgYmUgY2FsbGVkIHdoZW4gdGhlIHRleHR1cmUgc291cmNlIG11c3QgYmUgcmUtZ2VuZXJhdGVkLlxuICAgICAqL1xuICAgIF9jaGFuZ2VkKCkge1xuICAgICAgICAvLyBJZiBubyBlbGVtZW50IGlzIGFjdGl2ZWx5IHVzaW5nIHRoaXMgdGV4dHVyZSwgaWdub3JlIGl0IGFsdG9nZXRoZXIuXG4gICAgICAgIGlmICh0aGlzLmlzVXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTb3VyY2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX211c3RVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZVNvdXJjZSgpIHtcbiAgICAgICAgLy8gV2UgZGVsYXkgYWxsIHVwZGF0ZVNvdXJjZSBjYWxscyB0byB0aGUgbmV4dCBkcmF3RnJhbWUsIHNvIHRoYXQgd2UgY2FuIGJ1bmRsZSB0aGVtLlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgbWF5IHJlbG9hZCBhIHRleHR1cmUgbW9yZSBvZnRlbiB0aGFuIG5lY2Vzc2FyeSwgd2hlbiwgZm9yIGV4YW1wbGUsIHBhdGNoaW5nIG11bHRpcGxlIHRleHRcbiAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgdGhpcy5zdGFnZS5hZGRVcGRhdGVTb3VyY2VUZXh0dXJlKHRoaXMpO1xuICAgIH1cblxuICAgIF9wZXJmb3JtVXBkYXRlU291cmNlKGZvcmNlID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSWYsIGluIHRoZSBtZWFudGltZSwgdGhlIHRleHR1cmUgd2FzIG5vIGxvbmdlciB1c2VkLCBqdXN0IHJlbWVtYmVyIHRoYXQgaXQgbXVzdCB1cGRhdGUgdW50aWwgaXQgYmVjb21lcyB1c2VkXG4gICAgICAgIC8vIGFnYWluLlxuICAgICAgICBpZiAoZm9yY2UgfHwgdGhpcy5pc1VzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fbXVzdFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMuX2dldFRleHR1cmVTb3VyY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VUZXh0dXJlU291cmNlKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0VGV4dHVyZVNvdXJjZSgpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9nZXRJc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvb2t1cElkID0gdGhpcy5fZ2V0TG9va3VwSWQoKTtcbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX2dldFJldXNhYmxlVGV4dHVyZVNvdXJjZShsb29rdXBJZCk7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMubWFuYWdlci5nZXRUZXh0dXJlU291cmNlKHRoaXMuX2dldFNvdXJjZUxvYWRlcigpLCBsb29rdXBJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG5cbiAgICBfZ2V0UmV1c2FibGVUZXh0dXJlU291cmNlKGxvb2t1cElkID0gdGhpcy5fZ2V0TG9va3VwSWQoKSkge1xuICAgICAgICBpZiAodGhpcy5fZ2V0SXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBpZiAobG9va3VwSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyLmdldFJldXNhYmxlVGV4dHVyZVNvdXJjZShsb29rdXBJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgX3JlcGxhY2VUZXh0dXJlU291cmNlKG5ld1NvdXJjZSA9IG51bGwpIHtcbiAgICAgICAgbGV0IG9sZFNvdXJjZSA9IHRoaXMuX3NvdXJjZTtcblxuICAgICAgICB0aGlzLl9zb3VyY2UgPSBuZXdTb3VyY2U7XG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuc2l6ZSkge1xuICAgICAgICAgICAgaWYgKG9sZFNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRTb3VyY2UuZGVjQWN0aXZlVGV4dHVyZUNvdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2xkU291cmNlLnJlbW92ZVRleHR1cmUodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBNdXN0IGhhcHBlbiBiZWZvcmUgc2V0RGlzcGxheWVkVGV4dHVyZSB0byBlbnN1cmUgc3ByaXRlIG1hcCB0ZXhjb29yZHMgYXJlIHVzZWQuXG4gICAgICAgICAgICAgICAgbmV3U291cmNlLmFkZFRleHR1cmUodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1NvdXJjZS5pbmNBY3RpdmVUZXh0dXJlQ291bnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1VzZWQoKSkge1xuICAgICAgICAgICAgaWYgKG5ld1NvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTb3VyY2UuaXNMb2FkZWQoKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHJlc2l6ZU1vZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVzaXplTW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5fc2V0RGlzcGxheWVkVGV4dHVyZSh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9hZEVycm9yID0gbmV3U291cmNlLmxvYWRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uVGV4dHVyZVNvdXJjZUxvYWRFcnJvcihsb2FkRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5fc2V0RGlzcGxheWVkVGV4dHVyZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZCgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgc291cmNlIGlzIHVwIHRvIGRhdGUuXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZS5sb2FkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNMb2FkZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLmlzTG9hZGVkKCk7XG4gICAgfVxuXG4gICAgZ2V0IGxvYWRFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSAmJiB0aGlzLl9zb3VyY2UubG9hZEVycm9yO1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZS5mcmVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXQgcmVzaXplTW9kZSh7dHlwZSA9IFwiY292ZXJcIiwgdyA9IDAsIGggPSAwLCBjbGlwWCA9IDAuNSwgY2xpcFkgPSAwLjV9KSB7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZU1vZGUgPSB7dHlwZSwgdywgaCwgY2xpcFgsIGNsaXBZfTtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlSZXNpemVNb2RlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcmVzaXplTW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc2l6ZU1vZGU7XG4gICAgfVxuXG4gICAgX2NsZWFyUmVzaXplTW9kZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplTW9kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgX2FwcGx5UmVzaXplTW9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU1vZGUudHlwZSA9PT0gXCJjb3ZlclwiKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseVJlc2l6ZUNvdmVyKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcmVzaXplTW9kZS50eXBlID09PSBcImNvbnRhaW5cIikge1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlSZXNpemVDb250YWluKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlUHJlY2lzaW9uKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsaXBwaW5nKCk7XG4gICAgfVxuXG4gICAgX2FwcGx5UmVzaXplQ292ZXIoKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlWCA9IHRoaXMuX3Jlc2l6ZU1vZGUudyAvIHRoaXMuX3NvdXJjZS53O1xuICAgICAgICBjb25zdCBzY2FsZVkgPSB0aGlzLl9yZXNpemVNb2RlLmggLyB0aGlzLl9zb3VyY2UuaDtcbiAgICAgICAgbGV0IHNjYWxlID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICBpZiAoIXNjYWxlKSByZXR1cm47XG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IDEvc2NhbGU7XG4gICAgICAgIGlmIChzY2FsZVggJiYgc2NhbGVYIDwgc2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gdGhpcy5fcHJlY2lzaW9uICogdGhpcy5fcmVzaXplTW9kZS53O1xuICAgICAgICAgICAgY29uc3QgY2hvcHBlZE9mZlBpeGVscyA9IHRoaXMuX3NvdXJjZS53IC0gZGVzaXJlZFNpemU7XG4gICAgICAgICAgICB0aGlzLl94ID0gY2hvcHBlZE9mZlBpeGVscyAqIHRoaXMuX3Jlc2l6ZU1vZGUuY2xpcFg7XG4gICAgICAgICAgICB0aGlzLl93ID0gdGhpcy5fc291cmNlLncgLSBjaG9wcGVkT2ZmUGl4ZWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FsZVkgJiYgc2NhbGVZIDwgc2NhbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gdGhpcy5fcHJlY2lzaW9uICogdGhpcy5fcmVzaXplTW9kZS5oO1xuICAgICAgICAgICAgY29uc3QgY2hvcHBlZE9mZlBpeGVscyA9IHRoaXMuX3NvdXJjZS5oIC0gZGVzaXJlZFNpemU7XG4gICAgICAgICAgICB0aGlzLl95ID0gY2hvcHBlZE9mZlBpeGVscyAqIHRoaXMuX3Jlc2l6ZU1vZGUuY2xpcFk7XG4gICAgICAgICAgICB0aGlzLl9oID0gdGhpcy5fc291cmNlLmggLSBjaG9wcGVkT2ZmUGl4ZWxzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FwcGx5UmVzaXplQ29udGFpbigpIHtcbiAgICAgICAgY29uc3Qgc2NhbGVYID0gdGhpcy5fcmVzaXplTW9kZS53IC8gdGhpcy5fc291cmNlLnc7XG4gICAgICAgIGNvbnN0IHNjYWxlWSA9IHRoaXMuX3Jlc2l6ZU1vZGUuaCAvIHRoaXMuX3NvdXJjZS5oO1xuICAgICAgICBsZXQgc2NhbGUgPSBzY2FsZVg7XG4gICAgICAgIGlmICghc2NhbGUgfHwgc2NhbGVZIDwgc2NhbGUpIHtcbiAgICAgICAgICAgIHNjYWxlID0gc2NhbGVZO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2NhbGUpIHJldHVybjtcbiAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gMS9zY2FsZTtcbiAgICB9XG5cbiAgICBlbmFibGVDbGlwcGluZyh4LCB5LCB3LCBoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzaXplTW9kZSgpO1xuXG4gICAgICAgIHggKj0gdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICB5ICo9IHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgdyAqPSB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIGggKj0gdGhpcy5fcHJlY2lzaW9uO1xuICAgICAgICBpZiAodGhpcy5feCAhPT0geCB8fCB0aGlzLl95ICE9PSB5IHx8IHRoaXMuX3cgIT09IHcgfHwgdGhpcy5faCAhPT0gaCkge1xuICAgICAgICAgICAgdGhpcy5feCA9IHg7XG4gICAgICAgICAgICB0aGlzLl95ID0geTtcbiAgICAgICAgICAgIHRoaXMuX3cgPSB3O1xuICAgICAgICAgICAgdGhpcy5faCA9IGg7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXBwaW5nKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZUNsaXBwaW5nKCkge1xuICAgICAgICB0aGlzLl9jbGVhclJlc2l6ZU1vZGUoKTtcblxuICAgICAgICBpZiAodGhpcy5feCB8fCB0aGlzLl95IHx8IHRoaXMuX3cgfHwgdGhpcy5faCkge1xuICAgICAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgICAgICB0aGlzLl95ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3cgPSAwO1xuICAgICAgICAgICAgdGhpcy5faCA9IDA7XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlQ2xpcHBpbmcoKSB7XG4gICAgICAgIHRoaXMuY2xpcHBpbmcgPSAhISh0aGlzLl94IHx8IHRoaXMuX3kgfHwgdGhpcy5fdyB8fCB0aGlzLl9oKTtcblxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgaWYgbm90IHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIHRleHR1cmUuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5kaXNwbGF5ZWRUZXh0dXJlID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5vbkRpc3BsYXllZFRleHR1cmVDbGlwcGluZ0NoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZVByZWNpc2lvbigpIHtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGlmIG5vdCB0aGUgY3VycmVudGx5IGRpc3BsYXllZCB0ZXh0dXJlLlxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuZGlzcGxheWVkVGV4dHVyZSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQub25QcmVjaXNpb25DaGFuZ2VkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldE5vbkRlZmF1bHRzKCkge1xuICAgICAgICBsZXQgbm9uRGVmYXVsdHMgPSB7fTtcbiAgICAgICAgbm9uRGVmYXVsdHNbJ3R5cGUnXSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKHRoaXMueCAhPT0gMCkgbm9uRGVmYXVsdHNbJ3gnXSA9IHRoaXMueDtcbiAgICAgICAgaWYgKHRoaXMueSAhPT0gMCkgbm9uRGVmYXVsdHNbJ3knXSA9IHRoaXMueTtcbiAgICAgICAgaWYgKHRoaXMudyAhPT0gMCkgbm9uRGVmYXVsdHNbJ3cnXSA9IHRoaXMudztcbiAgICAgICAgaWYgKHRoaXMuaCAhPT0gMCkgbm9uRGVmYXVsdHNbJ2gnXSA9IHRoaXMuaDtcbiAgICAgICAgaWYgKHRoaXMucHJlY2lzaW9uICE9PSAxKSBub25EZWZhdWx0c1sncHJlY2lzaW9uJ10gPSB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgcmV0dXJuIG5vbkRlZmF1bHRzO1xuICAgIH1cblxuICAgIGdldCBweCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfVxuXG4gICAgZ2V0IHB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9XG5cbiAgICBnZXQgcHcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93O1xuICAgIH1cblxuICAgIGdldCBwaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgfVxuXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94IC8gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH1cbiAgICBzZXQgeCh2KSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzaXplTW9kZSgpO1xuICAgICAgICB2ID0gdiAqIHRoaXMuX3ByZWNpc2lvbjtcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ2xpcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feSAvIHRoaXMuX3ByZWNpc2lvbjtcbiAgICB9XG4gICAgc2V0IHkodikge1xuICAgICAgICB0aGlzLl9jbGVhclJlc2l6ZU1vZGUoKTtcbiAgICAgICAgdiA9IHYgKiB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIGlmICh0aGlzLl95ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl95ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3cgLyB0aGlzLl9wcmVjaXNpb247XG4gICAgfVxuXG4gICAgc2V0IHcodikge1xuICAgICAgICB0aGlzLl9jbGVhclJlc2l6ZU1vZGUoKTtcbiAgICAgICAgdiA9IHYgKiB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIGlmICh0aGlzLl93ICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl93ID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ggLyB0aGlzLl9wcmVjaXNpb247XG4gICAgfVxuXG4gICAgc2V0IGgodikge1xuICAgICAgICB0aGlzLl9jbGVhclJlc2l6ZU1vZGUoKTtcbiAgICAgICAgdiA9IHYgKiB0aGlzLl9wcmVjaXNpb247XG4gICAgICAgIGlmICh0aGlzLl9oICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9oID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcHJlY2lzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJlY2lzaW9uO1xuICAgIH1cblxuICAgIHNldCBwcmVjaXNpb24odikge1xuICAgICAgICB0aGlzLl9jbGVhclJlc2l6ZU1vZGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3ByZWNpc2lvbiAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fcHJlY2lzaW9uID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByZWNpc2lvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNBdXRvc2l6ZVRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGdldFJlbmRlcldpZHRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBdXRvc2l6ZVRleHR1cmUoKSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiB0aGUgcmVjdGFuZ2xlIHRleHR1cmUsIHdlJ2QgcHJlZmVyIHRvIG5vdCBjYXVzZSBhIDF4MSB3LGggYXMgaXQgd291bGQgaW50ZXJmZXJlIHdpdGggZmxleCBsYXlvdXQgZml0LXRvLWNvbnRlbnRzLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBkaW1lbnNpb25zIGFyZSB1bmtub3duICh0ZXh0dXJlIG5vdCB5ZXQgbG9hZGVkKSwgdXNlIG1heGltdW0gd2lkdGggYXMgYSBmYWxsYmFjayBhcyByZW5kZXIgd2lkdGggdG8gYWxsb3cgcHJvcGVyIGJvdW5kcyBjaGVja2luZy5cbiAgICAgICAgcmV0dXJuICh0aGlzLl93IHx8ICh0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UuZ2V0UmVuZGVyV2lkdGgoKSAtIHRoaXMuX3ggOiAwKSkgLyB0aGlzLl9wcmVjaXNpb247XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVySGVpZ2h0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBdXRvc2l6ZVRleHR1cmUoKSkge1xuICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiB0aGUgcmVjdGFuZ2xlIHRleHR1cmUsIHdlJ2QgcHJlZmVyIHRvIG5vdCBjYXVzZSBhIDF4MSB3LGggYXMgaXQgd291bGQgaW50ZXJmZXJlIHdpdGggZmxleCBsYXlvdXQgZml0LXRvLWNvbnRlbnRzLlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHRoaXMuX2ggfHwgKHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5nZXRSZW5kZXJIZWlnaHQoKSAtIHRoaXMuX3kgOiAwKSkgLyB0aGlzLl9wcmVjaXNpb247XG4gICAgfVxuXG4gICAgcGF0Y2goc2V0dGluZ3MpIHtcbiAgICAgICAgQmFzZS5wYXRjaE9iamVjdCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgfVxuXG59XG5cblRleHR1cmUucHJvdG90eXBlLmlzVGV4dHVyZSA9IHRydWU7XG5cblRleHR1cmUuaWQgPSAwO1xuXG5pbXBvcnQgQmFzZSBmcm9tIFwiLi9CYXNlLm1qc1wiO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IFRleHR1cmVTb3VyY2UgZnJvbSBcIi4vVGV4dHVyZVNvdXJjZS5tanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZU1hbmFnZXIge1xuXG4gICAgY29uc3RydWN0b3Ioc3RhZ2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZSA9IHN0YWdlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHVzZWQgYW1vdW50IG9mIHRleHR1cmUgbWVtb3J5LlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCB1cGxvYWRlZCB0ZXh0dXJlIHNvdXJjZXMuXG4gICAgICAgICAqIEB0eXBlIHtUZXh0dXJlU291cmNlW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIHNvdXJjZSBsb29rdXAgaWQgdG8gdGV4dHVyZSBzb3VyY2UgaGFzaG1hcC5cbiAgICAgICAgICogQHR5cGUge01hcDxTdHJpbmcsIFRleHR1cmVTb3VyY2U+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcCA9IG5ldyBNYXAoKTtcblxuICAgIH1cblxuICAgIGdldCB1c2VkTWVtb3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXNlZE1lbW9yeTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVGcmVlVGV4dHVyZVNvdXJjZSh0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy50ZXh0dXJlU291cmNlSGFzaG1hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ID0gMDtcbiAgICB9XG5cbiAgICBnZXRSZXVzYWJsZVRleHR1cmVTb3VyY2UoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuZ2V0KGlkKTtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlU291cmNlKGZ1bmMsIGlkKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRleHR1cmUgc291cmNlIGlzIGFscmVhZHkga25vd24uXG4gICAgICAgIGxldCB0ZXh0dXJlU291cmNlID0gaWQgPyB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLmdldChpZCkgOiBudWxsO1xuICAgICAgICBpZiAoIXRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgdGV4dHVyZSBzb3VyY2UuXG4gICAgICAgICAgICB0ZXh0dXJlU291cmNlID0gbmV3IFRleHR1cmVTb3VyY2UodGhpcywgZnVuYyk7XG5cbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIHRleHR1cmVTb3VyY2UubG9va3VwSWQgPSBpZDtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLnNldChpZCwgdGV4dHVyZVNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4dHVyZVNvdXJjZTtcbiAgICB9XG5cbiAgICB1cGxvYWRUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRleHR1cmVTb3VyY2UuaXNMb2FkZWQoKSkgcmV0dXJuO1xuXG4gICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKHRleHR1cmVTb3VyY2UudyAqIHRleHR1cmVTb3VyY2UuaCk7XG5cbiAgICAgICAgLy8gTG9hZCB0ZXh0dXJlLlxuICAgICAgICBjb25zdCBuYXRpdmVUZXh0dXJlID0gdGhpcy5fbmF0aXZlVXBsb2FkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlLCBvcHRpb25zKTtcblxuICAgICAgICB0ZXh0dXJlU291cmNlLl9uYXRpdmVUZXh0dXJlID0gbmF0aXZlVGV4dHVyZTtcblxuICAgICAgICAvLyBXZSBhdHRhY2ggdyBhbmQgaCB0byBuYXRpdmUgdGV4dHVyZSAod2UgbmVlZCBpdCBpbiBDb3JlUmVuZGVyU3RhdGUuX2lzUmVuZGVyVGV4dHVyZVJldXNhYmxlKS5cbiAgICAgICAgbmF0aXZlVGV4dHVyZS53ID0gdGV4dHVyZVNvdXJjZS53O1xuICAgICAgICBuYXRpdmVUZXh0dXJlLmggPSB0ZXh0dXJlU291cmNlLmg7XG5cbiAgICAgICAgbmF0aXZlVGV4dHVyZS51cGRhdGUgPSB0aGlzLnN0YWdlLmZyYW1lQ291bnRlcjtcblxuICAgICAgICB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzLnB1c2godGV4dHVyZVNvdXJjZSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmFkZFRvTG9va3VwTWFwKHRleHR1cmVTb3VyY2UpO1xuICAgIH1cblxuICAgIF9hZGRNZW1vcnlVc2FnZShkZWx0YSkge1xuICAgICAgICB0aGlzLl91c2VkTWVtb3J5ICs9IGRlbHRhO1xuICAgICAgICB0aGlzLnN0YWdlLmFkZE1lbW9yeVVzYWdlKGRlbHRhKTtcbiAgICB9XG4gICAgXG4gICAgYWRkVG9Mb29rdXBNYXAodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICBjb25zdCBsb29rdXBJZCA9IHRleHR1cmVTb3VyY2UubG9va3VwSWQ7XG4gICAgICAgIGlmIChsb29rdXBJZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLmhhcyhsb29rdXBJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVTb3VyY2VIYXNobWFwLnNldChsb29rdXBJZCwgdGV4dHVyZVNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnYygpIHtcbiAgICAgICAgdGhpcy5mcmVlVW51c2VkVGV4dHVyZVNvdXJjZXMoKTtcbiAgICAgICAgdGhpcy5fY2xlYW51cExvb2t1cE1hcCgpO1xuICAgIH1cbiAgICBcbiAgICBmcmVlVW51c2VkVGV4dHVyZVNvdXJjZXMoKSB7XG4gICAgICAgIGxldCByZW1haW5pbmdUZXh0dXJlU291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdHMgPSB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzW2ldO1xuICAgICAgICAgICAgaWYgKHRzLmFsbG93Q2xlYW51cCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlZU1hbmFnZWRUZXh0dXJlU291cmNlKHRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtYWluaW5nVGV4dHVyZVNvdXJjZXMucHVzaCh0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGxvYWRlZFRleHR1cmVTb3VyY2VzID0gcmVtYWluaW5nVGV4dHVyZVNvdXJjZXM7XG5cbiAgICAgICAgdGhpcy5fY2xlYW51cExvb2t1cE1hcCgpO1xuICAgIH1cblxuICAgIF9mcmVlTWFuYWdlZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICBpZiAodGV4dHVyZVNvdXJjZS5pc0xvYWRlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVGcmVlVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKC10ZXh0dXJlU291cmNlLncgKiB0ZXh0dXJlU291cmNlLmgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2hvdWxkIGJlIHJlbG9hZGVkLlxuICAgICAgICB0ZXh0dXJlU291cmNlLmxvYWRpbmdTaW5jZSA9IG51bGw7XG4gICAgfVxuXG4gICAgX2NsZWFudXBMb29rdXBNYXAoKSB7XG4gICAgICAgIC8vIFdlIGtlZXAgdGhvc2UgdGhhdCBzdGlsbCBoYXZlIHZhbHVlIChhcmUgYmVpbmcgbG9hZGVkIG9yIGFscmVhZHkgbG9hZGVkLCBvciBhcmUgbGlrZWx5IHRvIGJlIHJldXNlZCkuXG4gICAgICAgIHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuZm9yRWFjaCgodGV4dHVyZVNvdXJjZSwgbG9va3VwSWQpID0+IHtcbiAgICAgICAgICAgIGlmICghKHRleHR1cmVTb3VyY2UuaXNMb2FkZWQoKSB8fCB0ZXh0dXJlU291cmNlLmlzTG9hZGluZygpKSAmJiAhdGV4dHVyZVNvdXJjZS5pc1VzZWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZVNvdXJjZUhhc2htYXAuZGVsZXRlKGxvb2t1cElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXh0ZXJuYWxseSBmcmVlIHRleHR1cmUgc291cmNlLlxuICAgICAqIEBwYXJhbSB0ZXh0dXJlU291cmNlXG4gICAgICovXG4gICAgZnJlZVRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3VwbG9hZGVkVGV4dHVyZVNvdXJjZXMuaW5kZXhPZih0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgY29uc3QgbWFuYWdlZCA9IChpbmRleCAhPT0gLTEpO1xuXG4gICAgICAgIGlmICh0ZXh0dXJlU291cmNlLmlzTG9hZGVkKCkpIHtcbiAgICAgICAgICAgIGlmIChtYW5hZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkTWVtb3J5VXNhZ2UoLXRleHR1cmVTb3VyY2UudyAqIHRleHR1cmVTb3VyY2UuaCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkZWRUZXh0dXJlU291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRnJlZVRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaG91bGQgYmUgcmVsb2FkZWQuXG4gICAgICAgIHRleHR1cmVTb3VyY2UubG9hZGluZ1NpbmNlID0gbnVsbDtcbiAgICB9XG5cbiAgICBfbmF0aXZlVXBsb2FkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWdlLnJlbmRlcmVyLnVwbG9hZFRleHR1cmVTb3VyY2UodGV4dHVyZVNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgX25hdGl2ZUZyZWVUZXh0dXJlU291cmNlKHRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdGFnZS5yZW5kZXJlci5mcmVlVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKTtcbiAgICAgICAgdGV4dHVyZVNvdXJjZS5jbGVhck5hdGl2ZVRleHR1cmUoKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVTb3VyY2Uge1xuXG4gICAgY29uc3RydWN0b3IobWFuYWdlciwgbG9hZGVyID0gbnVsbCkge1xuICAgICAgICB0aGlzLmlkID0gVGV4dHVyZVNvdXJjZS5pZCsrO1xuXG4gICAgICAgIHRoaXMubWFuYWdlciA9IG1hbmFnZXI7XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IG1hbmFnZXIuc3RhZ2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBlbmFibGVkIHRleHR1cmVzICh0ZXh0dXJlcyB0aGF0IGFyZSB1c2VkIGJ5IHZpc2libGUgZWxlbWVudHMpLlxuICAgICAgICAgKiBAdHlwZSB7U2V0PFRleHR1cmU+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBhY3RpdmUgdGV4dHVyZXMgKHRleHR1cmVzIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmUgYWN0aXZlIGVsZW1lbnQpLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWN0aXZlVGV4dHVyZUNvdW50ID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZhY3RvcnkgZm9yIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllciBmb3IgcmV1c2UuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxvb2t1cElkID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0LCB0aGlzLmlzIGNhbGxlZCB3aGVuIHRoZSB0ZXh0dXJlIHNvdXJjZSBpcyBubyBsb25nZXIgZGlzcGxheWVkICh0aGlzLmNvbXBvbmVudHMuc2l6ZSBiZWNvbWVzIDApLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYW5jZWxDYiA9IG51bGw7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWRpbmcgc2luY2UgdGltZXN0YW1wIGluIG1pbGxpcy5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9hZGluZ1NpbmNlID0gMDtcblxuICAgICAgICB0aGlzLncgPSAwO1xuICAgICAgICB0aGlzLmggPSAwO1xuXG4gICAgICAgIHRoaXMuX25hdGl2ZVRleHR1cmUgPSBudWxsO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCB0aGVuIHRoaXMudGV4dHVyZSBzb3VyY2UgaXMgbmV2ZXIgZnJlZWQgZnJvbSBtZW1vcnkgZHVyaW5nIGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlcm1hbmVudCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWItb2JqZWN0IHdpdGggdGV4dHVyZS1zcGVjaWZpYyByZW5kZXJpbmcgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEZvciBpbWFnZXMsIGNvbnRhaW5zIHRoZSBzcmMgcHJvcGVydHksIGZvciB0ZXh0cywgY29udGFpbnMgaGFuZHkgcmVuZGVyaW5nIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJJbmZvID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVkIGZvciAncmVuZGVyVG9UZXh0dXJlJy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pc1Jlc3VsdFRleHR1cmUgPSAhdGhpcy5sb2FkZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRhaW5zIHRoZSBsb2FkIGVycm9yLCBpZiB0aGUgdGV4dHVyZSBzb3VyY2UgY291bGQgcHJldmlvdXNseSBub3QgYmUgbG9hZGVkLlxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZEVycm9yID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogIEhvbGQgYSByZWZlcmVuY2UgdG8gdGhlIGphdmFzY3JpcHQgdmFyaWFibGUgd2hpY2ggY29udGFpbnMgdGhlIHRleHR1cmUsIHRoaXMgaXMgbm90IHJlcXVpcmVkIGZvciBXZWJHTCBpbiBXZWJCcm93c2VycyBidXQgaXMgcmVxdWlyZWQgZm9yIFNwYXJrIHJ1bnRpbWUuXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbWFnZVJlZiA9IG51bGw7XG5cbiAgICB9XG5cbiAgICBnZXQgbG9hZEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZEVycm9yO1xuICAgIH1cblxuICAgIGFkZFRleHR1cmUodikge1xuICAgICAgICBpZiAoIXRoaXMudGV4dHVyZXMuaGFzKHYpKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzLmFkZCh2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZVRleHR1cmUodikge1xuICAgICAgICB0aGlzLnRleHR1cmVzLmRlbGV0ZSh2KTtcbiAgICB9XG5cbiAgICBpbmNBY3RpdmVUZXh0dXJlQ291bnQoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVGV4dHVyZUNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmJlY29tZXNVc2VkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNBY3RpdmVUZXh0dXJlQ291bnQoKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZVRleHR1cmVDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVGV4dHVyZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmJlY29tZXNVbnVzZWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBpc1Jlc3VsdFRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1Jlc3VsdFRleHR1cmU7XG4gICAgfVxuXG4gICAgc2V0IGlzUmVzdWx0VGV4dHVyZSh2KSB7XG4gICAgICAgIHRoaXMuX2lzUmVzdWx0VGV4dHVyZSA9IHY7XG4gICAgfVxuXG4gICAgZm9yRWFjaEVuYWJsZWRFbGVtZW50KGNiKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCh0ZXh0dXJlID0+IHtcbiAgICAgICAgICAgIHRleHR1cmUuZWxlbWVudHMuZm9yRWFjaChjYik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhhc0VuYWJsZWRFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZXMuc2l6ZSA+IDA7XG4gICAgfVxuXG4gICAgZm9yRWFjaEFjdGl2ZUVsZW1lbnQoY2IpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuICAgICAgICAgICAgdGV4dHVyZS5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnc7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVySGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oO1xuICAgIH1cblxuICAgIGFsbG93Q2xlYW51cCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnBlcm1hbmVudCAmJiAhdGhpcy5pc1VzZWQoKTtcbiAgICB9XG5cbiAgICBiZWNvbWVzVXNlZCgpIHtcbiAgICAgICAgLy8gRXZlbiB3aGlsZSB0aGUgdGV4dHVyZSBpcyBiZWluZyBsb2FkZWQsIG1ha2Ugc3VyZSBpdCBpcyBvbiB0aGUgbG9va3VwIG1hcCBzbyB0aGF0IG90aGVycyBjYW4gcmV1c2UgaXQuXG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cblxuICAgIGJlY29tZXNVbnVzZWQoKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuXG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbmNlbENiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ2IodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhciBjYWxsYmFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MuXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ2IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU2luY2UgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNMb2FkZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX25hdGl2ZVRleHR1cmU7XG4gICAgfVxuXG4gICAgaXNMb2FkaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG9hZGluZ1NpbmNlID4gMCk7XG4gICAgfVxuXG4gICAgaXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fbG9hZEVycm9yO1xuICAgIH1cblxuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgdGhpcy5mcmVlKCk7XG4gICAgICAgIGlmICh0aGlzLmlzVXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWQoZm9yY2VTeW5jID0gZmFsc2UpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgbW9tZW50IG9mIGxvYWRpbmcgKHdoZW4gYSB0ZXh0dXJlIHNvdXJjZSBiZWNvbWVzIHVzZWQgYnkgYWN0aXZlIGVsZW1lbnRzKVxuICAgICAgICBpZiAodGhpcy5pc1Jlc3VsdFRleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIEVsZW1lbnQgcmVzdWx0IHRleHR1cmUgc291cmNlLCBmb3Igd2hpY2ggdGhlIGxvYWRpbmcgaXMgbWFuYWdlZCBieSB0aGUgY29yZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbmF0aXZlVGV4dHVyZSAmJiAhdGhpcy5pc0xvYWRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU2luY2UgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ2IgPSB0aGlzLmxvYWRlcigoZXJyLCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGxvYWRzIHRoYXQgY29tZSBpbiBhZnRlciBhIGNhbmNlbC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciBjYWxsYmFjayB0byBhdm9pZCBtZW1vcnkgbGVha3MuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbENiID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnN0YWdlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFzeW5jIGxvYWQgd2hlbiBzdGFnZSBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCB0eEVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YWdlLmlzVXBkYXRpbmdGcmFtZSgpICYmICFmb3JjZVN5bmMgJiYgKG9wdGlvbnMudGhyb3R0bGUgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVUaHJvdHRsZXIgPSB0aGlzLnN0YWdlLnRleHR1cmVUaHJvdHRsZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsQ2IgPSB0ZXh0dXJlVGhyb3R0bGVyLmdlbmVyaWNDYW5jZWxDYjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlVGhyb3R0bGVyLmFkZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTG9hZGVkU291cmNlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzTG9hZGVkU291cmNlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2FkaW5nU2luY2UgPSAwO1xuICAgICAgICB0aGlzLnNldFNvdXJjZShvcHRpb25zKTtcbiAgICB9XG5cbiAgICBzZXRTb3VyY2Uob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZTtcblxuICAgICAgICB0aGlzLncgPSBzb3VyY2Uud2lkdGggfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy53KSB8fCAwO1xuICAgICAgICB0aGlzLmggPSBzb3VyY2UuaGVpZ2h0IHx8IChvcHRpb25zICYmIG9wdGlvbnMuaCkgfHwgMDtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlbmRlckluZm8pIHtcbiAgICAgICAgICAgIC8vIEFzc2lnbiB0byBpZCBpbiBjYWNoZSBzbyB0aGF0IGl0IGNhbiBiZSByZXVzZWQuXG4gICAgICAgICAgICB0aGlzLnJlbmRlckluZm8gPSBvcHRpb25zLnJlbmRlckluZm87XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBlcm1hbmVudCA9ICEhb3B0aW9ucy5wZXJtYW5lbnQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVJlZilcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlUmVmID0gb3B0aW9ucy5pbWFnZVJlZjtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGlwVGV4dHVyZVkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsaXBUZXh0dXJlWSA9IG9wdGlvbnMuZmxpcFRleHR1cmVZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZmxpcFRleHR1cmVZID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faXNOYXRpdmVUZXh0dXJlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIC8vIFRleHR1cmUgbWFuYWdlZCBieSBjYWxsZXIuXG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVUZXh0dXJlID0gc291cmNlO1xuXG4gICAgICAgICAgICB0aGlzLncgPSB0aGlzLncgfHwgc291cmNlLnc7XG4gICAgICAgICAgICB0aGlzLmggPSB0aGlzLmggfHwgc291cmNlLmg7XG5cbiAgICAgICAgICAgIC8vIFdlYkdMVGV4dHVyZSBvYmplY3RzIGFyZSBieSBkZWZhdWx0O1xuICAgICAgICAgICAgdGhpcy5wZXJtYW5lbnQgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdwZXJtYW5lbnQnKSA/IG9wdGlvbnMucGVybWFuZW50IDogdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci51cGxvYWRUZXh0dXJlU291cmNlKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTXVzdCBiZSBjbGVhcmVkIHdoZW4gcmVsb2FkIGlzIHN1Y2Nlc2Z1bC5cbiAgICAgICAgdGhpcy5fbG9hZEVycm9yID0gbnVsbDtcblxuICAgICAgICB0aGlzLm9uTG9hZCgpO1xuICAgIH1cblxuICAgIGlzVXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZVRleHR1cmVDb3VudCA+IDA7XG4gICAgfVxuXG4gICAgb25Mb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5pc1VzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKHRleHR1cmUgPT4ge1xuICAgICAgICAgICAgICAgIHRleHR1cmUub25Mb2FkKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcmNlUmVuZGVyVXBkYXRlKCkge1xuICAgICAgICAvLyBVc2VybGFuZCBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCBhZnRlciBjaGFuZ2luZyB0aGUgbmF0aXZlVGV4dHVyZSBtYW51YWxseSBvdXRzaWRlIG9mIHRoZSBmcmFtZXdvcmtcbiAgICAgICAgLy8gICh1c2luZyB0ZXhbU3ViXUltYWdlMmQgZm9yIGV4YW1wbGUpLlxuXG4gICAgICAgIGlmICh0aGlzLl9uYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICAvLyBDaGFuZ2UgJ3VwZGF0ZScgZmxhZy4gVGhpcyBpcyBjdXJyZW50bHkgbm90IHVzZWQgYnkgdGhlIGZyYW1ld29yayBidXQgaXMgaGFuZHkgaW4gdXNlcmxhbmQuXG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVUZXh0dXJlLnVwZGF0ZSA9IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb3JFYWNoQWN0aXZlRWxlbWVudChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5mb3JjZVJlbmRlclVwZGF0ZSgpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGZvcmNlVXBkYXRlUmVuZGVyQ29vcmRzKCkge1xuICAgICAgICB0aGlzLmZvckVhY2hBY3RpdmVFbGVtZW50KGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50Ll91cGRhdGVUZXh0dXJlQ29vcmRzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldCBuYXRpdmVUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlVGV4dHVyZTtcbiAgICB9XG5cbiAgICBjbGVhck5hdGl2ZVRleHR1cmUoKSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZVRleHR1cmUgPSBudWxsO1xuICAgICAgICAvL2Fsc28gY2xlYXIgdGhlIHJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZSB2YXJpYWJsZS5cbiAgICAgICAgdGhpcy5faW1hZ2VSZWYgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHJlc3VsdCB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICByZXBsYWNlTmF0aXZlVGV4dHVyZShuZXdOYXRpdmVUZXh0dXJlLCB3LCBoKSB7XG4gICAgICAgIGxldCBwcmV2TmF0aXZlVGV4dHVyZSA9IHRoaXMuX25hdGl2ZVRleHR1cmU7XG4gICAgICAgIC8vIExvYWRlZCBieSBjb3JlLlxuICAgICAgICB0aGlzLl9uYXRpdmVUZXh0dXJlID0gbmV3TmF0aXZlVGV4dHVyZTtcbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgdGhpcy5oID0gaDtcblxuICAgICAgICBpZiAoIXByZXZOYXRpdmVUZXh0dXJlICYmIHRoaXMuX25hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaEFjdGl2ZUVsZW1lbnQoZWxlbWVudCA9PiBlbGVtZW50Lm9uVGV4dHVyZVNvdXJjZUxvYWRlZCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fbmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JFYWNoQWN0aXZlRWxlbWVudChlbGVtZW50ID0+IGVsZW1lbnQuX3NldERpc3BsYXllZFRleHR1cmUobnVsbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGltZW5zaW9ucyBtdXN0IGJlIHVwZGF0ZWQgYWxzbyBvbiBlbmFibGVkIGVsZW1lbnRzLCBhcyBpdCBtYXkgZm9yY2UgaXQgdG8gZ28gd2l0aGluIGJvdW5kcy5cbiAgICAgICAgdGhpcy5mb3JFYWNoRW5hYmxlZEVsZW1lbnQoZWxlbWVudCA9PiBlbGVtZW50Ll91cGRhdGVEaW1lbnNpb25zKCkpO1xuXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IHRoZSBzcHJpdGUgbWFwIG11c3QgbmV2ZXIgY29udGFpbiByZW5kZXIgdGV4dHVyZXMuXG4gICAgfVxuXG4gICAgb25FcnJvcihlKSB7XG4gICAgICAgIHRoaXMuX2xvYWRFcnJvciA9IGU7XG4gICAgICAgIHRoaXMubG9hZGluZ1NpbmNlID0gMDtcbiAgICAgICAgY29uc29sZS5lcnJvcignW0xpZ2h0bmluZ10gdGV4dHVyZSBsb2FkIGVycm9yJywgZSwgdGhpcy5sb29rdXBJZCk7XG4gICAgICAgIHRoaXMuZm9yRWFjaEFjdGl2ZUVsZW1lbnQoZWxlbWVudCA9PiBlbGVtZW50Lm9uVGV4dHVyZVNvdXJjZUxvYWRFcnJvcihlKSk7XG4gICAgfVxuXG4gICAgZnJlZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmZyZWVUZXh0dXJlU291cmNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2lzTmF0aXZlVGV4dHVyZShzb3VyY2UpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIldlYkdMVGV4dHVyZVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCdXZWJHTFRleHR1cmUnIGluIHdpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZSBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbn1cblxuVGV4dHVyZVNvdXJjZS5wcm90b3R5cGUuaXNUZXh0dXJlU291cmNlID0gdHJ1ZTtcblxuVGV4dHVyZVNvdXJjZS5pZCA9IDE7XG5cbmltcG9ydCBVdGlscyBmcm9tIFwiLi9VdGlscy5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQWxsb3dzIHRocm90dGxpbmcgb2YgbG9hZGluZyB0ZXh0dXJlIHNvdXJjZXMsIGtlZXBpbmcgdGhlIGFwcCByZXNwb25zaXZlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlVGhyb3R0bGVyIHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgICAgICB0aGlzLmdlbmVyaWNDYW5jZWxDYiA9ICh0ZXh0dXJlU291cmNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUodGV4dHVyZVNvdXJjZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fc291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfVxuXG4gICAgcHJvY2Vzc1NvbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtKCk7XG4gICAgICAgICAgICB9IHdoaWxlKHRoaXMuX3NvdXJjZXMubGVuZ3RoICYmIChEYXRlLm5vdygpIC0gc3RhcnQgPCBUZXh0dXJlVGhyb3R0bGVyLk1BWF9VUExPQURfVElNRV9QRVJfRlJBTUUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9wcm9jZXNzSXRlbSgpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5fc291cmNlcy5wb3AoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGEucG9wKCk7XG4gICAgICAgIGlmIChzb3VyY2UuaXNMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgIHNvdXJjZS5wcm9jZXNzTG9hZGVkU291cmNlKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkKHRleHR1cmVTb3VyY2UsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fc291cmNlcy5wdXNoKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICB0aGlzLl9kYXRhLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgX3JlbW92ZSh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKHRleHR1cmVTb3VyY2UpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cblRleHR1cmVUaHJvdHRsZXIuTUFYX1VQTE9BRF9USU1FX1BFUl9GUkFNRSA9IDEwO1xuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXRpbHMge1xuXG4gICAgc3RhdGljIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcic7XG4gICAgfVxuXG4gICAgc3RhdGljIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgKHZhbHVlICUgMSkgPT09IDApO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgc3RhdGljIGNsb25lKHYpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2KSB8fCBBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuZ2V0RGVlcENsb25lKHYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29weSBieSB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNsb25lT2JqU2hhbGxvdyhvYmopIHtcbiAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBsZXQgY2xvbmUgPSB7fVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsb25lW2tleXNbaV1dID0gb2JqW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbWVyZ2Uob2JqMSwgb2JqMikge1xuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iajIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9iajFba2V5c1tpXV0gPSBvYmoyW2tleXNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmoxO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc09iamVjdCh2YWx1ZSkge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGxldCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PT0gJ29iamVjdCcpO1xuICAgIH1cblxuICAgIHN0YXRpYyBpc09iamVjdExpdGVyYWwodmFsdWUpe1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXRBcnJheUluZGV4KGluZGV4LCBhcnIpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLmdldE1vZHVsb0luZGV4KGluZGV4LCBhcnIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0TW9kdWxvSW5kZXgoaW5kZXgsIGxlbikge1xuICAgICAgICBpZiAobGVuID09PSAwKSByZXR1cm4gaW5kZXg7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIGluZGV4ICs9IE1hdGguY2VpbCgtaW5kZXggLyBsZW4pICogbGVuO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gaW5kZXggJSBsZW47XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0RGVlcENsb25lKG9iaikge1xuICAgICAgICBsZXQgaSwgYztcbiAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgICAgICAgLy8gQ29weSBmdW5jdGlvbnMgYnkgcmVmZXJlbmNlLlxuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgICAgICBjID0gW107XG4gICAgICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNba2V5c1tpXV0gPSBVdGlscy5nZXREZWVwQ2xvbmUob2JqW2tleXNbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgICAgIGMgPSB7fVxuICAgICAgICAgICAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjW2tleXNbaV1dID0gVXRpbHMuZ2V0RGVlcENsb25lKG9ialtrZXlzW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgZXF1YWxWYWx1ZXModjEsIHYyKSB7XG4gICAgICAgIGlmICgodHlwZW9mIHYxKSAhPT0gKHR5cGVvZiB2MikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0TGl0ZXJhbCh2MSkpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5pc09iamVjdExpdGVyYWwodjIpICYmIFV0aWxzLmVxdWFsT2JqZWN0TGl0ZXJhbHModjEsIHYyKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYxKSkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodjIpICYmIFV0aWxzLmVxdWFsQXJyYXlzKHYxLCB2Mik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdjEgPT09IHYyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGVxdWFsT2JqZWN0TGl0ZXJhbHMob2JqMSwgb2JqMikge1xuICAgICAgICBsZXQga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgICAgICAgbGV0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gICAgICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzMS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGsxID0ga2V5czFbaV07XG4gICAgICAgICAgICBjb25zdCBrMiA9IGtleXMyW2ldO1xuICAgICAgICAgICAgaWYgKGsxICE9PSBrMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdjEgPSBvYmoxW2sxXTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gb2JqMltrMl07XG5cbiAgICAgICAgICAgIGlmICghVXRpbHMuZXF1YWxWYWx1ZXModjEsIHYyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHN0YXRpYyBlcXVhbEFycmF5cyh2MSwgdjIpIHtcbiAgICAgICAgaWYgKHYxLmxlbmd0aCAhPT0gdjIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB2MS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lcXVhbFZhbHVlcyh2MVtpXSwgdjJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgc3RhdGljIHNldFRvQXJyYXkocykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgc3RhdGljIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBpdGVyYXRvclJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFpdGVyYXRvclJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVyYXRvclJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBpdGVyYXRvclJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHN0YXRpYyBpc1VjQ2hhcihjaGFyY29kZSkge1xuICAgICAgICByZXR1cm4gY2hhcmNvZGUgPj0gNjUgJiYgY2hhcmNvZGUgPD0gOTA7XG4gICAgfVxuXG59XG5cblV0aWxzLmlzV2ViID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpICYmICh0eXBlb2Ygc3BhcmtzY2VuZSA9PT0gXCJ1bmRlZmluZWRcIik7XG5VdGlscy5pc1dQRSA9IFV0aWxzLmlzV2ViICYmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJXUEVcIikgIT09IC0xKTtcblV0aWxzLmlzU3BhcmsgPSAodHlwZW9mIHNwYXJrc2NlbmUgIT09IFwidW5kZWZpbmVkXCIpO1xuVXRpbHMuaXNOb2RlID0gKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHx8IFV0aWxzLmlzU3Bhcms7XG5VdGlscy5pc1BTNCA9IFV0aWxzLmlzV2ViICYmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJQbGF5U3RhdGlvbiA0XCIpICE9PSAtMSk7XG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVDb250ZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKHN0YWdlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBzdGFnZTtcblxuICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xuXG4gICAgICAgIHRoaXMudXBkYXRlVHJlZU9yZGVyID0gMDtcblxuICAgICAgICB0aGlzLnJlbmRlclN0YXRlID0gdGhpcy5zdGFnZS5yZW5kZXJlci5jcmVhdGVDb3JlUmVuZGVyU3RhdGUodGhpcyk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJFeGVjID0gdGhpcy5zdGFnZS5yZW5kZXJlci5jcmVhdGVDb3JlUmVuZGVyRXhlY3V0b3IodGhpcyk7XG4gICAgICAgIHRoaXMucmVuZGVyRXhlYy5pbml0KCk7XG5cbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSA9IDA7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVQb29sID0gW107XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUlkID0gMTtcblxuICAgICAgICB0aGlzLl96U29ydHMgPSBbXTtcbiAgICB9XG5cbiAgICBnZXQgdXNlZE1lbW9yeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VzZWRNZW1vcnk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2wuZm9yRWFjaCh0ZXh0dXJlID0+IHRoaXMuX2ZyZWVSZW5kZXJUZXh0dXJlKHRleHR1cmUpKTtcbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSA9IDA7XG4gICAgfVxuXG4gICAgaGFzUmVuZGVyVXBkYXRlcygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yb290Ll9wYXJlbnQuX2hhc1JlbmRlclVwZGF0ZXM7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyBDbGVhciBmbGFnIHRvIGlkZW50aWZ5IGlmIGFueXRoaW5nIGNoYW5nZXMgYmVmb3JlIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgICB0aGlzLnJvb3QuX3BhcmVudC5faGFzUmVuZGVyVXBkYXRlcyA9IDA7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAvLyBEdWUgdG8gdGhlIGJvdW5kc1Zpc2liaWxpdHkgZmxhZyBmZWF0dXJlIChhbmQgb25BZnRlclVwZGF0ZSBob29rKSwgaXQgaXMgcG9zc2libGUgdGhhdCBvdGhlciBlbGVtZW50cyB3ZXJlXG4gICAgICAgIC8vIGNoYW5nZWQgZHVyaW5nIHRoZSB1cGRhdGUgbG9vcCAoZm9yIGV4YW1wbGUgZHVlIHRvIHRoZSB0eExvYWRlZCBldmVudCkuIFdlIHByb2Nlc3MgdGhlc2UgY2hhbmdlcyBpbW1lZGlhdGVseVxuICAgICAgICAvLyAoYnV0IG5vdCByZWN1cnNpdmVseSB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzKS5cbiAgICAgICAgaWYgKHRoaXMucm9vdC5faGFzVXBkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wZXJmb3JtRm9yY2VkWlNvcnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2VydGFpbiBFbGVtZW50Q29yZSBpdGVtcyBtYXkgYmUgZm9yY2VkIHRvIHpTb3J0IHRvIHN0cmlwIG91dCByZWZlcmVuY2VzIHRvIHByZXZlbnQgbWVtbGVha3MuLlxuICAgICAqL1xuICAgIF9wZXJmb3JtRm9yY2VkWlNvcnRzKCkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5felNvcnRzLmxlbmd0aDtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIC8vIEZvcmNlZCB6LXNvcnRzIChFbGVtZW50Q29yZSBtYXkgZm9yY2UgYSB6LXNvcnQgaW4gb3JkZXIgdG8gZnJlZSBtZW1vcnkvcHJldmVudCBtZW1vcnkgbGVha3MpLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl96U29ydHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pTb3J0c1tpXS56U29ydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96U29ydHNbaV0uc29ydFpJbmRleGVkQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl96U29ydHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVHJlZU9yZGVyID0gMDtcblxuICAgICAgICB0aGlzLnJvb3QudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgX3JlbmRlcigpIHtcbiAgICAgICAgLy8gT2J0YWluIGEgc2VxdWVuY2Ugb2YgdGhlIHF1YWQgb3BlcmF0aW9ucy5cbiAgICAgICAgdGhpcy5fZmlsbFJlbmRlclN0YXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhZ2UuZ2V0T3B0aW9uKCdyZWFkUGl4ZWxzQmVmb3JlRHJhdycpKSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbHMgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgICAgIGNvbnN0IGdsID0gdGhpcy5zdGFnZS5nbDtcbiAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyBydW4gdGhlbSB3aXRoIHRoZSByZW5kZXIgZXhlY3V0b3IuXG4gICAgICAgIHRoaXMuX3BlcmZvcm1SZW5kZXIoKTtcbiAgICB9XG5cbiAgICBfZmlsbFJlbmRlclN0YXRlKCkge1xuICAgICAgICB0aGlzLnJlbmRlclN0YXRlLnJlc2V0KCk7XG4gICAgICAgIHRoaXMucm9vdC5yZW5kZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZS5maW5pc2goKTtcbiAgICB9XG5cbiAgICBfcGVyZm9ybVJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJFeGVjLmV4ZWN1dGUoKTtcbiAgICB9XG5cbiAgICBfYWRkTWVtb3J5VXNhZ2UoZGVsdGEpIHtcbiAgICAgICAgdGhpcy5fdXNlZE1lbW9yeSArPSBkZWx0YTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRNZW1vcnlVc2FnZShkZWx0YSk7XG4gICAgfVxuXG4gICAgYWxsb2NhdGVSZW5kZXJUZXh0dXJlKHcsIGgpIHtcbiAgICAgICAgbGV0IHByZWMgPSB0aGlzLnN0YWdlLmdldFJlbmRlclByZWNpc2lvbigpO1xuICAgICAgICBsZXQgcHcgPSBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKHcgKiBwcmVjKSk7XG4gICAgICAgIGxldCBwaCA9IE1hdGgubWF4KDEsIE1hdGgucm91bmQoaCAqIHByZWMpKTtcblxuICAgICAgICAvLyBTZWFyY2ggbGFzdCBpdGVtIGZpcnN0LCBzbyB0aGF0IGxhc3QgcmVsZWFzZWQgcmVuZGVyIHRleHR1cmUgaXMgcHJlZmVycmVkIChtYXkgY2F1c2UgbWVtb3J5IGNhY2hlIGJlbmVmaXRzKS5cbiAgICAgICAgY29uc3QgbiA9IHRoaXMuX3JlbmRlclRleHR1cmVQb29sLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX3JlbmRlclRleHR1cmVQb29sW2ldO1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXVzZSB0aGUgc2FtZSByZW5kZXIgdGV4dHVyZXMgd2l0aGluIHRoZSBzYW1lIGZyYW1lIGJlY2F1c2UgdGhhdCB3aWxsIGNyZWF0ZSBncHUgc3RhbGxzLlxuICAgICAgICAgICAgaWYgKHRleHR1cmUudyA9PT0gcHcgJiYgdGV4dHVyZS5oID09PSBwaCAmJiAodGV4dHVyZS51cGRhdGUgIT09IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyKSkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUuZiA9IHRoaXMuc3RhZ2UuZnJhbWVDb3VudGVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVQb29sLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLl9jcmVhdGVSZW5kZXJUZXh0dXJlKHcsIGgsIHB3LCBwaCk7XG4gICAgICAgIHRleHR1cmUucHJlY2lzaW9uID0gcHJlYztcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuXG4gICAgcmVsZWFzZVJlbmRlclRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbC5wdXNoKHRleHR1cmUpO1xuICAgIH1cblxuICAgIGZyZWVVbnVzZWRSZW5kZXJUZXh0dXJlcyhtYXhBZ2UgPSA2MCkge1xuICAgICAgICAvLyBDbGVhbiB1cCBhbGwgdGV4dHVyZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWQuXG4gICAgICAgIC8vIFRoaXMgY2FjaGUgaXMgc2hvcnQtbGl2ZWQgYmVjYXVzZSBpdCBpcyByZWFsbHkganVzdCBtZWFudCB0byBzdXBwbHkgcnVubmluZyBzaGFkZXJzIHRoYXQgYXJlXG4gICAgICAgIC8vIHVwZGF0ZWQgZHVyaW5nIGEgbnVtYmVyIG9mIGZyYW1lcy5cbiAgICAgICAgbGV0IGxpbWl0ID0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXIgLSBtYXhBZ2U7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVBvb2wgPSB0aGlzLl9yZW5kZXJUZXh0dXJlUG9vbC5maWx0ZXIodGV4dHVyZSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dHVyZS5mIDw9IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlZVJlbmRlclRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9jcmVhdGVSZW5kZXJUZXh0dXJlKHcsIGgsIHB3LCBwaCkge1xuICAgICAgICB0aGlzLl9hZGRNZW1vcnlVc2FnZShwdyAqIHBoKTtcblxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5zdGFnZS5yZW5kZXJlci5jcmVhdGVSZW5kZXJUZXh0dXJlKHcsIGgsIHB3LCBwaCk7XG4gICAgICAgIHRleHR1cmUuaWQgPSB0aGlzLl9yZW5kZXJUZXh0dXJlSWQrKztcbiAgICAgICAgdGV4dHVyZS5mID0gdGhpcy5zdGFnZS5mcmFtZUNvdW50ZXI7XG4gICAgICAgIHRleHR1cmUub3cgPSB3O1xuICAgICAgICB0ZXh0dXJlLm9oID0gaDtcbiAgICAgICAgdGV4dHVyZS53ID0gcHc7XG4gICAgICAgIHRleHR1cmUuaCA9IHBoO1xuXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cblxuICAgIF9mcmVlUmVuZGVyVGV4dHVyZShuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UucmVuZGVyZXIuZnJlZVJlbmRlclRleHR1cmUobmF0aXZlVGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2FkZE1lbW9yeVVzYWdlKC1uYXRpdmVUZXh0dXJlLncgKiBuYXRpdmVUZXh0dXJlLmgpO1xuICAgIH1cblxuICAgIGNvcHlSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUsIG5hdGl2ZVRleHR1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdGFnZS5yZW5kZXJlci5jb3B5UmVuZGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlLCBuYXRpdmVUZXh0dXJlLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBmb3JjZVpTb3J0KGVsZW1lbnRDb3JlKSB7XG4gICAgICAgIHRoaXMuX3pTb3J0cy5wdXNoKGVsZW1lbnRDb3JlKTtcbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVRdWFkTGlzdCB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcblxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcblxuICAgICAgICB0aGlzLnF1YWRUZXh0dXJlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMucXVhZEVsZW1lbnRzID0gW107XG4gICAgfVxuXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZFRleHR1cmVzLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5xdWFkVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5xdWFkRWxlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgICB9XG5cbiAgICBnZXRFbGVtZW50KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRFbGVtZW50c1tpbmRleF0uX2VsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudENvcmUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZEVsZW1lbnRzW2luZGV4XTtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRUZXh0dXJlc1tpbmRleF07XG4gICAgfVxuXG4gICAgZ2V0VGV4dHVyZVdpZHRoKGluZGV4KSB7XG4gICAgICAgIGxldCBuYXRpdmVUZXh0dXJlID0gdGhpcy5xdWFkVGV4dHVyZXNbaW5kZXhdO1xuICAgICAgICBpZiAobmF0aXZlVGV4dHVyZS53KSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgdGV4dHVyZTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVUZXh0dXJlLnc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFkRWxlbWVudHNbaW5kZXhdLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlLnc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlSGVpZ2h0KGluZGV4KSB7XG4gICAgICAgIGxldCBuYXRpdmVUZXh0dXJlID0gdGhpcy5xdWFkVGV4dHVyZXNbaW5kZXhdO1xuICAgICAgICBpZiAobmF0aXZlVGV4dHVyZS5oKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgdGV4dHVyZTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVUZXh0dXJlLmg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFkRWxlbWVudHNbaW5kZXhdLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlLmg7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29yZVF1YWRPcGVyYXRpb24ge1xuXG4gICAgY29uc3RydWN0b3IoY3R4LCBzaGFkZXIsIHNoYWRlck93bmVyLCByZW5kZXJUZXh0dXJlSW5mbywgc2Npc3NvciwgaW5kZXgpIHtcblxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgIHRoaXMuc2hhZGVyT3duZXIgPSBzaGFkZXJPd25lcjtcbiAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlSW5mbyA9IHJlbmRlclRleHR1cmVJbmZvO1xuICAgICAgICB0aGlzLnNjaXNzb3IgPSBzY2lzc29yO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIH1cblxuICAgIGdldCBxdWFkcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3R4LnJlbmRlclN0YXRlLnF1YWRzO1xuICAgIH1cblxuICAgIGdldFRleHR1cmUoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhZHMuZ2V0VGV4dHVyZSh0aGlzLmluZGV4ICsgaW5kZXgpO1xuICAgIH1cblxuICAgIGdldEVsZW1lbnRDb3JlKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldEVsZW1lbnRDb3JlKHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRFbGVtZW50KHRoaXMuaW5kZXggKyBpbmRleCk7XG4gICAgfVxuXG4gICAgZ2V0RWxlbWVudFdpZHRoKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVsZW1lbnQoaW5kZXgpLnJlbmRlcldpZHRoO1xuICAgIH1cblxuICAgIGdldEVsZW1lbnRIZWlnaHQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudChpbmRleCkucmVuZGVySGVpZ2h0O1xuICAgIH1cblxuICAgIGdldFRleHR1cmVXaWR0aChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5nZXRUZXh0dXJlV2lkdGgodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRUZXh0dXJlSGVpZ2h0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1YWRzLmdldFRleHR1cmVIZWlnaHQodGhpcy5pbmRleCArIGluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGV4dHVyZUluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclRleHR1cmVJbmZvLnc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguc3RhZ2UudztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFJlbmRlckhlaWdodCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyVGV4dHVyZUluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclRleHR1cmVJbmZvLmg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdHguc3RhZ2UuaDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLypcbiAqIElmIG5vdCBzdGF0ZWQgb3RoZXJ3aXNlIGluIHRoaXMgZmlsZSBvciB0aGlzIGNvbXBvbmVudCdzIExJQ0VOU0UgZmlsZSB0aGVcbiAqIGZvbGxvd2luZyBjb3B5cmlnaHQgYW5kIGxpY2Vuc2VzIGFwcGx5OlxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1ldHJvbG9naWNhbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBMaWNlbnNlKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3JlUmVuZGVyRXhlY3V0b3Ige1xuXG4gICAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xuXG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSBjdHgucmVuZGVyU3RhdGU7XG5cbiAgICAgICAgdGhpcy5nbCA9IHRoaXMuY3R4LnN0YWdlLmdsO1xuICAgIH1cblxuICAgIGRlc3Ryb3koKSB7XG4gICAgfVxuXG4gICAgX3Jlc2V0KCkge1xuICAgICAgICB0aGlzLl9iaW5kUmVuZGVyVGV4dHVyZShudWxsKTtcbiAgICAgICAgdGhpcy5fc2V0U2Npc3NvcihudWxsKTtcbiAgICAgICAgdGhpcy5fY2xlYXJSZW5kZXJUZXh0dXJlKCk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcblxuICAgICAgICBsZXQgcW9wcyA9IHRoaXMucmVuZGVyU3RhdGUucXVhZE9wZXJhdGlvbnM7XG5cbiAgICAgICAgbGV0IGkgPSAwLCBqID0gMCwgbiA9IHFvcHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NRdWFkT3BlcmF0aW9uKHFvcHNbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Byb2Nlc3NRdWFkT3BlcmF0aW9uKHF1YWRPcGVyYXRpb24pIHtcbiAgICAgICAgaWYgKHF1YWRPcGVyYXRpb24ucmVuZGVyVGV4dHVyZUluZm8gJiYgcXVhZE9wZXJhdGlvbi5yZW5kZXJUZXh0dXJlSW5mby5pZ25vcmUpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBxdWFkIG9wZXJhdGlvbnMgd2hlbiB3ZSBhcmUgJ3JlLXVzaW5nJyBhbm90aGVyIHRleHR1cmUgYXMgdGhlIHJlbmRlciB0ZXh0dXJlIHJlc3VsdC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldHVwUXVhZE9wZXJhdGlvbihxdWFkT3BlcmF0aW9uKTtcbiAgICAgICAgdGhpcy5fZXhlY1F1YWRPcGVyYXRpb24ocXVhZE9wZXJhdGlvbik7XG5cbiAgICB9XG5cbiAgICBfc2V0dXBRdWFkT3BlcmF0aW9uKHF1YWRPcGVyYXRpb24pIHtcbiAgICB9XG5cbiAgICBfZXhlY1F1YWRPcGVyYXRpb24ob3ApIHtcbiAgICAgICAgLy8gU2V0IHJlbmRlciB0ZXh0dXJlLlxuICAgICAgICBsZXQgbmF0aXZlVGV4dHVyZSA9IG9wLnJlbmRlclRleHR1cmVJbmZvID8gb3AucmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSA6IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmUgIT09IG5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2JpbmRSZW5kZXJUZXh0dXJlKG5hdGl2ZVRleHR1cmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wLnJlbmRlclRleHR1cmVJbmZvICYmICFvcC5yZW5kZXJUZXh0dXJlSW5mby5jbGVhcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTY2lzc29yKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICBvcC5yZW5kZXJUZXh0dXJlSW5mby5jbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3NldFNjaXNzb3Iob3Auc2Npc3Nvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTY2lzc29yKG9wLnNjaXNzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyUXVhZE9wZXJhdGlvbihvcCk7XG4gICAgfVxuXG4gICAgX3JlbmRlclF1YWRPcGVyYXRpb24ob3ApIHtcbiAgICB9XG5cbiAgICBfYmluZFJlbmRlclRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gcmVuZGVyVGV4dHVyZTtcbiAgICB9XG5cbiAgICBfY2xlYXJSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmUpIHtcbiAgICB9XG5cbiAgICBfc2V0U2Npc3NvcihhcmVhKSB7XG4gICAgfVxuXG59XG5cbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcmVSZW5kZXJTdGF0ZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XG5cbiAgICAgICAgdGhpcy5zdGFnZSA9IGN0eC5zdGFnZTtcblxuICAgICAgICB0aGlzLmRlZmF1bHRTaGFkZXIgPSB0aGlzLnN0YWdlLnJlbmRlcmVyLmdldERlZmF1bHRTaGFkZXIoY3R4KTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gY3R4LnN0YWdlLnJlbmRlcmVyO1xuXG4gICAgICAgIHRoaXMucXVhZHMgPSB0aGlzLnJlbmRlcmVyLmNyZWF0ZUNvcmVRdWFkTGlzdChjdHgpO1xuXG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zY2lzc29yID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zaGFkZXIgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3NoYWRlck93bmVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9yZWFsU2hhZGVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9jaGVjayA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMucXVhZE9wZXJhdGlvbnMgPSBbXTtcblxuICAgICAgICB0aGlzLl90ZXh0dXJpemVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl90ZXh0dXJpemVyVGVtcG9yYXJ5ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fcXVhZE9wZXJhdGlvbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5xdWFkcy5yZXNldCgpO1xuXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeVRleHR1cml6ZXJzID0gW107XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9pc0NhY2hpbmdUZXh0dXJpemVyID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFkcy5xdWFkVGV4dHVyZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIHNldFNoYWRlcihzaGFkZXIsIG93bmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXJPd25lciAhPT0gb3duZXIgfHwgdGhpcy5fcmVhbFNoYWRlciAhPT0gc2hhZGVyKSB7XG4gICAgICAgICAgICAvLyBTYW1lIHNoYWRlciBvd25lcjogYWN0aXZlIHNoYWRlciBpcyBhbHNvIHRoZSBzYW1lLlxuICAgICAgICAgICAgLy8gUHJldmVudCBhbnkgc2hhZGVyIHVzYWdlIHRvIHNhdmUgcGVyZm9ybWFuY2UuXG5cbiAgICAgICAgICAgIHRoaXMuX3JlYWxTaGFkZXIgPSBzaGFkZXI7XG5cbiAgICAgICAgICAgIGlmIChzaGFkZXIudXNlRGVmYXVsdCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkZWZhdWx0IHNoYWRlciB3aGVuIHBvc3NpYmxlIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcHJvZ3JhbSBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuZGVmYXVsdFNoYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zaGFkZXIgIT09IHNoYWRlciB8fCB0aGlzLl9zaGFkZXJPd25lciAhPT0gb3duZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaGFkZXIgPSBzaGFkZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hhZGVyT3duZXIgPSBvd25lcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVjayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyVGV4dHVyZUluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mbztcbiAgICB9XG5cbiAgICBzZXRTY2lzc29yKGFyZWEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjaXNzb3IgIT09IGFyZWEpIHtcbiAgICAgICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2Npc3NvciA9IGFyZWE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0U2Npc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjaXNzb3I7XG4gICAgfVxuXG4gICAgc2V0UmVuZGVyVGV4dHVyZUluZm8ocmVuZGVyVGV4dHVyZUluZm8pIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmVJbmZvICE9PSByZW5kZXJUZXh0dXJlSW5mbykge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8gPSByZW5kZXJUZXh0dXJlSW5mbztcbiAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGV4dHVyaXplciB0byBiZSBkcmF3biBkdXJpbmcgc3Vic2VxdWVudCBhZGRRdWFkcy5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnRUZXh0dXJpemVyfSB0ZXh0dXJpemVyXG4gICAgICovXG4gICAgc2V0VGV4dHVyaXplcih0ZXh0dXJpemVyLCBjYWNoZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cml6ZXIgPSB0ZXh0dXJpemVyO1xuICAgICAgICB0aGlzLl9jYWNoZVRleHR1cml6ZXIgPSBjYWNoZTtcbiAgICB9XG5cbiAgICBzZXQgaXNDYWNoaW5nVGV4dHVyaXplcih2KSB7XG4gICAgICAgIHRoaXMuX2lzQ2FjaGluZ1RleHR1cml6ZXIgPSB2O1xuICAgIH1cblxuICAgIGdldCBpc0NhY2hpbmdUZXh0dXJpemVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDYWNoaW5nVGV4dHVyaXplcjtcbiAgICB9XG5cbiAgICBhZGRRdWFkKGVsZW1lbnRDb3JlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcXVhZE9wZXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlUXVhZE9wZXJhdGlvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoZWNrICYmIHRoaXMuX2hhc0NoYW5nZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoUXVhZE9wZXJhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5fY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuYXRpdmVUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cml6ZXIpIHtcbiAgICAgICAgICAgIG5hdGl2ZVRleHR1cmUgPSB0aGlzLl90ZXh0dXJpemVyLmdldFJlc3VsdFRleHR1cmUoKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVRleHR1cml6ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcmVsZWFzZSB0aGUgdGVtcG9yYXJ5IHRleHR1cmUgaW1tZWRpYXRlbHkgYWZ0ZXIgZmluYWxpemluZyB0aGlzIHF1YWQgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBvcmFyeVRleHR1cml6ZXJzLnB1c2godGhpcy5fdGV4dHVyaXplcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5hdGl2ZVRleHR1cmUpIHtcbiAgICAgICAgICAgIG5hdGl2ZVRleHR1cmUgPSBlbGVtZW50Q29yZS5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZS5uYXRpdmVUZXh0dXJlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmVJbmZvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2hhZGVyID09PSB0aGlzLmRlZmF1bHRTaGFkZXIgJiYgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdGV4dHVyZSBtaWdodCBiZSByZXVzYWJsZSB1bmRlciBzb21lIGNvbmRpdGlvbnMuIFdlIHdpbGwgY2hlY2sgdGhlbSBpbiBFbGVtZW50Q29yZS5yZW5kZXJlci5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlID0gbmF0aXZlVGV4dHVyZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5vZmZzZXQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJldXNlIGFub3RoZXIgdGV4dHVyZSB3aGVuIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgcXVhZC5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnF1YWRzLnF1YWRUZXh0dXJlcy5wdXNoKG5hdGl2ZVRleHR1cmUpO1xuICAgICAgICB0aGlzLnF1YWRzLnF1YWRFbGVtZW50cy5wdXNoKGVsZW1lbnRDb3JlKTtcblxuICAgICAgICB0aGlzLl9xdWFkT3BlcmF0aW9uLmxlbmd0aCsrO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUXVhZCh0aGlzLCB0aGlzLnF1YWRzLCB0aGlzLmxlbmd0aCAtIDEpXG4gICAgfVxuXG4gICAgZmluaXNoZWRSZW5kZXJUZXh0dXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGV4dHVyZUluZm8ubmF0aXZlVGV4dHVyZSkge1xuICAgICAgICAgICAgLy8gVGhlcmUgd2FzIG9ubHkgb25lIHRleHR1cmUgZHJhd24gaW4gdGhpcyByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiByZXVzZSBpdCBzbyB0aGF0IHdlIGNhbiBvcHRpbWl6ZSBvdXQgYW4gdW5uZWNlc3NhcnkgcmVuZGVyIHRleHR1cmUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgLy8gKGl0IHNob3VsZCBleGFjdGx5IHNwYW4gdGhpcyByZW5kZXIgdGV4dHVyZSkuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzUmVuZGVyVGV4dHVyZVJldXNhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9pc1JlbmRlclRleHR1cmVSZXVzYWJsZSgpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8ub2Zmc2V0O1xuICAgICAgICByZXR1cm4gKHRoaXMucXVhZHMucXVhZFRleHR1cmVzW29mZnNldF0udyA9PT0gdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8udykgJiZcbiAgICAgICAgICAgICh0aGlzLnF1YWRzLnF1YWRUZXh0dXJlc1tvZmZzZXRdLmggPT09IHRoaXMuX3JlbmRlclRleHR1cmVJbmZvLmgpICYmXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmlzUmVuZGVyVGV4dHVyZVJldXNhYmxlKHRoaXMsIHRoaXMuX3JlbmRlclRleHR1cmVJbmZvKVxuICAgIH1cblxuICAgIF9oYXNDaGFuZ2VzKCkge1xuICAgICAgICBsZXQgcSA9IHRoaXMuX3F1YWRPcGVyYXRpb247XG4gICAgICAgIGlmICh0aGlzLl9zaGFkZXIgIT09IHEuc2hhZGVyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NoYWRlck93bmVyICE9PSBxLnNoYWRlck93bmVyKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRleHR1cmVJbmZvICE9PSBxLnJlbmRlclRleHR1cmVJbmZvKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3NjaXNzb3IgIT09IHEuc2Npc3Nvcikge1xuICAgICAgICAgICAgaWYgKCh0aGlzLl9zY2lzc29yWzBdICE9PSBxLnNjaXNzb3JbMF0pIHx8ICh0aGlzLl9zY2lzc29yWzFdICE9PSBxLnNjaXNzb3JbMV0pIHx8ICh0aGlzLl9zY2lzc29yWzJdICE9PSBxLnNjaXNzb3JbMl0pIHx8ICh0aGlzLl9zY2lzc29yWzNdICE9PSBxLnNjaXNzb3JbM10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX2ZpbmlzaFF1YWRPcGVyYXRpb24oY3JlYXRlID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcXVhZE9wZXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3F1YWRPcGVyYXRpb24ubGVuZ3RoIHx8IHRoaXMuX3NoYWRlci5hZGRFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9xdWFkT3BlcmF0aW9uLnNjaXNzb3IgfHwgKCh0aGlzLl9xdWFkT3BlcmF0aW9uLnNjaXNzb3JbMl0gPiAwKSAmJiAodGhpcy5fcXVhZE9wZXJhdGlvbi5zY2lzc29yWzNdID4gMCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlbXB0eSBjbGlwcGluZyByZWdpb25zLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YWRPcGVyYXRpb25zLnB1c2godGhpcy5fcXVhZE9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGVtcG9yYXJ5VGV4dHVyaXplcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl90ZW1wb3JhcnlUZXh0dXJpemVycy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIG5vdyByZXVzZSB0aGVzZSByZW5kZXItdG8tdGV4dHVyZXMgaW4gc3Vic2VxdWVudCBzdGFnZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEh1Z2UgcGVyZm9ybWFuY2UgYmVuZWZpdCB3aGVuIGZpbHRlcmluZyAoZmFzdCBibHVyKS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcG9yYXJ5VGV4dHVyaXplcnNbaV0ucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fdGVtcG9yYXJ5VGV4dHVyaXplcnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcXVhZE9wZXJhdGlvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVRdWFkT3BlcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY3JlYXRlUXVhZE9wZXJhdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcXVhZE9wZXJhdGlvbiA9IHRoaXMucmVuZGVyZXIuY3JlYXRlQ29yZVF1YWRPcGVyYXRpb24oXG4gICAgICAgICAgICB0aGlzLmN0eCxcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlcixcbiAgICAgICAgICAgIHRoaXMuX3NoYWRlck93bmVyLFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZUluZm8sXG4gICAgICAgICAgICB0aGlzLl9zY2lzc29yLFxuICAgICAgICAgICAgdGhpcy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fY2hlY2sgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9xdWFkT3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBBZGQgcmVtYWluaW5nLlxuICAgICAgICAgICAgdGhpcy5fZmluaXNoUXVhZE9wZXJhdGlvbihmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmZpbmlzaFJlbmRlclN0YXRlKHRoaXMpO1xuICAgIH1cblxufVxuXG4iLCIvKlxuICogSWYgbm90IHN0YXRlZCBvdGhlcndpc2UgaW4gdGhpcyBmaWxlIG9yIHRoaXMgY29tcG9uZW50J3MgTElDRU5TRSBmaWxlIHRoZVxuICogZm9sbG93aW5nIGNvcHlyaWdodCBhbmQgbGljZW5zZXMgYXBwbHk6XG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTWV0cm9sb2dpY2FsXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIExpY2Vuc2UpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgRmxleFRhcmdldCBmcm9tIFwiLi4vLi4vZmxleC9GbGV4VGFyZ2V0Lm1qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50Q29yZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuXG4gICAgICAgIHRoaXMuY3R4ID0gZWxlbWVudC5zdGFnZS5jdHg7XG5cbiAgICAgICAgLy8gVGhlIG1lbW9yeSBsYXlvdXQgb2YgdGhlIGludGVybmFsIHZhcmlhYmxlcyBpcyBhZmZlY3RlZCBieSB0aGVpciBwb3NpdGlvbiBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgIC8vIEl0IGJvb3N0cyBwZXJmb3JtYW5jZSB0byBvcmRlciB0aGVtIGJ5IHVzYWdlIG9mIGNwdS1oZWF2eSBmdW5jdGlvbnMgKHJlbmRlclNpbXBsZSBhbmQgdXBkYXRlKS5cblxuICAgICAgICB0aGlzLl9yZWNhbGMgPSAwO1xuXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fb25VcGRhdGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3BSZWNhbGMgPSAwO1xuXG4gICAgICAgIHRoaXMuX3dvcmxkQ29udGV4dCA9IG5ldyBFbGVtZW50Q29yZUNvbnRleHQoKTtcblxuICAgICAgICB0aGlzLl9oYXNVcGRhdGVzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fbG9jYWxBbHBoYSA9IDE7XG5cbiAgICAgICAgdGhpcy5fb25BZnRlckNhbGNzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9vbkFmdGVyVXBkYXRlID0gbnVsbDtcblxuICAgICAgICAvLyBBbGwgbG9jYWwgdHJhbnNsYXRpb24vdHJhbnNmb3JtIHVwZGF0ZXM6IGRpcmVjdGx5IHByb3BhZ2F0ZWQgZnJvbSB4L3kvdy9oL3NjYWxlL3doYXRldmVyLlxuICAgICAgICB0aGlzLl9sb2NhbFB4ID0gMDtcbiAgICAgICAgdGhpcy5fbG9jYWxQeSA9IDA7XG5cbiAgICAgICAgdGhpcy5fbG9jYWxUYSA9IDE7XG4gICAgICAgIHRoaXMuX2xvY2FsVGIgPSAwO1xuICAgICAgICB0aGlzLl9sb2NhbFRjID0gMDtcbiAgICAgICAgdGhpcy5fbG9jYWxUZCA9IDE7XG5cbiAgICAgICAgdGhpcy5faXNDb21wbGV4ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fZGltc1Vua25vd24gPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9jbGlwcGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFVzZWQgYnkgYm90aCB1cGRhdGUgYW5kIHJlbmRlci5cbiAgICAgICAgdGhpcy5felNvcnQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIHNvdXJjZSB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqIEB0eXBlIHtUZXh0dXJlU291cmNlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fekNvbnRleHRVc2FnZSA9IDA7XG5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2hhc1JlbmRlclVwZGF0ZXMgPSAwO1xuXG4gICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSB0aGlzLl93b3JsZENvbnRleHQ7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSA9IHRoaXMuY3R4LnJlbmRlclN0YXRlO1xuXG4gICAgICAgIHRoaXMuX3NjaXNzb3IgPSBudWxsO1xuXG4gICAgICAgIC8vIFRoZSBhbmNlc3RvciBFbGVtZW50Q29yZSB0aGF0IG93bnMgdGhlIGluaGVyaXRlZCBzaGFkZXIuIE51bGwgaWYgbm9uZSBpcyBhY3RpdmUgKGRlZmF1bHQgc2hhZGVyKS5cbiAgICAgICAgdGhpcy5fc2hhZGVyT3duZXIgPSBudWxsO1xuXG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVHJlZU9yZGVyID0gMDtcblxuICAgICAgICB0aGlzLl9jb2xvclVsID0gdGhpcy5fY29sb3JVciA9IHRoaXMuX2NvbG9yQmwgPSB0aGlzLl9jb2xvckJyID0gMHhGRkZGRkZGRjtcblxuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgIHRoaXMuX3cgPSAwO1xuICAgICAgICB0aGlzLl9oID0gMDtcblxuICAgICAgICB0aGlzLl9vcHRGbGFncyA9IDA7XG4gICAgICAgIHRoaXMuX2Z1bmNYID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZnVuY1kgPSBudWxsO1xuICAgICAgICB0aGlzLl9mdW5jVyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Z1bmNIID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zY2FsZVggPSAxO1xuICAgICAgICB0aGlzLl9zY2FsZVkgPSAxO1xuICAgICAgICB0aGlzLl9waXZvdFggPSAwLjU7XG4gICAgICAgIHRoaXMuX3Bpdm90WSA9IDAuNTtcbiAgICAgICAgdGhpcy5fbW91bnRYID0gMDtcbiAgICAgICAgdGhpcy5fbW91bnRZID0gMDtcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSAwO1xuXG4gICAgICAgIHRoaXMuX2FscGhhID0gMTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fdWx4ID0gMDtcbiAgICAgICAgdGhpcy5fdWx5ID0gMDtcbiAgICAgICAgdGhpcy5fYnJ4ID0gMTtcbiAgICAgICAgdGhpcy5fYnJ5ID0gMTtcblxuICAgICAgICB0aGlzLl96SW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9mb3JjZVpJbmRleENvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5felBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5faXNSb290ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmZiB0cnVlLCBkdXJpbmcgelNvcnQsIHRoaXMgZWxlbWVudCBzaG91bGQgYmUgJ3JlLXNvcnRlZCcgYmVjYXVzZSBlaXRoZXI6XG4gICAgICAgICAqIC0gekluZGV4IGRpZCBjaGFuZ1xuICAgICAgICAgKiAtIHpQYXJlbnQgZGlkIGNoYW5nZVxuICAgICAgICAgKiAtIGVsZW1lbnQgd2FzIG1vdmVkIGluIHRoZSByZW5kZXIgdHJlZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3pJbmRleFJlc29ydCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3NoYWRlciA9IG51bGw7XG5cbiAgICAgICAgLy8gRWxlbWVudCBpcyByZW5kZXJlZCBvbiBhbm90aGVyIHRleHR1cmUuXG4gICAgICAgIHRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl90ZXh0dXJpemVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9ib3VuZHNNYXJnaW4gPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX3JlY0JvdW5kc01hcmdpbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fd2l0aGluQm91bmRzTWFyZ2luID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NsaXBib3ggPSB0cnVlO1xuXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyU2ltcGxlO1xuXG4gICAgICAgIHRoaXMuX2xheW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IG9mZnNldFgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9mdW5jWCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bmNYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5vcmlnaW5hbFg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0IG9mZnNldFgodikge1xuICAgICAgICBpZiAoVXRpbHMuaXNGdW5jdGlvbih2KSkge1xuICAgICAgICAgICAgdGhpcy5mdW5jWCA9IHY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlRnVuY1goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMueCArPSAodiAtIHRoaXMuX2xheW91dC5vcmlnaW5hbFgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dC5zZXRPcmlnaW5hbFhXaXRob3V0VXBkYXRpbmdMYXlvdXQodik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XG4gICAgfVxuXG4gICAgc2V0IHgodikge1xuICAgICAgICBpZiAodiAhPT0gdGhpcy5feCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGVEZWx0YSh2IC0gdGhpcy5feCwgMCk7XG4gICAgICAgICAgICB0aGlzLl94ID0gdjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBmdW5jWCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vcHRGbGFncyAmIDEgPyB0aGlzLl9mdW5jWCA6IG51bGwpO1xuICAgIH1cblxuICAgIHNldCBmdW5jWCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9mdW5jWCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fb3B0RmxhZ3MgfD0gMTtcbiAgICAgICAgICAgIHRoaXMuX2Z1bmNYID0gdjtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xheW91dC5zZXRPcmlnaW5hbFhXaXRob3V0VXBkYXRpbmdMYXlvdXQoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuZm9yY2VMYXlvdXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2Rpc2FibGVGdW5jWCgpIHtcbiAgICAgICAgdGhpcy5fb3B0RmxhZ3MgPSB0aGlzLl9vcHRGbGFncyAmICgweEZGRkYgLSAxKTtcbiAgICAgICAgdGhpcy5fZnVuY1ggPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBvZmZzZXRZKCkge1xuICAgICAgICBpZiAodGhpcy5fZnVuY1kpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mdW5jWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQub3JpZ2luYWxZO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldCBvZmZzZXRZKHYpIHtcbiAgICAgICAgaWYgKFV0aWxzLmlzRnVuY3Rpb24odikpIHtcbiAgICAgICAgICAgIHRoaXMuZnVuY1kgPSB2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUZ1bmNZKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkgKz0gKHYgLSB0aGlzLl9sYXlvdXQub3JpZ2luYWxZKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQuc2V0T3JpZ2luYWxZV2l0aG91dFVwZGF0aW5nTGF5b3V0KHYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cblxuICAgIHNldCB5KHYpIHtcbiAgICAgICAgaWYgKHYgIT09IHRoaXMuX3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlRGVsdGEoMCwgdiAtIHRoaXMuX3kpO1xuICAgICAgICAgICAgdGhpcy5feSA9IHY7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgZnVuY1koKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fb3B0RmxhZ3MgJiAyID8gdGhpcy5fZnVuY1kgOiBudWxsKTtcbiAgICB9XG5cbiAgICBzZXQgZnVuY1kodikge1xuICAgICAgICBpZiAodGhpcy5fZnVuY1kgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdEZsYWdzIHw9IDI7XG4gICAgICAgICAgICB0aGlzLl9mdW5jWSA9IHY7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQuc2V0T3JpZ2luYWxZV2l0aG91dFVwZGF0aW5nTGF5b3V0KDApO1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmZvcmNlTGF5b3V0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJSZWNhbGNUcmFuc2xhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9kaXNhYmxlRnVuY1koKSB7XG4gICAgICAgIHRoaXMuX29wdEZsYWdzID0gdGhpcy5fb3B0RmxhZ3MgJiAoMHhGRkZGIC0gMik7XG4gICAgICAgIHRoaXMuX2Z1bmNZID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgZnVuY1coKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fb3B0RmxhZ3MgJiA0ID8gdGhpcy5fZnVuY1cgOiBudWxsKTtcbiAgICB9XG5cbiAgICBzZXQgZnVuY1codikge1xuICAgICAgICBpZiAodGhpcy5fZnVuY1cgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdEZsYWdzIHw9IDQ7XG4gICAgICAgICAgICB0aGlzLl9mdW5jVyA9IHY7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQuX29yaWdpbmFsV2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LmNoYW5nZWREaW1lbnNpb25zKHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzYWJsZUZ1bmNXKCkge1xuICAgICAgICB0aGlzLl9vcHRGbGFncyA9IHRoaXMuX29wdEZsYWdzICYgKDB4RkZGRiAtIDQpO1xuICAgICAgICB0aGlzLl9mdW5jVyA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGZ1bmNIKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX29wdEZsYWdzICYgOCA/IHRoaXMuX2Z1bmNIIDogbnVsbCk7XG4gICAgfVxuXG4gICAgc2V0IGZ1bmNIKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Z1bmNIICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRGbGFncyB8PSA4O1xuICAgICAgICAgICAgdGhpcy5fZnVuY0ggPSB2O1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5b3V0Ll9vcmlnaW5hbEhlaWdodCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuY2hhbmdlZERpbWVuc2lvbnMoZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlRnVuY0goKSB7XG4gICAgICAgIHRoaXMuX29wdEZsYWdzID0gdGhpcy5fb3B0RmxhZ3MgJiAoMHhGRkZGIC0gOCk7XG4gICAgICAgIHRoaXMuX2Z1bmNIID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVyV2lkdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0ZsZXhMYXlvdXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xheW91dC5vcmlnaW5hbFdpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2g7XG4gICAgfVxuXG4gICAgZ2V0UmVuZGVySGVpZ2h0KCkge1xuICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQub3JpZ2luYWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBzY2FsZVgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVg7XG4gICAgfVxuXG4gICAgc2V0IHNjYWxlWCh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9zY2FsZVggIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlWCA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHNjYWxlWSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlWTtcbiAgICB9XG5cbiAgICBzZXQgc2NhbGVZKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlWSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVZID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlWDtcbiAgICB9XG5cbiAgICBzZXQgc2NhbGUodikge1xuICAgICAgICBpZiAodGhpcy5fc2NhbGVYICE9PSB2IHx8IHRoaXMuX3NjYWxlWSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVYID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlWSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHBpdm90WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WDtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3RYKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bpdm90WCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3RYID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgcGl2b3RZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGl2b3RZO1xuICAgIH1cblxuICAgIHNldCBwaXZvdFkodikge1xuICAgICAgICBpZiAodGhpcy5fcGl2b3RZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9waXZvdFkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBwaXZvdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bpdm90WDtcbiAgICB9XG5cbiAgICBzZXQgcGl2b3Qodikge1xuICAgICAgICBpZiAodGhpcy5fcGl2b3RYICE9PSB2IHx8IHRoaXMuX3Bpdm90WSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fcGl2b3RYID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3Bpdm90WSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG1vdW50WCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdW50WDtcbiAgICB9XG5cbiAgICBzZXQgbW91bnRYKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vdW50WCAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fbW91bnRYID0gdjtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgbW91bnRZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW91bnRZO1xuICAgIH1cblxuICAgIHNldCBtb3VudFkodikge1xuICAgICAgICBpZiAodGhpcy5fbW91bnRZICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VudFkgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdW50WDtcbiAgICB9XG5cbiAgICBzZXQgbW91bnQodikge1xuICAgICAgICBpZiAodGhpcy5fbW91bnRYICE9PSB2IHx8IHRoaXMuX21vdW50WSAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fbW91bnRYID0gdjtcbiAgICAgICAgICAgIHRoaXMuX21vdW50WSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XG4gICAgfVxuXG4gICAgc2V0IHJvdGF0aW9uKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uICE9PSB2KSB7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGFscGhhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGE7XG4gICAgfVxuXG4gICAgc2V0IGFscGhhKHYpIHtcbiAgICAgICAgLy8gQWNjb3VudCBmb3Igcm91bmRpbmcgZXJyb3JzLlxuICAgICAgICB2ID0gKHYgPiAxID8gMSA6ICh2IDwgMWUtMTQgPyAwIDogdikpO1xuICAgICAgICBpZiAodGhpcy5fYWxwaGEgIT09IHYpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gdGhpcy5fYWxwaGE7XG4gICAgICAgICAgICB0aGlzLl9hbHBoYSA9IHY7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMb2NhbEFscGhhKCk7XG4gICAgICAgICAgICBpZiAoKHByZXYgPT09IDApICE9PSAodiA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50Ll91cGRhdGVFbmFibGVkRmxhZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cblxuICAgIHNldCB2aXNpYmxlKHYpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTG9jYWxBbHBoYSgpO1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudC5fdXBkYXRlRW5hYmxlZEZsYWcoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzRmxleExheW91dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0VmlzaWJsZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JvdGF0aW9uICE9PSAwICYmIHRoaXMuX3JvdGF0aW9uICUgKDIgKiBNYXRoLlBJKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZSByb3RhdGlvbiBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcmVuZGVyLiBUaGlzIG1lYW5zIHdlIG9ubHkgbmVlZCB0byB1c2Ugc2luIGFuZCBjb3Mgd2hlbiByb3RhdGlvbiBhY3R1YWxseSBjaGFuZ2VzXG4gICAgICAgICAgICBsZXQgX3NyID0gTWF0aC5zaW4odGhpcy5fcm90YXRpb24pO1xuICAgICAgICAgICAgbGV0IF9jciA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uKTtcblxuICAgICAgICAgICAgdGhpcy5fc2V0TG9jYWxUcmFuc2Zvcm0oXG4gICAgICAgICAgICAgICAgX2NyICogdGhpcy5fc2NhbGVYLFxuICAgICAgICAgICAgICAgIC1fc3IgKiB0aGlzLl9zY2FsZVksXG4gICAgICAgICAgICAgICAgX3NyICogdGhpcy5fc2NhbGVYLFxuICAgICAgICAgICAgICAgIF9jciAqIHRoaXMuX3NjYWxlWVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldExvY2FsVHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgIHRoaXMuX3NjYWxlWCxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgdGhpcy5fc2NhbGVZXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgfTtcblxuICAgIF91cGRhdGVMb2NhbFRyYW5zbGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVjYWxjTG9jYWxUcmFuc2xhdGUoKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgIH07XG5cbiAgICBfcmVjYWxjTG9jYWxUcmFuc2xhdGUoKSB7XG4gICAgICAgIGxldCBwaXZvdFhNdWwgPSB0aGlzLl9waXZvdFggKiB0aGlzLl93O1xuICAgICAgICBsZXQgcGl2b3RZTXVsID0gdGhpcy5fcGl2b3RZICogdGhpcy5faDtcbiAgICAgICAgbGV0IHB4ID0gdGhpcy5feCAtIChwaXZvdFhNdWwgKiB0aGlzLl9sb2NhbFRhICsgcGl2b3RZTXVsICogdGhpcy5fbG9jYWxUYikgKyBwaXZvdFhNdWw7XG4gICAgICAgIGxldCBweSA9IHRoaXMuX3kgLSAocGl2b3RYTXVsICogdGhpcy5fbG9jYWxUYyArIHBpdm90WU11bCAqIHRoaXMuX2xvY2FsVGQpICsgcGl2b3RZTXVsO1xuICAgICAgICBweCAtPSB0aGlzLl9tb3VudFggKiB0aGlzLl93O1xuICAgICAgICBweSAtPSB0aGlzLl9tb3VudFkgKiB0aGlzLl9oO1xuICAgICAgICB0aGlzLl9sb2NhbFB4ID0gcHg7XG4gICAgICAgIHRoaXMuX2xvY2FsUHkgPSBweTtcbiAgICB9XG5cbiAgICBfdXBkYXRlTG9jYWxUcmFuc2xhdGVEZWx0YShkeCwgZHkpIHtcbiAgICAgICAgdGhpcy5fYWRkTG9jYWxUcmFuc2xhdGUoZHgsIGR5KTtcbiAgICB9O1xuXG4gICAgX3VwZGF0ZUxvY2FsQWxwaGEoKSB7XG4gICAgICAgIHRoaXMuX3NldExvY2FsQWxwaGEodGhpcy5fdmlzaWJsZSA/IHRoaXMuX2FscGhhIDogMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gICAgICogMDogbm8gdXBkYXRlc1xuICAgICAqIDE6IHJlLWludm9rZSBzaGFkZXJcbiAgICAgKiAzOiByZS1jcmVhdGUgcmVuZGVyIHRleHR1cmUgYW5kIHJlLWludm9rZSBzaGFkZXJcbiAgICAgKi9cbiAgICBzZXRIYXNSZW5kZXJVcGRhdGVzKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmxkQ29udGV4dC5hbHBoYSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGlmICd3b3JsZCBpbnZpc2libGUnLiBSZW5kZXIgdXBkYXRlcyB3aWxsIGJlIHJlc2V0IHRvIDMgZm9yIGV2ZXJ5IGVsZW1lbnQgdGhhdCBiZWNvbWVzIHZpc2libGUuXG4gICAgICAgICAgICBsZXQgcCA9IHRoaXM7XG4gICAgICAgICAgICBwLl9oYXNSZW5kZXJVcGRhdGVzID0gTWF0aC5tYXgodHlwZSwgcC5faGFzUmVuZGVyVXBkYXRlcyk7XG4gICAgICAgICAgICB3aGlsZSAoKHAgPSBwLl9wYXJlbnQpICYmIChwLl9oYXNSZW5kZXJVcGRhdGVzICE9PSAzKSkge1xuICAgICAgICAgICAgICAgIHAuX2hhc1JlbmRlclVwZGF0ZXMgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAgICAgKiAgIDE6IGFscGhhXG4gICAgICogICAyOiB0cmFuc2xhdGVcbiAgICAgKiAgIDQ6IHRyYW5zZm9ybVxuICAgICAqIDEyODogYmVjb21lcyB2aXNpYmxlXG4gICAgICogMjU2OiBmbGV4IGxheW91dCB1cGRhdGVkXG4gICAgICovXG4gICAgX3NldFJlY2FsYyh0eXBlKSB7XG4gICAgICAgIHRoaXMuX3JlY2FsYyB8PSB0eXBlO1xuXG4gICAgICAgIHRoaXMuX3NldEhhc1VwZGF0ZXMoKTtcblxuICAgICAgICAvLyBBbnkgY2hhbmdlcyBpbiBkZXNjZW5kYW50cyBzaG91bGQgdHJpZ2dlciB0ZXh0dXJlIHVwZGF0ZXMuXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NldEhhc1VwZGF0ZXMoKSB7XG4gICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHAgJiYgIXAuX2hhc1VwZGF0ZXMpIHtcbiAgICAgICAgICAgIHAuX2hhc1VwZGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgcCA9IHAuX3BhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICB9XG5cbiAgICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgICAgbGV0IHByZXZJc1pDb250ZXh0ID0gdGhpcy5pc1pDb250ZXh0KCk7XG4gICAgICAgICAgICBsZXQgcHJldlBhcmVudCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcblxuICAgICAgICAgICAgLy8gTm90aWZ5IGZsZXggbGF5b3V0IGVuZ2luZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXlvdXQgfHwgKHBhcmVudCAmJiBwYXJlbnQuaXNGbGV4Q29udGFpbmVyKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc2V0UGFyZW50KHByZXZQYXJlbnQsIHBhcmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcmV2UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBlbGVtZW50cyBhcmUgZGVsZXRlZCwgdGhlIHJlbmRlciB0ZXh0dXJlIG11c3QgYmUgcmUtcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgcHJldlBhcmVudC5zZXRIYXNSZW5kZXJVcGRhdGVzKDMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9zZXRSZWNhbGMoMSArIDIgKyA0KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIEZvcmNlIHBhcmVudCB0byBwcm9wYWdhdGUgaGFzVXBkYXRlcyBmbGFnLlxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fc2V0SGFzVXBkYXRlcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fekluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRaUGFyZW50KHBhcmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0WlBhcmVudChwYXJlbnQgPyBwYXJlbnQuZmluZFpDb250ZXh0KCkgOiBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHByZXZJc1pDb250ZXh0ICE9PSB0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlWkNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVpDb250ZXh0KHByZXZQYXJlbnQuZmluZFpDb250ZXh0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVHJlZSBvcmRlciBkaWQgY2hhbmdlOiBldmVuIGlmIHpQYXJlbnQgc3RheXMgdGhlIHNhbWUsIHdlIG11c3QgcmVzb3J0LlxuICAgICAgICAgICAgdGhpcy5fekluZGV4UmVzb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5lbmFibGVaU29ydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3NoYWRlcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXdTaGFkZXJPd25lciA9IHBhcmVudCAmJiAhcGFyZW50Ll9yZW5kZXJUb1RleHR1cmVFbmFibGVkID8gcGFyZW50Ll9zaGFkZXJPd25lciA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1NoYWRlck93bmVyICE9PSB0aGlzLl9zaGFkZXJPd25lcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNoYWRlck93bmVyUmVjdXJzaXZlKG5ld1NoYWRlck93bmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZW5hYmxlWlNvcnQoZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3pTb3J0ICYmIHRoaXMuX3pDb250ZXh0VXNhZ2UgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl96U29ydCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBaU29ydCBtdXN0IGJlIGRvbmUsIGV2ZW4gaWYgdGhpcyBlbGVtZW50IGlzIGludmlzaWJsZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgd2hlbiByZW1vdmluZyBlbGVtZW50IGZyb20gaW5hY3RpdmUgcmVuZGVyIGJyYW5jaGVzLlxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZvcmNlWlNvcnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRDaGlsZEF0KGluZGV4LCBjaGlsZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgY2hpbGQuc2V0UGFyZW50KHRoaXMpO1xuICAgIH07XG5cbiAgICBzZXRDaGlsZEF0KGluZGV4LCBjaGlsZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NoaWxkcmVuKSB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbltpbmRleF0uc2V0UGFyZW50KG51bGwpO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbltpbmRleF0gPSBjaGlsZDtcbiAgICAgICAgY2hpbGQuc2V0UGFyZW50KHRoaXMpO1xuICAgIH1cblxuICAgIHJlbW92ZUNoaWxkQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBjaGlsZC5zZXRQYXJlbnQobnVsbCk7XG4gICAgfTtcblxuICAgIHJlbW92ZUNoaWxkcmVuKCkge1xuICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0uc2V0UGFyZW50KG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UoMCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl96SW5kZXhlZENoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbi5zcGxpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc3luY0NoaWxkcmVuKHJlbW92ZWQsIGFkZGVkLCBvcmRlcikge1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IG9yZGVyO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICByZW1vdmVkW2ldLnNldFBhcmVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFkZGVkLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgYWRkZWRbaV0uc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbW92ZUNoaWxkKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICBsZXQgYyA9IHRoaXMuX2NoaWxkcmVuW2Zyb21JbmRleF07XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbi5zcGxpY2UodG9JbmRleCwgMCwgYyk7XG5cbiAgICAgICAgLy8gVHJlZSBvcmRlciBjaGFuZ2VkOiBtdXN0IHJlc29ydCE7XG4gICAgICAgIHRoaXMuX3pJbmRleFJlc29ydCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl96UGFyZW50LmVuYWJsZVpTb3J0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfc2V0TG9jYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCkge1xuICAgICAgICB0aGlzLl9zZXRSZWNhbGMoNCk7XG4gICAgICAgIHRoaXMuX2xvY2FsVGEgPSBhO1xuICAgICAgICB0aGlzLl9sb2NhbFRiID0gYjtcbiAgICAgICAgdGhpcy5fbG9jYWxUYyA9IGM7XG4gICAgICAgIHRoaXMuX2xvY2FsVGQgPSBkO1xuXG4gICAgICAgIC8vIFdlIGFsc28gcmVnYXJkIG5lZ2F0aXZlIHNjYWxpbmcgYXMgYSBjb21wbGV4IGNhc2UsIHNvIHRoYXQgd2UgY2FuIG9wdGltaXplIHRoZSBub24tY29tcGxleCBjYXNlIGJldHRlci5cbiAgICAgICAgdGhpcy5faXNDb21wbGV4ID0gKGIgIT09IDApIHx8IChjICE9PSAwKSB8fCAoYSA8IDApIHx8IChkIDwgMCk7XG4gICAgfTtcblxuICAgIF9hZGRMb2NhbFRyYW5zbGF0ZShkeCwgZHkpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxQeCArPSBkeDtcbiAgICAgICAgdGhpcy5fbG9jYWxQeSArPSBkeTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgIH1cblxuICAgIF9zZXRMb2NhbEFscGhhKGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLl93b3JsZENvbnRleHQuYWxwaGEgJiYgKCh0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll93b3JsZENvbnRleHQuYWxwaGEpICYmIGEpKSB7XG4gICAgICAgICAgICAvLyBFbGVtZW50IGlzIGJlY29taW5nIHZpc2libGUuIFdlIG5lZWQgdG8gZm9yY2UgdXBkYXRlLlxuICAgICAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDEgKyAxMjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGEgPCAxZS0xNCkge1xuICAgICAgICAgICAgLy8gVGlueSByb3VuZGluZyBlcnJvcnMgbWF5IGNhdXNlIGZhaWxpbmcgdmlzaWJpbGl0eSB0ZXN0cy5cbiAgICAgICAgICAgIGEgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9jYWxBbHBoYSA9IGE7XG4gICAgfTtcblxuICAgIHNldERpbWVuc2lvbnModywgaCwgaXNFc3RpbWF0ZSA9IHRoaXMuX2RpbXNVbmtub3duKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgYW4gZXN0aW1hdGlvbiwgdGhlIHVwZGF0ZSBsb29wIHNob3VsZCBwZXJmb3JtIGRpZmZlcmVudCBib3VuZCBjaGVja3MuXG4gICAgICAgIHRoaXMuX2RpbXNVbmtub3duID0gaXNFc3RpbWF0ZTtcblxuICAgICAgICBpZiAodGhpcy5oYXNGbGV4TGF5b3V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5vcmlnaW5hbFdpZHRoID0gdztcbiAgICAgICAgICAgIHRoaXMuX2xheW91dC5vcmlnaW5hbEhlaWdodCA9IGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdyAhPT0gdyB8fCB0aGlzLl9oICE9PSBoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucyh3LCBoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF91cGRhdGVEaW1lbnNpb25zKHcsIGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3cgIT09IHcgfHwgdGhpcy5faCAhPT0gaCkge1xuICAgICAgICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICAgICAgICB0aGlzLl9oID0gaDtcblxuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyaXplcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnVwZGF0ZVJlc3VsdFRleHR1cmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIER1ZSB0byB3aWR0aC9oZWlnaHQgY2hhbmdlOiB1cGRhdGUgdGhlIHRyYW5zbGF0aW9uIHZlY3Rvci5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUxvY2FsVHJhbnNsYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRUZXh0dXJlQ29vcmRzKHVseCwgdWx5LCBicngsIGJyeSkge1xuICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG5cbiAgICAgICAgdGhpcy5fdWx4ID0gdWx4O1xuICAgICAgICB0aGlzLl91bHkgPSB1bHk7XG4gICAgICAgIHRoaXMuX2JyeCA9IGJyeDtcbiAgICAgICAgdGhpcy5fYnJ5ID0gYnJ5O1xuICAgIH07XG5cbiAgICBnZXQgZGlzcGxheWVkVGV4dHVyZVNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2U7XG4gICAgfVxuXG4gICAgc2V0RGlzcGxheWVkVGV4dHVyZVNvdXJjZSh0ZXh0dXJlU291cmNlKSB7XG4gICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygzKTtcbiAgICAgICAgdGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA9IHRleHR1cmVTb3VyY2U7XG4gICAgfTtcblxuICAgIGdldCBpc1Jvb3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1Jvb3Q7XG4gICAgfVxuXG4gICAgc2V0QXNSb290KCkge1xuICAgICAgICAvLyBVc2UgcGFyZW50IGR1bW15LlxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBuZXcgRWxlbWVudENvcmUodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgLy8gQWZ0ZXIgc2V0dGluZyByb290LCBtYWtlIHN1cmUgaXQncyB1cGRhdGVkLlxuICAgICAgICB0aGlzLl9wYXJlbnQuX2hhc1JlbmRlclVwZGF0ZXMgPSAzO1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2hhc1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgICAgIC8vIFJvb3QgaXMsIGFuZCB3aWxsIGFsd2F5cyBiZSwgdGhlIHByaW1hcnkgekNvbnRleHQuXG4gICAgICAgIHRoaXMuX2lzUm9vdCA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jdHgucm9vdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gU2V0IHNjaXNzb3IgYXJlYSBvZiAnZmFrZSBwYXJlbnQnIHRvIHN0YWdlJ3Mgdmlld3BvcnQuXG4gICAgICAgIHRoaXMuX3BhcmVudC5fdmlld3BvcnQgPSBbMCwgMCwgdGhpcy5jdHguc3RhZ2UuY29vcmRzV2lkdGgsIHRoaXMuY3R4LnN0YWdlLmNvb3Jkc0hlaWdodF07XG4gICAgICAgIHRoaXMuX3BhcmVudC5fc2Npc3NvciA9IHRoaXMuX3BhcmVudC5fdmlld3BvcnQ7XG5cbiAgICAgICAgLy8gV2hlbiByZWNCb3VuZHNNYXJnaW4gaXMgbnVsbCwgdGhlIGRlZmF1bHRzIGFyZSB1c2VkICgxMDAgZm9yIGFsbCBzaWRlcykuXG4gICAgICAgIHRoaXMuX3BhcmVudC5fcmVjQm91bmRzTWFyZ2luID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9zZXRSZWNhbGMoMSArIDIgKyA0KTtcbiAgICB9O1xuXG4gICAgaXNBbmNlc3Rvck9mKGMpIHtcbiAgICAgICAgbGV0IHAgPSBjO1xuICAgICAgICB3aGlsZSAocCA9IHAuX3BhcmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMgPT09IHApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGlzWkNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZm9yY2VaSW5kZXhDb250ZXh0IHx8IHRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgfHwgdGhpcy5fekluZGV4ICE9PSAwIHx8IHRoaXMuX2lzUm9vdCB8fCAhdGhpcy5fcGFyZW50KTtcbiAgICB9O1xuXG4gICAgZmluZFpDb250ZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudC5maW5kWkNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZXRaUGFyZW50KG5ld1pQYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3pQYXJlbnQgIT09IG5ld1pQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl96UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmRlY1pDb250ZXh0VXNhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IGZpbHRlciBvdXQgdGhpcyBpdGVtIHVwb24gdGhlIG5leHQgcmVzb3J0LlxuICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZW5hYmxlWlNvcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5ld1pQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaGFkWkNvbnRleHRVc2FnZSA9IChuZXdaUGFyZW50Ll96Q29udGV4dFVzYWdlID4gMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBAcHJlOiBuZXcgcGFyZW50J3MgY2hpbGRyZW4gYXJyYXkgaGFzIGFscmVhZHkgYmVlbiBtb2RpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fekluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1pQYXJlbnQuaW5jWkNvbnRleHRVc2FnZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChuZXdaUGFyZW50Ll96Q29udGV4dFVzYWdlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhZFpDb250ZXh0VXNhZ2UgJiYgKHRoaXMuX3BhcmVudCA9PT0gbmV3WlBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgY2hpbGQgd2FzIGFscmVhZHkgaW4gdGhlIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWRkIGRvdWJsZS5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBuZXcgY2hpbGQgdG8gYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdaUGFyZW50Ll96SW5kZXhlZENoaWxkcmVuLnB1c2godGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBPcmRlciBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICAgICAgICAgICAgICAgICAgbmV3WlBhcmVudC5lbmFibGVaU29ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5felBhcmVudCA9IG5ld1pQYXJlbnQ7XG5cbiAgICAgICAgICAgIC8vIE5ld2x5IGFkZGVkIGVsZW1lbnQgbXVzdCBiZSBtYXJrZWQgZm9yIHJlc29ydC5cbiAgICAgICAgICAgIHRoaXMuX3pJbmRleFJlc29ydCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5jWkNvbnRleHRVc2FnZSgpIHtcbiAgICAgICAgdGhpcy5fekNvbnRleHRVc2FnZSsrO1xuICAgICAgICBpZiAodGhpcy5fekNvbnRleHRVc2FnZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl96SW5kZXhlZENoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weS5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuLnB1c2godGhpcy5fY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsbHksIGNoaWxkcmVuIGFyZSBhbHJlYWR5IHNvcnRlZCBwcm9wZXJseSAodHJlZSBvcmRlcikuXG4gICAgICAgICAgICAgICAgdGhpcy5felNvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBkZWNaQ29udGV4dFVzYWdlKCkge1xuICAgICAgICB0aGlzLl96Q29udGV4dFVzYWdlLS07XG4gICAgICAgIGlmICh0aGlzLl96Q29udGV4dFVzYWdlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl96U29ydCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbi5zcGxpY2UoMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IHpJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pJbmRleDtcbiAgICB9XG5cbiAgICBzZXQgekluZGV4KHpJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5fekluZGV4ICE9PSB6SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygxKTtcblxuICAgICAgICAgICAgbGV0IG5ld1pQYXJlbnQgPSB0aGlzLl96UGFyZW50O1xuXG4gICAgICAgICAgICBsZXQgcHJldklzWkNvbnRleHQgPSB0aGlzLmlzWkNvbnRleHQoKTtcbiAgICAgICAgICAgIGlmICh6SW5kZXggPT09IDAgJiYgdGhpcy5fekluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudCA9PT0gdGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5felBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5kZWNaQ29udGV4dFVzYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdaUGFyZW50ID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoekluZGV4ICE9PSAwICYmIHRoaXMuX3pJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5ld1pQYXJlbnQgPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZmluZFpDb250ZXh0KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChuZXdaUGFyZW50ID09PSB0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl96UGFyZW50LmluY1pDb250ZXh0VXNhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZW5hYmxlWlNvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoekluZGV4ICE9PSB0aGlzLl96SW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5felBhcmVudCAmJiB0aGlzLl96UGFyZW50Ll96Q29udGV4dFVzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pQYXJlbnQuZW5hYmxlWlNvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdaUGFyZW50ICE9PSB0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRaUGFyZW50KG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl96SW5kZXggPSB6SW5kZXg7XG5cbiAgICAgICAgICAgIGlmIChuZXdaUGFyZW50ICE9PSB0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRaUGFyZW50KG5ld1pQYXJlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJldklzWkNvbnRleHQgIT09IHRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVaQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlWkNvbnRleHQodGhpcy5fcGFyZW50LmZpbmRaQ29udGV4dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHJlc29ydCBpcyBkb25lLlxuICAgICAgICAgICAgdGhpcy5fekluZGV4UmVzb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl96UGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5felBhcmVudC5lbmFibGVaU29ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGdldCBmb3JjZVpJbmRleENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JjZVpJbmRleENvbnRleHQ7XG4gICAgfVxuXG4gICAgc2V0IGZvcmNlWkluZGV4Q29udGV4dCh2KSB7XG4gICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygxKTtcblxuICAgICAgICBsZXQgcHJldklzWkNvbnRleHQgPSB0aGlzLmlzWkNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5fZm9yY2VaSW5kZXhDb250ZXh0ID0gdjtcblxuICAgICAgICBpZiAocHJldklzWkNvbnRleHQgIT09IHRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNaQ29udGV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlWkNvbnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGVaQ29udGV4dCh0aGlzLl9wYXJlbnQuZmluZFpDb250ZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGVuYWJsZVpDb250ZXh0KHByZXZaQ29udGV4dCkge1xuICAgICAgICBpZiAocHJldlpDb250ZXh0ICYmIHByZXZaQ29udGV4dC5fekNvbnRleHRVc2FnZSA+IDApIHtcbiAgICAgICAgICAgIC8vIFRyYW5zZmVyIGZyb20gdXBwZXIgeiBjb250ZXh0IHRvIHRoaXMgeiBjb250ZXh0LlxuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuX2dldFpJbmRleGVkRGVzY3MoKTtcbiAgICAgICAgICAgIHJlc3VsdHMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQW5jZXN0b3JPZihjKSAmJiBjLl96SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYy5zZXRaUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldFpJbmRleGVkRGVzY3MoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLl9nZXRaSW5kZXhlZERlc2NzUmVjKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIF9nZXRaSW5kZXhlZERlc2NzUmVjKHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3pJbmRleCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NoaWxkcmVuICYmICF0aGlzLmlzWkNvbnRleHQoKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5fZ2V0WkluZGV4ZWREZXNjc1JlYyhyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRpc2FibGVaQ29udGV4dCgpIHtcbiAgICAgICAgLy8gVHJhbnNmZXIgZnJvbSB0aGlzIHogY29udGV4dCB0byB1cHBlciB6IGNvbnRleHQuXG4gICAgICAgIGlmICh0aGlzLl96Q29udGV4dFVzYWdlID4gMCkge1xuICAgICAgICAgICAgbGV0IG5ld1pQYXJlbnQgPSB0aGlzLl9wYXJlbnQuZmluZFpDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHotaW5kZXhlZCBjaGlsZHJlbiBhcmUgdXAgdG8gZGF0ZSAob2xkIG9uZXMgcmVtb3ZlZCkuXG4gICAgICAgICAgICBpZiAodGhpcy5felNvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRaSW5kZXhlZENoaWxkcmVuKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW4uc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuX3pJbmRleCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjLnNldFpQYXJlbnQobmV3WlBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0IGNvbG9yVWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvclVsO1xuICAgIH1cblxuICAgIHNldCBjb2xvclVsKGNvbG9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvclVsICE9PSBjb2xvcikge1xuICAgICAgICAgICAgdGhpcy5zZXRIYXNSZW5kZXJVcGRhdGVzKHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UgPyAzIDogMSk7XG4gICAgICAgICAgICB0aGlzLl9jb2xvclVsID0gY29sb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY29sb3JVcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yVXI7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yVXIoY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yVXIgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXModGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA/IDMgOiAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yVXIgPSBjb2xvcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgY29sb3JCbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQmw7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQmwoY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yQmwgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXModGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA/IDMgOiAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yQmwgPSBjb2xvcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBnZXQgY29sb3JCcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQnI7XG4gICAgfVxuXG4gICAgc2V0IGNvbG9yQnIoY29sb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yQnIgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXModGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSA/IDMgOiAxKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yQnIgPSBjb2xvcjtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHNldCBvblVwZGF0ZShmKSB7XG4gICAgICAgIHRoaXMuX29uVXBkYXRlID0gZjtcbiAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDcpO1xuICAgIH1cblxuICAgIHNldCBvbkFmdGVyVXBkYXRlKGYpIHtcbiAgICAgICAgdGhpcy5fb25BZnRlclVwZGF0ZSA9IGY7XG4gICAgICAgIHRoaXMuX3NldFJlY2FsYyg3KTtcbiAgICB9XG5cbiAgICBzZXQgb25BZnRlckNhbGNzKGYpIHtcbiAgICAgICAgdGhpcy5fb25BZnRlckNhbGNzID0gZjtcbiAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDcpO1xuICAgIH1cblxuICAgIGdldCBzaGFkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaGFkZXI7XG4gICAgfVxuXG4gICAgc2V0IHNoYWRlcih2KSB7XG4gICAgICAgIHRoaXMuc2V0SGFzUmVuZGVyVXBkYXRlcygxKTtcblxuICAgICAgICBsZXQgcHJldlNoYWRlciA9IHRoaXMuX3NoYWRlcjtcbiAgICAgICAgdGhpcy5fc2hhZGVyID0gdjtcbiAgICAgICAgaWYgKCF2ICYmIHByZXZTaGFkZXIpIHtcbiAgICAgICAgICAgIC8vIERpc2FibGVkIHNoYWRlci5cbiAgICAgICAgICAgIGxldCBuZXdTaGFkZXJPd25lciA9ICh0aGlzLl9wYXJlbnQgJiYgIXRoaXMuX3BhcmVudC5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCA/IHRoaXMuX3BhcmVudC5fc2hhZGVyT3duZXIgOiBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFNoYWRlck93bmVyUmVjdXJzaXZlKG5ld1NoYWRlck93bmVyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2KSB7XG4gICAgICAgICAgICAvLyBFbmFibGVkIHNoYWRlci5cbiAgICAgICAgICAgIHRoaXMuX3NldFNoYWRlck93bmVyUmVjdXJzaXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGFjdGl2ZVNoYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRlck93bmVyID8gdGhpcy5fc2hhZGVyT3duZXIuc2hhZGVyIDogdGhpcy5yZW5kZXJTdGF0ZS5kZWZhdWx0U2hhZGVyO1xuICAgIH1cblxuICAgIGdldCBhY3RpdmVTaGFkZXJPd25lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYWRlck93bmVyO1xuICAgIH1cblxuICAgIGdldCBjbGlwcGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaXBwaW5nO1xuICAgIH1cblxuICAgIHNldCBjbGlwcGluZyh2KSB7XG4gICAgICAgIGlmICh0aGlzLl9jbGlwcGluZyAhPT0gdikge1xuICAgICAgICAgICAgdGhpcy5fY2xpcHBpbmcgPSB2O1xuXG4gICAgICAgICAgICAvLyBGb3JjZSB1cGRhdGUgb2Ygc2Npc3NvciBieSB1cGRhdGluZyB0cmFuc2xhdGUuXG4gICAgICAgICAgICAvLyBBbHBoYSBtdXN0IGFsc28gYmUgdXBkYXRlZCBiZWNhdXNlIHRoZSBzY2lzc29yIGFyZWEgbWF5IGhhdmUgYmVlbiBlbXB0eS5cbiAgICAgICAgICAgIHRoaXMuX3NldFJlY2FsYygxICsgMik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgY2xpcGJveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsaXBib3g7XG4gICAgfVxuXG4gICAgc2V0IGNsaXBib3godikge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIG91dC1vZi1ib3VuZHMgZWxlbWVudCwgYWxsIGNoaWxkcmVuIHdpbGwgYWxzbyBiZSBpZ25vcmVkLlxuICAgICAgICAvLyBJdCB3aWxsIHNhdmUgdXMgZnJvbSBleGVjdXRpbmcgdGhlIHVwZGF0ZS9yZW5kZXIgbG9vcHMgZm9yIHRob3NlLlxuICAgICAgICAvLyBUaGUgb3B0aW1pemF0aW9uIHdpbGwgYmUgdXNlZCBpbW1lZGlhdGVseSBkdXJpbmcgdGhlIG5leHQgZnJhbWUuXG4gICAgICAgIHRoaXMuX2NsaXBib3ggPSB2O1xuICAgIH1cblxuICAgIF9zZXRTaGFkZXJPd25lclJlY3Vyc2l2ZShlbGVtZW50Q29yZSkge1xuICAgICAgICB0aGlzLl9zaGFkZXJPd25lciA9IGVsZW1lbnRDb3JlO1xuXG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbiAmJiAhdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICghYy5fc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuX3NldFNoYWRlck93bmVyUmVjdXJzaXZlKGVsZW1lbnRDb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgYy5faGFzUmVuZGVyVXBkYXRlcyA9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9zZXRTaGFkZXJPd25lckNoaWxkcmVuUmVjdXJzaXZlKGVsZW1lbnRDb3JlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGlmICghYy5fc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuX3NldFNoYWRlck93bmVyUmVjdXJzaXZlKGVsZW1lbnRDb3JlKTtcbiAgICAgICAgICAgICAgICAgICAgYy5faGFzUmVuZGVyVXBkYXRlcyA9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIF9oYXNSZW5kZXJDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQ29udGV4dCAhPT0gdGhpcy5fd29ybGRDb250ZXh0O1xuICAgIH1cblxuICAgIGdldCByZW5kZXJDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQ29udGV4dDtcbiAgICB9XG5cbiAgICB1cGRhdGVSZW5kZXJUb1RleHR1cmVFbmFibGVkKCkge1xuICAgICAgICAvLyBFbmZvcmNlIHRleHR1cml6ZXIgaW5pdGlhbGlzYXRpb24uXG4gICAgICAgIGxldCB2ID0gdGhpcy50ZXh0dXJpemVyLl9lbmFibGVkO1xuXG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVSZW5kZXJUb1RleHR1cmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVSZW5kZXJUb1RleHR1cmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9lbmFibGVSZW5kZXJUb1RleHR1cmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCkge1xuICAgICAgICAgICAgbGV0IHByZXZJc1pDb250ZXh0ID0gdGhpcy5pc1pDb250ZXh0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gbmV3IEVsZW1lbnRDb3JlQ29udGV4dCgpO1xuXG4gICAgICAgICAgICAvLyBJZiByZW5kZXIgdG8gdGV4dHVyZSBpcyBhY3RpdmUsIGEgbmV3IHNoYWRlciBjb250ZXh0IGlzIHN0YXJ0ZWQuXG4gICAgICAgICAgICB0aGlzLl9zZXRTaGFkZXJPd25lckNoaWxkcmVuUmVjdXJzaXZlKG51bGwpO1xuXG4gICAgICAgICAgICBpZiAoIXByZXZJc1pDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyIGNvbnRleHQgZm9yY2VzIHogY29udGV4dC5cbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVpDb250ZXh0KHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5maW5kWkNvbnRleHQoKSA6IG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByZW5kZXIgY29vcmRpbmF0ZXMgZ2V0IHVwZGF0ZWQuXG4gICAgICAgICAgICB0aGlzLl9zZXRSZWNhbGMoNyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyQWR2YW5jZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlzYWJsZVJlbmRlclRvVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRvVGV4dHVyZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5fc2V0U2hhZGVyT3duZXJDaGlsZHJlblJlY3Vyc2l2ZSh0aGlzLl9zaGFkZXJPd25lcik7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSB0aGlzLl93b3JsZENvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1pDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVaQ29udGV4dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcmVuZGVyIGNvb3JkaW5hdGVzIGdldCB1cGRhdGVkLlxuICAgICAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDcpO1xuXG4gICAgICAgICAgICB0aGlzLnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyU2ltcGxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNXaGl0ZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9jb2xvclVsID09PSAweEZGRkZGRkZGKSAmJiAodGhpcy5fY29sb3JVciA9PT0gMHhGRkZGRkZGRikgJiYgKHRoaXMuX2NvbG9yQmwgPT09IDB4RkZGRkZGRkYpICYmICh0aGlzLl9jb2xvckJyID09PSAweEZGRkZGRkZGKTtcbiAgICB9XG5cbiAgICBoYXNTaW1wbGVUZXhDb29yZHMoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fdWx4ID09PSAwKSAmJiAodGhpcy5fdWx5ID09PSAwKSAmJiAodGhpcy5fYnJ4ID09PSAxKSAmJiAodGhpcy5fYnJ5ID09PSAxKTtcbiAgICB9XG5cbiAgICBfc3Rhc2hUZXhDb29yZHMoKSB7XG4gICAgICAgIHRoaXMuX3N0YXNoZWRUZXhDb29yZHMgPSBbdGhpcy5fdWx4LCB0aGlzLl91bHksIHRoaXMuX2JyeCwgdGhpcy5fYnJ5XTtcbiAgICAgICAgdGhpcy5fdWx4ID0gMDtcbiAgICAgICAgdGhpcy5fdWx5ID0gMDtcbiAgICAgICAgdGhpcy5fYnJ4ID0gMTtcbiAgICAgICAgdGhpcy5fYnJ5ID0gMTtcbiAgICB9XG5cbiAgICBfdW5zdGFzaFRleENvb3JkcygpIHtcbiAgICAgICAgdGhpcy5fdWx4ID0gdGhpcy5fc3Rhc2hlZFRleENvb3Jkc1swXTtcbiAgICAgICAgdGhpcy5fdWx5ID0gdGhpcy5fc3Rhc2hlZFRleENvb3Jkc1sxXTtcbiAgICAgICAgdGhpcy5fYnJ4ID0gdGhpcy5fc3Rhc2hlZFRleENvb3Jkc1syXTtcbiAgICAgICAgdGhpcy5fYnJ5ID0gdGhpcy5fc3Rhc2hlZFRleENvb3Jkc1szXTtcbiAgICAgICAgdGhpcy5fc3Rhc2hlZFRleENvb3JkcyA9IG51bGw7XG4gICAgfVxuXG4gICAgX3N0YXNoQ29sb3JzKCkge1xuICAgICAgICB0aGlzLl9zdGFzaGVkQ29sb3JzID0gW3RoaXMuX2NvbG9yVWwsIHRoaXMuX2NvbG9yVXIsIHRoaXMuX2NvbG9yQnIsIHRoaXMuX2NvbG9yQmxdO1xuICAgICAgICB0aGlzLl9jb2xvclVsID0gMHhGRkZGRkZGRjtcbiAgICAgICAgdGhpcy5fY29sb3JVciA9IDB4RkZGRkZGRkY7XG4gICAgICAgIHRoaXMuX2NvbG9yQnIgPSAweEZGRkZGRkZGO1xuICAgICAgICB0aGlzLl9jb2xvckJsID0gMHhGRkZGRkZGRjtcbiAgICB9XG5cbiAgICBfdW5zdGFzaENvbG9ycygpIHtcbiAgICAgICAgdGhpcy5fY29sb3JVbCA9IHRoaXMuX3N0YXNoZWRDb2xvcnNbMF07XG4gICAgICAgIHRoaXMuX2NvbG9yVXIgPSB0aGlzLl9zdGFzaGVkQ29sb3JzWzFdO1xuICAgICAgICB0aGlzLl9jb2xvckJyID0gdGhpcy5fc3Rhc2hlZENvbG9yc1syXTtcbiAgICAgICAgdGhpcy5fY29sb3JCbCA9IHRoaXMuX3N0YXNoZWRDb2xvcnNbM107XG4gICAgICAgIHRoaXMuX3N0YXNoZWRDb2xvcnMgPSBudWxsO1xuICAgIH1cblxuICAgIGlzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9sb2NhbEFscGhhID4gMWUtMTQpO1xuICAgIH07XG5cbiAgICBnZXQgb3V0T2ZCb3VuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdXRPZkJvdW5kcztcbiAgICB9XG5cbiAgICBzZXQgYm91bmRzTWFyZ2luKHYpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogIG51bGw6IGluaGVyaXQgZnJvbSBwYXJlbnQuXG4gICAgICAgICAqICBudW1iZXJbNF06IHNwZWNpZmljIG1hcmdpbnM6IGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2JvdW5kc01hcmdpbiA9IHYgPyB2LnNsaWNlKCkgOiBudWxsO1xuXG4gICAgICAgIC8vIFdlIGZvcmNlIHJlY2FsYyBpbiBvcmRlciB0byBzZXQgYWxsIGJvdW5kc01hcmdpbiByZWN1cnNpdmVseSBkdXJpbmcgdGhlIG5leHQgdXBkYXRlLlxuICAgICAgICB0aGlzLl90cmlnZ2VyUmVjYWxjVHJhbnNsYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGJvdW5kc01hcmdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kc01hcmdpbjtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3JlY2FsYyB8PSB0aGlzLl9wYXJlbnQuX3BSZWNhbGM7XG5cbiAgICAgICAgaWYgKHRoaXMuX2xheW91dCAmJiB0aGlzLl9sYXlvdXQuaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWNhbGMgJiAyNTYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXlvdXQubGF5b3V0RmxleFRyZWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgodGhpcy5fcmVjYWxjICYgMikgJiYgdGhpcy5fb3B0RmxhZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmVsYXRpdmVEaW1GdW5jcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX29uVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBCbG9jayBhbGwgJ3Vwd2FyZHMnIHVwZGF0ZXMgd2hlbiBjaGFuZ2luZyB0aGluZ3MgaW4gdGhpcyBicmFuY2guXG4gICAgICAgICAgICB0aGlzLl9oYXNVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX29uVXBkYXRlKHRoaXMuZWxlbWVudCwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwdyA9IHRoaXMuX3BhcmVudC5fd29ybGRDb250ZXh0O1xuICAgICAgICBsZXQgdyA9IHRoaXMuX3dvcmxkQ29udGV4dDtcbiAgICAgICAgY29uc3QgdmlzaWJsZSA9IChwdy5hbHBoYSAmJiB0aGlzLl9sb2NhbEFscGhhKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2UgbXVzdCB1cGRhdGUgaWY6XG4gICAgICAgICAqIC0gYnJhbmNoIGNvbnRhaW5zIHVwZGF0ZXMgKGV2ZW4gd2hlbiBpbnZpc2libGUgYmVjYXVzZSBpdCBtYXkgY29udGFpbiB6LWluZGV4ZWQgZGVzY2VuZGFudHMpXG4gICAgICAgICAqIC0gdGhlcmUgYXJlIChpbmhlcml0ZWQpIHVwZGF0ZXMgYW5kIHRoaXMgYnJhbmNoIGlzIHZpc2libGVcbiAgICAgICAgICogLSB0aGlzIGJyYW5jaCBiZWNvbWVzIGludmlzaWJsZSAoZGVzY3MgbWF5IGJlIHotaW5kZXhlZCBzbyB3ZSBtdXN0IHVwZGF0ZSBhbGwgYWxwaGEgdmFsdWVzKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuX2hhc1VwZGF0ZXMgfHwgKHRoaXMuX3JlY2FsYyAmJiB2aXNpYmxlKSB8fCAody5hbHBoYSAmJiAhdmlzaWJsZSkpIHtcbiAgICAgICAgICAgIGxldCByZWNhbGMgPSB0aGlzLl9yZWNhbGM7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB3b3JsZCBjb29yZHMvYWxwaGEuXG4gICAgICAgICAgICBpZiAocmVjYWxjICYgMSkge1xuICAgICAgICAgICAgICAgIGlmICghdy5hbHBoYSAmJiB2aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY29tZXMgdmlzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzUmVuZGVyVXBkYXRlcyA9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHcuYWxwaGEgPSBwdy5hbHBoYSAqIHRoaXMuX2xvY2FsQWxwaGE7XG5cbiAgICAgICAgICAgICAgICBpZiAody5hbHBoYSA8IDFlLTE0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRpbnkgcm91bmRpbmcgZXJyb3JzIG1heSBjYXVzZSBmYWlsaW5nIHZpc2liaWxpdHkgdGVzdHMuXG4gICAgICAgICAgICAgICAgICAgIHcuYWxwaGEgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlY2FsYyAmIDYpIHtcbiAgICAgICAgICAgICAgICB3LnB4ID0gcHcucHggKyB0aGlzLl9sb2NhbFB4ICogcHcudGE7XG4gICAgICAgICAgICAgICAgdy5weSA9IHB3LnB5ICsgdGhpcy5fbG9jYWxQeSAqIHB3LnRkO1xuICAgICAgICAgICAgICAgIGlmIChwdy50YiAhPT0gMCkgdy5weCArPSB0aGlzLl9sb2NhbFB5ICogcHcudGI7XG4gICAgICAgICAgICAgICAgaWYgKHB3LnRjICE9PSAwKSB3LnB5ICs9IHRoaXMuX2xvY2FsUHggKiBwdy50YztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlY2FsYyAmIDQpIHtcbiAgICAgICAgICAgICAgICB3LnRhID0gdGhpcy5fbG9jYWxUYSAqIHB3LnRhO1xuICAgICAgICAgICAgICAgIHcudGIgPSB0aGlzLl9sb2NhbFRkICogcHcudGI7XG4gICAgICAgICAgICAgICAgdy50YyA9IHRoaXMuX2xvY2FsVGEgKiBwdy50YztcbiAgICAgICAgICAgICAgICB3LnRkID0gdGhpcy5fbG9jYWxUZCAqIHB3LnRkO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29tcGxleCkge1xuICAgICAgICAgICAgICAgICAgICB3LnRhICs9IHRoaXMuX2xvY2FsVGMgKiBwdy50YjtcbiAgICAgICAgICAgICAgICAgICAgdy50YiArPSB0aGlzLl9sb2NhbFRiICogcHcudGE7XG4gICAgICAgICAgICAgICAgICAgIHcudGMgKz0gdGhpcy5fbG9jYWxUYyAqIHB3LnRkO1xuICAgICAgICAgICAgICAgICAgICB3LnRkICs9IHRoaXMuX2xvY2FsVGIgKiBwdy50YztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSByZW5kZXIgY29vcmRzL2FscGhhLlxuICAgICAgICAgICAgY29uc3QgcHIgPSB0aGlzLl9wYXJlbnQuX3JlbmRlckNvbnRleHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50Ll9oYXNSZW5kZXJDb250ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0ID0gdGhpcy5fcmVuZGVyQ29udGV4dCA9PT0gdGhpcy5fd29ybGRDb250ZXh0O1xuICAgICAgICAgICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IHJlbmRlciBjb250ZXh0IGJ1aWxkOiBtYWtlIHN1cmUgdGhhdCBpdCBpcyBmdWxseSBpbml0aWFsaXplZCBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgd2UgZ2V0IGludG8gYm91bmRzIGxhdGVyLCB0aGUgcmVuZGVyIGNvbnRleHQgd291bGQgbm90IGJlIGluaXRpYWxpemVkIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IG5ldyBFbGVtZW50Q29yZUNvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCByID0gdGhpcy5fcmVuZGVyQ29udGV4dDtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB3b3JsZCBjb29yZHMvYWxwaGEuXG4gICAgICAgICAgICAgICAgaWYgKGluaXQgfHwgKHJlY2FsYyAmIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHIuYWxwaGEgPSBwci5hbHBoYSAqIHRoaXMuX2xvY2FsQWxwaGE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuYWxwaGEgPCAxZS0xNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5hbHBoYSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5pdCB8fCAocmVjYWxjICYgNikpIHtcbiAgICAgICAgICAgICAgICAgICAgci5weCA9IHByLnB4ICsgdGhpcy5fbG9jYWxQeCAqIHByLnRhO1xuICAgICAgICAgICAgICAgICAgICByLnB5ID0gcHIucHkgKyB0aGlzLl9sb2NhbFB5ICogcHIudGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwci50YiAhPT0gMCkgci5weCArPSB0aGlzLl9sb2NhbFB5ICogcHIudGI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwci50YyAhPT0gMCkgci5weSArPSB0aGlzLl9sb2NhbFB4ICogcHIudGM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2V0IHRoZSByZWNhbGMgdG9nZ2xlLCBiZWNhdXNlIHdlIG11c3QgbWFrZSBzdXJlIHRoYXQgdGhlIHNjaXNzb3IgaXMgdXBkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgcmVjYWxjIHw9IDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGluaXQgfHwgKHJlY2FsYyAmIDQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHIudGEgPSB0aGlzLl9sb2NhbFRhICogcHIudGE7XG4gICAgICAgICAgICAgICAgICAgIHIudGIgPSB0aGlzLl9sb2NhbFRkICogcHIudGI7XG4gICAgICAgICAgICAgICAgICAgIHIudGMgPSB0aGlzLl9sb2NhbFRhICogcHIudGM7XG4gICAgICAgICAgICAgICAgICAgIHIudGQgPSB0aGlzLl9sb2NhbFRkICogcHIudGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzQ29tcGxleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgci50YSArPSB0aGlzLl9sb2NhbFRjICogcHIudGI7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnRiICs9IHRoaXMuX2xvY2FsVGIgKiBwci50YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIudGMgKz0gdGhpcy5fbG9jYWxUYyAqIHByLnRkO1xuICAgICAgICAgICAgICAgICAgICAgICAgci50ZCArPSB0aGlzLl9sb2NhbFRiICogcHIudGM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSB0aGlzLl93b3JsZENvbnRleHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmN0eC51cGRhdGVUcmVlT3JkZXIgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHgudXBkYXRlVHJlZU9yZGVyID0gdGhpcy5fdXBkYXRlVHJlZU9yZGVyICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVHJlZU9yZGVyID0gdGhpcy5jdHgudXBkYXRlVHJlZU9yZGVyKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGV0aGVyIHdlIG11c3QgdXNlIGEgJ3JlbmRlclRleHR1cmUnLlxuICAgICAgICAgICAgY29uc3QgdXNlUmVuZGVyVG9UZXh0dXJlID0gdGhpcy5fcmVuZGVyVG9UZXh0dXJlRW5hYmxlZCAmJiB0aGlzLl90ZXh0dXJpemVyLm11c3RSZW5kZXJUb1RleHR1cmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUgIT09IHVzZVJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIC8vIENvb3JkcyBtdXN0IGJlIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjYWxjIHw9IDIgKyA0O1xuXG4gICAgICAgICAgICAgICAgLy8gU2Npc3NvciBtYXkgY2hhbmdlOiBmb3JjZSB1cGRhdGUuXG4gICAgICAgICAgICAgICAgcmVjYWxjIHw9IDI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtdXN0IHJlbGVhc2UgdGhlIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSA9IHVzZVJlbmRlclRvVGV4dHVyZTtcblxuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX3JlbmRlckNvbnRleHQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGJib3hXID0gdGhpcy5fZGltc1Vua25vd24gPyAyMDQ4IDogdGhpcy5fdztcbiAgICAgICAgICAgIGNvbnN0IGJib3hIID0gdGhpcy5fZGltc1Vua25vd24gPyAyMDQ4IDogdGhpcy5faDtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGEgYmJveCBmb3IgdGhpcyBlbGVtZW50LlxuICAgICAgICAgICAgbGV0IHN4LCBzeSwgZXgsIGV5O1xuICAgICAgICAgICAgY29uc3QgckNvbXBsZXggPSAoci50YiAhPT0gMCkgfHwgKHIudGMgIT09IDApIHx8IChyLnRhIDwgMCkgfHwgKHIudGQgPCAwKTtcbiAgICAgICAgICAgIGlmIChyQ29tcGxleCkge1xuICAgICAgICAgICAgICAgIHN4ID0gTWF0aC5taW4oMCwgYmJveFcgKiByLnRhLCBiYm94VyAqIHIudGEgKyBiYm94SCAqIHIudGIsIGJib3hIICogci50YikgKyByLnB4O1xuICAgICAgICAgICAgICAgIGV4ID0gTWF0aC5tYXgoMCwgYmJveFcgKiByLnRhLCBiYm94VyAqIHIudGEgKyBiYm94SCAqIHIudGIsIGJib3hIICogci50YikgKyByLnB4O1xuICAgICAgICAgICAgICAgIHN5ID0gTWF0aC5taW4oMCwgYmJveFcgKiByLnRjLCBiYm94VyAqIHIudGMgKyBiYm94SCAqIHIudGQsIGJib3hIICogci50ZCkgKyByLnB5O1xuICAgICAgICAgICAgICAgIGV5ID0gTWF0aC5tYXgoMCwgYmJveFcgKiByLnRjLCBiYm94VyAqIHIudGMgKyBiYm94SCAqIHIudGQsIGJib3hIICogci50ZCkgKyByLnB5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeCA9IHIucHg7XG4gICAgICAgICAgICAgICAgZXggPSByLnB4ICsgci50YSAqIGJib3hXO1xuICAgICAgICAgICAgICAgIHN5ID0gci5weTtcbiAgICAgICAgICAgICAgICBleSA9IHIucHkgKyByLnRkICogYmJveEg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9kaW1zVW5rbm93biAmJiAockNvbXBsZXggfHwgdGhpcy5fbG9jYWxUYSA8IDEgfHwgdGhpcy5fbG9jYWxUYiA8IDEpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhIG5vbi1pZGVudGl0eSBtYXRyaXgsIHdlIG11c3QgZXh0ZW5kIHRoZSBiYm94IHNvIHRoYXQgd2l0aGluQm91bmRzIGFuZFxuICAgICAgICAgICAgICAgIC8vICBzY2lzc29ycyB3aWxsIGluY2x1ZGUgdGhlIGNvbXBsZXRlIHJhbmdlIG9mIChwb3NpdGl2ZSkgZGltZW5zaW9ucyB1cCB0byAsbGguXG4gICAgICAgICAgICAgICAgY29uc3QgbnggPSB0aGlzLl94ICogcHIudGEgKyB0aGlzLl95ICogcHIudGIgKyBwci5weDtcbiAgICAgICAgICAgICAgICBjb25zdCBueSA9IHRoaXMuX3ggKiBwci50YyArIHRoaXMuX3kgKiBwci50ZCArIHByLnB5O1xuICAgICAgICAgICAgICAgIGlmIChueCA8IHN4KSBzeCA9IG54O1xuICAgICAgICAgICAgICAgIGlmIChueSA8IHN5KSBzeSA9IG55O1xuICAgICAgICAgICAgICAgIGlmIChueCA+IGV4KSBleCA9IG54O1xuICAgICAgICAgICAgICAgIGlmIChueSA+IGV5KSBleSA9IG55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVjYWxjICYgNiB8fCAhdGhpcy5fc2Npc3NvciAvKiBpbml0aWFsICovKSB7XG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgd2UgbXVzdCAnY2xpcCcuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NsaXBwaW5nICYmIHIuaXNTcXVhcmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFyZW50IHJlbmRlcnMgdG8gYSB0ZXh0dXJlLCBpdCdzIHNjaXNzb3Igc2hvdWxkIGJlIGlnbm9yZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9wYXJlbnQuX3VzZVJlbmRlclRvVGV4dHVyZSA/IHRoaXMuX3BhcmVudC5fdmlld3BvcnQgOiB0aGlzLl9wYXJlbnQuX3NjaXNzb3I7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSBzY2lzc29yIGFyZWFzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbHggPSBNYXRoLm1heChhcmVhWzBdLCBzeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBseSA9IE1hdGgubWF4KGFyZWFbMV0sIHN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oYXJlYVsyXSArIGFyZWFbMF0sIGV4KSAtIGx4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGFyZWFbM10gKyBhcmVhWzFdLCBleSkgLSBseVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjaXNzb3IgPSBbc3gsIHN5LCBleCAtIHN4LCBleSAtIHN5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNsaXBwaW5nOiByZXVzZSBwYXJlbnQgc2Npc3Nvci5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2Npc3NvciA9IHRoaXMuX3BhcmVudC5fdXNlUmVuZGVyVG9UZXh0dXJlID8gdGhpcy5fcGFyZW50Ll92aWV3cG9ydCA6IHRoaXMuX3BhcmVudC5fc2Npc3NvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3V0T2ZCb3VuZHMgbWFyZ2luLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvdW5kc01hcmdpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY0JvdW5kc01hcmdpbiA9IHRoaXMuX2JvdW5kc01hcmdpbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjQm91bmRzTWFyZ2luID0gdGhpcy5fcGFyZW50Ll9yZWNCb3VuZHNNYXJnaW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkFmdGVyQ2FsY3MpIHtcbiAgICAgICAgICAgICAgICAvLyBBZnRlciBjYWxjcyBtYXkgY2hhbmdlIHJlbmRlciBjb29yZHMsIHNjaXNzb3IgYW5kL29yIHJlY0JvdW5kc01hcmdpbi5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25BZnRlckNhbGNzKHRoaXMuZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgYmJveC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJDb21wbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzeCA9IE1hdGgubWluKDAsIGJib3hXICogci50YSwgYmJveFcgKiByLnRhICsgYmJveEggKiByLnRiLCBiYm94SCAqIHIudGIpICsgci5weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ID0gTWF0aC5tYXgoMCwgYmJveFcgKiByLnRhLCBiYm94VyAqIHIudGEgKyBiYm94SCAqIHIudGIsIGJib3hIICogci50YikgKyByLnB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3kgPSBNYXRoLm1pbigwLCBiYm94VyAqIHIudGMsIGJib3hXICogci50YyArIGJib3hIICogci50ZCwgYmJveEggKiByLnRkKSArIHIucHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleSA9IE1hdGgubWF4KDAsIGJib3hXICogci50YywgYmJveFcgKiByLnRjICsgYmJveEggKiByLnRkLCBiYm94SCAqIHIudGQpICsgci5weTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN4ID0gci5weDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ID0gci5weCArIHIudGEgKiBiYm94VztcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5ID0gci5weTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV5ID0gci5weSArIHIudGQgKiBiYm94SDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kaW1zVW5rbm93biAmJiAockNvbXBsZXggfHwgdGhpcy5fbG9jYWxUYSA8IDEgfHwgdGhpcy5fbG9jYWxUYiA8IDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBueCA9IHRoaXMuX3ggKiBwci50YSArIHRoaXMuX3kgKiBwci50YiArIHByLnB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbnkgPSB0aGlzLl94ICogcHIudGMgKyB0aGlzLl95ICogcHIudGQgKyBwci5weTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChueCA8IHN4KSBzeCA9IG54O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG55IDwgc3kpIHN5ID0gbnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobnggPiBleCkgZXggPSBueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChueSA+IGV5KSBleSA9IG55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50Ll9vdXRPZkJvdW5kcyA9PT0gMikge1xuICAgICAgICAgICAgICAgIC8vIEluaGVyaXQgcGFyZW50IG91dCBvZiBib3VuZHNuZXNzLlxuICAgICAgICAgICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMjtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2l0aGluQm91bmRzTWFyZ2luID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5fZGlzYWJsZVdpdGhpbkJvdW5kc01hcmdpbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2FsYyAmIDYpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjaGVjayBpZiBlbGVtZW50IGlzIG91dC1vZi1ib3VuZHMgKGFsbCBzZXR0aW5ncyB0aGF0IGFmZmVjdCB0aGlzIHNob3VsZCBlbmFibGUgcmVjYWxjIGJpdCAyIG9yIDQpLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB3aXRoaW5NYXJnaW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9mZnNjcmVlbnMgYXJlIGFsd2F5cyByZW5kZXJlZCBhcyBsb25nIGFzIHRoZSBwYXJlbnQgaXMgd2l0aGluIGJvdW5kcy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJUb1RleHR1cmVFbmFibGVkIHx8ICF0aGlzLl90ZXh0dXJpemVyIHx8ICF0aGlzLl90ZXh0dXJpemVyLnJlbmRlck9mZnNjcmVlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NjaXNzb3IgJiYgKHRoaXMuX3NjaXNzb3JbMl0gPD0gMCB8fCB0aGlzLl9zY2lzc29yWzNdIDw9IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1wdHkgc2Npc3NvciBhcmVhLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGJib3ggdG8gY2hlY2sgb3V0LW9mLWJvdW5kbmVzcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuX3NjaXNzb3JbMF0gPiBleCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuX3NjaXNzb3JbMV0gPiBleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN4ID4gKHRoaXMuX3NjaXNzb3JbMF0gKyB0aGlzLl9zY2lzc29yWzJdKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN5ID4gKHRoaXMuX3NjaXNzb3JbMV0gKyB0aGlzLl9zY2lzc29yWzNdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0T2ZCb3VuZHMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vdXRPZkJvdW5kcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xpcHBpbmcgfHwgdGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlIHx8ICh0aGlzLl9jbGlwYm94ICYmIChiYm94VyAmJiBiYm94SCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhpbk1hcmdpbiA9ICh0aGlzLl9vdXRPZkJvdW5kcyA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpdGhpbk1hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlLXRlc3QsIG5vdyB3aXRoIG1hcmdpbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlY0JvdW5kc01hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoaW5NYXJnaW4gPSAhKChleCA8IHRoaXMuX3NjaXNzb3JbMF0gLSB0aGlzLl9yZWNCb3VuZHNNYXJnaW5bMl0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXkgPCB0aGlzLl9zY2lzc29yWzFdIC0gdGhpcy5fcmVjQm91bmRzTWFyZ2luWzNdKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN4ID4gdGhpcy5fc2Npc3NvclswXSArIHRoaXMuX3NjaXNzb3JbMl0gKyB0aGlzLl9yZWNCb3VuZHNNYXJnaW5bMF0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3kgPiB0aGlzLl9zY2lzc29yWzFdICsgdGhpcy5fc2Npc3NvclszXSArIHRoaXMuX3JlY0JvdW5kc01hcmdpblsxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhpbk1hcmdpbiA9ICEoKGV4IDwgdGhpcy5fc2Npc3NvclswXSAtIDEwMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChleSA8IHRoaXMuX3NjaXNzb3JbMV0gLSAxMDApIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3ggPiB0aGlzLl9zY2lzc29yWzBdICsgdGhpcy5fc2Npc3NvclsyXSArIDEwMCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzeSA+IHRoaXMuX3NjaXNzb3JbMV0gKyB0aGlzLl9zY2lzc29yWzNdICsgMTAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aXRoaW5NYXJnaW4gJiYgdGhpcy5fb3V0T2ZCb3VuZHMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hpbGRyZW4gbXVzdCBiZSB2aXNpdGVkIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBlbGVtZW50cyB0aGF0IGFyZSB3aXRoaW4gbWFyZ2luLCBzbyBtdXN0IGJlIHZpc2libGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX291dE9mQm91bmRzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2l0aGluQm91bmRzTWFyZ2luICE9PSB3aXRoaW5NYXJnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbiA9IHdpdGhpbk1hcmdpbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpdGhpbkJvdW5kc01hcmdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IHVwZGF0ZSB0aGluZ3MgKHR4TG9hZGVkIGV2ZW50cykgaW4gdGhlIGVsZW1lbnQgaXRzZWxmLCBidXQgYWxzbyBpbiBkZXNjZW5kYW50cyBhbmQgYW5jZXN0b3JzLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlcyBpbiBhbmNlc3RvcnMgc2hvdWxkIGJlIGV4ZWN1dGVkIGR1cmluZyB0aGUgbmV4dCBjYWxsIG9mIHRoZSBzdGFnZSB1cGRhdGUuIEJ1dCB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSBjYXJlIHRoYXQgdGhlIF9yZWNhbGMgYW5kIF9oYXNVcGRhdGVzIGZsYWdzIGFyZSBwcm9wZXJseSByZWdpc3RlcmVkLiBUaGF0J3Mgd2h5IHdlIGNsZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm90aCBiZWZvcmUgZW50ZXJpbmcgdGhlIGNoaWxkcmVuLCBhbmQgdXNlIF9wUmVjYWxjIHRvIHRyYW5zZmVyIGluaGVyaXRlZCB1cGRhdGVzIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBfcmVjYWxjIGRpcmVjdGx5LlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlcyBpbiBkZXNjZW5kYW50cyBhcmUgYXV0b21hdGljYWxseSBleGVjdXRlZCB3aXRoaW4gdGhlIGN1cnJlbnQgdXBkYXRlIGxvb3AsIHRob3VnaCB3ZSBtdXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGFrZSBjYXJlIHRvIG5vdCB1cGRhdGUgdGhlIGhhc1VwZGF0ZXMgZmxhZyB1bm5lY2Vzc2FyaWx5IGluIGFuY2VzdG9ycy4gV2UgYWNoaWV2ZSB0aGlzIGJ5IG1ha2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1cmUgdGhhdCB0aGUgaGFzVXBkYXRlcyBmbGFnIG9mIHRoaXMgZWxlbWVudCBpcyB0dXJuZWQgb24sIHdoaWNoIGJsb2NrcyBpdCBmb3IgYW5jZXN0b3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhc1VwZGF0ZXMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjYWxjID0gdGhpcy5fcmVjYWxjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY2FsYyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Ll9lbmFibGVXaXRoaW5Cb3VuZHNNYXJnaW4oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWNhbGMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBlbGVtZW50IG5lZWRzIHRvIGJlIHJlLXVwZGF0ZWQgbm93LCBiZWNhdXNlIHdlIHdhbnQgdGhlIGRpbWVuc2lvbnMgKGFuZCBvdGhlciBjaGFuZ2VzKSB0byBiZSB1cGRhdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWNhbGMgPSByZWNhbGM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5fZGlzYWJsZVdpdGhpbkJvdW5kc01hcmdpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHZpZXdwb3J0IG5lY2Vzc2FyeSBmb3IgY2hpbGRyZW4gc2Npc3NvciBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdmlld3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRbMl0gPSBiYm94VztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRbM10gPSBiYm94SDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydCA9IFswLCAwLCBiYm94VywgYmJveEhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBiaXRzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb3BpZWQgdG8gdGhlIGNoaWxkcmVuIChjdXJyZW50bHkgYWxsIGFyZSkuXG4gICAgICAgICAgICB0aGlzLl9wUmVjYWxjID0gKHRoaXMuX3JlY2FsYyAmIDEzNSk7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIGZsYWdzIHNvIHRoYXQgZnV0dXJlIHVwZGF0ZXMgYXJlIHByb3Blcmx5IGRldGVjdGVkLlxuICAgICAgICAgICAgdGhpcy5fcmVjYWxjID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2hhc1VwZGF0ZXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX291dE9mQm91bmRzIDwgMikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91c2VSZW5kZXJUb1RleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmxkQ29udGV4dC5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXphdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JsZCBjb250ZXh0IGlzIGFscmVhZHkgaWRlbnRpdHk6IHVzZSB0aGUgd29ybGQgY29udGV4dCBhcyByZW5kZXIgY29udGV4dCB0byBwcmV2ZW50cyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuY2VzdG9ycyBmcm9tIGhhdmluZyB0byB1cGRhdGUgdGhlIHJlbmRlciBjb250ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQ29udGV4dCA9IHRoaXMuX3dvcmxkQ29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IHJlcGxhY2UgdGhlIHJlbmRlciBjb29yZCBhdHRyaWJzIGJ5IHRoZSBpZGVudGl0eSBtYXRyaXguXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgY2hpbGRyZW4gdG8gY2FsY3VsYXRlIHRoZSByZW5kZXIgY29udGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSBFbGVtZW50Q29yZUNvbnRleHQuSURFTlRJVFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJDb250ZXh0ID0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuW2ldLl9oYXNVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0udXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCBsb3NlIHRoZSAnaW5oZXJpdGVkJyB1cGRhdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLl9yZWNhbGMgfD0gdGhpcy5fcFJlY2FsYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS51cGRhdGVPdXRPZkJvdW5kcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fb25BZnRlclVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQWZ0ZXJVcGRhdGUodGhpcy5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN0eC51cGRhdGVUcmVlT3JkZXIgPT09IC0xIHx8IHRoaXMuX3VwZGF0ZVRyZWVPcmRlciA+PSB0aGlzLmN0eC51cGRhdGVUcmVlT3JkZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBuZXcgdHJlZSBvcmRlciBkb2VzIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgY3VycmVudCAoZ2FwcyBhbGxvd2VkKSB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhdmVyc2UgdGhlIGJyYW5jaC5cbiAgICAgICAgICAgICAgICB0aGlzLmN0eC51cGRhdGVUcmVlT3JkZXIgPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmVlT3JkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9hcHBseVJlbGF0aXZlRGltRnVuY3MoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcHRGbGFncyAmIDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9mdW5jWCh0aGlzLl9wYXJlbnQudyk7XG4gICAgICAgICAgICBpZiAoeCAhPT0gdGhpcy5feCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsUHggKz0gKHggLSB0aGlzLl94KTtcbiAgICAgICAgICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0RmxhZ3MgJiAyKSB7XG4gICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fZnVuY1kodGhpcy5fcGFyZW50LmgpO1xuICAgICAgICAgICAgaWYgKHkgIT09IHRoaXMuX3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbFB5ICs9ICh5IC0gdGhpcy5feSk7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hhbmdlZERpbXMgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX29wdEZsYWdzICYgNCkge1xuICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMuX2Z1bmNXKHRoaXMuX3BhcmVudC53KTtcbiAgICAgICAgICAgIGlmICh3ICE9PSB0aGlzLl93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdyA9IHc7XG4gICAgICAgICAgICAgICAgY2hhbmdlZERpbXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRGbGFncyAmIDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSB0aGlzLl9mdW5jSCh0aGlzLl9wYXJlbnQuaCk7XG4gICAgICAgICAgICBpZiAoaCAhPT0gdGhpcy5faCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ggPSBoO1xuICAgICAgICAgICAgICAgIGNoYW5nZWREaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VkRGltcykge1xuICAgICAgICAgICAgLy8gUmVjYWxjIG1vdW50LCBzY2FsZSBwb3NpdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY0xvY2FsVHJhbnNsYXRlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5vbkRpbWVuc2lvbnNDaGFuZ2VkKHRoaXMuX3csIHRoaXMuX2gpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlT3V0T2ZCb3VuZHMoKSB7XG4gICAgICAgIC8vIFByb3BhZ2F0ZSBvdXRPZkJvdW5kcyBmbGFnIHRvIGRlc2NlbmRhbnRzIChuZWNlc3NhcnkgYmVjYXVzZSBvZiB6LWluZGV4aW5nKS5cbiAgICAgICAgLy8gSW52aXNpYmxlIGVsZW1lbnRzIGFyZSBub3QgZHJhd24gYW55d2F5LiBXaGVuIGFscGhhIGlzIHVwZGF0ZWQsIHNvIHdpbGwgX291dE9mQm91bmRzLlxuICAgICAgICBpZiAodGhpcy5fb3V0T2ZCb3VuZHMgIT09IDIgJiYgdGhpcy5fcmVuZGVyQ29udGV4dC5hbHBoYSA+IDApIHtcblxuICAgICAgICAgICAgLy8gSW5oZXJpdCBwYXJlbnQgb3V0IG9mIGJvdW5kc25lc3MuXG4gICAgICAgICAgICB0aGlzLl9vdXRPZkJvdW5kcyA9IDI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93aXRoaW5Cb3VuZHNNYXJnaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuX2Rpc2FibGVXaXRoaW5Cb3VuZHNNYXJnaW4oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0udXBkYXRlT3V0T2ZCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVUcmVlT3JkZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbEFscGhhICYmICh0aGlzLl9vdXRPZkJvdW5kcyAhPT0gMikpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRyZWVPcmRlciA9IHRoaXMuY3R4LnVwZGF0ZVRyZWVPcmRlcisrO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS51cGRhdGVUcmVlT3JkZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVuZGVyU2ltcGxlKCkge1xuICAgICAgICB0aGlzLl9oYXNSZW5kZXJVcGRhdGVzID0gMDtcblxuICAgICAgICBpZiAodGhpcy5felNvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydFpJbmRleGVkQ2hpbGRyZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vdXRPZkJvdW5kcyA8IDIgJiYgdGhpcy5fcmVuZGVyQ29udGV4dC5hbHBoYSkge1xuICAgICAgICAgICAgbGV0IHJlbmRlclN0YXRlID0gdGhpcy5yZW5kZXJTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKCh0aGlzLl9vdXRPZkJvdW5kcyA9PT0gMCkgJiYgdGhpcy5fZGlzcGxheWVkVGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNoYWRlcih0aGlzLmFjdGl2ZVNoYWRlciwgdGhpcy5fc2hhZGVyT3duZXIpO1xuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNjaXNzb3IodGhpcy5fc2Npc3Nvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZS5hZGRRdWFkKHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHNvIGFkZCBjaGlsZHJlbiB0byB0aGUgVkJPLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3pDb250ZXh0VXNhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl96SW5kZXhlZENoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fekluZGV4ZWRDaGlsZHJlbltpXS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW5baV0uX3pJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHpJbmRleCBpcyBzZXQsIHRoaXMgaXRlbSBhbHJlYWR5IGJlbG9uZ3MgdG8gYSB6SW5kZXhlZENoaWxkcmVuIGFycmF5IGluIG9uZSBvZiB0aGUgYW5jZXN0b3JzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVuZGVyQWR2YW5jZWQoKSB7XG4gICAgICAgIGNvbnN0IGhhc1JlbmRlclVwZGF0ZXMgPSB0aGlzLl9oYXNSZW5kZXJVcGRhdGVzO1xuXG4gICAgICAgIC8vIFdlIG11c3QgY2xlYXIgdGhlIGhhc1JlbmRlclVwZGF0ZXMgZmxhZyBiZWZvcmUgcmVuZGVyaW5nLCBiZWNhdXNlIHVwZGF0aW5nIHJlc3VsdCB0ZXh0dXJlcyBpbiBjb21iaW5hdGlvblxuICAgICAgICAvLyB3aXRoIHotaW5kZXhpbmcgbWF5IHRyaWdnZXIgcmVuZGVyIHVwZGF0ZXMgb24gYSByZW5kZXIgYnJhbmNoIHRoYXQgaXMgJ2hhbGYgZG9uZScuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGZ1bGwgcmVuZGVyIGJyYW5jaCBpcyBtYXJrZWQgZm9yIHJlbmRlciB1cGRhdGVzLCBub3Qgb25seSBoYWxmIChsZWFkaW5nIHRvIGZyZWV6ZSkuXG4gICAgICAgIHRoaXMuX2hhc1JlbmRlclVwZGF0ZXMgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLl96U29ydCkge1xuICAgICAgICAgICAgdGhpcy5zb3J0WkluZGV4ZWRDaGlsZHJlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX291dE9mQm91bmRzIDwgMiAmJiB0aGlzLl9yZW5kZXJDb250ZXh0LmFscGhhKSB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyU3RhdGUgPSB0aGlzLnJlbmRlclN0YXRlO1xuXG4gICAgICAgICAgICBsZXQgbXVzdFJlbmRlckNoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCByZW5kZXJUZXh0dXJlSW5mbztcbiAgICAgICAgICAgIGxldCBwcmV2UmVuZGVyVGV4dHVyZUluZm87XG4gICAgICAgICAgICBpZiAodGhpcy5fdXNlUmVuZGVyVG9UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3cgPT09IDAgfHwgdGhpcy5faCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgdGhpcyBicmFuY2ggYW5kIGRvbid0IGRyYXcgYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl90ZXh0dXJpemVyLmhhc1JlbmRlclRleHR1cmUoKSB8fCAoaGFzUmVuZGVyVXBkYXRlcyA+PSAzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTd2l0Y2ggdG8gZGVmYXVsdCBzaGFkZXIgZm9yIGJ1aWxkaW5nIHVwIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0U2hhZGVyKHJlbmRlclN0YXRlLmRlZmF1bHRTaGFkZXIsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXZSZW5kZXJUZXh0dXJlSW5mbyA9IHJlbmRlclN0YXRlLnJlbmRlclRleHR1cmVJbmZvO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlVGV4dHVyZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogMCwgIC8vIFNldCBieSBDb3JlUmVuZGVyU3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICB3OiB0aGlzLl93LFxuICAgICAgICAgICAgICAgICAgICAgICAgaDogdGhpcy5faCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cml6ZXIuaGFzUmVzdWx0VGV4dHVyZSgpIHx8ICghcmVuZGVyU3RhdGUuaXNDYWNoaW5nVGV4dHVyaXplciAmJiAoaGFzUmVuZGVyVXBkYXRlcyA8IDMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBXZSBkb24ndCBhbHdheXMgY2FjaGUgcmVuZGVyIHRleHR1cmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSBydWxlIGlzLCB0aGF0IGNhY2hpbmcgZm9yIGEgc3BlY2lmaWMgcmVuZGVyIHRleHR1cmUgaXMgb25seSBlbmFibGVkIGlmOlxuICAgICAgICAgICAgICAgICAgICAgICAgICogLSBUaGVyZSBpcyBhIHJlc3VsdCB0ZXh0dXJlIHRvIGJlIHVwZGF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAtIFRoZXJlIHdlcmUgbm8gcmVuZGVyIHVwZGF0ZXMgLXdpdGhpbiB0aGUgY29udGVudHMtIHNpbmNlIGxhc3QgZnJhbWUgKEVsZW1lbnRDb3JlLmhhc1JlbmRlclVwZGF0ZXMgPCAzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICogLSBBTkQgdGhlcmUgYXJlIG5vIGFuY2VzdG9ycyB0aGF0IGFyZSBiZWluZyBjYWNoZWQgZHVyaW5nIHRoaXMgZnJhbWUgKENvcmVSZW5kZXJTdGF0ZS5pc0NhY2hpbmdUZXh0dXJpemVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICogICBJZiBhbiBhbmNlc3RvciBpcyBjYWNoZWQgYW55d2F5LCBpdCdzIHByb2JhYmx5IG5vdCBuZWNlc3NhcnkgdG8ga2VlcCBkZWVwZXIgY2FjaGVzLiBJZiB0aGUgdG9wIGxldmVsIGlzIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIGNoYW5nZSB3aGlsZSBhIGxvd2VyIG9uZSBpcyBub3QsIHRoYXQgbG93ZXIgbGV2ZWwgd2lsbCBiZSBjYWNoZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJbiBjYXNlIG9mIHRoZSBmYXN0IGJsdXIgZWxlbWVudCwgdGhpcyBwcmV2ZW50cyBoYXZpbmcgdG8gY2FjaGUgYWxsIGJsdXIgbGV2ZWxzIGFuZCBzdGFnZXMsIHNhdmluZyBhIGh1Z2UgYW1vdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBvZiBHUFUgbWVtb3J5IVxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEVzcGVjaWFsbHkgd2hlbiB1c2luZyBtdWx0aXBsZSBzdGFja2VkIGxheWVycyBvZiB0aGUgc2FtZSBkaW1lbnNpb25zIHRoYXQgYXJlIFJUVCB0aGlzIHdpbGwgaGF2ZSBhIHZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIG5vdGljYWJsZSBlZmZlY3Qgb24gcGVyZm9ybWFuY2UgYXMgbGVzcyByZW5kZXIgdGV4dHVyZXMgbmVlZCB0byBiZSBhbGxvY2F0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmVJbmZvLmNhY2hlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmlzQ2FjaGluZ1RleHR1cml6ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl90ZXh0dXJpemVyLmhhc1Jlc3VsdFRleHR1cmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIGFscmVhZHkgcmVsZWFzZSB0aGUgY3VycmVudCB0ZXh0dXJlIHRvIHRoZSBwb29sLCBhcyBpdCB3aWxsIGJlIHJlYnVpbGQgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBsYXllcnMgb2YgJ2ZpbHRlcmluZycsIHRoaXMgbWF5IHNhdmUgdXMgZnJvbSBoYXZpbmcgdG8gY3JlYXRlIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIHJlbmRlci10by10ZXh0dXJlIGxheWVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWNlIHRoYXQgd2UgZG9uJ3QgZG8gdGhpcyB3aGVuIHRoZXJlIGlzIGEgcmVzdWx0IHRleHR1cmUsIGFzIGFueSBvdGhlciBlbGVtZW50IG1heSByZWx5IG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgdGhhdCByZXN1bHQgdGV4dHVyZSBiZWluZyBmaWxsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRSZW5kZXJUZXh0dXJlSW5mbyhyZW5kZXJUZXh0dXJlSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNjaXNzb3IobnVsbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Rpc3BsYXllZFRleHR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByID0gdGhpcy5fcmVuZGVyQ29udGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGFuIGlkZW50aXR5IGNvbnRleHQgZm9yIGRyYXdpbmcgdGhlIGRpc3BsYXllZCB0ZXh0dXJlIHRvIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSBFbGVtZW50Q29yZUNvbnRleHQuSURFTlRJVFk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBkaXNwbGF5ZWQgdGV4dHVyZSBzb3VyY2UgaW4gbG9jYWwgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclN0YXRlLmFkZFF1YWQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckNvbnRleHQgPSByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbXVzdFJlbmRlckNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuX291dE9mQm91bmRzID09PSAwKSAmJiB0aGlzLl9kaXNwbGF5ZWRUZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNoYWRlcih0aGlzLmFjdGl2ZVNoYWRlciwgdGhpcy5fc2hhZGVyT3duZXIpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTY2lzc29yKHRoaXMuX3NjaXNzb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclN0YXRlLmFkZFF1YWQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHNvIGFkZCBjaGlsZHJlbiB0byB0aGUgVkJPLlxuICAgICAgICAgICAgaWYgKG11c3RSZW5kZXJDaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl96Q29udGV4dFVzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBuID0gdGhpcy5fekluZGV4ZWRDaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3pJbmRleGVkQ2hpbGRyZW5baV0ucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuW2ldLl96SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB6SW5kZXggaXMgc2V0LCB0aGlzIGl0ZW0gYWxyZWFkeSBiZWxvbmdzIHRvIGEgekluZGV4ZWRDaGlsZHJlbiBhcnJheSBpbiBvbmUgb2YgdGhlIGFuY2VzdG9ycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGlsZHJlbltpXS5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX3VzZVJlbmRlclRvVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVSZXN1bHRUZXh0dXJlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG11c3RSZW5kZXJDaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZCByZWZyZXNoaW5nIHJlbmRlclRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmZpbmlzaGVkUmVuZGVyVGV4dHVyZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdGhpbmcgd2FzIHJlbmRlcmVkLCB3ZSBzdG9yZSBhIGZsYWcgaW4gdGhlIHRleHR1cml6ZXIgYW5kIHByZXZlbnQgdW5uZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgLy8gIHJlbmRlci10by10ZXh0dXJlIGFuZCBmaWx0ZXJpbmcuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIuZW1wdHkgPSByZW5kZXJUZXh0dXJlSW5mby5lbXB0eTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVuZGVyVGV4dHVyZUluZm8uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGlnbm9yZSBlbXB0eSByZW5kZXIgdGV4dHVyZXMgYW5kIGRvIG5vdCBkcmF3IHRoZSBmaW5hbCBxdWFkLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNsZWFucyB1cCBtZW1vcnkgYW5kIGVuZm9yY2VzIHRoYXQgdGhlIHJlc3VsdCB0ZXh0dXJlIGlzIGFsc28gY2xlYXJlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIucmVsZWFzZVJlbmRlclRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuYXRpdmVUZXh0dXJlIGlzIHNldCwgd2UgY2FuIHJldXNlIHRoYXQgZGlyZWN0bHkgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIucmV1c2VUZXh0dXJlQXNSZW5kZXJUZXh0dXJlKHJlbmRlclRleHR1cmVJbmZvLm5hdGl2ZVRleHR1cmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlSW5mby5pZ25vcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RleHR1cml6ZXIucmVuZGVyVGV4dHVyZVJldXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFF1YWQgb3BlcmF0aW9ucyBtdXN0IGJlIHdyaXR0ZW4gdG8gYSByZW5kZXIgdGV4dHVyZSBhY3R1YWxseSBvd25lZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGNyZWF0ZSB0aGUgcmVuZGVyIHRleHR1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlSW5mby5uYXRpdmVUZXh0dXJlID0gdGhpcy5fdGV4dHVyaXplci5nZXRSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBwYXJlbnQncyByZW5kZXIgdGV4dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuc2V0UmVuZGVyVGV4dHVyZUluZm8ocHJldlJlbmRlclRleHR1cmVJbmZvKTtcblxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVSZXN1bHRUZXh0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cml6ZXIuZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFRleHR1cmUgPSB0aGlzLl90ZXh0dXJpemVyLmdldFJlc3VsdFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZVJlc3VsdFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9nZ2luZyB0aGUgdXBkYXRlIGZyYW1lIGNhbiBiZSBoYW5keSBmb3IgdXNlcmxhbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VGV4dHVyZS51cGRhdGUgPSByZW5kZXJTdGF0ZS5zdGFnZS5mcmFtZUNvdW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJpemVyLnVwZGF0ZVJlc3VsdFRleHR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdGV4dHVyaXplci5yZW5kZXJPZmZzY3JlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciByZXN1bHQgdGV4dHVyZSB0byB0aGUgYWN0dWFsIHJlbmRlciB0YXJnZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRTaGFkZXIodGhpcy5hY3RpdmVTaGFkZXIsIHRoaXMuX3NoYWRlck93bmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFNjaXNzb3IodGhpcy5fc2Npc3Nvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHJlbmRlciB0ZXh0dXJlIGluZm8gaXMgc2V0LCB0aGUgY2FjaGUgY2FuIGJlIHJldXNlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gIXJlbmRlclRleHR1cmVJbmZvIHx8IHJlbmRlclRleHR1cmVJbmZvLmNhY2hlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5zZXRUZXh0dXJpemVyKHRoaXMuX3RleHR1cml6ZXIsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXNoVGV4Q29vcmRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cml6ZXIuY29sb3JpemUpIHRoaXMuX3N0YXNoQ29sb3JzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclN0YXRlLmFkZFF1YWQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3RleHR1cml6ZXIuY29sb3JpemUpIHRoaXMuX3Vuc3Rhc2hDb2xvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Vuc3Rhc2hUZXhDb29yZHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLnNldFRleHR1cml6ZXIobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJUZXh0dXJlSW5mbyAmJiByZW5kZXJUZXh0dXJlSW5mby5jYWNoZSkge1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IHNpYmxpbmdzIHRvIGNhY2hlLlxuICAgICAgICAgICAgICAgIHJlbmRlclN0YXRlLmlzQ2FjaGluZ1RleHR1cml6ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCB6U29ydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pTb3J0O1xuICAgIH1cblxuICAgIHNvcnRaSW5kZXhlZENoaWxkcmVuKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2Ugd2FudCB0byBhdm9pZCByZXNvcnRpbmcgZXZlcnl0aGluZy4gSW5zdGVhZCwgd2UgZG8gYSBzaW5nbGUgcGFzcyBvZiB0aGUgZnVsbCBhcnJheTpcbiAgICAgICAgICogLSBmaWx0ZXJpbmcgb3V0IGVsZW1lbnRzIHdpdGggYSBkaWZmZXJlbnQgelBhcmVudCB0aGFuIHRoaXMgKHdlcmUgcmVtb3ZlZClcbiAgICAgICAgICogLSBmaWx0ZXJpbmcgb3V0LCBidXQgYWxzbyBnYXRoZXJpbmcgKGluIGEgdGVtcG9yYXJ5IGFycmF5KSB0aGUgZWxlbWVudHMgdGhhdCBoYXZlIHpJbmRleFJlc29ydCBmbGFnXG4gICAgICAgICAqIC0gdGhlbiwgZmluYWxseSwgd2UgbWVyZ2Utc29ydCBib3RoIHRoZSBuZXcgYXJyYXkgYW5kIHRoZSAnb2xkJyBvbmVcbiAgICAgICAgICogLSBlbGVtZW50IG1heSBoYXZlIGJlZW4gYWRkZWQgJ2RvdWJsZScsIHNvIHdoZW4gbWVyZ2Utc29ydGluZyBhbHNvIGNoZWNrIGZvciBkb3VibGVzLlxuICAgICAgICAgKiAtIGlmIHRoZSBvbGQgb25lIGlzIGxhcmdlciAoaW4gc2l6ZSkgdGhhbiBpdCBzaG91bGQgYmUsIHNwbGljZSBvZmYgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgICAgICAqL1xuXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLl96SW5kZXhlZENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgbGV0IHB0ciA9IDA7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLl96SW5kZXhlZENoaWxkcmVuO1xuXG4gICAgICAgIC8vIE5vdGljZSB0aGF0IGl0ZW1zIG1heSBvY2N1ciBtdWx0aXBsZSB0aW1lcyBkdWUgdG8gei1pbmRleCBjaGFuZ2luZy5cbiAgICAgICAgY29uc3QgYiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgaWYgKGFbaV0uX3pQYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYVtpXS5fekluZGV4UmVzb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGIucHVzaChhW2ldKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHRyICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhW3B0cl0gPSBhW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHB0cisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG0gPSBiLmxlbmd0aDtcbiAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICAgICAgYltqXS5fekluZGV4UmVzb3J0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGIuc29ydChFbGVtZW50Q29yZS5zb3J0WkluZGV4ZWRDaGlsZHJlbik7XG4gICAgICAgICAgICBjb25zdCBuID0gcHRyO1xuICAgICAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgICAgICAgcHRyID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBhW3B0cisrXSA9IGJbaisrXTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChqIDwgbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggPiBwdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2xpY2Ugb2xkICh1bm5lY2Vzc2FyeSkgcGFydCBvZmYgYXJyYXkuXG4gICAgICAgICAgICAgICAgICAgIGEuc3BsaWNlKHB0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZS1zb3J0IGFycmF5cztcbiAgICAgICAgICAgICAgICBwdHIgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VSZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSAoYVtpXS5fekluZGV4ID09PSBiW2pdLl96SW5kZXggPyBhW2ldLl91cGRhdGVUcmVlT3JkZXIgLSBiW2pdLl91cGRhdGVUcmVlT3JkZXIgOiBhW2ldLl96SW5kZXggLSBiW2pdLl96SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZCA9IHYgPiAwID8gYltqKytdIDogYVtpKytdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwdHIgPT09IDAgfHwgKG1lcmdlUmVzdWx0W3B0ciAtIDFdICE9PSBhZGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZVJlc3VsdFtwdHIrK10gPSBhZGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkID0gYltqKytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwdHIgPT09IDAgfHwgKG1lcmdlUmVzdWx0W3B0ciAtIDFdICE9PSBhZGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlUmVzdWx0W3B0cisrXSA9IGFkZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChqIDwgbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChqID49IG0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGQgPSBhW2krK107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHB0ciA9PT0gMCB8fCAobWVyZ2VSZXN1bHRbcHRyIC0gMV0gIT09IGFkZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VSZXN1bHRbcHRyKytdID0gYWRkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGkgPCBuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl96SW5kZXhlZENoaWxkcmVuID0gbWVyZ2VSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYS5sZW5ndGggPiBwdHIpIHtcbiAgICAgICAgICAgICAgICAvLyBTbGljZSBvbGQgKHVubmVjZXNzYXJ5KSBwYXJ0IG9mZiBhcnJheS5cbiAgICAgICAgICAgICAgICBhLnNwbGljZShwdHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5felNvcnQgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgZ2V0IGxvY2FsVGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFRhO1xuICAgIH07XG5cbiAgICBnZXQgbG9jYWxUYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsVGI7XG4gICAgfTtcblxuICAgIGdldCBsb2NhbFRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxUYztcbiAgICB9O1xuXG4gICAgZ2V0IGxvY2FsVGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFRkO1xuICAgIH07XG5cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gICAgfVxuXG4gICAgZ2V0IHJlbmRlclVwZGF0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNSZW5kZXJVcGRhdGVzO1xuICAgIH1cblxuICAgIGdldCB0ZXh0dXJpemVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RleHR1cml6ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cml6ZXIgPSBuZXcgRWxlbWVudFRleHR1cml6ZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cml6ZXI7XG4gICAgfVxuXG4gICAgZ2V0Q29ybmVyUG9pbnRzKCkge1xuICAgICAgICBsZXQgdyA9IHRoaXMuX3dvcmxkQ29udGV4dDtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdy5weCxcbiAgICAgICAgICAgIHcucHksXG4gICAgICAgICAgICB3LnB4ICsgdGhpcy5fdyAqIHcudGEsXG4gICAgICAgICAgICB3LnB5ICsgdGhpcy5fdyAqIHcudGMsXG4gICAgICAgICAgICB3LnB4ICsgdGhpcy5fdyAqIHcudGEgKyB0aGlzLl9oICogdy50YixcbiAgICAgICAgICAgIHcucHkgKyB0aGlzLl93ICogdy50YyArIHRoaXMuX2ggKiB3LnRkLFxuICAgICAgICAgICAgdy5weCArIHRoaXMuX2ggKiB3LnRiLFxuICAgICAgICAgICAgdy5weSArIHRoaXMuX2ggKiB3LnRkXG4gICAgICAgIF07XG4gICAgfTtcblxuICAgIGdldFJlbmRlclRleHR1cmVDb29yZHMocmVsWCwgcmVsWSkge1xuICAgICAgICBsZXQgciA9IHRoaXMuX3JlbmRlckNvbnRleHQ7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICByLnB4ICsgci50YSAqIHJlbFggKyByLnRiICogcmVsWSxcbiAgICAgICAgICAgIHIucHkgKyByLnRjICogcmVsWCArIHIudGQgKiByZWxZXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZ2V0QWJzb2x1dGVDb29yZHMocmVsWCwgcmVsWSkge1xuICAgICAgICBsZXQgdyA9IHRoaXMuX3JlbmRlckNvbnRleHQ7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB3LnB4ICsgdy50YSAqIHJlbFggKyB3LnRiICogcmVsWSxcbiAgICAgICAgICAgIHcucHkgKyB3LnRjICogcmVsWCArIHcudGQgKiByZWxZXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgY29sbGVjdEF0Q29vcmQoeCwgeSwgY2hpbGRyZW4pIHtcbiAgICAgICAgLy8gcmV0dXJuIHdoZW4gYnJhbmNoIGlzIGhpZGRlblxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyQ29udGV4dC5hbHBoYSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5Cb3VuZCh4LCB5KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NjaXNzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pblNjaXNzb3IoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgaiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0uY29sbGVjdEF0Q29vcmQoeCwgeSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNvcnQoRWxlbWVudENvcmUuc29ydFpJbmRleGVkQ2hpbGRyZW4pO1xuICAgIH1cblxuICAgIGluQm91bmQodHgsIHR5KSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldENvcm5lclBvaW50cygpO1xuICAgICAgICByZXR1cm4gdHggPiBjWzBdICYmIHR4IDwgY1syXSAmJiB0eSA+IGNbMV0gJiYgdHkgPCBjWzddO1xuICAgIH1cblxuICAgIGluU2Npc3NvcigpIHtcbiAgICAgICAgY29uc3Qgc2MgPSB0aGlzLl9zY2lzc29yO1xuICAgICAgICBjb25zdCBjID0gdGhpcy5nZXRDb3JuZXJQb2ludHMoKTtcblxuICAgICAgICByZXR1cm4gY1syXSA+PSBzY1swXSAmJiBjWzBdIDw9IHNjWzBdICsgc2NbMl0gJiYgY1s3XSA+PSBzY1sxXSAmJiBjWzFdIDw9IHNjWzFdICsgc2NbM107XG4gICAgfVxuXG4gICAgZ2V0IGxheW91dCgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlTGF5b3V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQ7XG4gICAgfVxuXG4gICAgZ2V0IGZsZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQgPyB0aGlzLl9sYXlvdXQuZmxleCA6IG51bGw7XG4gICAgfVxuXG4gICAgc2V0IGZsZXgodikge1xuICAgICAgICB0aGlzLmxheW91dC5mbGV4ID0gdjtcbiAgICB9XG5cbiAgICBnZXQgZmxleEl0ZW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXQgPyB0aGlzLl9sYXlvdXQuZmxleEl0ZW0gOiBudWxsO1xuICAgIH1cblxuICAgIHNldCBmbGV4SXRlbSh2KSB7XG4gICAgICAgIHRoaXMubGF5b3V0LmZsZXhJdGVtID0gdjtcbiAgICB9XG5cbiAgICBpc0ZsZXhJdGVtKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LmlzRmxleEl0ZW1FbmFibGVkKCk7XG4gICAgfVxuXG4gICAgaXNGbGV4Q29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9sYXlvdXQgJiYgdGhpcy5fbGF5b3V0LmlzRmxleEVuYWJsZWQoKTtcbiAgICB9XG5cbiAgICBlbmFibGVGbGV4TGF5b3V0KCkge1xuICAgICAgICB0aGlzLl9lbnN1cmVMYXlvdXQoKTtcbiAgICB9XG5cbiAgICBfZW5zdXJlTGF5b3V0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fbGF5b3V0ID0gbmV3IEZsZXhUYXJnZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNhYmxlRmxleExheW91dCgpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpO1xuICAgIH1cblxuICAgIGhhc0ZsZXhMYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fbGF5b3V0ICYmIHRoaXMuX2xheW91dC5pc0VuYWJsZWQoKSk7XG4gICAgfVxuXG4gICAgc2V0TGF5b3V0KHgsIHksIHcsIGgpIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucyh3LCBoKTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyTGF5b3V0KCkge1xuICAgICAgICB0aGlzLl9zZXRSZWNhbGMoMjU2KTtcbiAgICB9XG5cbiAgICBfdHJpZ2dlclJlY2FsY1RyYW5zbGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fc2V0UmVjYWxjKDIpO1xuICAgIH1cblxufVxuXG5jbGFzcyBFbGVtZW50Q29yZUNvbnRleHQge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xuXG4gICAgICAgIHRoaXMucHggPSAwO1xuICAgICAgICB0aGlzLnB5ID0gMDtcblxuICAgICAgICB0aGlzLnRhID0gMTtcbiAgICAgICAgdGhpcy50YiA9IDA7XG4gICAgICAgIHRoaXMudGMgPSAwO1xuICAgICAgICB0aGlzLnRkID0gMTtcbiAgICB9XG5cbiAgICBpc0lkZW50aXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbHBoYSA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5weCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5weSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy50YSA9PT0gMSAmJlxuICAgICAgICAgICAgdGhpcy50YiA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy50YyA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy50ZCA9PT0gMTtcbiAgICB9XG5cbiAgICBpc1NxdWFyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGIgPT09IDAgJiYgdGhpcy50YyA9PT0gMDtcbiAgICB9XG5cbn1cblxuRWxlbWVudENvcmVDb250ZXh0LklERU5USVRZID0gbmV3IEVsZW1lbnRDb3JlQ29udGV4dCgpO1xuRWxlbWVudENvcmUuc29ydFpJbmRleGVkQ2hpbGRyZW4gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAoYS5fekluZGV4ID09PSBiLl96SW5kZXggPyBhLl91cGRhdGVUcmVlT3JkZXIgLSBiLl91cGRhdGVUcmVlT3JkZXIgOiBhLl96SW5kZXggLSBiLl96SW5kZXgpO1xufTtcblxuaW1wb3J0IEVsZW1lbnRUZXh0dXJpemVyIGZyb20gXCIuL0VsZW1lbnRUZXh0dXJpemVyLm1qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCIuLi9VdGlscy5tanNcIjtcbiIsIi8qXG4gKiBJZiBub3Qgc3RhdGVkIG90aGVyd2lzZSBpbiB0aGlzIGZpbGUgb3IgdGhpcyBjb21wb25lbnQncyBMSUNFTlNFIGZpbGUgdGhlXG4gKiBmb2xsb3dpbmcgY29weXJpZ2h0IGFuZCBsaWNlbnNlcyBhcHBseTpcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMCBNZXRyb2xvZ2ljYWxcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgTGljZW5zZSk7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBUZXh0dXJlU291cmNlIGZyb20gJy4uL1RleHR1cmVTb3VyY2UubWpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWxlbWVudFRleHR1cml6ZXIge1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudENvcmUpIHtcblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudENvcmUuZWxlbWVudDtcbiAgICAgICAgdGhpcy5fY29yZSA9IGVsZW1lbnRDb3JlO1xuXG4gICAgICAgIHRoaXMuY3R4ID0gdGhpcy5fY29yZS5jdHg7XG5cbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhenkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29sb3JpemUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUmV1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyT2Zmc2NyZWVuID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5lbXB0eSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9XG5cbiAgICBzZXQgZW5hYmxlZCh2KSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB2O1xuICAgICAgICB0aGlzLl9jb3JlLnVwZGF0ZVJlbmRlclRvVGV4dHVyZUVuYWJsZWQoKTtcbiAgICB9XG5cbiAgICBnZXQgcmVuZGVyT2Zmc2NyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyT2Zmc2NyZWVuO1xuICAgIH1cblxuICAgIHNldCByZW5kZXJPZmZzY3JlZW4odikge1xuICAgICAgICB0aGlzLl9yZW5kZXJPZmZzY3JlZW4gPSB2O1xuICAgICAgICB0aGlzLl9jb3JlLnNldEhhc1JlbmRlclVwZGF0ZXMoMSk7XG5cbiAgICAgICAgLy8gVGhpcyBlbmZvcmNlcyByZWNoZWNraW5nIHRoZSAnd2l0aGluIGJvdW5kcycuXG4gICAgICAgIHRoaXMuX2NvcmUuX3NldFJlY2FsYyg2KTtcbiAgICB9XG5cbiAgICBnZXQgY29sb3JpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcml6ZTtcbiAgICB9XG5cbiAgICBzZXQgY29sb3JpemUodikge1xuICAgICAgICBpZiAodGhpcy5fY29sb3JpemUgIT09IHYpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yaXplID0gdjtcblxuICAgICAgICAgICAgLy8gT25seSBhZmZlY3RzIHRoZSBmaW5hbGx5IGRyYXduIHF1YWQuXG4gICAgICAgICAgICB0aGlzLl9jb3JlLnNldEhhc1JlbmRlclVwZGF0ZXMoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZ2V0VGV4dHVyZVNvdXJjZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlID0gbmV3IFRleHR1cmVTb3VyY2UodGhpcy5fZWxlbWVudC5zdGFnZS50ZXh0dXJlTWFuYWdlcik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc3VsdFRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZTtcbiAgICB9XG5cbiAgICBoYXNSZXN1bHRUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlO1xuICAgIH1cblxuICAgIHJlc3VsdFRleHR1cmVJblVzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UgJiYgdGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZS5oYXNFbmFibGVkRWxlbWVudHMoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVSZXN1bHRUZXh0dXJlKCkge1xuICAgICAgICBsZXQgcmVzdWx0VGV4dHVyZSA9IHRoaXMuZ2V0UmVzdWx0VGV4dHVyZSgpO1xuICAgICAgICBpZiAodGhpcy5fcmVzdWx0VGV4dHVyZVNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc3VsdFRleHR1cmVTb3VyY2UubmF0aXZlVGV4dHVyZSAhPT0gcmVzdWx0VGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIGxldCB3ID0gcmVzdWx0VGV4dHVyZSA/IHJlc3VsdFRleHR1cmUudyA6IDA7XG4gICAgICAgICAgICAgICAgbGV0IGggPSByZXN1bHRUZXh0dXJlID8gcmVzdWx0VGV4dHVyZS5oIDogMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlLnJlcGxhY2VOYXRpdmVUZXh0dXJlKHJlc3VsdFRleHR1cmUsIHcsIGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUZXh0dXJlIHdpbGwgYmUgdXBkYXRlZDogYWxsIGVsZW1lbnRzIHVzaW5nIHRoZSBzb3VyY2UgbmVlZCB0byBiZSB1cGRhdGVkIGFzIHdlbGwuXG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRUZXh0dXJlU291cmNlLmZvckVhY2hFbmFibGVkRWxlbWVudChlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50Ll91cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jb3JlLnNldEhhc1JlbmRlclVwZGF0ZXMoMyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG11c3RSZW5kZXJUb1RleHR1cmUoKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIG11c3QgcmVhbGx5IHJlbmRlciBhcyB0ZXh0dXJlLlxuICAgICAgICBpZiAodGhpcy5fZW5hYmxlZCAmJiAhdGhpcy5sYXp5KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9lbmFibGVkICYmIHRoaXMubGF6eSAmJiB0aGlzLl9jb3JlLl9oYXNSZW5kZXJVcGRhdGVzIDwgMykge1xuICAgICAgICAgICAgLy8gU3RhdGljLW9ubHk6IGlmIHJlbmRlclRvVGV4dHVyZSBkaWQgbm90IG5lZWQgdG8gdXBkYXRlIGR1cmluZyBsYXN0IGRyYXduIGZyYW1lLCBnZW5lcmF0ZSBpdCBhcyBhIGNhY2hlLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMucmVsZWFzZSgpO1xuICAgIH1cblxuICAgIGdldCByZW5kZXJUZXh0dXJlUmV1c2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyVGV4dHVyZVJldXNlZDtcbiAgICB9XG5cbiAgICByZWxlYXNlKCkge1xuICAgICAgICB0aGlzLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgfVxuXG4gICAgcmVsZWFzZVJlbmRlclRleHR1cmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclRleHR1cmVSZXVzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5yZWxlYXNlUmVuZGVyVGV4dHVyZSh0aGlzLl9yZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGV4dHVyZVJldXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVSZXN1bHRUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXVzZXMgdGhlIHNwZWNpZmllZCB0ZXh0dXJlIGFzIHRoZSByZW5kZXIgdGV4dHVyZSAoaW4gYW5jZXN0b3IpLlxuICAgIHJldXNlVGV4dHVyZUFzUmVuZGVyVGV4dHVyZShuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUZXh0dXJlICE9PSBuYXRpdmVUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VSZW5kZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlID0gbmF0aXZlVGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmVSZXVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzUmVuZGVyVGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fcmVuZGVyVGV4dHVyZTtcbiAgICB9XG5cbiAgICBnZXRSZW5kZXJUZXh0dXJlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRleHR1cmUgPSB0aGlzLmN0eC5hbGxvY2F0ZVJlbmRlclRleHR1cmUodGhpcy5fY29yZS5fdywgdGhpcy5fY29yZS5faCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUZXh0dXJlUmV1c2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmU7XG4gICAgfVxuXG4gICAgZ2V0UmVzdWx0VGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclRleHR1cmU7XG4gICAgfVxuXG59XG5cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvKlxuKiBDb3B5cmlnaHQgMjAyMSBDb21jYXN0IENhYmxlIENvbW11bmljYXRpb25zIE1hbmFnZW1lbnQsIExMQ1xuKlxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4qIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4qIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKlxuKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuKi9cblxuaW1wb3J0IHsgTGF1bmNoIH0gZnJvbSAnQGxpZ2h0bmluZ2pzL3Nkayc7XG5cbmltcG9ydCB7IEFwcCB9IGZyb20gJy4uL3NyYy9BcHAnO1xuaW1wb3J0IHsgYXBwRGF0YSwgYXBwU2V0dGluZ3MsIHBsYXRmb3JtU2V0dGluZ3MgfSBmcm9tICcuLi9zcmMvc2V0dGluZ3MnO1xuXG4vLyBsYXVuY2ggdGhlIGFwcGxpY2F0aW9uIHdpdGggY3VzdG9tIHNldHRpbmdzXG5jb25zdCBhcHAgPSBMYXVuY2goQXBwLCBhcHBTZXR0aW5ncywgcGxhdGZvcm1TZXR0aW5ncywgYXBwRGF0YSk7XG5cbi8vIGFwcGVuZCB0aGUgY2FudmFzIHRvIHRoZSBkb21cbmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYXBwLnN0YWdlLmdldENhbnZhcygpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==